{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/ast.ts","webpack://liyad/./src/s-exp/compile.ops/helpers.ts","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/compile.ts","webpack://liyad/./src/s-exp/compile.ops/index.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/operators/core/core.fn.ts","webpack://liyad/./src/s-exp/operators/core/core.operator.ts","webpack://liyad/./src/s-exp/operators/core/core.macro.ts","webpack://liyad/./src/s-exp/operators/core/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core/index.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic/index.ts","webpack://liyad/./src/lib/data.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence/index.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx/index.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent/index.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/s-exp/browser.ts","webpack://liyad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","setEvaluationCount","checkParamsLength","_types__WEBPACK_IMPORTED_MODULE_0__","state","evalCount","config","maxEvalCount","args","min","max","length","Error","toNumber","resolveSplice","resolveMacro","resolveValueSymbolScope","resolveValueSymbol","collectCapturedVariables","getCapturedScopes","installScope","uninstallScope","getScope","getGlobalScope","optimizeTailCall","evaluate","_ast__WEBPACK_IMPORTED_MODULE_0__","_errors__WEBPACK_IMPORTED_MODULE_1__","x","NaN","Number","enableSplice","Array","isArray","reservedNames","splice","slice","concat","macroInfo","macroMap","symbol","lastErr","r1","formalArgs","fn","actualArgs","matchResult","matchMacroArgs","Boolean","lastIsSpread","error","next","nullIfNotDefined","scopes","localScope","scope","capturedScopes","isBlockLocal","globalScope","symInfo","symbolMap","valueSymbolResolverFallback","raiseOnUnresolvedSymbol","names","a","unshift","assign","push","pop","macroName","nm","startsWith","endsWith","tpos","lastIndexOf","tname","fnBody","front","tail","if","self","varBaseName","tempVarsSyms","map","idx","until","let","set","sym","quote","backquote","resolveUnquote","unquote","eval","sprs","spread","reverse","funcInfo","funcMap","v","funcSymbolResolverFallback","resolveFunctionSymbol","JSON","stringify","wrapExternalValue","car","cdr","dotted","wrapByUnquote","isSymbol","applyMacros","stripQuote","stripQuoteOrPass","getScope_stateApplied","resolveValueSymbol_dynamic","_evaluate__WEBPACK_IMPORTED_MODULE_1__","_errors__WEBPACK_IMPORTED_MODULE_2__","tok","FatalError","MaxEvaluationCountError","ScriptTerminationError","[object Object]","message","super","where","compileLambda","_compile_ops_helpers__WEBPACK_IMPORTED_MODULE_2__","_compile_ops__WEBPACK_IMPORTED_MODULE_3__","compileCore","_$_vars","compileValue","b","compFnBody","String","ctx","varNames","has","varsCount","compileToken","body","ops","join","arr","Map","varNamesCount","varDefs","makeScope","scoped","varNamesCopy","entries","enableTailCallOptimization","compFormalArgs","compFnBodyRoot","evalCompiledLambda","_$_state","code","registerOperators","_helpers__WEBPACK_IMPORTED_MODULE_2__","raise","quoted","vName","symName","regToVars","not","w1","w0","hasSpread","isEOF","ch","isSpace","trim","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","lookCurrentLineHint","line","index","pos","strings","getChar","virtualEof","disableEscape","eof","values","split","eofSeq","ch1","ch2","fromCodePoint","parseInt","lookAheads","chs","lookAhead","skipWhitespaces","parseNumber","parseSymbol","enableShorthands","match","ws","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","types","parseList","parseString","parseHereDoc","attrs","q","inner","parseSingleLineComment","comment","parseMultiLineComment","parseOneToken","ahead","isSpliceUnquote","ret","ast","aheads","enableSpread","enableHereDoc","isHereDoc","Template","ahs","enableVerbatimStringLiteral","listStopChar","initialList","stripComments","parse","$car","errors","$$first","$cdr","$cons","$$firstAndSecond","$first","$second","$$second","$last","$rest","$firstAndSecond","$atom","$eq","$notEq","$list","$__scope","returnMultiple","kv","kvSym","xSym","$__lambda","fa","$comp$__lambda","compile","$apply","apply","$raise","$pipe","$__let","$__set","path","subst","inprog","last","$boolean","$$boolean","$not","$$not","$__and","prev","curr","$__or","$ambiguousEq","$$ambiguousEq","$ambiguousNotEq","$lt","$le","$gt","$ge","$symbol","$isSymbol","$isList","$isString","$isNumber","$isNaN","isNaN","$isFinite","isFinite","$isInteger","isInteger","$toString","$toNumber","$objectAssign","$jsonStringify","$jsonParse","$now","Date","now","$datetimeFromIso","dt","getTime","$datetime","year","padStart","$datetimeLc","$datetimeToIsoString","toISOString","$datetimeToComponents","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getUTCDay","$datetimeToComponentsLc","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTimezoneOffset","getDay","$match","RegExp","exec","$consoleLog","console","log","$consoleError","$consoleTrace","trace","$consoleTime","time","$consoleTimeEnd","timeEnd","$consoleTimeLog","timeLog","core_operator","st","info","fArgs","aArgs","list","Function","e","tempVarSym","keyName","core_macro","core_symbol","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","install","funcs","macros","symbols","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","reduce","$bitOr","$bitXor","$add","$sub","$mul","$sup","Math","pow","$div","$mod","$max","$min","$avg","$floor","floor","$ceil","ceil","$round","round","$abs","abs","$sign","sign","arithmetic_operator","arithmetic_macro","arithmetic_symbol","arithmetic_install","Query","data","this","condition","y","desc","sort","start","groupBy","array","w","first","intermediate","single","filter","query","$length","$trim","$trimHead","trimLeft","$trimTail","trimRight","$replaceAll","$split","$join","$concat","$slice","$top","$tail","$push","$pop","$__at","$reverse","$reverseDestructive","$find","find","$filter","$map","$reduce","$reduceFromTail","reduceRight","$sort","$sortDestructive","$groupEvery","groupEvery","select","$groupBy","$orderBy","orderBy","$where","sequence_operator","stop","step","from","sequence_macro","sequence_symbol","sequence_install","$jsxProps","styles","matched","classes","z","cs","forEach","fragment","__html","__text","getJsxTagsParams","children","props","$jsxStandardTag","jsx","$jsxComponentTag","component","jsx_operator","jsx_macro","jsx_symbol","jsx_install","lsxConf","components","jsxFlagment","JsxFragment","$__letAsync","promise","then","Promise","resolve","reject","$__setAsync","$then","$resolveAll","promises","all","$resolveAny","invert","res","rej","ps","firstOf","$resolvePipe","lambdas","$resolveFork","resolvers","rejectors","pa","lp","catch","f","concurrent_operator","concurrent_macro","concurrent_symbol","concurrent_install","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","and","or","gensym","defaultConfig","enableEvaluate","returnMultipleRoot","initState","globals","resetState","SExpression","conf","startup","evaluateAST","repl","fRepl","sync","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","installer","SExpressionAsync","__awaiter","stat","execSync","S","L","LS","lisp","L_async","LS_async","lisp_async","LM","LM_async","LSX","LSX_async","runScriptTags","contentType","codes","document","querySelectorAll","innerHTML","builtinOperators","builtinMacros","builtinSymbols","core","arithmetic","sequence","concurrent"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,OAAA,GAAAH,GACA,iBAAAC,QACAA,QAAA,MAAAD,IAEAD,EAAA,MAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,EAAA,GAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,GAAA,CACAC,EAAAD,EACAE,GAAA,EACAT,QAAA,IAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA0DA,OArDAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,EAAA,CAA0CK,YAAA,EAAAC,IAAAL,KAK1CV,EAAAgB,EAAA,SAAAtB,GACA,oBAAAuB,eAAAC,aACAN,OAAAC,eAAAnB,EAAAuB,OAAAC,YAAA,CAAwDC,MAAA,WAExDP,OAAAC,eAAAnB,EAAA,cAAiDyB,OAAA,KAQjDnB,EAAAoB,EAAA,SAAAD,EAAAE,GAEA,GADA,EAAAA,IAAAF,EAAAnB,EAAAmB,IACA,EAAAE,EAAA,OAAAF,EACA,KAAAE,GAAA,iBAAAF,QAAAG,WAAA,OAAAH,EACA,IAAAI,EAAAX,OAAAY,OAAA,MAGA,GAFAxB,EAAAgB,EAAAO,GACAX,OAAAC,eAAAU,EAAA,WAAyCT,YAAA,EAAAK,UACzC,EAAAE,GAAA,iBAAAF,EAAA,QAAAM,KAAAN,EAAAnB,EAAAQ,EAAAe,EAAAE,EAAA,SAAAA,GAAgH,OAAAN,EAAAM,IAAqBC,KAAA,KAAAD,IACrI,OAAAF,GAIAvB,EAAA2B,EAAA,SAAAhC,GACA,IAAAe,EAAAf,KAAA2B,WACA,WAA2B,OAAA3B,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAiB,EAAAC,GAAsD,OAAAjB,OAAAkB,UAAAC,eAAA1B,KAAAuB,EAAAC,IAGtD7B,EAAAgC,EAAA,GAIAhC,IAAAiC,EAAA,kCClFAjC,EAAAQ,EAAA0B,EAAA,sBAAAC,IAAAnC,EAAAQ,EAAA0B,EAAA,sBAAAE,IAAA,IAAAC,EAAArC,EAAA,GAUM,SAAUmC,EAAmBG,GAE/B,GADAA,EAAMC,YACFD,EAAME,OAAOC,cAAgBH,EAAME,OAAOC,aAAeH,EAAMC,UAC/D,MAAM,IAAIF,EAAA,EAKZ,SAAUD,EAAkB3B,EAAciC,EAAsBC,EAAaC,GAC/E,GAAIF,EAAKG,OAASF,EACd,MAAM,IAAIG,cAAcrC,yCAA4CkC,aAAeD,EAAKG,WAE5F,GAAID,GAAOA,EAAMF,EAAKG,OAClB,MAAM,IAAIC,cAAcrC,yCAA4CmC,aAAeF,EAAKG,WAE5F,OAAO,iCCzBX7C,EAAAQ,EAAA0B,EAAA,sBAAAa,IAAA/C,EAAAQ,EAAA0B,EAAA,sBAAAc,IAAAhD,EAAAQ,EAAA0B,EAAA,sBAAAe,IAAAjD,EAAAQ,EAAA0B,EAAA,sBAAAgB,IAAAlD,EAAAQ,EAAA0B,EAAA,sBAAAiB,IAAAnD,EAAAQ,EAAA0B,EAAA,sBAAAkB,IAAApD,EAAAQ,EAAA0B,EAAA,sBAAAmB,IAAArD,EAAAQ,EAAA0B,EAAA,sBAAAoB,IAAAtD,EAAAQ,EAAA0B,EAAA,sBAAAqB,IAAAvD,EAAAQ,EAAA0B,EAAA,sBAAAsB,IAAAxD,EAAAQ,EAAA0B,EAAA,sBAAAuB,IAAAzD,EAAAQ,EAAA0B,EAAA,sBAAAwB,IAAA1D,EAAAQ,EAAA0B,EAAA,sBAAAyB,IAAA,IAAAC,EAAA5D,EAAA,GAAA6D,EAAA7D,EAAA,GAmBM,SAAU+C,EAASe,GACrB,cAAeA,GACf,IAAK,SAAU,IAAK,SAAU,IAAK,WAC/B,OAAOC,IACX,QACI,OAAOC,OAAOF,IAoBhB,SAAUd,EAAcV,EAAsBtB,GAChD,GAAIsB,EAAME,OAAOyB,aACb,IAAK,IAAI/D,EAAIc,EAAE6B,OAAS,EAAG3C,GAAK,EAAGA,IAAK,CAClBgE,MAAMC,QAAQnD,EAAEd,KAAOU,OAAAgD,EAAA,EAAAhD,CAAUI,EAAEd,GAAiB,GAAIoC,EAAME,OAAO4B,cAAcC,UAEjGrD,EAAIA,EAAEsD,MAAM,EAAGpE,GAAGqE,OAAQvD,EAAEd,GAAiB,GAAIc,EAAEsD,MAAMpE,EAAI,KAIzE,OAAOc,EAIL,SAAUiC,EAAaX,EAAsBwB,EAAa9C,GAC5D,MAAMwD,EAAYlC,EAAMmC,SAAS1D,IAAI+C,EAAEY,QACvC,IAAIC,EAAU,KACd,GAAIH,EAAW,CACX,IAAIlE,EAA6BkE,EACjC,MAAMI,EAAK5D,EAAEsD,MAAM,GACnB,KAAOhE,GAAG,CACN,IAAIA,EAAEuE,WAWF,MAAO,CACHC,GAAIxE,EAAEwE,GAAGxC,EAAOwB,EAAEY,QAClBK,WAAY/D,GAbF,CACd,MAAMgE,EAAcC,EAAe3C,EAAOwB,EAAEY,OAAQpE,EAAEuE,WAAYK,QAAQ5E,EAAE6E,cAAeP,GAC3F,IAAMI,EAAYI,MACd,MAAO,CACHN,GAAIxE,EAAEwE,GAAGxC,EAAOwB,EAAEY,OAAQM,EAAYH,YACtCE,WAAY/D,EAAEsD,MAAM,EAAG,GAAGC,OAAOS,EAAYD,aAGrDJ,EAAUK,EAAYI,MACtB9E,EAAIA,EAAE+E,MAQd,GAAIV,EACA,MAAM,IAAI7B,MAAM6B,GAGxB,OAAO,EA2BL,SAAUzB,EAAwBZ,EAAsBwB,EAAawB,GACvE,IAAK,IAAIpF,EAAIoC,EAAMiD,OAAO1C,OAAS,EAAG3C,EAAI,EAAGA,IAAK,CAC9C,MAAMsF,EAAsBlD,EAAMiD,OAAOrF,GACzC,GAAIsF,GAAc5E,OAAOkB,UAAUC,eAAe1B,KAAKmF,EAAWC,MAAO3B,EAAEY,QACvE,OAAOc,EAAWC,MAEtB,GAAID,EAAWE,gBACX9E,OAAOkB,UAAUC,eAAe1B,KAAKmF,EAAWE,eAAgB5B,EAAEY,QAClE,OAAOc,EAAWE,eAAe5B,EAAEY,QAEvC,IAAMc,EAAWG,aACb,MAGR,MAAMC,EAAcnC,EAAenB,GACnC,OAAI1B,OAAOkB,UAAUC,eAAe1B,KAAKuF,EAAYH,MAAO3B,EAAEY,QACnDkB,EAAYH,MAEhBH,EAAmB,KAAO9B,EAASlB,GAAOmD,MAI/C,SAAUtC,EAAmBb,EAAsBwB,GACrD,MAAM2B,EAAQvC,EAAwBZ,EAAOwB,GAAG,GAChD,GAAI2B,EACA,OAAOA,EAAM3B,EAAEY,QAEnB,MAAMmB,EAAUvD,EAAMwD,UAAU/E,IAAI+C,EAAEY,QACtC,GAAImB,EACA,OAAOA,EAAQf,GAAGxC,EAAOwB,EAAEY,QAE3B,GAAIpC,EAAME,OAAOuD,4BACb,OAAOzD,EAAME,OAAOuD,4BAA4BzD,EAAOwB,EAAEY,QAE7D,GAAIpC,EAAME,OAAOwD,wBACb,MAAM,IAAIlD,qDAAqDgB,EAAEY,WAErE,OAAOZ,EAAEY,OAKX,SAAUtB,EAAyBd,EAAsB2D,GAC3D,MAAMP,EAAiC,GACvC,IAAK,MAAM/D,KAAKsE,EAAO,CACnB,MAAMR,EAAQvC,EAAwBZ,EAAOX,GAAG,GAChD,GAAc,OAAV8D,EACA,MAAM,IAAI3C,2DAA2DnB,KAEzE+D,EAAe/D,EAAE+C,QAAUe,EAE/B,OAAOC,EAIL,SAAUrC,EAAkBf,GAC9B,MAAM4D,EAAsB,GAC5B,IAAK,IAAIhG,EAAIoC,EAAMiD,OAAO1C,OAAS,EAAG3C,EAAI,EAAGA,IAAK,CAC9C,MAAMsF,EAAsBlD,EAAMiD,OAAOrF,GAIzC,GAHIsF,EAAWE,gBACXQ,EAAEC,QAAQX,EAAWE,iBAEnBF,EAAWG,aACb,MAGR,OAAOO,EAAErD,OAAS,EAAIjC,OAAOwF,OAAO,MAAOF,QAAK,EAI9C,SAAU5C,EAAahB,EAAsBmD,EAAYE,EAAuBD,GAClFpD,EAAMiD,OAAOc,KAAK,CAACV,eAAcF,QAAOC,mBAItC,SAAUnC,EAAejB,GAC3B,GAAIA,EAAMiD,OAAO1C,OAAS,EACtB,MAAM,IAAIC,MAAM,6CAEpB,OAAOR,EAAMiD,OAAOe,MAIlB,SAAU9C,EAASlB,GACrB,OAAOA,EAAMiD,OAAOjD,EAAMiD,OAAO1C,OAAS,GAIxC,SAAUY,EAAenB,GAC3B,OAAOA,EAAMiD,OAAO,GAIlB,SAAUN,EACR3C,EAAsBiE,EACtB1B,EAAwBM,EAAuBJ,GAInD,GAFAF,EAAaA,EAAWP,MAAM,IAC9BS,EAAaA,EAAWT,MAAM,IACdzB,QAAUsC,EAAe,EAAI,GAAMN,EAAWhC,OAC1D,MAAQ,CAAEuC,0BAA2BmB,qCACjCxB,EAAWlC,mBAAmBgC,EAAWhC,WAEjD,IAAK,IAAI3C,EAAI2E,EAAWhC,QAAUsC,EAAe,EAAI,GAAIjF,GAAK,EAAGA,IAAK,CAClE,IAAIsG,EAAK3B,EAAW3E,GAAGwE,OACvB,GAAI8B,EAAGC,WAAW,MAId,GAHA5B,EAAW3E,GAAGwE,OAASG,EAAW3E,GAAGwE,OAAOJ,MAAM,GAClDkC,EAAK3B,EAAW3E,GAAGwE,QAEb9D,OAAAgD,EAAA,EAAAhD,CAASmE,EAAW7E,IACtB,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,0BAEtE,GAAIA,EAAGC,WAAW,MAAQD,EAAGE,SAAS,KAAM,CAI/C,GAHA7B,EAAW3E,GAAGwE,OAASG,EAAW3E,GAAGwE,OAAOJ,MAAM,GAAI,GACtDkC,EAAK3B,EAAW3E,GAAGwE,QAEf9D,OAAAgD,EAAA,EAAAhD,CAASmE,EAAW7E,GAAIsG,GAIxB,MAAQ,CAAEpB,0BAA2BmB,kBAA0BrG,MAAMsG,8BAHrE3B,EAAaA,EAAWP,MAAM,EAAGpE,GAAGqE,OAAOM,EAAWP,MAAMpE,EAAI,IAChE6E,EAAaA,EAAWT,MAAM,EAAGpE,GAAGqE,OAAOQ,EAAWT,MAAMpE,EAAI,QAIjE,CACH,MAAMyG,EAAOH,EAAGI,YAAY,KAC5B,GAAI,EAAID,EAAM,CACV,MAAME,EAAQL,EAAGlC,MAAMqC,EAAO,GAC9B,OAAQE,GACR,IAAK,SACD,GAA6B,iBAAlB9B,EAAW7E,GAClB,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,qBAEzE,MACJ,IAAK,SACD,GAA6B,iBAAlBzB,EAAW7E,GAClB,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,qBAEzE,MACJ,IAAK,WACD,IAAOtC,MAAMC,QAAQY,EAAW7E,MAAOU,OAAAgD,EAAA,EAAAhD,CAAUmE,EAAW7E,GAAW,IACnE,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,uBAEzE,MACJ,IAAK,OACD,IAAMtC,MAAMC,QAAQY,EAAW7E,IAC3B,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,mBAEzE,MACJ,IAAK,SACD,IAAM5F,OAAAgD,EAAA,EAAAhD,CAASmE,EAAW7E,IACtB,MAAQ,CAAEkF,0BAA2BmB,kBAA0BrG,MAAMsG,qBAEzE,MACJ,IAAK,MACD,MACJ,QACI,MAAQ,CAAEpB,0BAA2BmB,kBAA0BrG,MAAMsG,sBAAuBK,MAEhGhC,EAAW3E,GAAGwE,OAASG,EAAW3E,GAAGwE,OAAOJ,MAAM,EAAGqC,KAIjE,MAAQ,CAAE9B,aAAYE,cAIpB,SAAUrB,EAAiBpB,EAAsBuC,EAAwBiC,GAI3E,GAAI5C,MAAMC,QAAQ2C,EAAOA,EAAOjE,OAAS,IAAK,CAC1C,MAAMkE,EAAQD,EAAOxC,MAAM,EAAGwC,EAAOjE,OAAS,GACxCmE,EAAOF,EAAOA,EAAOjE,OAAS,GACpC,GAAImE,GAA4B,iBAAZA,EAAK,IAAoBA,EAAK,GAAGtC,SAAWpC,EAAME,OAAO4B,cAAc6C,IAEnF/C,MAAMC,QAAQ6C,EAAK,KAA8B,iBAAfA,EAAK,GAAG,IAAoBA,EAAK,GAAG,GAAGtC,SAAWpC,EAAME,OAAO4B,cAAc8C,KAAM,CAuBrH,MAAMC,qBAAiC7E,EAAMC,iBACvC6E,EAAevC,EAAWwC,IAAI,CAACnB,EAAGoB,KAAJ,CAAc5C,UAAWyC,OAAiBG,KAAOpB,EAAExB,YAEvF,MAAO,CACH,CAAC,CAACA,OAAQpC,EAAME,OAAO4B,cAAcmD,OAAQP,EAAK,GAC9C,CAAC,CAACtC,OAAQpC,EAAME,OAAO4B,cAAcoD,KAAM,IAAIJ,MACxCL,KACEC,EAAK,GAAG1C,MAAM,GAAa+C,IAAI,CAACvD,EAAQwD,IACzC,CAAC,CAAC5C,OAAQpC,EAAME,OAAO4B,cAAcqD,KAAML,EAAaE,GAAMxD,OAC9DsD,EAAaC,IAAI,CAACvD,EAAGwD,IACrB,CAAC,CAAC5C,OAAQpC,EAAME,OAAO4B,cAAcqD,KAAM5C,EAAWyC,GAAMxD,SAGrEiD,EACHC,EAAK,KAKrB,OAAOF,EAIL,SAAUnD,EAASrB,EAAsBwB,GAG3C,GAFAlD,OAAAiD,EAAA,EAAAjD,CAAmB0B,GAEfwB,QACA,OAAOA,EAEX,IAAI9C,EAAa8C,EAEjB,KACQI,MAAMC,QAAQnD,IADb,CACiB,CAClB,GAAiB,IAAbA,EAAE6B,OACF,OAAO7B,EAEXA,EAAIgC,EAAcV,EAAOtB,GACzB,MAAM0G,EAAM9G,OAAAgD,EAAA,EAAAhD,CAASI,EAAE,IACvB,IAAI0G,EAQA,MARK,CACL,MAAMpH,EAAI2C,EAAaX,EAAOoF,EAAK1G,GACnC,IAAIV,EAGA,MAFAU,EAAIV,EAAEwE,GAAGxE,EAAEyE,aAUvBnE,OAAAiD,EAAA,EAAAjD,CAAmB0B,GAGvB,GAAI4B,MAAMC,QAAQnD,IAEd,GAAI,GADJA,EAAIA,EAAEsD,MAAM,IACFzB,OAAQ,CACd,MAAM6E,EAAM9G,OAAAgD,EAAA,EAAAhD,CAASI,EAAE,IACvB,GAAI0G,EAAK,CACL,GAAIA,EAAIhD,SAAWpC,EAAME,OAAO4B,cAAcuD,MAC1C,OAAO3G,EAAEsD,MAAM,EAAG,GAAG,GAEzB,GAAIoD,EAAIhD,SAAWpC,EAAME,OAAO4B,cAAcwD,UAK1C,OAJA5G,EAAIA,EAAEsD,MAAM,EAAG,GAAG,GACdJ,MAAMC,QAAQnD,KACdA,EAzVlB,SAAU6G,EAAevF,EAAsBtB,GACjD,IAAK,IAAId,EAAI,EAAGA,EAAIc,EAAE6B,OAAQ3C,IACPgE,MAAMC,QAAQnD,EAAEd,KAAOU,OAAAgD,EAAA,EAAAhD,CAAUI,EAAEd,GAAiB,GAAIoC,EAAME,OAAO4B,cAAc0D,WAElG9G,EAAIA,EAAEsD,MAAM,EAAGpE,GAAGqE,OAAO,CAACZ,EAASrB,EAAQtB,EAAEd,GAAiB,KAAMc,EAAEsD,MAAMpE,EAAI,KAEhFgE,MAAMC,QAAQnD,EAAEd,OAChBc,EAAIA,EAAEsD,MAAM,IACVpE,GAAK2H,EAAevF,EAAOtB,EAAEd,KAGvC,OAAO8C,EAAcV,EAAOtB,GA8UJ6G,CAAevF,EAAOtB,IAEvBA,EAEX,GAAI0G,EAAIhD,SAAWpC,EAAME,OAAO4B,cAAc2D,KAC1C,OAAOpE,EAASrB,EAAOqB,EAASrB,EAAOtB,EAAEsD,MAAM,EAAG,GAAG,KAI7D,MAAM0D,EAAO,GACb,IAAK,IAAI9H,EAAI,EAAGA,EAAIc,EAAE6B,OAAQ3C,IAAK,CAE/B,GADegE,MAAMC,QAAQnD,EAAEd,KAAOU,OAAAgD,EAAA,EAAAhD,CAAUI,EAAEd,GAAiB,GAAIoC,EAAME,OAAO4B,cAAc6D,QACtF,CACRD,EAAK3B,KAAKnG,GACV,MAAMgG,EAAIvC,EAASrB,EAAQtB,EAAEd,GAAiB,IAC9Cc,EAAEd,GAAKgE,MAAMC,QAAQ+B,GAAKA,EAAI,CAACA,QAE/BlF,EAAEd,GAAKyD,EAASrB,EAAOtB,EAAEd,IAGjC,IAAK,MAAMA,KAAK8H,EAAKE,UACjBlH,EAAKA,EAAgBsD,MAAM,EAAGpE,GAAGqE,OAAOvD,EAAEd,GAAIc,EAAEsD,MAAMpE,EAAI,IAG9D,IAAI4E,EASJ,GAAkB,mBAPdA,EADgB,mBAAT9D,EAAE,GACJA,EAAE,GACA0G,EAxTjB,SAAgCpF,EAAsBwB,GACxD,GAAiB,mBAANA,EACP,OAAOA,EAEX,MAAMqE,EAAW7F,EAAM8F,QAAQrH,IAAI+C,EAAEY,QACrC,GAAIyD,EACA,OAAOA,EAASrD,GAAGxC,EAAOwB,EAAEY,QACzB,CACH,MAAM2D,EAAIlF,EAAmBb,EAAOwB,GACpC,GAAiB,mBAANuE,EACP,OAAOA,EAEX,GAAI/F,EAAME,OAAO8F,2BACb,OAAOhG,EAAME,OAAO8F,2BAA2BhG,EAAOwB,EAAEY,QAE5D,GAAIpC,EAAME,OAAOwD,wBACb,MAAM,IAAIlD,wDAAwDgB,EAAEY,WAExE,OAAOZ,EAAEY,QAuSI6D,CAAsBjG,EAAOoF,GAE7B/D,EAASrB,EAAOtB,EAAE,KAMvB,MAAM,IAAI8B,8DAA8D0F,KAAKC,UAAUzH,OAFvFA,EAAK8D,KAAe9D,EAAEsD,MAAM,UAKjC,GAAIhC,EAAME,OAAOkG,mBAAqB9H,OAAOkB,UAAUC,eAAe1B,KAAKW,EAAG,SACjFA,EAAKA,EAAsBG,WACxB,GAAIP,OAAOkB,UAAUC,eAAe1B,KAAKW,EAAG,UAC/CA,EAAImC,EAAmBb,EAAOtB,QAC3B,GAAIJ,OAAOkB,UAAUC,eAAe1B,KAAKW,EAAG,OAAQ,CACvD,MAAM2H,EAAMhF,EAASrB,EAAQtB,EAAmB2H,KAC1CC,EAAMjF,EAASrB,EAAQtB,EAAmB4H,KAChD,GAAI1E,MAAMC,QAAQyE,GAAM,CACpB,MAAM1C,EAAK0C,EAActE,MAAM,GAC/B4B,EAAEC,QAAQwC,GACV3H,EAAIkF,OAEJlF,EAAI,CAAE2H,MAAKC,YAERhI,OAAOkB,UAAUC,eAAe1B,KAAKW,EAAG,UAC/CA,EAAI,CACA2C,EAASrB,EAAQtB,EAAuB6H,SAErCjI,OAAOkB,UAAUC,eAAe1B,KAAKW,EAAG,aAC/CA,EAAI,IAGR,OAAOA,iCCzaL,SAAU2G,EAAMrF,EAAsBwB,GACxC,MAAO,CAAC,CAACY,OAAQpC,EAAME,OAAO4B,cAAcuD,OAAQ7D,GAelD,SAAU8D,EAAUtF,EAAsBwB,GAC5C,MAAO,CAAC,CAACY,OAAQpC,EAAME,OAAO4B,cAAcwD,WAAY9D,GAetD,SAAUgF,EAAcxG,EAAsBwB,GAChD,MAAO,CAAC,CAACY,OAAQpC,EAAME,OAAO4B,cAAc0D,SAAUhE,GAepD,SAAUmE,EAAO3F,EAAsBwB,GACzC,MAAO,CAAC,CAACY,OAAQpC,EAAME,OAAO4B,cAAc6D,QAASnE,GAInD,SAAUO,EAAO/B,EAAsBwB,GACzC,MAAO,CAAC,CAACY,OAAQpC,EAAME,OAAO4B,cAAcC,QAASP,GAInD,SAAUiF,EAASjF,EAAQrD,GAC7B,OAAIqD,GAAkB,iBAANA,GAAkBlD,OAAOkB,UAAUC,eAAe1B,KAAKyD,EAAG,eACzD,IAATrD,EACOqD,EAAEY,SAAWjE,EAAOqD,EAAI,KAExBA,EAGR,KA5EX9D,EAAAQ,EAAA0B,EAAA,sBAAAyF,IAAA3H,EAAAQ,EAAA0B,EAAA,sBAAA0F,IAAA5H,EAAAQ,EAAA0B,EAAA,sBAAA4G,IAAA9I,EAAAQ,EAAA0B,EAAA,sBAAA+F,IAAAjI,EAAAQ,EAAA0B,EAAA,sBAAAmC,IAAArE,EAAAQ,EAAA0B,EAAA,sBAAA6G,kCCAA/I,EAAAQ,EAAA0B,EAAA,sBAAA8G,IAAAhJ,EAAAQ,EAAA0B,EAAA,sBAAA+G,IAAAjJ,EAAAQ,EAAA0B,EAAA,sBAAAgH,IAAAlJ,EAAAQ,EAAA0B,EAAA,sBAAAiH,IAAAnJ,EAAAQ,EAAA0B,EAAA,sBAAAkH,IAAA,IAAAxF,EAAA5D,EAAA,GAAAqJ,EAAArJ,EAAA,GAAAsJ,EAAAtJ,EAAA,GAgBM,SAAUgJ,EAAY1G,EAAsBiH,GAC9C,IAAIvI,EAAauI,EACjB,KACQrF,MAAMC,QAAQnD,IADb,CACiB,CAClB,GAAiB,IAAbA,EAAE6B,OACF,MAEJ7B,EAAIJ,OAAAyI,EAAA,EAAAzI,CAAc0B,EAAOtB,GACzB,MAAM0G,EAAM9G,OAAAgD,EAAA,EAAAhD,CAASI,EAAE,IACvB,IAAI0G,EAQA,MARK,CACL,MAAMpH,EAAIM,OAAAyI,EAAA,EAAAzI,CAAa0B,EAAOoF,EAAK1G,GACnC,IAAIV,EAGA,MAFAU,EAAIV,EAAEwE,GAAGxE,EAAEyE,aAUvBnE,OAAA0I,EAAA,EAAA1I,CAAmB0B,GAEvB,OAAOtB,EAIL,SAAUiI,EAAW3G,EAAsBiH,GAC7C,IAAOrF,MAAMC,QAAQoF,KAAQ3I,OAAAgD,EAAA,EAAAhD,CAAU2I,EAAY,GAAIjH,EAAME,OAAO4B,cAAcuD,OAC9E,MAAM,IAAI7E,MAAM,yCAEpB,OAAQyG,EAAY,GAIlB,SAAUL,EAAiB5G,EAAsBiH,GACnD,OAAIrF,MAAMC,QAAQoF,IAAQ3I,OAAAgD,EAAA,EAAAhD,CAAU2I,EAAY,GAAIjH,EAAME,OAAO4B,cAAcuD,OACnE4B,EAAY,GAEbA,EAKT,SAAUJ,EAAsB7G,GAClC,OAAQ,WAAa,OAAO1B,OAAAyI,EAAA,EAAAzI,CAAS0B,IAInC,SAAU8G,EAA2B9G,EAAsB7B,GAC7D,OAAQ,WAAY,OAAOG,OAAAyI,EAAA,EAAAzI,CAAmB0B,EAAO,CAACoC,OAAQjE,oCCnElET,EAAAQ,EAAA0B,EAAA,sBAAAsH,IAAAxJ,EAAAQ,EAAA0B,EAAA,sBAAAuH,IAAAzJ,EAAAQ,EAAA0B,EAAA,sBAAAwH,IAyMM,MAAOF,UAAmB1G,MAC5B6G,YAAmBC,GACfC,MAAMD,IAKR,MAAOH,UAAgCD,EACzCG,cACIE,MAAM,uEAKR,MAAOH,UAA+BF,EACxCG,YAAmBG,GACfD,cAAcC,iHCzNtB9J,oBAAAQ,EAAA0B,oBAAA,sBAAA6H,gBAAA,IAAAnG,kCAAA5D,oBAAA,GAAAqJ,uCAAArJ,oBAAA,GAAAgK,kDAAAhK,oBAAA,GAAAiK,0CAAAjK,oBAAA,GAsBA,SAASkK,YAAY5H,EAAsBuC,EAAwBM,EAAuB2B,EAAeqD,GAYrG,SAASC,EAAaC,GAClB,IAAIC,EAAa,GACjB,GAAU,OAAND,EACAC,GAAc,cACX,QAAU,IAAND,EACPC,GAAc,gBACX,cAAeD,GACtB,IAAK,UAAW,IAAK,SACjBC,OAAkBC,OAAOF,MACzB,MACJ,IAAK,SACD,GAAIzJ,OAAAgD,kCAAA,EAAAhD,CAASyJ,GAAI,CACb,MAAM3C,EAAM2C,EACRG,EAAIC,SAASC,IAAIhD,EAAIhD,QACrB4F,OAAkBE,EAAIC,SAAS1J,IAAI2G,EAAIhD,YAEvCyF,EAAQK,EAAIG,WAAajD,EAAIhD,OAC7B4F,eAA0BC,OAAOC,EAAIG,kBAEzC,MAGR,QACIR,EAAQK,EAAIG,WAAaN,EACzBC,eAA0BC,OAAOC,EAAIG,iBAGzC,OAAOL,EAIX,SAASM,EAAaC,EAAa3K,GAC/B,IAAIoK,EAAa,GACjB,MAAMD,EAAIQ,EAAK3K,GACf,GAAIgE,MAAMC,QAAQkG,GACd,GAAI,EAAIA,EAAExH,OAAQ,CACd,MAAM7B,EAAaJ,OAAAoJ,kDAAA,EAAApJ,CAAY0B,EAAO+H,GACtC,GAAInG,MAAMC,QAAQnD,GACd,GAAI,EAAIA,EAAE6B,OACN,GAAIjC,OAAAgD,kCAAA,EAAAhD,CAASI,EAAE,IAAK,CAChB,MAAM0G,EAAM1G,EAAE,GACR0B,EAAO1B,EAAEsD,MAAM,GACjBwG,EAAIJ,IAAIhD,EAAIhD,QACZ4F,GAAeQ,EAAI/J,IAAI2G,EAAIhD,OAAZoG,CAAyC9J,EAAG0B,GAEvDgF,EAAIhD,SAAWpC,EAAME,OAAO4B,cAAc6D,OAC1CqC,UACI5H,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAoJ,kDAAA,EAAApJ,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,QACjEzI,EAAM8F,QAAQsC,IAAIhD,EAAIhD,SAC7ByF,EAAQK,EAAIG,WAAcrI,EAAM8F,QAAQrH,IAAI2G,EAAIhD,QAAuBI,GAAGxC,EAAO,IACjFgI,gBAA2BC,OAAOC,EAAIG,kBAClCjI,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAoJ,kDAAA,EAAApJ,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,UACjEP,EAAIC,SAASC,IAAIhD,EAAIhD,QAC5B4F,OAAkBC,OAAOC,EAAIC,SAAS1J,IAAI2G,EAAIhD,aAC1ChC,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAoJ,kDAAA,EAAApJ,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,SAExEZ,EAAQK,EAAIG,WAAa/J,OAAAoJ,kDAAA,EAAApJ,CAA2B0B,EAAOoF,EAAIhD,QAC/D4F,gBAA2BC,OAAOC,EAAIG,oBAClCjI,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAoJ,kDAAA,EAAApJ,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,eAIhF,cAAe/J,EAAE,IACjB,IAAK,WACDmJ,EAAQK,EAAIG,WAAa3J,EAAE,GAC3BsJ,gBAA2BC,OAAOC,EAAIG,kBAClC3J,EAAEsD,MAAM,GAAG+C,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAa,CAAChK,OAAAoJ,kDAAA,EAAApJ,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,SACxF,MACJ,QACI,MAAM,IAAIjI,kEAAkE0F,KAAKC,UAAUzH,EAAE,aAIrGsJ,GAAc,YAGlBA,GAAcF,EAAaC,QAG/BC,GAAc,YAGlBA,GAAcF,EAAaC,GAE/B,OAAOC,EAIX,MAAME,EAAuB,CACzBL,UACAQ,UAAW,EACXF,SAAU,IAAIQ,IACdC,cAAe,EACfC,QAAS,UACTL,IAAK,IAAIG,IACTG,UAzGJ,SAAmBC,GACf,MAAMC,EAAe,IAAIL,IACzB,IAAK,MAAMnH,KAAK0G,EAAIC,SAASc,UACzBD,EAAa7D,IAAI3D,EAAE,GAAIA,EAAE,IAE7BuH,IACAb,EAAIC,SAAWa,GAoGfV,gBAGJhK,OAAAqJ,0CAAA,EAAArJ,CAAkB0B,EAAOkI,GACzB,MAAMM,EAAMN,EAAIM,IAEZxI,EAAME,OAAOgJ,6BACb1E,EAASlG,OAAAyI,uCAAA,EAAAzI,CAAiB0B,EAAOuC,EAAYiC,IAGjD,MAAMpB,EAAiB9E,OAAAyI,uCAAA,EAAAzI,CAAkB0B,GACzC,GAAIoD,EACA,IAAK,MAAM5B,KAAK4B,EACR9E,OAAOmB,eAAe1B,KAAKqF,EAAgB5B,KAC3CqG,EAAQK,EAAIG,aAAe7G,EAC3BqG,EAAQK,EAAIG,WAAajF,EAAe5B,GACxC0G,EAAIC,SAAShD,IAAI3D,cAAeyG,OAAOC,EAAIG,uBAAuBJ,OAAOC,EAAIG,UAAY,SACzFH,EAAIG,aAKhB,MAAMc,KAAoB5G,EAAWwC,IAAI,CAACvD,EAAG5D,KACzCsK,EAAIC,SAAShD,IAAI5C,EAAW3E,GAAGwE,OAAQ,IAAMxE,MAClCiF,GAAgBjF,IAAM2E,EAAWhC,OAAS,EAAK,MAAQ,MAAM3C,MACzE6K,KAAK,OAEFW,YAA2B5E,EAAOO,IAAI,CAACvD,EAAG5D,IAAM0K,EAAa9D,EAAQ5G,IAAI6K,KAAK,QACpF,mBAAoBU,eAA4BjB,EAAIW,UAAUO,MAKlE,SAASC,mBAAmBC,SAAyBzB,QAAgB0B,MAGjE,OADA1B,QAAQ,GAAKpC,KAAK8D,MACX1B,QAAQ,GAIb,SAAUJ,cAAczH,EAAsBuC,EAAwBM,EAAuB2B,GAE/F,MAAMqD,EAAiB,GACvB,OAAOwB,mBAAmBrJ,EAAO6H,EAASD,YAAY5H,EAAOuC,EAAYM,EAAc2B,EAAQqD,mCC7KnGnK,EAAAQ,EAAA0B,EAAA,sBAAA4J,IAAA,IAAAlI,EAAA5D,EAAA,GAAA6D,EAAA7D,EAAA,GAAA+L,EAAA/L,EAAA,GAkBM,SAAU8L,EAAkBxJ,EAAsBkI,GACpD,MAAML,QACFA,EADEW,IAEFA,EAFEM,UAGFA,EAHER,aAIFA,GACAJ,EAGJM,EAAIrD,IAAInF,EAAME,OAAO4B,cAAcuD,MAAO,SAAS3G,EAAc0B,GAC7D,IAAI4H,EAAa,GAGjB,OAFAH,EAAQK,EAAIG,WAAa3J,EAAE,GAC3BsJ,eAA0BC,OAAOC,EAAIG,mBAKzCG,EAAIrD,IAAInF,EAAME,OAAO4B,cAAc8C,KAAM,SAASlG,EAAc0B,GAC5D,IAAI4H,EAAa,GAGjB,OAFAA,oBACI5H,EAAK2E,IAAIvD,GAAK8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAiB0B,EAAOwB,IAAK,IAAIiH,KAAK,WAK1ED,EAAIrD,IAAI,QAAS,SAASzG,EAAc0B,GAIpC,IAAI4H,EAAa,GAKjB,OAJA1J,OAAAiD,EAAA,EAAAjD,CAAkB,qBAAsB8B,EAAM,EAAG,GACjD4H,OAAkBM,EAAa5J,EAAG,OAC9B4J,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,QACxC4J,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,SAKhD8J,EAAIrD,IAAI,aAAc,SAASzG,EAAc0B,GAIzC,IAAI4H,EAAa,GAIjB,OAHA1J,OAAAiD,EAAA,EAAAjD,CAAkB,0BAA2B8B,EAAM,EAAG,GACtD4H,uBAAkCM,EAAa5J,EAAG,0BAC9C4J,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,eAKhD8J,EAAIrD,IAAI,UAAW,SAASzG,EAAc0B,GAItC,IAAI4H,EAAa,GAEb1J,OAAAiD,EAAA,EAAAjD,CAAkB,uBAAwB8B,EAAM,GAChD4H,GAAc,IACd,IAAK,IAAItI,EAAI,EAAGA,EAAIU,EAAKG,OAAQb,GAAK,EAClCsI,MAAiBM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOI,EAAKV,KAAM,OACxD4I,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOI,EAAKV,EAAI,KAAM,QAEvDsI,GAAc,OACd,IAAK,IAAItI,EAAI,EAAGA,EAAIU,EAAKG,OAAQb,GAAK,EAClCsI,GAAc,IAItB,OAFIA,GAAc,MAMtBQ,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAIvC,IAAI4H,EAAa,GAMjB,OALA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,GACjD4H,kCACIM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,aACxCA,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,2BAM5ED,EAAIrD,IAAI,cAAe,SAASzG,EAAc0B,GAI1C,IAAI4H,EAAa,GAKjB,OAJA1J,OAAAiD,EAAA,EAAAjD,CAAkB,2BAA4B8B,EAAM,GACpD4H,qCACItJ,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,eACpEH,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,wBAKhD8J,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAIvC,IAAI4H,EAAa,GAMjB,OALA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,GACjD4H,mCACIM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,aACxCA,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,2BAM5ED,EAAIrD,IAAI,cAAe,SAASzG,EAAc0B,GAI1C,IAAI4H,EAAa,GAKjB,OAJA1J,OAAAiD,EAAA,EAAAjD,CAAkB,2BAA4B8B,EAAM,GACpD4H,qCACItJ,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,gBACpEH,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,wBAKhD8J,EAAIrD,IAAI,YAAa,SAASzG,EAAc0B,GAIxC,IAAI4H,EAAa,GAEjB,GADA1J,OAAAiD,EAAA,EAAAjD,CAAkB,yBAA0B8B,EAAM,IAC5C9B,OAAAgD,EAAA,EAAAhD,CAAS8B,EAAK,IAChB,MAAM,IAAII,MAAM,yDASpB,OAPAsI,EAAU,KACN,MAAM3K,EAAO,IAAM+J,EAAIU,gBACvBV,EAAIC,SAAShD,IAAK/E,EAAK,GAAgBgC,OAAQjE,GAC/C6J,wCAAmD7J,OAAUA,UAAaA,cACtEO,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,uBACjDH,EAAalI,EAAM,SAEvC4H,IAIXQ,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAIrC,IAAI4H,EAAa,GAEjB,GADA1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,IACzC9B,OAAAgD,EAAA,EAAAhD,CAAS8B,EAAK,IAChB,MAAM,IAAII,MAAM,sDASpB,OAPAsI,EAAU,KACN,MAAM3K,EAAO,IAAM+J,EAAIU,gBACvBV,EAAIC,SAAShD,IAAK/E,EAAK,GAAgBgC,OAAQjE,GAC/C6J,0CAAqD7J,oBACjDO,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,uBACjDH,EAAalI,EAAM,SAEvC4H,IAIXQ,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAIvC,IAAI4H,EAAa,GAIjB,GAHA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,IAG3CwB,MAAMC,QAAQnD,EAAE,IAClB,MAAM,IAAI8B,MAAM,uDA0BpB,OAxBAsI,EAAU,KACN,IAAK,MAAMtH,KAAKlD,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,IAAc,CAC9C,IAAIP,EAAO,GACX,GAAIyD,MAAMC,QAAQL,GAAI,CAClB,GAAIA,EAAEjB,OAAS,EACX,MAAM,IAAIC,MAAM,0DAEpB,IAAMlC,OAAAgD,EAAA,EAAAhD,CAASkD,EAAE,IACb,MAAM,IAAIhB,MAAM,8DAEpBrC,EAAOqD,EAAE,GAAGY,OACZ4F,OAAkB,IAAME,EAAIU,iBAAiBN,EAAa9G,EAAG,UAC1D,CACH,IAAMlD,OAAAgD,EAAA,EAAAhD,CAASkD,GACX,MAAM,IAAIhB,MAAM,2DAEpBrC,EAAOqD,EAAEY,OAEb8F,EAAIW,iBAAmBX,EAAIU,wBAC3BV,EAAIC,SAAShD,IAAI3D,EAAEY,OAAQ,IAAM8F,EAAIU,iBAEzC,MAAMjJ,KAAOjB,EAAEsD,MAAM,GAAG+C,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,OACjFT,GAActJ,EAAE,OAASiB,SAAWA,OAEjCqI,IAIXQ,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAIrC,IAAI4H,EAAa,GAYjB,OAXA1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,EAAG,GAClD4H,iBACIM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,aACxCwJ,EAAIU,uBAAuBV,EAAIU,cAAgB,cAAcX,OAAOC,EAAIG,kBAC5ER,EAAQK,EAAIG,aAAe/J,OAAAmL,EAAA,EAAAnL,CAAsB0B,GACjD8I,EAAU,KACNZ,EAAIC,SAAShD,IAAI,SAAU,IAAM+C,EAAIU,iBACrCV,EAAIC,SAAShD,IAAI,UAAW,IAAM+C,EAAIU,iBACtCZ,MACIM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,KAAM,aAEzCsJ,IAIXQ,EAAIrD,IAAInF,EAAME,OAAO4B,cAAc4H,MAAO,SAAShL,EAAc0B,GAG7D,IAAI4H,EAAa,GAGjB,OAFAA,mBACIM,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAiB0B,EAAOtB,EAAE,KAAM,YAKtD8J,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAGvC,IAAI4H,EAAa,GAIjB,OAHA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,EAAG,GACpD4H,WAAsBM,EAAalI,EAAM,8DAM7CoI,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAGrC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,GAC/C,MAAMuJ,EAASrL,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,IAC7BP,EAAOG,OAAAgD,EAAA,EAAAhD,CAASqL,GAAUA,EAAOvH,OAA4B,iBAAXuH,EAAsBA,EAAS,KACvF,GAAoB,iBAATxL,EACP,MAAM,IAAIqC,4DAA4D0F,KAAKC,UAAUzH,EAAE,QAE3F,IAAIkL,EAAQ,GACR1B,EAAIC,SAASC,IAAIjK,GACjByL,EAAQ1B,EAAIC,SAAS1J,IAAIN,IAEzB0J,EAAQK,EAAIG,WAAa/J,OAAAmL,EAAA,EAAAnL,CAA2B0B,EAAO7B,GAC3DyL,aAAmB3B,OAAOC,EAAIG,iBAUlC,OAJAL,QAAmB4B,KAASlL,EAAEsD,MAAM,GAAG+C,IAAI,CAACvD,EAAGwD,EAAK0D,QAChDpK,OAAAgD,EAAA,EAAAhD,CAASoK,EAAI1D,IALE6E,KACfhC,EAAQK,EAAIG,WAAawB,aACP5B,OAAOC,EAAIG,iBAIzByB,CAAWpB,EAAY1D,GAAK5C,QAC5BkG,EAAaI,EAAK1D,OAASyD,KAAK,SAK5CD,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAGrC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,EAAG,GAClD,MAAMuJ,EAASrL,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,IAC7BP,EAAOG,OAAAgD,EAAA,EAAAhD,CAASqL,GAAUA,EAAOvH,OAA4B,iBAAXuH,EAAsBA,EAAS,KACvF,GAAoB,iBAATxL,EACP,MAAM,IAAIqC,4DAA4D0F,KAAKC,UAAUzH,EAAE,QAO3F,OALMwJ,EAAIC,SAASC,IAAIjK,KACnB+J,EAAIW,iBAAmBX,EAAIU,wBAC3BV,EAAIC,SAAShD,IAAIhH,EAAM,IAAM+J,EAAIU,kBAErCZ,OAAkBE,EAAIC,SAAS1J,IAAIN,MAASmK,EAAa5J,EAAG,QAKhE8J,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAGrC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,GAC/C,MAAMuJ,EAASrL,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOtB,EAAE,IAC7BP,EAAOG,OAAAgD,EAAA,EAAAhD,CAASqL,GAClBA,EAAOvH,OACY,iBAAXuH,EACJA,EACC/H,MAAMC,QAAQ8H,GACVrL,OAAAgD,EAAA,EAAAhD,CAASqL,EAAO,IACbA,EAAO,GAAGvH,OACY,iBAAduH,EAAO,GAAkBA,EAAO,GAAK,KAEjD,KAGZ,GAAoB,iBAATxL,EACP,MAAM,IAAIqC,4DAA4D0F,KAAKC,UAAUzH,EAAE,QAE3F,IAAIkL,EAAQ,GACR1B,EAAIC,SAASC,IAAIjK,GACjByL,EAAQ1B,EAAIC,SAAS1J,IAAIN,IAEzB0J,EAAQK,EAAIG,WAAa/J,OAAAmL,EAAA,EAAAnL,CAA2B0B,EAAO7B,GAC3DyL,aAAmB3B,OAAOC,EAAIG,iBAUlC,OAJAL,QAAmB4B,MAAUhI,MAAMC,QAAQ8H,GAAUA,EAAO3H,MAAM,GAAK,IAAI+C,IAAI,CAACvD,EAAGwD,EAAK0D,QACpFpK,OAAAgD,EAAA,EAAAhD,CAASoK,EAAI1D,IALE6E,KACfhC,EAAQK,EAAIG,WAAawB,aACP5B,OAAOC,EAAIG,iBAIzByB,CAAWpB,EAAY1D,GAAK5C,QAC5BkG,EAAaI,EAAK1D,OAASyD,KAAK,OAAOH,EAAa5J,EAAG,QAKnE8J,EAAIrD,IAAInF,EAAME,OAAO4B,cAAciI,IAAK,SAASrL,EAAc0B,GAG3D,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,oBAAqB8B,EAAM,EAAG,GAChD4H,QAAmBM,EAAalI,EAAM,QAK1CoI,EAAIrD,IAAI,SAAU,SAASzG,EAAc0B,GAIrC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,sBAAuB8B,EAAM,GAC/C4H,OAAkB5H,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,WAKpFD,EAAIrD,IAAI,QAAS,SAASzG,EAAc0B,GAIpC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,qBAAsB8B,EAAM,GAC9C4H,OAAkB5H,EAAK2E,IAAKvD,GAAM8G,EAAa,CAAChK,OAAAmL,EAAA,EAAAnL,CAAW0B,EAAOwB,IAAK,IAAIiH,KAAK,WAKpFD,EAAIrD,IAAI,MAAO,SAASzG,EAAc0B,GAIlC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,mBAAoB8B,EAAM,EAAG,GAC/C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,YAK7ED,EAAIrD,IAAI,MAAO,SAASzG,EAAc0B,GAIlC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,mBAAoB8B,EAAM,EAAG,GAC/C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,YAK7ED,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,EAAG,GAC7C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAK7ED,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,EAAG,GAC7C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAK7ED,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,UAAW,SAASzG,EAAc0B,GAGtC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,uBAAwB8B,EAAM,GAChD,IAAI4J,EAAK,GACT,GAAIpI,MAAMC,QAAQzB,EAAK,KAAO9B,OAAAgD,EAAA,EAAAhD,CAAU8B,EAAK,GAAW,GAAIJ,EAAME,OAAO4B,cAAc6D,QAAS,CAC5F,MAAMsE,EAAK3B,EAAalI,EAAK,GAAW,GACxC4J,MAASC,iBAAkBA,cAAeA,gBAAiBA,gCAE3DD,KAAQ1B,EAAalI,EAAa,aAItC,OAFA4H,OAAkBgC,IACd5J,EAAK4B,MAAM,GAAG+C,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAKxED,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,GAE1C,IAAI8J,GAAY,EAahB,OAZA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,iDAG1DrI,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAMjFD,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,GAE1C,IAAI8J,GAAY,EAehB,OAdA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,mGAG1D/J,EAAE6B,OAAS,EACzBH,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAClDR,OAAOK,EAAa5J,EAAG,YAMxC8J,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,GAE1C,IAAI8J,GAAY,EAahB,OAZA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,iDAG1DrI,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAMjFD,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,GAE3C,IAAI8J,GAAY,EAahB,OAZA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,kDAG1DrI,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAMjFD,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,GAE1C,IAAI8J,GAAY,EAahB,OAZA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,iDAG1DrI,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAMjFD,EAAIrD,IAAI,IAAK,SAASzG,EAAc0B,GAGhC,IAAI4H,EAAa,GACjB1J,OAAAiD,EAAA,EAAAjD,CAAkB,iBAAkB8B,EAAM,GAE1C,IAAI8J,GAAY,EAahB,OAZA9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,KACV9G,MAAMC,QAAQL,IAAMlD,OAAAgD,EAAA,EAAAhD,CAAUkD,EAAU,GAAIxB,EAAME,OAAO4B,cAAc6D,UACvEuE,GAAY,KAIhBlC,GADAkC,yBAEI9J,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,kBAAsBJ,EAAaI,EAAK1D,OAASyD,KAAK,iDAG1DrI,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAMjFD,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,KAAM,SAASzG,EAAc0B,GAGjC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,kBAAmB8B,EAAM,EAAG,GAC9C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,WAK7ED,EAAIrD,IAAI,MAAO,SAASzG,EAAc0B,GAGlC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,mBAAoB8B,EAAM,EAAG,GAC/C4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,YAK7ED,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAGvC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,EAAG,GACpD4H,SAAoBM,EAAa5J,EAAG,SAKxC8J,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAGvC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,EAAG,GACpD4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAK7ED,EAAIrD,IAAI,UAAW,SAASzG,EAAc0B,GAGtC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,uBAAwB8B,EAAM,EAAG,GACnD4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,UAK7ED,EAAIrD,IAAI,WAAY,SAASzG,EAAc0B,GAGvC,IAAI4H,EAAa,GAGjB,OAFA1J,OAAAiD,EAAA,EAAAjD,CAAkB,wBAAyB8B,EAAM,EAAG,GACpD4H,OAAkB5H,EAAK2E,IAAI,CAACvD,EAAGwD,EAAK0D,IAAQJ,EAAaI,EAAK1D,IAAMyD,KAAK,kGC3pBjF,SAAS0B,EAAMC,GACX,MAAqB,iBAAPA,GAAmB9L,OAAOkB,UAAUC,eAAe1B,KAAKqM,EAAI,OAI9E,SAASC,EAAQD,GACb,MAAqB,iBAAPA,GAAwC,IAArBA,EAAGE,OAAO/J,OAI/C,SAASgK,EAAkBH,GACvB,MAAqB,iBAAPA,GAAmB,cAAcI,KAAKJ,GAIxD,SAASK,EAAsBL,GAC3B,MAAqB,iBAAPA,GAAmB,UAAUI,KAAKJ,GAIpD,SAASM,EAAkBN,GACvB,MAAqB,iBAAPA,IACTC,EAAQD,KACRG,EAAkBH,GAK3B,SAASO,EAAoB3K,GACzB,eAAgBA,EAAM4K,mBAAmB5K,EAAM6K,gBAAgB7K,EAAM8K,QACjE9K,EAAM+K,QAAQxK,OAASP,EAAM6K,MACzB7K,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,IAAM,KAI1E,SAASE,EAAQhL,EAAsBiL,EAAuBC,GAC1D,GAAIlL,EAAM+K,QAAQxK,QAAUP,EAAM6K,MAC9B,MAAO,CAACM,KAAK,GAEjB,GAAInL,EAAM+K,QAAQ/K,EAAM6K,OAAOtK,QAAUP,EAAM8K,IAAK,CAChD,IAAO9K,EAAMoL,QAAYpL,EAAMoL,OAAO7K,QAAUP,EAAM6K,MAGlD,OAFA7K,EAAM8K,IAAM,EACZ9K,EAAM6K,QACCG,EAAQhL,GACZ,CACH,MAAMoK,EAAK,CAACvL,MAAOmB,EAAMoL,OAAOpL,EAAM6K,QAGtC,OAFA7K,EAAM8K,IAAM,EACZ9K,EAAM6K,QACCT,GAGf,GAAIa,EACA,IAAK,MAAMlF,KAAKkF,EAAY,CACxB,MAAMb,EAAKpK,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM/E,EAAExF,QACrE,GAAI6J,IAAOrE,EAGP,OAFA/F,EAAM8K,KAAO/E,EAAExF,OACfP,EAAM4K,MAAQR,EAAGiB,MAAM,MAAM9K,OAAS,EAC/B,CAAE4K,KAAK,EAAQG,OAAQvF,GAI1C,CACI,IAAIqE,EAAKpK,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,GAOjE,GANA9K,EAAM8K,MAEK,OAAPV,GACApK,EAAM4K,QAGHM,GAAyB,OAAPd,EAAa,CAClC,GAAIpK,EAAM+K,QAAQ/K,EAAM6K,OAAOtK,QAAUP,EAAM8K,IAC3C,MAAM,IAAItK,0CAA0CmK,EAAoB3K,OAK5E,OAHAoK,EAAKpK,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,GAC7D9K,EAAM8K,MAEEV,GACR,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IACDA,EAAK,KACL,MACJ,IAAK,IAAK,IAAK,IAEP,GAAmE,MAA/DpK,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,GAAY,CACpE,IAAIS,EAAM,GACV,IAAK,IAAI3N,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAM4N,EAAMxL,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAMlN,EAAGoC,EAAM8K,IAAM,EAAIlN,GAC5E,GAAY,MAAR4N,EAAa,CACb,GAAU,IAAN5N,EACA,MAAM,IAAI4C,0CAA0CmK,EAAoB3K,OAE5EA,EAAM8K,KAAOlN,EACb,MACG,IAAM,mBAAmB4M,KAAKe,GACjC,MAAM,IAAI/K,0CAA0CmK,EAAoB3K,OAE5EuL,GAAOC,EAEX,GAAmE,MAA/DxL,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,GACxD,MAAM,IAAItK,0CAA0CmK,EAAoB3K,OAE5EA,EAAM8K,MACNV,EAAKnC,OAAOwD,cAAc/J,OAAOgK,SAASH,EAAK,SAC5C,CACH,MAAMA,EAAMvL,EAAM+K,QAAQ/K,EAAM6K,OAAO7I,MAAMhC,EAAM8K,IAAK9K,EAAM8K,IAAM,GACpE,IAAM,mBAAmBN,KAAKe,GAC1B,MAAM,IAAI/K,0CAA0CmK,EAAoB3K,OAE5EA,EAAM8K,KAAO,EACbV,EAAKnC,OAAOwD,cAAc/J,OAAOgK,SAASH,EAAK,OAM/D,OAAOnB,GAKf,SAASuB,EAAW3L,EAAsBX,EAAW4L,EAAuBC,GACxE,MAAML,EAAQ7K,EAAM6K,MACdC,EAAM9K,EAAM8K,IACZF,EAAO5K,EAAM4K,KACbgB,EAAgB,GAEtB,IACI,IAAK,IAAIhO,EAAI,EAAGA,EAAIyB,EAAGzB,IACnBgO,EAAI7H,KAAKiH,EAAQhL,EAAOiL,EAAYC,IAF5C,QAKIlL,EAAM6K,MAAQA,EACd7K,EAAM8K,IAAMA,EACZ9K,EAAM4K,KAAOA,EAGjB,OAAOgB,EAIX,SAASC,EAAU7L,EAAsBiL,EAAuBC,GAC5D,MAAML,EAAQ7K,EAAM6K,MACdC,EAAM9K,EAAM8K,IACZF,EAAO5K,EAAM4K,KACnB,IAAIR,EAEJ,IACIA,EAAKY,EAAQhL,EAAOiL,EAAYC,GADpC,QAGIlL,EAAM6K,MAAQA,EACd7K,EAAM8K,IAAMA,EACZ9K,EAAM4K,KAAOA,EAGjB,OAAOR,EAIX,SAAS0B,EAAgB9L,GACrB,IAAIoK,EAAKyB,EAAU7L,GACnB,MAAQmK,EAAMC,IAAOC,EAAQD,IACzBY,EAAQhL,GACRoK,EAAKyB,EAAU7L,GAMvB,SAAS+L,EAAY/L,EAAsBiL,GACvC,IAAItL,EAAI,GACJyK,EAAKyB,EAAU7L,EAAOiL,GAE1B,MAASd,EAAMC,IACO,iBAAPA,GADK,CAEZ,GAAI,oBAAoBI,KAAK7K,EAAIyK,GAC7BY,EAAQhL,EAAOiL,GACftL,GAAKyK,MACF,KAAI,8BAA8BI,KAAK7K,EAAIyK,GAI9C,MAHAY,EAAQhL,EAAOiL,GACftL,GAAKyK,EAQbA,EAAKyB,EAAU7L,EAAOiL,GAG1B,IAAM,mFAAmFT,KAAK7K,GAC1F,MAAM,IAAIa,8CAA8CmK,EAAoB3K,OAEhF,OAAO0B,OAAO/B,GAIlB,SAASqM,EAAYhM,EAAsBiL,GACvC,IAAItL,EAAI,GACJyK,EAAKyB,EAAU7L,EAAOiL,GAE1B,MAASd,EAAMC,IAAK,CAChB,GAAkB,iBAAPA,EAAiB,CACxB,GAAIC,EAAQD,GACR,MACG,GAAW,MAAPA,GAAsD,MAAxCuB,EAAW3L,EAAO,EAAGiL,GAAY,GACtD,MACG,IAAI,cAAcT,KAAK7K,EAAIyK,GAI9B,MAHAY,EAAQhL,EAAOiL,GACftL,GAAKyK,MAIN,CACH,GAAkB,iBAAPA,IAAmB9L,OAAOkB,UAAUC,eAAe1B,KAAKqM,EAAI,SAKnE,MAAM,IAAI5J,8CAA8CmK,EAAoB3K,OAJ5EgL,EAAQhL,EAAOiL,GACJb,EAAuBvL,MAClCc,GAAKsI,OAAOmC,GAMpBA,EAAKyB,EAAU7L,EAAOiL,GAG1B,GAAIjL,EAAME,OAAO+L,iBAAkB,CAC/B,IAAIjO,EAA6B,KAEjC,GAAIA,EAAI2B,EAAEuM,MAAM,qBAAsB,CAElC,MAAMC,EAAKnO,EAAE,GAAGqN,MAAM,KAOtB,MALI,CAAC,CAACjJ,OAAQpC,EAAME,OAAO4B,cAAcC,QACjC,CAAC,CAACK,OAAQpC,EAAME,OAAO4B,cAAcqD,KACjCgH,IAMX,GAAInO,EAAI2B,EAAEuM,MAAM,6BAA8B,CAE/C,MAAMC,EAAKnO,EAAE,GAAGqN,MAAM,KAQtB,MANI,CAAC,CAACjJ,OAAQpC,EAAME,OAAO4B,cAAcC,QACjC,CAAC,CAACK,OAAQpC,EAAME,OAAO4B,cAAc/D,MACjC,CAAC,CAACqE,OAAQpC,EAAME,OAAO4B,cAAcrD,QAAS0N,GAC9C,CAAC/J,OAAQpE,EAAE,MAMtB,GAAIA,EAAI2B,EAAEuM,MAAM,gBAAiB,CAElC,MAAMC,EAAKnO,EAAE,GAAGqN,MAAM,KAEtB,MADU,CAAC,CAACjJ,OAAQpC,EAAME,OAAO4B,cAAcrD,QAAS0N,IAKhE,MAAO,CAAC/J,OAAQzC,GAIpB,SAASyM,EACDpM,EAAsBmL,EACtBkB,EACAC,EACApB,GAGJ,MAAMqB,EAAUF,EAAiB,IAAIlB,EAAKkB,GAAkBlB,EACtDJ,EAAoB,GACpBK,EAAgB,GAEtB,OAAS,CACL,IAAIzL,EAAI,GACJyK,EAAKyB,EAAU7L,EAAOuM,EAASrB,GAEnC,MAASf,EAAMC,IAAK,CAChB,GAAkB,iBAAPA,EACPY,EAAQhL,EAAOuM,EAASrB,GACxBvL,GAAKyK,MACF,CACH,GAAkB,iBAAPA,IAAmB9L,OAAOkB,UAAUC,eAAe1B,KAAKqM,EAAI,SAKnE,MAAM,IAAI5J,uDAAuDmK,EAAoB3K,OAJrFgL,EAAQhL,EAAOuM,EAASrB,GACbd,EAAuBvL,MAClCc,GAAKsI,OAAOmC,GAMpBA,EAAKyB,EAAU7L,EAAOuM,EAASrB,GAKnC,GAFAF,EAAQhL,EAAOuM,EAASrB,IAEE,IAArBd,EAAae,IACd,MAAM,IAAIqB,EAAA,EAAuB,wBAKrC,GAFAzB,EAAQhH,KAAKpE,GAERyK,EAAakB,SAAWe,EAGzB,MAFAjB,EAAOrH,KAAK0I,EAAUzM,EAAOsM,EAAgB,KAMrD,MAAO,CAAEvB,UAASK,UAItB,SAASsB,EAAY1M,EAAsBkL,GACvC,OAAOkB,EAAqBpM,EAAO,CAAC,KAAM,KAAM,IAAKkL,GAAeH,QAAQ,GAIhF,SAAS4B,EAAa3M,EAAsBoC,EAAkBwK,GAC1D,MAAMC,EAAe,CAACzK,GAElBwK,GACAC,EAAE9I,KAAK6I,GAGX,MAAME,EAAQV,EAAqBpM,EAAO,CAAC,OAAQ,OAAQ,KAAK,GAChE,IAAK,IAAIpC,EAAI,EAAGA,EAAIkP,EAAM/B,QAAQxK,OAAQ3C,IACtCiP,EAAE9I,KAAK+I,EAAM/B,QAAQnN,IACjBA,EAAIkP,EAAM1B,OAAO7K,QACjBsM,EAAE9I,KAAK+I,EAAM1B,OAAOxN,IAI5B,OAAOiP,EAIX,SAASE,EAAuB/M,GAC5B,MAAO,CACHgN,QAASZ,EAAqBpM,EAAO,CAAC,KAAM,MAAO,KAAM,KAAK,GAAO+K,QAAQ,IAKrF,SAASkC,EAAsBjN,GAC3B,MAAO,CACHgN,QAASZ,EAAqBpM,EAAO,CAAC,MAAO,KAAM,KAAK,GAAO+K,QAAQ,IAK/E,SAASmC,EAAclN,GACnB8L,EAAgB9L,GAChB,IAAIoK,EAAKyB,EAAU7L,GAEnB,MAASmK,EAAMC,IAAK,CAChB,OAAQA,GACR,IAAK,IACD,MAAM,IAAI5J,gDAAgDmK,EAAoB3K,OAElF,IAAK,IAED,OADAgL,EAAQhL,GACDyM,EAAUzM,EAAO,IAAK,IAEjC,IAAK,IAAK,IAAK,IAAK,IAAK,IACrB,CACIgL,EAAQhL,GACR,MAAMmN,EAAQtB,EAAU7L,GACxB,IAAIoN,GAAkB,EACX,MAAPhD,GAAwB,MAAV+C,IACdnC,EAAQhL,GACRoN,GAAkB,GAEtBtB,EAAgB9L,GAChB,MAAMqN,GAAc,MAAPjD,EACLkD,EAAA,EACQ,MAAPlD,EAAakD,EAAA,EAAYA,EAAA,GAC7BtN,EAAOkN,EAAclN,IAE1B,OAAQoN,EAAkB9O,OAAAgP,EAAA,EAAAhP,CAAO0B,EAAOqN,GAAOA,EAGvD,IAAK,IACD,CACIrC,EAAQhL,GACR,MAAMuN,EAAS5B,EAAW3L,EAAO,GACjC,OAAIA,EAAME,OAAOsN,cAA8B,MAAdD,EAAO,IAA4B,MAAdA,EAAO,IACzDvC,EAAQhL,GACRgL,EAAQhL,GACR8L,EAAgB9L,GACT1B,OAAAgP,EAAA,EAAAhP,CAAO0B,EAAOkN,EAAclN,MAEnC8L,EAAgB9L,GACT,CAACuG,OAAQ2G,EAAclN,KAI1C,IAAK,IAED,OADAgL,EAAQhL,GACD+M,EAAuB/M,GAElC,IAAK,IAGG,MAAkB,MADH2L,EAAW3L,EAAO,GACtB,IACPgL,EAAQhL,GACRgL,EAAQhL,GACDiN,EAAsBjN,IAEtBgM,EAAYhM,GAI/B,IAAK,IACD,CACIgL,EAAQhL,GACR,MAAMuN,EAAS5B,EAAW3L,EAAO,GACjC,GAAIA,EAAME,OAAOuN,eAA+B,MAAdF,EAAO,IAA4B,MAAdA,EAAO,GAAY,CACtE,IAAIG,GAAY,EACZvD,EAAMoD,EAAO,KAAOlD,EAAQkD,EAAO,MAE5BhD,EAAkBgD,EAAO,IACd,MAAdA,EAAO,IAA4B,MAAdA,EAAO,IACtB9C,EAAsB8C,EAAO,MAC/BG,GAAY,GAIbhD,EAAkB6C,EAAO,MAChCG,GAAY,IAIhB1C,EAAQhL,GACRgL,EAAQhL,GAER,IAAIoF,EAAgC,KAChCwH,EAA0B,KAC9B,GAAIc,EACAtI,EAAM,CAAChD,OAAQpC,EAAME,OAAO4B,cAAc6L,cACvC,CAEH,GAAY,QADZvI,EAAM4G,EAAYhM,EAAO,CAAC,OAEtB,MAAM,IAAIQ,gDAAgDmK,EAAoB3K,OAElF,GAAmB,iBAARoF,EACP,MAAM,IAAI5E,gDAAgDmK,EAAoB3K,OAElF,MAAM4N,EAAMjC,EAAW3L,EAAO,GAC9B,GAAe,MAAX4N,EAAI,GAAY,CAChB,GAAe,MAAXA,EAAI,GACJ,MAAM,IAAIpN,gDAAgDmK,EAAoB3K,OAElFgL,EAAQhL,GACRgL,EAAQhL,GACR,MAAM4D,EAAI6I,EAAUzM,EAAO,IAAK,CAAC,CAACoC,OAAQ,OACtCR,MAAMC,QAAQ+B,KACdgJ,EAAQhJ,IAKpB,OAAO+I,EAAa3M,EAAOoF,EAAKwH,GAEhC,OAAOF,EAAY1M,GAAO,GAItC,IAAK,IACD,GAAIA,EAAME,OAAO2N,4BAA6B,CAE1C,GAAkB,MADHlC,EAAW3L,EAAO,GACtB,GAGP,OAFAgL,EAAQhL,GACRgL,EAAQhL,GACD0M,EAAY1M,GAAO,GAKtC,QACI,GAAkB,iBAAPoK,EAAiB,CACxB,GAAkB,iBAAPA,GAAmB9L,OAAOkB,UAAUC,eAAe1B,KAAKqM,EAAI,SAEnE,OADAY,EAAQhL,GACDA,EAAME,OAAOkG,kBAAoBgE,EAAMA,EAAuBvL,MAErE,MAAM,IAAI2B,gDAAgDmK,EAAoB3K,OAE/E,GAAIqK,EAAQD,GACf,MACG,GAAIG,EAAkBH,GAAK,CAC9B,GAAW,MAAPA,GAAqB,MAAPA,EAAY,CAE1B,IAAMK,EADSkB,EAAW3L,EAAO,GACE,IAC/B,OAAOgM,EAAYhM,GAG3B,OAAO+L,EAAY/L,GAChB,GAAI0K,EAAkBN,GACzB,OAAO4B,EAAYhM,GAEnB,MAAM,IAAIQ,gDAAgDmK,EAAoB3K,OAItF8L,EAAgB9L,GAChBoK,EAAKyB,EAAU7L,GAGnB,MAAM,IAAIwM,EAAA,EAAuB,iBAIrC,SAASC,EAAUzM,EAAsB8N,EAAsBC,GAC3D,MAAMrP,EAAeqP,EAAY/L,MAAM,GACvC,IAAIuE,GAAS,EAEbuF,EAAgB9L,GAChB,IAAIoK,EAAKyB,EAAU7L,GAEnB,MAASmK,EAAMC,IAAK,CAChB,OAAQA,GACR,KAAK0D,EAED,OADA9C,EAAQhL,GACJuG,EACO7H,EAAE,GAEFA,EAGf,QACI,CACI,MAAMI,EAAIoO,EAAclN,GACxB,GAAiB,iBAANlB,GAAkBR,OAAOkB,UAAUC,eAAe1B,KAAKe,EAAG,UAAW,CAC5E,GAAiB,IAAbJ,EAAE6B,OACF,MAAM,IAAIC,4CAA4CmK,EAAoB3K,OAE9EuG,GAAS,EACL3E,MAAMC,QAAQ/C,IACdA,EAAE+E,QAAQnF,EAAEsF,OACZtF,EAAEqF,KAAKjF,IAEPJ,EAAEqF,KAAK,CAACsC,IAAK3H,EAAEsF,MAAkBsC,IAAMxH,EAAuByH,cAE/D,GAAiB,iBAANzH,GAAkBR,OAAOkB,UAAUC,eAAe1B,KAAKe,EAAG,WAClEkB,EAAME,OAAO8N,eACftP,EAAEqF,KAAKjF,OAER,CACH,GAAIyH,EACA,MAAM,IAAI/F,4CAA4CmK,EAAoB3K,OAE9EtB,EAAEqF,KAAKjF,KAMnBgN,EAAgB9L,GAChBoK,EAAKyB,EAAU7L,GAGnB,MAAM,IAAIwM,EAAA,EAAuB,aAK/B,SAAUyB,EAAMjO,GAClB,MAAMtB,EAAe,GAErBoN,EAAgB9L,GAChB,IAAIoK,EAAKyB,EAAU7L,GAEnB,MAASmK,EAAMC,IAAK,CAChB,OAAQA,GACR,IAAK,IACDY,EAAQhL,GACRtB,EAAEqF,KAAK0I,EAAUzM,EAAO,IAAK,KAC7B,MAEJ,IAAK,IAAK,IAAK,IAIP,IAFAgL,EAAQhL,GACR8L,EAAgB9L,KACP,CACL,MAAMlB,EAAIoO,EAAclN,GACxB,GAAiB,iBAANlB,IAAkBR,OAAOkB,UAAUC,eAAe1B,KAAKe,EAAG,WAI9D,CACHJ,EAAEqF,MAAa,MAAPqG,EAAakD,EAAA,EAAQA,EAAA,GAAWtN,EAAOlB,IAC/C,MALMkB,EAAME,OAAO8N,eACftP,EAAEqF,KAAKjF,GAOnB,MAGR,IAAK,IACDkM,EAAQhL,GACJA,EAAME,OAAO8N,cACbjB,EAAuB/M,GAEvBtB,EAAEqF,KAAKgJ,EAAuB/M,IAElC,MAEJ,IAAK,IAGqB,MADH2L,EAAW3L,EAAO,GACtB,IACPgL,EAAQhL,GACRgL,EAAQhL,GACJA,EAAME,OAAO8N,cACbf,EAAsBjN,GAEtBtB,EAAEqF,KAAKkJ,EAAsBjN,MAGjCgL,EAAQhL,GACJA,EAAME,OAAO8N,cACbjB,EAAuB/M,GAEvBtB,EAAEqF,KAAKgJ,EAAuB/M,KAI1C,MAEJ,IAAK,IACD,CACI,MAAMuN,EAAS5B,EAAW3L,EAAO,GACjC,GAAkB,MAAduN,EAAO,IAA4B,MAAdA,EAAO,GAAY,CACxC7O,EAAEqF,KAAKmJ,EAAclN,IACrB,OAKZ,QACI,MAAM,IAAIQ,oDAAoDmK,EAAoB3K,OAGtF8L,EAAgB9L,GAChBoK,EAAKyB,EAAU7L,GAGnB,OAAOtB,2BCjpBJ,MAAMwP,EAAO,CAAClO,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAEnC,MAAMiG,EAAM+H,KAAWhO,GACvB,IAAMwB,MAAMC,QAAQwE,GAChB,MAAM,IAAI7F,MAAM,yDAEpB,GAAmB,IAAf6F,EAAI9F,OACJ,MAAM,IAAIC,MAAM,mDAEpB,OAAO6F,EAAI,IAKFgI,GAHQH,IAGD,CAAClO,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAEnC,MAAMiG,EAAM+H,KAAWhO,GACvB,IAAMwB,MAAMC,QAAQwE,GAChB,MAAM,IAAI7F,MAAM,yDAEpB,GAAmB,IAAf6F,EAAI9F,OACJ,MAAM,IAAIC,MAAM,mDAEpB,OAAO6F,EAAIrE,MAAM,KAKRsM,GAHQD,IAGA,CAACrO,EAAsB7B,IAAiB,IAAIiC,KAO7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,IAAIiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GAQrC,OAPY,OAARiG,IACAA,EAAM,IAEE,OAARC,IACAA,EAAM,IAGN1E,MAAMC,QAAQyE,KACdA,EAAMA,EAAItE,MAAM,IACZ6B,QAAQwC,GACLC,GAEA,CAACD,MAAKC,SAMRkI,GAHSF,IAGA,CAACtO,EAAsB7B,IAAiB,IAAIiC,KAK9D,MAAMiG,EAAWjG,EAAK4B,MAAM,EAAG,GAC/B,OAAuB,IAAfqE,EAAI9F,OAAgB8F,EAAI,GAAK,OAE5B+H,EARiD,IAAIhO,KAK9D,MAAMiG,EAAWjG,EAAK4B,MAAM,EAAG,GAC/B,OAAuB,IAAfqE,EAAI9F,OAAgB8F,EAAI,GAAK,MAK5BoI,EAAU,CAACzO,EAAsB7B,IAAiB,IAAIiC,KAK/D,MAAMkG,EAAWlG,EAAK4B,MAAM,EAAG,GAC/B,OAAuB,IAAfsE,EAAI/F,OAAgB+F,EAAI,GAAK,MAE5BoI,EARkD,IAAItO,KAK/D,MAAMkG,EAAWlG,EAAK4B,MAAM,EAAG,GAC/B,OAAuB,IAAfsE,EAAI/F,OAAgB+F,EAAI,GAAK,MAK5BqI,EAAQ,CAAC3O,EAAsB7B,IAAiB,IAAIiC,KAK7D,MAAMiG,EAAWjG,EAAK4B,MAAM5B,EAAKG,OAAS,EAAGH,EAAKG,QAClD,OAAuB,IAAf8F,EAAI9F,OAAgB8F,EAAI,GAAK,MAK5BuI,EAAQ,CAAC5O,EAAsB7B,IAAiB,IAAIiC,KAK7D,MAAMkG,EAAWlG,EAAK4B,MAAM,GAC5B,OAAQ,EAAIsE,EAAI/F,OAAU+F,EAAM,MAKvBuI,EAAkB,CAAC7O,EAAsB7B,IAAiB,IAAIiC,KAGvE,IAAIiG,EAAWjG,EAAK4B,MAAM,EAAG,GAC7BqE,EAAsB,IAAfA,EAAI9F,OAAgB8F,EAAI,GAAK,KAEpC,IAAIC,EAAWlG,EAAK4B,MAAM,EAAG,GAG7B,MAAO,CAACqE,MAAKC,IAFbA,EAAsB,IAAfA,EAAI/F,OAAgB+F,EAAI,GAAK,OAI3BiI,EAX0D,IAAInO,KAGvE,IAAIiG,EAAWjG,EAAK4B,MAAM,EAAG,GAC7BqE,EAAsB,IAAfA,EAAI9F,OAAgB8F,EAAI,GAAK,KAEpC,IAAIC,EAAWlG,EAAK4B,MAAM,EAAG,GAG7B,MAAO,CAACqE,MAAKC,IAFbA,EAAsB,IAAfA,EAAI/F,OAAgB+F,EAAI,GAAK,OAO3BwI,EAAQ,CAAC9O,EAAsB7B,IAAiB,IAAIiC,KAI7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,EAAM+H,KAAWhO,GAEvB,GAAIiG,QACA,OAAO,EAEX,GAAIzE,MAAMC,QAAQwE,GACd,OAAmB,IAAfA,EAAI9F,OAIZ,cAAe8F,GACf,IAAK,SAAU,IAAK,SAAU,IAAK,WAAY,IAAK,UAChD,OAAO,EACX,IAAK,SACD,QAAO/H,OAAAgP,EAAA,EAAAhP,CAAS+H,GAEpB,OAAO,GAKE0I,GAHSD,IAGH,CAAC9O,EAAsB7B,IAAiB,IAAIiC,KAI3D9B,OAAA6P,EAAA,EAAA7P,CAAkB,MAAO8B,EAAM,EAAG,GAElC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAOiG,IAAQC,IAKN0I,GAHOD,IAGE,CAAC/O,EAAsB7B,IAAiB,IAAIiC,KAI9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAOiG,IAAQC,IAKN2I,GAHUD,IAGF,CAAChP,EAAsB7B,IAAiB,IAAIiC,IAG7DA,EAAK4B,MAAM,IAKFkN,EAAW,CAAClP,EAAsB7B,EAAciF,IAAoC,IAAIhD,KAIjG9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,GAEpC,MAAMiD,EAAe+K,KAAWhO,GAC1B+O,EAAiBT,KAAYtO,IAC7BiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,EAAK4B,MAAM,IAClD,IAAItD,EAAa,KAEjB,MAAMyE,EAAa,GACnB,GAAIvB,MAAMC,QAAQwE,GACd,IAAK,MAAM7E,KAAK6E,EACZ,GAAIzE,MAAMC,QAAQL,GAAI,CAClB,MAAM4N,EAAKb,KAAoB/M,GACzB6N,EAAQ/Q,OAAAgP,EAAA,EAAAhP,CAAS8Q,EAAG/I,KAC1BlD,EAAMkM,EAAQA,EAAMjN,OAAS6F,OAAOmH,EAAG/I,MAAQ/H,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOoP,EAAG9I,SAC/D,CACH,MAAMgJ,EAAOhR,OAAAgP,EAAA,EAAAhP,CAASkD,GACtB2B,EAAMmM,EAAOA,EAAKlN,OAAS6F,OAAOzG,IAAM,KAIpDlD,OAAA+C,EAAA,EAAA/C,CAAa0B,EAAOmD,EAAOE,EAAcD,GAEzC,IACI,GAAI,EAAIhD,EAAKG,OACT,GAAI4O,EAAgB,CAChBzQ,EAAI,GACJ,IAAK,MAAM8C,KAAKpB,EAAK4B,MAAM,GACvBtD,EAAEqF,KAAKzF,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,SAG3B,IAAK,MAAMA,KAAKpB,EAAK4B,MAAM,GACvBtD,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,QAI5B9C,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOsG,GAb5B,QAgBIhI,OAAA+C,EAAA,EAAA/C,CAAe0B,GAGnB,OAAOtB,GAmEE6Q,EAAY,CAACvP,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,GAErC,MAAMmC,EAAyBnC,EAAK,GACpC,IAAMwB,MAAMC,QAAQU,GAChB,MAAM,IAAI/B,MAAM,8DAGpB,IAAIqC,GAAe,EACnB,IAAK,IAAIjF,EAAI,EAAGA,EAAI2E,EAAWhC,OAAQ3C,IAAK,CACxC,MAAM4R,EAAKjN,EAAW3E,GACtB,GAAIA,IAAM2E,EAAWhC,OAAS,GAAKP,EAAME,OAAOsN,cAC5C5L,MAAMC,QAAQ2N,IAAOlR,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,GAAIxP,EAAME,OAAO4B,cAAc6D,QAAS,CACzE,IAAMrH,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,IACd,MAAM,IAAIhP,qEAAqE5C,qBAEnF2E,EAAW3E,GAAK4R,EAAG,GACnB3M,GAAe,OACZ,IAAMvE,OAAAgP,EAAA,EAAAhP,CAASkR,GAClB,MAAM,IAAIhP,qEAAqE5C,qBAIvF,IAAI4G,EAASpE,EAAK4B,MAAM,GACpBhC,EAAME,OAAOgJ,6BACb1E,EAASlG,OAAA+C,EAAA,EAAA/C,CAAiB0B,EAAOuC,EAAYiC,IAGjD,MAAMpB,EAAiB9E,OAAA+C,EAAA,EAAA/C,CAAkB0B,GAEnCwC,EAAK,IAAIC,KACX,GAAKA,EAAWlC,QAAUsC,EAAe,EAAI,GAAMN,EAAWhC,OAC1D,MAAM,IAAIC,uDACNiC,EAAWlC,mBAAmBgC,EAAWhC,WAIjD,OAAO2O,EAASlP,EAAO7B,EAAMiF,EAAtB8L,EAAsC,GAAO,EAAO,CACvD,CAAClP,EAAME,OAAO4B,cAAc8C,KAAMpC,MAC9BD,EAAWwC,IAAI,CAACvD,EAAaqJ,IAAU,CACvCrJ,EAAEY,OACF9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EACD6C,GAAgBgI,IAAUtI,EAAWhC,OAAS,EAC3CkC,EAAWT,MAAM6I,GAASpI,EAAWoI,UAG/CrG,IAEV,OAAOhC,GAKEiN,EAAiB,CAACzP,EAAsB7B,IAAiB,IAAIiC,KAGtE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,GAEtC,MAAMmC,EAAyBnC,EAAK,GACpC,IAAMwB,MAAMC,QAAQU,GAChB,MAAM,IAAI/B,MAAM,+DAGpB,IAAIqC,GAAe,EACnB,IAAK,IAAIjF,EAAI,EAAGA,EAAI2E,EAAWhC,OAAQ3C,IAAK,CACxC,MAAM4R,EAAKjN,EAAW3E,GACtB,GAAIA,IAAM2E,EAAWhC,OAAS,GAAKP,EAAME,OAAOsN,cAC5C5L,MAAMC,QAAQ2N,IAAOlR,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,GAAIxP,EAAME,OAAO4B,cAAc6D,QAAS,CACzE,IAAMrH,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,IACd,MAAM,IAAIhP,sEAAsE5C,qBAEpF2E,EAAW3E,GAAK4R,EAAG,GACnB3M,GAAe,OACZ,IAAMvE,OAAAgP,EAAA,EAAAhP,CAASkR,GAClB,MAAM,IAAIhP,sEAAsE5C,qBAIxF,MAAM4G,EAASpE,EAAK4B,MAAM,GAC1B,OAAO1D,OAAAoR,EAAA,EAAApR,CAAc0B,EAAOuC,EAAYM,EAAc2B,IA4I7CmL,EAAS,CAAC3P,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,GAElC,MAAMiG,EAAiB+H,KAAWhO,GAClC,GAAmB,mBAARiG,EACP,MAAM,IAAI7F,MAAM,8DAGpB,MACI,IAAId,IAAa2G,EAAIuJ,MAAM,KAAMxP,EAAK4B,MAAM,GAAGC,OAAOvC,KAiDjDmQ,GA9CUF,IA8CD,CAAC3P,EAAsB7B,IAAiB,IAAIiC,KAI9D,MADYgO,KAAWhO,KAsMd0P,GAnMUD,IAmMF,CAAC7P,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,GAEjC,IAAI2F,EAAI3F,EAAK,GACb,IAAK,IAAIxC,EAAI,EAAGA,EAAIwC,EAAKG,OAAQ3C,IAC7BmI,EAAI3F,EAAKxC,GAAGmI,GAEhB,OAAOA,IA2EEgK,GAzESD,IAyEA,CAAC9P,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,IAAIgF,EAAM9G,OAAAgP,EAAA,EAAAhP,CAAS8P,KAAWhO,IAE9B,IAAMgF,EAAK,CACP,GAAuB,iBAAZhF,EAAK,GAGZ,MAAM,IAAII,MAAM,mDAFhB4E,EAAM,CAAChD,OAAQhC,EAAK,IAS5B,OAHc9B,OAAA+C,EAAA,EAAA/C,CAAwB0B,EAAOoF,GAAK,GAC5CA,EAAIhD,QAAUhC,EAAK,GAElBA,EAAK,KAKH4P,EAAS,CAAChQ,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,IAAI6P,EAAY,GAEZrO,MAAMC,QAAQzB,EAAK,IACnB6P,EAAO7P,EAAK,GAEZ6P,EAAKlM,KAAK3D,EAAK,IAGnB,IAAIgF,EAAM9G,OAAAgP,EAAA,EAAAhP,CAAS2R,EAAK,IAExB,IAAM7K,EAAK,CACP,GAAuB,iBAAZ6K,EAAK,GAGZ,MAAM,IAAIzP,MAAM,mDAFhB4E,EAAM,CAAChD,OAAQ6N,EAAK,IAM5B,IAAI9M,EAAQ7E,OAAA+C,EAAA,EAAA/C,CAAwB0B,EAAOoF,GAAK,GAChD,GAAc,OAAVjC,EACA,MAAM,IAAI3C,yCAAyC4E,EAAIhD,WAG3D,IAAI8N,GAAQ,EAEZ,IAAK,IAAItS,EAAI,EAAGA,EAAIqS,EAAK1P,OAAQ3C,IAAK,CAClC,IAAIiP,EAASoD,EAAKrS,GACduS,GAAS,EACb,MAAMC,EAAOxS,IAAMqS,EAAK1P,OAAS,EACjC,KAAO4P,GACH,cAAetD,GACf,IAAK,WACD1J,EAAQ0J,EAAE1J,GACVgN,GAAS,EACT,MACJ,IAAK,SACD,GAAIvO,MAAMC,QAAQgL,GACdA,EAAIvO,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO6M,QAGpB,GADAzH,EAAM9G,OAAAgP,EAAA,EAAAhP,CAASuO,GAEXA,EAAIzH,EAAIhD,WACL,KAAI9D,OAAOkB,UAAUC,eAAe1B,KAAK8O,EAAG,SAG/C,MAAM,IAAIrM,MAAM,mDAFhBqM,EAAIvO,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO6M,GAK5B,MACJ,IAAK,SACGA,EAAI,IACJA,EAAI1J,EAAM5C,OAASsM,GAG3B,IAAK,SACGuD,GACAjN,EAAM0J,GAAKzM,EAAK,GAChB8P,GAAQ,GAER/M,EAAQA,EAAM0J,GAElBsD,GAAS,EACT,MACJ,QACI,MAAM,IAAI3P,MAAM,oDAK5B,IAAM0P,EACF,MAAM,IAAI1P,MAAM,8DAGpB,OAAOJ,EAAK,IAIHiQ,EAAW,CAACrQ,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,EAAG,GAEvC,MAAMiG,EAAM+H,KAAWhO,GACvB,QAAIwB,MAAMC,QAAQwE,IAAuB,IAAfA,EAAI9F,SAClBqC,QAAQyD,IAEXiK,EAAYD,IAGZE,EAAO,CAACvQ,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,IAE1BkQ,KAAalQ,IAEboQ,GAAQD,IAIRE,GAAS,CAACzQ,EAAsB7B,IAAiB,IAAIiC,KAI9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,GAElC,IAAIsQ,EAAO,KACX,IAAK,IAAI9S,EAAI,EAAGA,EAAIwC,EAAKG,OAAQ3C,IAAK,CAClC,MAAM+S,EAAOrS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAKxC,IAClC,IAAM0S,EAAUK,GACZ,OAAOA,EAEXD,EAAOC,EAEX,OAAOD,GAOEE,IAJUH,GAAO,MAIT,CAACzQ,EAAsB7B,IAAiB,IAAIiC,KAI7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,GAEjC,IAAIsQ,EAAO,KACX,IAAK,IAAI9S,EAAI,EAAGA,EAAIwC,EAAKG,OAAQ3C,IAAK,CAClC,MAAM+S,EAAOrS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAKxC,IAClC,GAAI0S,EAAUK,GACV,OAAOA,EAEXD,EAAOC,EAEX,OAAOD,IAMEG,IAHSD,GAAM,MAGA,CAAC5Q,EAAsB7B,IAAiB,IAAIiC,KAGpE9B,OAAA6P,EAAA,EAAA7P,CAAkB,eAAgB8B,EAAM,EAAG,GAE3C,IAAIiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GAMrC,OALIwB,MAAMC,QAAQwE,IAAuB,IAAfA,EAAI9F,SAAc8F,EAAM,MAC9CzE,MAAMC,QAAQyE,IAAuB,IAAfA,EAAI/F,SAAc+F,EAAM,WACtC,IAARD,IAAgBA,EAAM,WACd,IAARC,IAAgBA,EAAM,MAEnBD,GAAOC,IAELwK,GAAgBD,KAGhBE,GAAkB,CAAC/Q,EAAsB7B,IAAiB,IAAIiC,KAG9D0Q,MAAiB1Q,GAKjB4Q,IAHmBD,KAGb,CAAC/Q,EAAsB7B,IAAiB,IAAIiC,KAG3D9B,OAAA6P,EAAA,EAAA7P,CAAkB,MAAO8B,EAAM,EAAG,GAElC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAO9B,OAAA+C,EAAA,EAAA/C,CAAS+H,GAAO/H,OAAA+C,EAAA,EAAA/C,CAASgI,KAKvB2K,IAHOD,KAGD,CAAChR,EAAsB7B,IAAiB,IAAIiC,KAG3D9B,OAAA6P,EAAA,EAAA7P,CAAkB,MAAO8B,EAAM,EAAG,GAElC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAO9B,OAAA+C,EAAA,EAAA/C,CAAS+H,IAAQ/H,OAAA+C,EAAA,EAAA/C,CAASgI,KAKxB4K,IAHOD,KAGD,CAACjR,EAAsB7B,IAAiB,IAAIiC,KAG3D9B,OAAA6P,EAAA,EAAA7P,CAAkB,MAAO8B,EAAM,EAAG,GAElC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAO9B,OAAA+C,EAAA,EAAA/C,CAAS+H,GAAO/H,OAAA+C,EAAA,EAAA/C,CAASgI,KAKvB6K,IAHOD,KAGD,CAAClR,EAAsB7B,IAAiB,IAAIiC,KAG3D9B,OAAA6P,EAAA,EAAA7P,CAAkB,MAAO8B,EAAM,EAAG,GAElC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAO9B,OAAA+C,EAAA,EAAA/C,CAAS+H,IAAQ/H,OAAA+C,EAAA,EAAA/C,CAASgI,KAKxB8K,IAHOD,KAGG,CAACnR,EAAsB7B,IAAiB,IAAIiC,KAM/D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAEf,iBAAZA,EAAK,GACZ,MAAO,CAACgC,OAAQhC,EAAK,IAErB,MAAM,IAAII,MAAM,0EA6BX6Q,IA1BWD,KA0BC,CAACpR,EAAsB7B,IAAiB,IAAIiC,KAMjE,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEpB,IAAhBA,EAAKG,OACL,QAAQjC,OAAAgP,EAAA,EAAAhP,CAAS8B,EAAK,IAEtB,GAAuB,iBAAZA,EAAK,GACZ,QAAQ9B,OAAAgP,EAAA,EAAAhP,CAAS8B,EAAK,GAAIA,EAAK,IAE/B,MAAM,IAAII,MAAM,4EAOf8Q,IAHaD,KAGH,CAACrR,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAE/BwB,MAAMC,QAAQuM,KAAWhO,MAKvBmR,IAHWD,KAGC,CAACtR,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEL,iBAArBgO,KAAWhO,KAKhBoR,IAHaD,KAGD,CAACvR,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEL,iBAArBgO,KAAWhO,KAKhBqR,IAHaD,KAGJ,CAACxR,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAE9BsB,OAAOgQ,MAAMtD,KAAWhO,MAKtBuR,IAHUF,KAGE,CAACzR,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEjCsB,OAAOkQ,SAASxD,KAAWhO,MAKzByR,IAHaF,KAGA,CAAC3R,EAAsB7B,IAAiB,IAAIiC,KAGlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,EAAG,GAElCsB,OAAOoQ,UAAU1D,KAAWhO,MAK1B2R,IAHcF,KAGF,CAAC7R,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEjC6H,OAAOmG,KAAWhO,MAKhB4R,IAHaD,KAGD,CAAC/R,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAEjC9B,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,MAuClB6R,IArCaD,KAqCG,CAAChS,EAAsB7B,IAAiB,IAAIiC,KAGrE9B,OAAA6P,EAAA,EAAA7P,CAAkB,gBAAiB8B,EAAM,GAElC9B,OAAOwF,OAAO1D,EAAK,MAAQA,EAAK4B,MAAM,MAKpCkQ,IAHiBD,KAGA,CAACjS,EAAsB7B,IAAiB,IAAIiC,KAGtE9B,OAAA6P,EAAA,EAAA7P,CAAkB,iBAAkB8B,EAAM,EAAG,GAEtC8F,KAAKC,UAAUiI,KAAWhO,MAKxB+R,IAHkBD,KAGL,CAAClS,EAAsB7B,IAAiB,IAAIiC,KAGlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,EAAG,GAEzC,MAAMT,EAAIyO,KAAWhO,GACrB,GAAiB,iBAANT,EACP,MAAM,IAAIa,MAAM,gEAEpB,OAAO0F,KAAK+H,MAAMtO,KAKTyS,IAHcD,KAGP,CAACnS,EAAsB7B,IAAiB,IAAIiC,IAGrDiS,KAAKC,OAKHC,IAHQH,KAGW,CAACpS,EAAsB7B,IAAiB,IAAIiC,KAGxE9B,OAAA6P,EAAA,EAAA7P,CAAkB,mBAAoB8B,EAAM,EAAG,GAE/C,MAAMT,EAAIyO,KAAWhO,GACrB,GAAiB,iBAANT,EACP,MAAM,IAAIa,MAAM,sEAEpB,IAAM,oLAAoLgK,KAAK7K,GAC3L,MAAM,IAAIa,sEAAsEb,MAEpF,MAAM6S,EAAK,IAAIH,KAAK1S,GAAG8S,UACvB,GAAI/Q,OAAOgQ,MAAMc,GACb,MAAM,IAAIhS,kDAAkDb,MAEhE,OAAO6S,IAKEE,IAHoBH,KAGR,CAACvS,EAAsB7B,IAAiB,IAAIiC,KAOjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,IAAIT,EAAI,GACR,MAAMgT,EAAOjR,OAAOtB,EAAK,IAErBT,GADAgT,GAAQ,EACH1K,OAAO0K,GAAMC,SAAS,EAAG,KAEzB,IAAM3K,QAAQ0K,GAAMC,SAAS,EAAG,KAGzCjT,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE/CjT,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE3CxS,EAAKG,QAAU,IACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE3CxS,EAAKG,QAAU,EACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE/CjT,GAAK,MAGLS,EAAKG,QAAU,IACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,MAG/CxS,EAAKG,QAAU,IACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAAK5Q,MAAM,EAAG,IAEjErC,GAAK,KAET,MAAM6S,EAAK,IAAIH,KAAK1S,GAAG8S,UACvB,GAAI/Q,OAAOgQ,MAAMc,GACb,MAAM,IAAIhS,2CAA2Cb,MAEzD,OAAO6S,IAKEK,IAHaH,KAGC,CAAC1S,EAAsB7B,IAAiB,IAAIiC,KAOnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAE1C,IAAIT,EAAI,GACR,MAAMgT,EAAOjR,OAAOtB,EAAK,IAErBT,GADAgT,GAAQ,EACH1K,OAAO0K,GAAMC,SAAS,EAAG,KAEzB,IAAM3K,QAAQ0K,GAAMC,SAAS,EAAG,KAGzCjT,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE/CjT,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE3CxS,EAAKG,QAAU,GACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE3CxS,EAAKG,QAAU,EACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAE/CjT,GAAK,MAGLS,EAAKG,QAAU,IACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,MAG/CxS,EAAKG,QAAU,IACfZ,GAAK,IAAMsI,OAAOvG,OAAOtB,EAAK,KAAKwS,SAAS,EAAG,KAAK5Q,MAAM,EAAG,KAGjErC,GAAK,gBAET,MAAM6S,EAAK,IAAIH,KAAK1S,GAAG8S,UACvB,GAAI/Q,OAAOgQ,MAAMc,GACb,MAAM,IAAIhS,6CAA6Cb,MAE3D,OAAO6S,IAKEM,IAHeD,KAGQ,CAAC7S,EAAsB7B,IAAiB,IAAIiC,KAG5E9B,OAAA6P,EAAA,EAAA7P,CAAkB,uBAAwB8B,EAAM,EAAG,GAEnD,MAAMf,EAAI+O,KAAWhO,GACrB,GAAiB,iBAANf,EACP,MAAM,IAAImB,MAAM,0EAEpB,MAAMgS,EAAK,IAAIH,KAAKhT,GACpB,GAAIqC,OAAOgQ,MAAMc,EAAGC,WAChB,MAAM,IAAIjS,sDAAsDnB,MAEpE,OAAOmT,EAAGO,gBAKDC,IAHwBF,KAGA,CAAC9S,EAAsB7B,IAAiB,IAAIiC,KAG7E9B,OAAA6P,EAAA,EAAA7P,CAAkB,wBAAyB8B,EAAM,EAAG,GAEpD,MAAMf,EAAI+O,KAAWhO,GACrB,GAAiB,iBAANf,EACP,MAAM,IAAImB,MAAM,2EAEpB,MAAMgS,EAAK,IAAIH,KAAKhT,GACpB,GAAIqC,OAAOgQ,MAAMc,EAAGC,WAChB,MAAM,IAAIjS,uDAAuDnB,MAErE,MAAQ,CACJmT,EAAGS,iBACHT,EAAGU,cAAgB,EACnBV,EAAGW,aACHX,EAAGY,cACHZ,EAAGa,gBACHb,EAAGc,gBACHd,EAAGe,qBACH,EACAf,EAAGgB,eAMEC,IAHyBT,KAGC,CAAChT,EAAsB7B,IAAiB,IAAIiC,KAG/E9B,OAAA6P,EAAA,EAAA7P,CAAkB,0BAA2B8B,EAAM,EAAG,GAEtD,MAAMf,EAAI+O,KAAWhO,GACrB,GAAiB,iBAANf,EACP,MAAM,IAAImB,MAAM,6EAEpB,MAAMgS,EAAK,IAAIH,KAAKhT,GACpB,GAAIqC,OAAOgQ,MAAMc,EAAGC,WAChB,MAAM,IAAIjS,yDAAyDnB,MAEvE,MAAQ,CACJmT,EAAGkB,cACHlB,EAAGmB,WAAa,EAChBnB,EAAGoB,UACHpB,EAAGqB,WACHrB,EAAGsB,aACHtB,EAAGuB,aACHvB,EAAGwB,mBACFxB,EAAGyB,oBAEJzB,EAAG0B,YAMEC,IAH2BV,KAGlB,CAACzT,EAAsB7B,IAAiB,IAAIiC,KAM9D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAEjB,IAAhBA,EAAKG,OAAc,CAEnB,OADU,IAAI6T,OAAOhU,EAAK,IACjBiU,KAAKjU,EAAK,IAGnB,OADU,IAAIgU,OAAOhU,EAAK,GAAIA,EAAK,IAC1BiU,KAAKjU,EAAK,MAMdkU,IAHUH,KAGI,CAACnU,EAAsB7B,IAAiB,IAAIiC,KAGnEmU,QAAQC,OAAOpU,GACR,OAKEqU,IAHeH,KAGC,CAACtU,EAAsB7B,IAAiB,IAAIiC,KAGrEmU,QAAQzR,SAAS1C,GACV,OAKEsU,IAHiBD,KAGD,CAACzU,EAAsB7B,IAAiB,IAAIiC,KAGrEmU,QAAQI,SAASvU,GACV,OAKEwU,IAHiBF,KAGF,CAAC1U,EAAsB7B,IAAiB,IAAIiC,KAIpEmU,QAAQM,QAAQzU,GACT,OAKE0U,IAHgBF,KAGE,CAAC5U,EAAsB7B,IAAiB,IAAIiC,KAIvEmU,QAAQQ,WAAW3U,GACZ,OAKE4U,IAHmBF,KAGD,CAAC9U,EAAsB7B,IAAiB,IAAIiC,KAItEmU,QAAgBU,WAAW7U,GACrB,OAEqB4U,KCn0CjB,IAAAE,GAnPoB,CAAC,CAChC/W,KAAM,OACNqE,GAAI0L,GACL,CACC/P,KAAM,OACNqE,GAAI6L,GACL,CACClQ,KAAM,QACNqE,GAAI8L,GACL,CACCnQ,KAAM,SACNqE,GAAIgM,GACL,CACCrQ,KAAM,UACNqE,GAAIiM,GACL,CACCtQ,KAAM,QACNqE,GAAImM,GACL,CACCxQ,KAAM,SACNqE,GAAImM,GACL,CACCxQ,KAAM,QACNqE,GAAIoM,GACL,CACCzQ,KAAM,oBACNqE,GAAIqM,GACL,CACC1Q,KAAM,QACNqE,GAAIsM,GACL,CACC3Q,KAAM,MACNqE,GAAIuM,GACL,CACC5Q,KAAM,MACNqE,GAAIuM,GACL,CACC5Q,KAAM,UACNqE,GAAIwM,GACL,CACC7Q,KAAM,MACNqE,GAAIwM,GACL,CACC7Q,KAAM,QACNqE,GAAIyM,GACL,CACC9Q,KAAM,WACNqE,GAAI0M,GACL,CACC/Q,KAAM,YACNqE,GDsM0B,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAItE9B,OAAA6P,EAAA,EAAA7P,CAAkB,iBAAkB8B,EAAM,GAE1C,MAAM+O,EAAiBf,KAAWhO,GAC5BkG,EAAMoI,KAAYtO,GACxB,IAAI1B,EAAa,KAEjBJ,OAAA+C,EAAA,EAAA/C,CAAa0B,EAAO1B,OAAA+C,EAAA,EAAA/C,CAAe0B,GAAOmD,OAAO,GACjD,IACI,GAAI,EAAI/C,EAAKG,OACT,GAAI4O,EAAgB,CAChBzQ,EAAI,GACJ,IAAK,MAAM8C,KAAKpB,EAAK4B,MAAM,GACvBtD,EAAEqF,KAAKzF,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,SAG3B,IAAK,MAAMA,KAAKpB,EAAK4B,MAAM,GACvBtD,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,QAI5B9C,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOsG,GAb5B,QAgBIhI,OAAA+C,EAAA,EAAA/C,CAAe0B,GAGnB,OAAOtB,ICnOR,CACCP,KAAM,aACNqE,GDsOsB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,GAEtC,MAAMmC,EAAyBnC,EAAK,GACpC,IAAMwB,MAAMC,QAAQU,GAChB,MAAM,IAAI/B,MAAM,8DAGpB,IAAI9B,EAAa,KAEjB,MAAM0E,EAAiB9E,OAAA+C,EAAA,EAAA/C,CAAyB0B,EAAOuC,GACvDjE,OAAA+C,EAAA,EAAA/C,CAAa0B,EAAO,IAAI,EAAMoD,GAC9B,IACI,IAAK,MAAM5B,KAAKpB,EAAK4B,MAAM,GACvBtD,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAF5B,QAKIlD,OAAA+C,EAAA,EAAA/C,CAAe0B,GAGnB,OAAOtB,IC3PR,CACCP,KAAM,YACNqE,GAAI+M,GACL,CACCpR,KAAM,aACNqE,GAAIiN,GACL,CACCtR,KAAM,WACNqE,GD8UoB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,GAEpC,MAAMiG,EAAgB+H,KAAWhO,GAC3BoC,EAAK+M,EAAUvP,EAAVuP,IAA0BnP,EAAK4B,MAAM,IAUhD,OAPAhC,EAAM8F,QAAQX,IAAIkB,EAAIjE,OAAQ,CAC1BjE,KAAMkI,EAAIjE,OACVI,GAAI,CAAC2S,EAAIjR,IAAO1B,IAKbA,IC7VR,CACCrE,KAAM,YACNqE,GDgWyB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGrE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,GAErC,MAAMiG,EAAgB+H,KAAWhO,GAC3BoC,EAAKiN,EAAezP,EAAfyP,IAA+BrP,EAAK4B,MAAM,IAUrD,OAPAhC,EAAM8F,QAAQX,IAAIkB,EAAIjE,OAAQ,CAC1BjE,KAAMkI,EAAIjE,OACVI,GAAI,CAAC2S,EAAIjR,IAAO1B,IAKbA,IC/WR,CACCrE,KAAM,WACNqE,GDkXoB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,EAAG,GAEvC,MAAMiG,EAAgB+H,KAAWhO,GAC3BgV,EAAOpV,EAAM8F,QAAQrH,IAAI4H,EAAIjE,QACnC,IAAKgT,EACD,MAAM,IAAI5U,iCAAiC6F,EAAIjE,0BAEnD,OAAOgT,EAAK5S,GAAGxC,EAAOqG,EAAIjE,UC3X3B,CACCjE,KAAM,cACNqE,GD8XuB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,GAEvC,MAAMiG,EAAgB+H,KAAWhO,GAC3BmC,EAAyBnC,EAAK,GACpC,IAAMwB,MAAMC,QAAQU,GAChB,MAAM,IAAI/B,MAAM,gEAGpB,IAAIqC,GAAe,EACnB,IAAK,IAAIjF,EAAI,EAAGA,EAAI2E,EAAWhC,OAAQ3C,IAAK,CACxC,MAAM4R,EAAKjN,EAAW3E,GACtB,GAAIA,IAAM2E,EAAWhC,OAAS,GAAKP,EAAME,OAAOsN,cAC5C5L,MAAMC,QAAQ2N,IAAOlR,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,GAAIxP,EAAME,OAAO4B,cAAc6D,QAAS,CACzE,IAAMrH,OAAAgP,EAAA,EAAAhP,CAASkR,EAAG,IACd,MAAM,IAAIhP,uEAAuE5C,qBAErF2E,EAAW3E,GAAK4R,EAAG,GACnB3M,GAAe,OACZ,IAAMvE,OAAAgP,EAAA,EAAAhP,CAASkR,GAClB,MAAM,IAAIhP,uEAAuE5C,qBAIzF,MAAM4G,EAASpE,EAAK4B,MAAM,GACpBoB,EAAiB9E,OAAA+C,EAAA,EAAA/C,CAAkB0B,GAEnCwC,EAAM6S,GAAsB,IAAIC,IAC3BpG,EAASlP,EAAO7B,EAAMiF,EAAtB8L,EAAsC,GAAO,EAAO,CACvD,CAAClP,EAAME,OAAO4B,cAAc8C,KAAMpC,MAC9B6S,EAAMtQ,IAAI,CAACvD,EAAaqJ,IAAU,CAClCrJ,EAAEY,OACF9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EACD6C,GAAgBgI,IAAUwK,EAAM9U,OAAS,EACtC+U,EAAMtT,MAAM6I,GAASyK,EAAMzK,UAGrCrG,GAGJxG,EAAiB,CACnBG,KAAMkI,EAAIjE,OACVI,GAAI,CAAC2S,EAAmBjR,EAAYmR,IAAuBE,GAAoB/S,EAAG6S,EAAH7S,IAAc+S,EAAKvT,MAAM,IACxGO,aACAM,gBAEJ,GAAI7C,EAAMmC,SAASiG,IAAI/B,EAAIjE,QAAS,CAChC,IAAIuO,EAAO3Q,EAAMmC,SAAS1D,IAAI4H,EAAIjE,QAElC,GADCuO,EAAqB5N,KAAO/E,EACzB2S,GAAQA,EAAKpO,WACb,GAAIoO,EAAKpO,WAAWhC,OAASgC,EAAWhC,OACpCP,EAAMmC,SAASgD,IAAIkB,EAAIjE,OAAQpE,GAC/BA,EAAE+E,KAAO4N,MACN,CACH,IAAID,EAAOC,EAEX,IADAA,EAAOA,EAAK5N,KACL4N,GAAM,CACT,GAAIA,EAAKpO,YACDoO,EAAKpO,WAAWhC,OAASgC,EAAWhC,OAAQ,CAC5CmQ,EAAK3N,KAAO/E,EACZA,EAAE+E,KAAO4N,EACT,MAGRD,EAAOC,EACPA,EAAOA,EAAK5N,YAKxB/C,EAAMmC,SAASgD,IAAIkB,EAAIjE,OAAQpE,GAEnC,OAAOwE,ICvcR,CACCrE,KAAM,SACNqE,GAAImN,GACL,CACCxR,KAAM,UACNqE,GDwdmB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,GAEnC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACjCgF,EAAM9G,OAAAgP,EAAA,EAAAhP,CAASgI,GACrB,OAAOkP,SAAShW,UAAUoQ,MAAM7R,KAC5BsI,EAAIjB,EAAMA,EAAIhD,OAAS9D,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOsG,IACvCD,EACAjG,EAAK4B,MAAM,MCjehB,CACC7D,KAAM,SACNqE,GDqekB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAI9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,IAAI1B,EAAa,GACjB,IACIA,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAK,IAC3B,MAAOqV,GACL,GAAIA,aAAajJ,EAAA,EACb,MAAMiJ,EAGN/W,EADA,EAAI0B,EAAKG,OACL2O,EAASlP,EAATkP,EAAsB,GAAM,EAAO,CACnC,CAAC,SAAU5Q,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOyV,IACxB,CAAC,UAAWnX,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAO1B,OAAA+C,EAAA,EAAA/C,CAAS0B,MACnCI,EAAK,IAEJ,KAGZ,OAAO1B,IC1fR,CACCP,KAAM,SACNqE,GAAIqN,GACL,CACC1R,KAAM,QACNqE,GDmgBiB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAI7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,EAAM+H,KAAWhO,GACvB,IAAI1B,EAAa,GAUjB,OARIA,EADA4R,EAAUjK,GACN/H,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAK,IAErB,EAAIA,EAAKG,OACLjC,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAK,IAErB,OChhBb,CACCjC,KAAM,aACNqE,GDshBqB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,IAAI1B,EAAa,GAMjB,OAFIA,EAHEoS,GAAczK,EAAK,MAGjB/H,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOsG,GAFhBD,IC9hBT,CACClI,KAAM,UACNqE,GDqiBmB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAI/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,GAEnC,IAAK,IAAIxC,EAAI,EAAGA,EAAIwC,EAAKG,OAAS,EAAG3C,GAAK,EAAG,CACzC,MAAMK,EAAImC,EAAKxC,GACT4D,EAAIpB,EAAKxC,EAAI,GACnB,GAAI0S,EAAUhS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO/B,IAC1B,OAAOK,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAG/B,OAAO,OCjjBR,CACCrD,KAAM,WACNqE,GDojBoB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,GAEpC,MAAMiG,EAAM+H,KAAWhO,GACjBkG,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KACjB,KAAO4R,EAAUhS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOqG,KAC7B,IAAK,MAAM7E,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAG5B,OAAO9C,ICjkBR,CACCP,KAAM,cACNqE,GDokBsB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,GAEtC,MAAMiG,EAAM+H,KAAWhO,GACjBkG,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KAEjB,GACI,IAAK,MAAM8C,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,SAEnB8O,EAAUhS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOqG,KACnC,OAAO3H,ICllBR,CACCP,KAAM,WACNqE,GDqlBoB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,GAEpC,MAAMiG,EAAM+H,KAAWhO,GACjBkG,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KACjB,KAAO8R,GAAMlS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOqG,KACzB,IAAK,MAAM7E,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAG5B,OAAO9C,IClmBR,CACCP,KAAM,cACNqE,GDqmBsB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,GAEtC,MAAMiG,EAAM+H,KAAWhO,GACjBkG,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KACjB,GACI,IAAK,MAAM8C,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,SAEnBgP,GAAMlS,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOqG,KAC/B,OAAO3H,IClnBR,CACCP,KAAM,YACNqE,GDqnBqB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,GAErC,MAAMgF,EAAM9G,OAAAgP,EAAA,EAAAhP,CAAS8P,KAAWhO,IAChC,IAAMgF,EACF,MAAM,IAAI5E,MAAM,0EAEpB,MAAM2C,EAAQ7E,OAAA+C,EAAA,EAAA/C,CAAwB0B,EAAOoF,GAAK,GAE5C/F,EAAIf,OAAA+C,EAAA,EAAA/C,CAASoQ,KAAYtO,IACzBkG,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KACjB,IAAK,IAAId,EAAI,EAAGA,EAAIyB,EAAGzB,IAAK,CACxBuF,EAAMiC,EAAIhD,QAAUxE,EACpB,IAAK,MAAM4D,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAG5B,OAAO9C,ICzoBR,CACCP,KAAM,SACNqE,GD4oBkB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAI9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,GAElC,MAAMgF,EAAM9G,OAAAgP,EAAA,EAAAhP,CAAS8P,KAAWhO,IAChC,IAAMgF,EACF,MAAM,IAAI5E,MAAM,uEAEpB,MAAM2C,EAAQ7E,OAAA+C,EAAA,EAAA/C,CAAwB0B,EAAOoF,GAAK,GAE5CmQ,EAAO7G,KAAYtO,GACzB,IAAMwB,MAAMC,QAAQ0T,GAChB,MAAM,IAAI/U,MAAM,sEAGpB,MAAM8F,EAAMlG,EAAK4B,MAAM,GACvB,IAAItD,EAAa,KACjB,IAAK,MAAMmO,KAAK0I,EAAM,CAClBpS,EAAMiC,EAAIhD,QAAUyK,EACpB,IAAK,MAAMrL,KAAK8E,EACZ5H,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,GAG5B,OAAO9C,ICpqBR,CACCP,KAAM,QACNqE,GAAIsN,GACL,CACC3R,KAAM,SACNqE,GDmrBkB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,GAElC,IAAI2F,EAAS,KACTX,EAAM9G,OAAAgP,EAAA,EAAAhP,CAAS8B,EAAK,IAExB,IAAKgF,EACD,cAAehF,EAAK,IACpB,IAAK,SAAU,IAAK,SAChBgF,EAAM,CAAChD,OAAQ6F,OAAO7H,EAAK,KAC3B,MACJ,QACI2F,EAAIzH,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOI,EAAK,IAKjC,GAAIgF,EAAK,CACL,MAAMjC,EAAQ7E,OAAA+C,EAAA,EAAA/C,CAAwB0B,EAAOoF,GAAK,GAClD,IAAMjC,EACF,MAAM,IAAI3C,4DAA4D4E,EAAIhD,2BAE9E2D,EAAI5C,EAAMiC,EAAIhD,QAGlB,IAAK,IAAIxE,EAAI,EAAGA,EAAIwC,EAAKG,OAAQ3C,IAAK,CAClC,IAAIiP,EAASzM,EAAKxC,GACduS,GAAS,EACb,KAAOA,GACH,cAAetD,GACf,IAAK,WACD9G,EAAI8G,EAAE9G,GACNoK,GAAS,EACT,MACJ,IAAK,SACD,GAAIvO,MAAMC,QAAQgL,GACdA,EAAIvO,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO6M,QAGpB,GADAzH,EAAM9G,OAAAgP,EAAA,EAAAhP,CAASuO,GAEXA,EAAIzH,EAAIhD,WACL,KAAI9D,OAAOkB,UAAUC,eAAe1B,KAAK8O,EAAG,SAG/C,MAAM,IAAIrM,MAAM,wDAFhBqM,EAAIvO,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO6M,GAK5B,MACJ,IAAK,SACGA,EAAI,IACJA,EAAI9G,EAAExF,OAASsM,GAGvB,IAAK,SACD9G,EAAIA,EAAE8G,GACNsD,GAAS,EACT,MACJ,QACI,MAAM,IAAI3P,MAAM,yDAI5B,OAAOuF,IClvBR,CACC5H,KAAM,SACNqE,GAAIuN,GACL,CACC5R,KAAM,SACNqE,GAAIwN,GACL,CACC7R,KAAM,WACNqE,GAAI6N,GACL,CACClS,KAAM,OACNqE,GAAI+N,GACL,CACCpS,KAAM,SACNqE,GAAIiO,IACL,CACCtS,KAAM,QACNqE,GAAIoO,IACL,CACCzS,KAAM,KACNqE,GAAIqO,IACL,CACC1S,KAAM,KACNqE,GAAIuO,IACL,CACC5S,KAAM,IACNqE,GAAIwO,IACL,CACC7S,KAAM,KACNqE,GAAIyO,IACL,CACC9S,KAAM,IACNqE,GAAI0O,IACL,CACC/S,KAAM,KACNqE,GAAI2O,IACL,CACChT,KAAM,UACNqE,GAAI4O,IACL,CACCjT,KAAM,YACNqE,GD28BqB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAIjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MACMsV,EAAc,CAACtT,6BADkBpC,EAAMC,4BAE7C,GAAoB,IAAhBG,EAAKG,OAAc,CACnB,MAAMqD,EAAItF,OAAAgP,EAAA,EAAAhP,CAAS8B,EAAK,IACxB,GAAIwD,EACAmM,EAAO/P,EAAP+P,CAAkBnM,EAAG8R,OAClB,IAAuB,iBAAZtV,EAAK,GAGnB,MAAM,IAAII,MAAM,0EAFhBuP,EAAO/P,EAAP+P,CAAkB,CAAC3N,OAAQhC,EAAK,IAAKsV,IAK7C,OAAOA,IC59BR,CACCvX,KAAM,aACNqE,GAAI6O,IACL,CACClT,KAAM,WACNqE,GAAI8O,IACL,CACCnT,KAAM,aACNqE,GAAI+O,IACL,CACCpT,KAAM,aACNqE,GAAIgP,IACL,CACCrT,KAAM,UACNqE,GAAIiP,IACL,CACCtT,KAAM,aACNqE,GAAImP,IACL,CACCxT,KAAM,cACNqE,GAAIqP,IACL,CACC1T,KAAM,aACNqE,GAAIuP,IACL,CACC5T,KAAM,aACNqE,GAAIwP,IACL,CACC7T,KAAM,OACNqE,GDuiCuB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGnE,MAAM1B,EAAS,GACf,IAAK,MAAM8C,KAAKpB,EAAM,CAClB,KAAIwB,MAAMC,QAAQL,IAAM,EAAIA,EAAEjB,QAqB1B,MAAM,IAAIC,MAAM,gEArBkB,CAClC,MAAM4E,EAAM9G,OAAAgP,EAAA,EAAAhP,CAASkD,EAAE,IACjBmU,EACFvQ,EAAMA,EAAIhD,OACV6F,OAAO3J,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,KACZ,IAAbA,EAAEjB,OAGF7B,EAAEiX,IAAW,EACO,IAAbnU,EAAEjB,OAGT7B,EAAEiX,GAAWrX,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,IAI/B9C,EAAEiX,GACErX,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAQ,CAAC,CAACoC,OAAQpC,EAAME,OAAO4B,cAAcyT,OACrDtT,OAAOT,EAAEQ,MAAM,MAMhC,OAAOtD,ICnkCR,CACCP,KAAM,iBACNqE,GAAIyP,IACL,CACC9T,KAAM,kBACNqE,GAAI0P,IACL,CACC/T,KAAM,OACNqE,GAAI4P,IACL,CACCjU,KAAM,qBACNqE,GAAI+P,IACL,CACCpU,KAAM,YACNqE,GAAIkQ,IACL,CACCvU,KAAM,eACNqE,GAAIqQ,IACL,CACC1U,KAAM,0BACNqE,GAAIsQ,IACL,CACC3U,KAAM,0BACNqE,GAAIwQ,IACL,CACC7U,KAAM,6BACNqE,GAAIiR,IACL,CACCtV,KAAM,cACNqE,GAAI2P,IACL,CACChU,KAAM,SACNqE,GAAI2R,IACL,CACChW,KAAM,eACNqE,GAAI8R,IACL,CACCnW,KAAM,iBACNqE,GAAIiS,IACL,CACCtW,KAAM,iBACNqE,GAAIkS,IACL,CACCvW,KAAM,gBACNqE,GAAIoS,IACL,CACCzW,KAAM,oBACNqE,GAAIsS,IACL,CACC3W,KAAM,oBACNqE,GAAIwS,KC2KO,IAAAY,GAvZsB,CAAC,CAClCzX,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,YACbmT,EAAK,GACLA,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,aACb,GACA,KACImT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,UACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,cACb,KACImT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,aACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,aACb,GACA,KACImT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,WACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,iBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,WACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,IADejX,OAAAgP,EAAA,EAAAhP,CAASiX,EAAK,GAAI,OAE7B,MAAM,IAAI/U,MAAM,yDAEpB,MAAO,CAAC,CAAC4B,OAAQ,cAAe9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAAKjX,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAO,CAAC,CAACoC,OAAQ,aAC1E9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,OACdA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,SAGjD,CACCrD,KAAM,MACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACVmT,EAAKvT,MAAM,KAGvB,CACC7D,KAAM,YACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,IADejX,OAAAgP,EAAA,EAAAhP,CAASiX,EAAK,GAAI,OAE7B,MAAM,IAAI/U,MAAM,yDAEpB,MAAO,CAAC,CAAC4B,OAAQ,cAAe9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAAKjX,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAO,CAAC,CAACoC,OAAQ,cAC1E9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,OACdA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,SAGjD,CACCrD,KAAM,MACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,gBACVmT,EAAKvT,MAAM,KAGvB,CACC7D,KAAM,UACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,gBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,gBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,WACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,iBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,iBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,UACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,gBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,YACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,kBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,QACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,QAASiX,EAAM,GAE1B,CAAC,CAACnT,OAAQ,WACbmT,EAAK,GACLjX,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,OACdA,EAAKvT,MAAM,MAGxB,CACC7D,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,aACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,MACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,SACbmT,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,WACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,cACbmT,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,cACbmT,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,QACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,cACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,YACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,kBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,eACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,YACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,kBACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,UACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,IADcjX,OAAAgP,EAAA,EAAAhP,CAASiX,EAAK,GAAI,MAE5B,MAAM,IAAI/U,MAAM,uDAEpB,MAAO,CAAC,CAAC4B,OAAQ,aACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,OAGjD,CACCrD,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,IADcjX,OAAAgP,EAAA,EAAAhP,CAASiX,EAAK,GAAI,MAE5B,MAAM,IAAI/U,MAAM,oDAEpB,MAAO,CAAC,CAAC4B,OAAQ,UACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,OAGjD,CACCrD,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,aACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQiX,EAAM,EAAG,GAE5B,CAAC,CAACnT,OAAQ,UACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MAGd,CACCpX,KAAM,gBACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,gBAAiBiX,EAAM,EAAG,GAErC,CAAC,CAACnT,OAAQ,WACb,CAAC,CAACA,OAAQ,UACN9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,OAIlB,CACCpX,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQiX,EAAM,EAAG,GAE5B,CAAC,CAACnT,OAAQ,UACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MAGd,CACCpX,KAAM,cACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,cAAeiX,EAAM,EAAG,GAEnC,CAAC,CAACnT,OAAQ,UACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MAGd,CACCpX,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,aACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,MACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CAAC,CAACnT,OAAQ,YACTmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,UACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAIlC,CACH,CAACnT,OAAQ,gBACLmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,IACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CACH,CAACnT,OAAQ,WACLmT,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,OCxXrC,IAAAqU,GA5BwB,CACnC,CAAC1X,KAAM,MAAOqE,GAAI,CAACxC,EAAsB7B,IAAiB,IAC1D,CAACA,KAAM,OAAQqE,GAAI,CAACxC,EAAsB7B,IAAiB,MAE3D,CAACA,KAAM,YAAaqE,GAAI,CAACxC,EAAsB7B,SAAiB,GAEhE,CAACA,KAAM,OAAQqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAC3D,CAACA,KAAM,QAASqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAC5D,CAACA,KAAM,KAAMqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAEzD,CAACA,KAAM,QAASqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAC5D,CAACA,KAAM,SAAUqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAC7D,CAACA,KAAM,KAAMqE,GAAI,CAACxC,EAAsB7B,KAAiB,GAEzD,CAACA,KAAM,mBAAoBqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOoU,mBAC9E,CAAC3X,KAAM,YAAaqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOoU,mBACvE,CAAC3X,KAAM,YAAaqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOqU,mBAEvE,CAAC5X,KAAM,kBAAmBqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOsU,SAC7E,CAAC7X,KAAM,mBAAoBqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOuU,WAC9E,CAAC9X,KAAM,mBAAoBqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOwU,WAC9E,CAAC/X,KAAM,yBAA0BqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOyU,kBACpF,CAAChY,KAAM,yBAA0BqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAO0U,kBAEpF,CAACjY,KAAM,MAAOqE,GAAI,CAACxC,EAAsB7B,IAAiBuD,OAAOD,MCtBvD,SAAU4U,GAAQnW,GAI5B,OAHAA,EAAOoW,OAASpW,EAAOoW,OAAS,IAAIrU,OAAOiT,IAC3ChV,EAAOqW,QAAUrW,EAAOqW,QAAU,IAAItU,OAAO2T,IAC7C1V,EAAOsW,SAAWtW,EAAOsW,SAAW,IAAIvU,OAAO4T,IACxC3V,ECHJ,MAAMuW,GAAa,CAACzW,EAAsB7B,IAAiB,IAAIiC,KAGlE9B,OAAA6P,EAAA,EAAA7P,CAAkB,aAAc8B,EAAM,EAAG,GAEzC,IAAIiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GAIrC,OAHAiG,EAAM/H,OAAA+C,EAAA,EAAA/C,CAAS+H,GAGX,IAFJC,EAAMhI,OAAA+C,EAAA,EAAA/C,CAASgI,IAGJA,EAAM,GAAKD,GAAOC,EAAM,EAExBA,GAAO,GAAKD,KAAUC,EAAO,GAM/BoQ,IAHcD,KAGA,CAACzW,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAE1C,IAAIiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GAIrC,OAHAiG,EAAM/H,OAAA+C,EAAA,EAAA/C,CAAS+H,GAGX,IAFJC,EAAMhI,OAAA+C,EAAA,EAAA/C,CAASgI,IAGJA,EAAM,GAAKD,GAAOC,EAAa,WAAND,GAAsB,EAAI,EAEnDC,GAAO,GAAKD,IAASC,EAAO,IAM9BqQ,IAHeD,KAGD,CAAC1W,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAE1C,IAAIiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GAIrC,OAHAiG,EAAM/H,OAAA+C,EAAA,EAAA/C,CAAS+H,GAGX,IAFJC,EAAMhI,OAAA+C,EAAA,EAAA/C,CAASgI,IAGJA,EAAM,GAAKD,IAAQC,EAAM,EAEzBA,GAAO,GAAKD,IAASC,EAAO,IAM9BsQ,IAHeD,KAGL,CAAC3W,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAEtC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAQ9B,OAAA+C,EAAA,EAAA/C,CAAS+H,KAKRwQ,IAHWD,KAGD,CAAC5W,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,GAEnC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7E0Q,IAHWF,KAGF,CAAC7W,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,GAElC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7E2Q,IAHUD,KAGA,CAAC/W,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,GAEnC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7E4Q,IAHWD,KAGJ,CAAChX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEzBA,EAAK0W,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAO,KAK3DuG,IAHQD,KAGD,CAACjX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEhC,MAAMiG,EAAM+H,KAAWhO,GAEvB,OAAoB,IADPA,EAAK4B,MAAM,GACfzB,QAEGjC,OAAA+C,EAAA,EAAA/C,CAAS+H,GAGVjG,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAMjF8Q,IAHQD,KAGD,CAAClX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEhC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7E+Q,IAHQD,KAGD,CAACnX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEhC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAAS0G,KAAAC,IAAAhZ,OAAA+C,EAAA,EAAA/C,CAASoS,GAASpS,OAAA+C,EAAA,EAAA/C,CAASqS,IAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK9EkR,IAHQH,KAGD,CAACpX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEhC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7EmR,IAHQD,KAGD,CAACvX,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,GAEhC,MAAMiG,EAAM+H,KAAWhO,GACvB,OAAOA,EAAK4B,MAAM,GAAG8U,OAAO,CAACpG,EAAMC,IAASrS,OAAA+C,EAAA,EAAA/C,CAASoS,GAAQpS,OAAA+C,EAAA,EAAA/C,CAASqS,GAAOrS,OAAA+C,EAAA,EAAA/C,CAAS+H,MAK7EoR,IAHQD,KAGD,CAACxX,EAAsB7B,IAAiB,IAAIiC,IAGrDiX,KAAK/W,OAAQF,EAAK2E,IAAIvD,GAAKlD,OAAA+C,EAAA,EAAA/C,CAASkD,MAKlCkW,IAHQD,KAGD,CAACzX,EAAsB7B,IAAiB,IAAIiC,IAGrDiX,KAAKhX,OAAQD,EAAK2E,IAAIvD,GAAKlD,OAAA+C,EAAA,EAAA/C,CAASkD,MAKlCmW,IAHQD,KAGD,CAAC1X,EAAsB7B,IAAiB,IAAIiC,KAG5D,MAAMwD,EAAIxD,EAAK2E,IAAIvD,GAAKlD,OAAA+C,EAAA,EAAA/C,CAASkD,IACjC,OAAOoC,EAAErD,OAAS,EAAIqD,EAAEkT,OAAO,CAACpG,EAAMC,IAASD,EAAOC,EAAM,GAAK/M,EAAErD,OAASkB,MAKnEmW,IAHQD,KAGC,CAAC3X,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAE9BiX,KAAKQ,MAAMvZ,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,OAK7B0X,IAHUF,KAGF,CAAC5X,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAE7BiX,KAAKU,KAAKzZ,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,OAK5B4X,IAHSF,KAGA,CAAC9X,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAE9BiX,KAAKY,MAAM3Z,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,OAK7B8X,IAHUF,KAGH,CAAChY,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAE5BiX,KAAKc,IAAI7Z,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,OAK3BgY,IAHQF,KAGA,CAAClY,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAE7BiX,KAAKgB,KAAK/Z,OAAA+C,EAAA,EAAA/C,CAAS8P,KAAWhO,OAEnBgY,KClJP,IAAAE,GAnGoB,CAAC,CAChCna,KAAM,KACNqE,GAAIiU,IACL,CACCtY,KAAM,eACNqE,GAAIiU,IACL,CACCtY,KAAM,KACNqE,GAAIkU,IACL,CACCvY,KAAM,gBACNqE,GAAIkU,IACL,CACCvY,KAAM,MACNqE,GAAImU,IACL,CACCxY,KAAM,gBACNqE,GAAImU,IACL,CACCxY,KAAM,WACNqE,GAAIoU,IACL,CACCzY,KAAM,WACNqE,GAAIqU,IACL,CACC1Y,KAAM,UACNqE,GAAIuU,IACL,CACC5Y,KAAM,WACNqE,GAAIwU,IACL,CACC7Y,KAAM,IACNqE,GAAIyU,IACL,CACC9Y,KAAM,OACNqE,GAAIyU,IACL,CACC9Y,KAAM,OACNqE,GAAIyU,IACL,CACC9Y,KAAM,IACNqE,GAAI0U,IACL,CACC/Y,KAAM,OACNqE,GAAI0U,IACL,CACC/Y,KAAM,OACNqE,GAAI0U,IACL,CACC/Y,KAAM,IACNqE,GAAI2U,IACL,CACChZ,KAAM,OACNqE,GAAI2U,IACL,CACChZ,KAAM,KACNqE,GAAI4U,IACL,CACCjZ,KAAM,OACNqE,GAAI4U,IACL,CACCjZ,KAAM,IACNqE,GAAI+U,IACL,CACCpZ,KAAM,OACNqE,GAAI+U,IACL,CACCpZ,KAAM,IACNqE,GAAIgV,IACL,CACCrZ,KAAM,OACNqE,GAAIgV,IACL,CACCrZ,KAAM,OACNqE,GAAIiV,IACL,CACCtZ,KAAM,OACNqE,GAAIkV,IACL,CACCvZ,KAAM,OACNqE,GAAImV,IACL,CACCxZ,KAAM,SACNqE,GAAIoV,IACL,CACCzZ,KAAM,QACNqE,GAAIsV,IACL,CACC3Z,KAAM,SACNqE,GAAIwV,IACL,CACC7Z,KAAM,OACNqE,GAAI0V,IACL,CACC/Z,KAAM,QACNqE,GAAI4V,KCmBO,IAAAG,GA/GsB,CAAC,CAClCpa,KAAM,QACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,QAASiX,EAAM,EAAG,GAE7B,CAAC,CAACnT,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,GAAI,MAGrC,CACCpX,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,KAAMiX,EAAM,EAAG,GAE1B,CAAC,CAACnT,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,GAAI,MAGrC,CACCpX,KAAM,QACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,QAASiX,EAAM,EAAG,GAE7B,CAAC,CAACnT,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,IAAK,MAGtC,CACCpX,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,KAAMiX,EAAM,EAAG,GAE1B,CAAC,CAACnT,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,IAAK,MAGtC,CACCpX,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,GADAjX,OAAA6P,EAAA,EAAA7P,CAAkB,SAAUiX,EAAM,EAAG,GACd,iBAAZA,EAAK,GACZ,MAAM,IAAI/U,MAAM,yDAGpB,MAAO,CAAC,CAAC4B,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,GAAIA,EAAK,OAG1C,CACCpX,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,GADAjX,OAAA6P,EAAA,EAAA7P,CAAkB,KAAMiX,EAAM,EAAG,GACV,iBAAZA,EAAK,GACZ,MAAM,IAAI/U,MAAM,qDAGpB,MAAO,CAAC,CAAC4B,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,GAAIA,EAAK,OAG1C,CACCpX,KAAM,SACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,GADAjX,OAAA6P,EAAA,EAAA7P,CAAkB,SAAUiX,EAAM,EAAG,GACd,iBAAZA,EAAK,GACZ,MAAM,IAAI/U,MAAM,yDAGpB,MAAO,CAAC,CAAC4B,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,IAAMA,EAAK,OAG5C,CACCpX,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,GADAjX,OAAA6P,EAAA,EAAA7P,CAAkB,KAAMiX,EAAM,EAAG,GACV,iBAAZA,EAAK,GACZ,MAAM,IAAI/U,MAAM,qDAGpB,MAAO,CAAC,CAAC4B,OAAQ,QACbmT,EAAK,GACL,CAAC,CAACnT,OAAQ,QAASmT,EAAK,IAAMA,EAAK,QC1GhC,IAAAiD,GAHwB,GCGzB,SAAUC,GAAQvY,GAI5B,OAHAA,EAAOoW,OAASpW,EAAOoW,OAAS,IAAIrU,OAAOqW,IAC3CpY,EAAOqW,QAAUrW,EAAOqW,QAAU,IAAItU,OAAOsW,IAC7CrY,EAAOsW,SAAWtW,EAAOsW,SAAW,IAAIvU,OAAOuW,IACxCtY,ECVL,MAAOwY,GACTrR,YAA0BsR,GAAAC,KAAAD,OAGnBtR,QAAQwR,GACX,IAAIrW,EAkBJ,OAhBIA,EADAZ,MAAMC,QAAQgX,GACT,CAACrX,EAAMsX,KACR,IAAK,MAAM7a,KAAK4a,EACZ,GAAiB,iBAAN5a,EAAgB,CACvB,GAAIuD,EAAEvD,GAAK6a,EAAE7a,GAAI,OAAO,EACxB,GAAIuD,EAAEvD,GAAK6a,EAAE7a,GAAI,OAAQ,MACtB,CACH,MAAM8a,EAAgB,SAAT9a,EAAE,IAAiB,EAAI,EACpC,GAAIuD,EAAEvD,EAAE,IAAM6a,EAAE7a,EAAE,IAAK,OAAO,EAAI8a,EAClC,GAAIvX,EAAEvD,EAAE,IAAM6a,EAAE7a,EAAE,IAAK,OAAQ,EAAI8a,EAG3C,OAAO,GAGNF,EAEF,IAAIH,GAAME,KAAKD,KAAK3W,MAAM,GAAGgX,KAAKxW,IAGtC6E,QAAQwR,GACX,IAAIrW,EAEAA,EADAZ,MAAMC,QAAQgX,GACT,CAACrX,EAAMsX,KACR,IAAK,MAAM7a,KAAK4a,EACZ,GAAIrX,EAAEvD,KAAO6a,EAAE7a,GAAI,OAAO,EAE9B,OAAO,GAGN4a,EAET,MAAMna,EAAW,GACjB,IAAIua,EAAQ,EACRrb,EAAI,EACR,KAAOA,EAAIgb,KAAKD,KAAKpY,OAAQ3C,IACnB4E,EAAGoW,KAAKD,KAAKM,GAAQL,KAAKD,KAAK/a,GAAIA,EAAGgb,KAAKD,QAC7Cja,EAAEqF,KAAK6U,KAAKD,KAAK3W,MAAMiX,EAAOrb,IAC9Bqb,EAAQrb,GAIhB,OADAc,EAAEqF,KAAK6U,KAAKD,KAAK3W,MAAMiX,EAAOrb,IACvB,IAAI8a,GAAMha,GAGd2I,WAAWhI,GACd,GAAiB,iBAANA,EACP,OAAOuZ,KAAKM,QAAQ,CAACtV,EAAGmE,EAAG8C,EAAOsO,IACzBtO,EAAQxL,GAAO,GAGrB,CACH,MAAM+Z,EAAI9a,OAAOwF,OAAO,CAACuV,MAAOha,EAAEia,aAAclJ,KAAM/Q,EAAEia,cAAeja,GACjEX,EAAIka,KAAKM,QAAQ,CAACtV,EAAGmE,EAAG8C,EAAOsO,IAC7BC,EAAEG,QAAUJ,EAAM5Y,OACbsK,EAAQuO,EAAEG,QAAY,EAEpB1O,GAASuO,EAAEC,MACbxO,EAAQuO,EAAEC,OAAW,GAGpBxO,EAAQuO,EAAEC,OAASD,EAAEE,cAAkB,GAmBrD,OAfsB,IAAlB5a,EAAEia,KAAKpY,OACH6Y,EAAEG,OAAS7a,EAAEia,KAAK,GAAGpY,QACrB7B,EAAEia,KAAK5U,KAAK,IAGZqV,EAAEC,MAAQ3a,EAAEia,KAAK,GAAGpY,QAEpB7B,EAAEia,KAAK9U,QAAQ,IAGnBnF,EAAEia,KAAKpY,OAAS,GACZ7B,EAAEia,KAAKja,EAAEia,KAAKpY,OAAS,GAAGA,OAAS6Y,EAAEhJ,MACrC1R,EAAEia,KAAK5U,KAAK,IAGbrF,GAIR2I,MAAM7E,GACT,OAAO,IAAIkW,GAAME,KAAKD,KAAKa,OAAOhX,IAK/B6E,OAAU7E,GACb,OAAOA,EAAKoW,KAAKD,KAAK5T,IAAIvC,GAAMoW,KAAKD,MAMvC,SAAUc,GAASd,GACrB,OAAO,IAAID,GAASC,GC/FjB,MAoBMe,GAAU,CAAC1Z,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAEtC,MAAMiG,EAAM+H,KAAWhO,GACvB,cAAeiG,GACf,IAAK,SACD,KAAO,WAAYA,GACf,MAGR,IAAK,SACD,OAAOA,EAAI9F,OAEf,MAAM,IAAIC,MAAM,0EAKPmZ,IAHWD,KAGH,CAAC1Z,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,EAAM+H,KAAWhO,GACvB,GAAmB,iBAARiG,EACP,OAAOA,EAAIiE,OAEf,MAAM,IAAI9J,MAAM,+DAKPoZ,IAHSD,KAGG,CAAC3Z,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,EAAM+H,KAAWhO,GACvB,GAAmB,iBAARiG,EACP,OAAOA,EAAIwT,WAEf,MAAM,IAAIrZ,MAAM,mEAKPsZ,IAHaF,KAGD,CAAC5Z,EAAsB7B,IAAiB,IAAIiC,KAGjE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,EAAM+H,KAAWhO,GACvB,GAAmB,iBAARiG,EACP,OAAOA,EAAI0T,YAEf,MAAM,IAAIvZ,MAAM,mEAKPwZ,IAHaF,KAGC,CAAC9Z,EAAsB7B,IAAiB,IAAIiC,KAKnE,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAEnB,iBAAZA,EAAK,IAAsC,iBAAZA,EAAK,IAAsC,iBAAZA,EAAK,GAC1E,OAAOA,EAAK,GAAGiL,MAAMjL,EAAK,IAAIqI,KAAKrI,EAAK,IAE5C,MAAM,IAAII,MAAM,mFAKPyZ,IAHeD,KAGN,CAACha,EAAsB7B,IAAiB,IAAIiC,KAK9D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAEd,iBAAZA,EAAK,IAAsC,iBAAZA,EAAK,GAC3C,OAAOA,EAAK,GAAGiL,MAAMjL,EAAK,IAE9B,MAAM,IAAII,MAAM,uEAKP0Z,IAHUD,KAGF,CAACja,EAAsB7B,IAAiB,IAAIiC,KAMzD,GAHJ9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEzBwB,MAAMC,QAAQzB,EAAK,IACtBA,EAAKG,OAAS,EAAG,CACjB,GAAuB,iBAAZH,EAAK,GACZ,OAAOA,EAAK,GAAGqI,KAAKrI,EAAK,IAE7B,MAAM,IAAII,MAAM,6DAEhB,OAAOJ,EAAK,GAAGqI,SAQd0R,IAHSD,KAGC,CAACla,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,GAEnC,MAAMiG,EAAM+H,KAAWhO,GACvB,cAAeiG,GACf,IAAK,SACD,KAAO,WAAYA,GACf,MAGR,IAAK,SACD,OAAOA,EAAIpE,UAAU7B,EAAK4B,MAAM,IAEpC,MAAM,IAAIxB,MAAM,2EAKP4Z,IAHWD,KAGF,CAACna,EAAsB7B,IAAiB,IAAIiC,KAM9D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAEjB,IAAhBA,EAAKG,SACkB,iBAAZH,EAAK,IAAmBwB,MAAMC,QAAQzB,EAAK,KAClD,OAAOA,EAAK,GAAG4B,MAAM1D,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,IAAK9B,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,KAG9D,GAAoB,IAAhBA,EAAKG,SACkB,iBAAZH,EAAK,IAAmBwB,MAAMC,QAAQzB,EAAK,KAClD,OAAOA,EAAK,GAAG4B,MAAM1D,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,KAG3C,MAAM,IAAII,kDAAkDJ,EAAKG,OAAS,gCAKjE8Z,IAHUD,KAGH,CAACpa,EAAsB7B,IAAiB,IAAIiC,KAK5D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAEZ,iBAAZA,EAAK,IAAmBwB,MAAMC,QAAQzB,EAAK,IAClD,OAAOA,EAAK,GAAG4B,MAAM,EAAG1D,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,KAE1C,MAAM,IAAII,MAAM,uEAKP8Z,IAHQD,KAGA,CAACra,EAAsB7B,IAAiB,IAAIiC,KAK7D,GAFA9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEb,iBAAZA,EAAK,IAAmBwB,MAAMC,QAAQzB,EAAK,IAAK,CACvD,MAAMf,GAAKf,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,IACzB,OAAOA,EAAK,GAAG4B,MAAM3C,GAAK,GAAKqC,OAAOgQ,MAAMrS,GAAKe,EAAK,GAAGG,OAASlB,GAEtE,MAAM,IAAImB,MAAM,wEAKP+Z,IAHSD,KAGD,CAACta,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEzBwB,MAAMC,QAAQzB,EAAK,IAC1BA,EAAK,GAAG2D,KAAK3D,EAAK,IACXA,EAAK,KAOPoa,IAHSD,KAGF,CAACva,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAExBwB,MAAMC,QAAQzB,EAAK,IAE1B,OADUA,EAAK,GAAG4D,QASbyW,IAJQD,KAIA,CAACxa,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,OAAOkG,EAAID,KAMFqU,IAHSD,KAGE,CAACza,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,WAAY8B,EAAM,EAAG,GAEvC,MAAMiG,EAAM+H,KAAWhO,GACvB,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAIrE,MAAM,GAAG4D,UAExB,MAAM,IAAIpF,MAAM,iEAKPma,IAHYD,KAGU,CAAC1a,EAAsB7B,IAAiB,IAAIiC,KAG3E9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,EAAM+H,KAAWhO,GACvB,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAIT,UAEf,MAAM,IAAIpF,MAAM,kEAKPoa,IAHuBD,KAGf,CAAC3a,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAIwU,KAAKvU,GAEpB,MAAM,IAAI9F,MAAM,8DAKPsa,IAHSF,KAGC,CAAC5a,EAAsB7B,IAAiB,IAAIiC,KAG/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAEtC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAImT,OAAOlT,GAEtB,MAAM,IAAI9F,MAAM,gEAKPua,IAHWD,KAGJ,CAAC9a,EAAsB7B,IAAiB,IAAIiC,KAG5D9B,OAAA6P,EAAA,EAAA7P,CAAkB,OAAQ8B,EAAM,EAAG,GAEnC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAItB,IAAIuB,GAEnB,MAAM,IAAI9F,MAAM,6DAKPwa,IAHQD,KAGE,CAAC/a,EAAsB7B,IAAiB,IAAIiC,KAI/D9B,OAAA6P,EAAA,EAAA7P,CAAkB,UAAW8B,EAAM,EAAG,GAEtC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAIjG,EAAKG,OAAS,EACP8F,EAAIyQ,OAAOxQ,GAEXD,EAAIyQ,OAAOxQ,EAAKlG,EAAK,IAGpC,MAAM,IAAII,MAAM,gEAKPya,IAHWD,KAGO,CAAChb,EAAsB7B,IAAiB,IAAIiC,KAIvE9B,OAAA6P,EAAA,EAAA7P,CAAkB,kBAAmB8B,EAAM,EAAG,GAE9C,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAIjG,EAAKG,OAAS,EACP8F,EAAI6U,YAAY5U,GAEhBD,EAAI6U,YAAY5U,EAAKlG,EAAK,IAGzC,MAAM,IAAII,MAAM,wEAKP2a,IAHmBF,KAGX,CAACjb,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAIrE,MAAM,GAAGgX,KAAK1S,GAE7B,MAAM,IAAI9F,MAAM,8DAKP4a,IAHSD,KAGU,CAACnb,EAAsB7B,IAAiB,IAAIiC,KAGxE9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAIwB,MAAMC,QAAQwE,GACd,OAAOA,EAAI2S,KAAK1S,GAEpB,MAAM,IAAI9F,MAAM,+DAKP6a,IAHoBD,KAGN,CAACpb,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,eAAgB8B,EAAM,EAAG,GAE3C,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,IAAMwB,MAAMC,QAAQyE,GAChB,MAAM,IAAI9F,MAAM,mEAGpB,OAAOiZ,GAAMnT,GAAcgV,WAAWjV,GAAKkV,WAKlCC,IAHeH,KAGJ,CAACrb,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,IAAMwB,MAAMC,QAAQyE,GAChB,MAAM,IAAI9F,MAAM,gEAGpB,OAAOiZ,GAAMnT,GAAc4S,QAAQ7S,GAAKkV,WAK/BE,IAHYD,KAGD,CAACxb,EAAsB7B,IAAiB,IAAIiC,KAGhE9B,OAAA6P,EAAA,EAAA7P,CAAkB,YAAa8B,EAAM,EAAG,GAExC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,IAAMwB,MAAMC,QAAQyE,GAChB,MAAM,IAAI9F,MAAM,gEAGpB,OAAOiZ,GAAMnT,GAAcoV,QAAQrV,GAAKkV,WAK/BI,IAHYF,KAGH,CAACzb,EAAsB7B,IAAiB,IAAIiC,KAG9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,GAAuB,mBAAZA,EAAK,GACZ,MAAM,IAAII,MAAM,gEAEpB,IAAMoB,MAAMC,QAAQyE,GAChB,MAAM,IAAI9F,MAAM,6DAGpB,OAAOiZ,GAAMnT,GAAckB,MAAMnB,GAAKkV,WAEnBI,KC5VR,IAAAC,GA1FoB,CAAC,CAChCzd,KAAM,SACNqE,GDGkB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAI9D9B,OAAA6P,EAAA,EAAA7P,CAAkB,SAAU8B,EAAM,EAAG,GAErC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACjC6Y,EAAQ3a,OAAA+C,EAAA,EAAA/C,CAAS+H,IAAQ,EACzBwV,EAAOvd,OAAA+C,EAAA,EAAA/C,CAASgI,IAAQ,EAExBwV,EAAQ1b,EAAKG,OAAS,GAAIjC,OAAA+C,EAAA,EAAA/C,CAAS8B,EAAK,MAAkB6Y,GAAS4C,EAAO,GAAK,GAC/Exc,EAAIgY,KAAKgB,KAAKwD,EAAO5C,GAAS5B,KAAKgB,KAAKyD,KAAU,EACnDzE,KAAKQ,MAAOR,KAAKc,IAAI0D,EAAO5C,GAAS5B,KAAKc,IAAI2D,IAAU,EAAK,EAIlE,OAFA9b,EAAMC,WAAaZ,EACnBf,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAO,GACT4B,MAAMma,KAAK,CAACxb,OAAQlB,GAAI,CAACmC,EAAG5D,IAAMqb,EAAQrb,EAAIke,KClBtD,CACC3d,KAAM,UACNqE,GAAIkX,IACL,CACCvb,KAAM,QACNqE,GAAImX,IACL,CACCxb,KAAM,aACNqE,GAAIoX,IACL,CACCzb,KAAM,aACNqE,GAAIsX,IACL,CACC3b,KAAM,eACNqE,GAAIwX,IACL,CACC7b,KAAM,SACNqE,GAAIyX,IACL,CACC9b,KAAM,QACNqE,GAAI0X,IACL,CACC/b,KAAM,UACNqE,GAAI2X,IACL,CACChc,KAAM,SACNqE,GAAI4X,IACL,CACCjc,KAAM,OACNqE,GAAI6X,IACL,CACClc,KAAM,QACNqE,GAAI8X,IACL,CACCnc,KAAM,QACNqE,GAAI+X,IACL,CACCpc,KAAM,OACNqE,GAAIgY,IACL,CACCrc,KAAM,QACNqE,GAAIiY,IACL,CACCtc,KAAM,WACNqE,GAAIkY,IACL,CACCvc,KAAM,YACNqE,GAAImY,IACL,CACCxc,KAAM,QACNqE,GAAIoY,IACL,CACCzc,KAAM,UACNqE,GAAIsY,IACL,CACC3c,KAAM,OACNqE,GAAIuY,IACL,CACC5c,KAAM,UACNqE,GAAIwY,IACL,CACC7c,KAAM,oBACNqE,GAAIwY,IACL,CACC7c,KAAM,oBACNqE,GAAIyY,IACL,CACC9c,KAAM,QACNqE,GAAI2Y,IACL,CACChd,KAAM,SACNqE,GAAI4Y,IACL,CACCjd,KAAM,eACNqE,GAAI6Y,IACL,CACCld,KAAM,YACNqE,GAAIgZ,IACL,CACCrd,KAAM,YACNqE,GAAIiZ,IACL,CACCtd,KAAM,SACNqE,GAAImZ,KCpEO,IAAAK,GAjBsB,CAAC,CAClC7d,KAAM,KACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAIzC,IADcjX,OAAAgP,EAAA,EAAAhP,CAASiX,EAAK,GAAI,KAE5B,MAAM,IAAI/U,MAAM,sDAEpB,MAAO,CAAC,CAAC4B,OAAQ,SACbmT,EAAK,GACLA,EAAK,OCVF,IAAA0G,GAHwB,GCGzB,SAAUC,GAAQhc,GAI5B,OAHAA,EAAOoW,OAASpW,EAAOoW,OAAS,IAAIrU,OAAO2Z,IAC3C1b,EAAOqW,QAAUrW,EAAOqW,QAAU,IAAItU,OAAO+Z,IAC7C9b,EAAOsW,SAAWtW,EAAOsW,SAAW,IAAIvU,OAAOga,IACxC/b,ECIJ,MAsDMic,GAAY,CAACnc,EAAsB7B,IAAiB,IAAIiC,KAGjE,MAAM1B,EAAS,GACf,IAAK,MAAM8C,KAAKpB,EAAM,CAClB,KAAIwB,MAAMC,QAAQL,IAAM,EAAIA,EAAEjB,QA8I1B,MAAM,IAAIC,MAAM,8DA9IkB,CAClC,MAAM4E,EAAM9G,OAAAgP,EAAA,EAAAhP,CAASkD,EAAE,IACjBmU,EACFvQ,EAAMA,EAAIhD,OACV6F,OAAO3J,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,KAC7B,OAAQmU,GACR,IAAK,QAEG,GAAiB,IAAbnU,EAAEjB,OAGF7B,EAAEiX,GAAW,QACV,GAAInU,EAAEjB,QAAU,EAAG,CAItB,MAAM6b,EAAiB,GACvB,IAAK,MAAMzc,KAAK6B,EAAEQ,MAAM,GACpB,GAAIJ,MAAMC,QAAQlC,IAAM,EAAIA,EAAEY,OAC1B6b,EAAOnU,OAAO3J,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOL,EAAE,MAAQsI,OAAO3J,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOL,EAAE,UAC9D,GAAiB,iBAANA,EACd,IAAK,MAAMoG,KAAKpG,EAAE0L,MAAM,KAAM,CAC1B,MAAMgR,EAAU,4BAA4BhI,KAAKtO,GAC7CsW,IACAD,EAAOC,EAAQ,IAAMA,EAAQ,IAK7C3d,EAAEiX,GAAWyG,EAGrB,MACJ,IAAK,QAAS,IAAK,aAEX,GAAiB,IAAb5a,EAAEjB,OAGF7B,EAAEiX,GAAW,QACV,GAAInU,EAAEjB,QAAU,EAAG,CAItB,IAAI+b,EAAiB,GACrB,IAAK,MAAMre,KAAKuD,EAAEQ,MAAM,GAChBJ,MAAMC,QAAQ5D,GACdqe,EAAUA,EAAQra,OAAOhE,EAAE8G,IAAIwX,GAAKje,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOuc,KAChC,iBAANte,IACdqe,EAAUA,EAAQra,OAAOhE,EAAEoN,MAAM,OAGzC,MAAMmR,EAAe,GACfha,EAA0BoB,GAAMA,EACjC6Y,QAAQxe,GAAMA,aACX,EACC2D,MAAMC,QAAQ5D,GAAKuE,EAAGvE,GAAKue,EAAGzY,KAAKkE,OAAOhK,KACnDuE,EAAG8Z,GACH5d,EAAEiX,GAAW6G,EAGrB,MACJ,IAAK,YAEG,GAAiB,IAAbhb,EAAEjB,OAGF7B,EAAEiX,GAAW,QACV,GAAInU,EAAEjB,QAAU,EAAG,CAItB,IAAI+b,EAAkB,GACtB,IAAK,MAAMre,KAAKuD,EAAEQ,MAAM,GAAI,CACxB,IAAI0a,EAAW,GACf,GAAI9a,MAAMC,QAAQ5D,GAAI,CAClB,MAAMue,EAAe,GACfha,EAA0BoB,GAAMA,EACjCmB,IAAIwX,GAAKje,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOuc,IACzBE,QAAQF,GAAMA,aACX,EACC3a,MAAMC,QAAQ0a,GAAK/Z,EAAG+Z,GAAKC,EAAGzY,KAAKkE,OAAOsU,KACnD/Z,EAAGvE,GACHye,EAAWF,EAAG/T,KAAK,SACC,iBAANxK,IACdye,EAAWze,GAEX,EAAIqe,EAAQ/b,OAAQ+b,GAAW,IAAMI,EACpCJ,EAAUI,EAEnBhe,EAAEiX,GAAW2G,EAGrB,MACJ,IAAK,0BAEoB,IAAb9a,EAAEjB,OACF7B,EAAEiX,GAAW,CAACgH,OAAQ,IACfnb,EAAEjB,QAAU,EACnB7B,EAAEiX,GAAW,CAACgH,OAAQre,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,KAExC9C,EAAEiX,GAAW,CAACgH,OACVre,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAQ,CAAC,CAACoC,OAAQpC,EAAME,OAAO4B,cAAcyT,OACrDtT,OAAOT,EAAEQ,MAAM,MAI5B,MACJ,IAAK,eAEoB,IAAbR,EAAEjB,OACF7B,EAAEiX,GAAW,CAACiH,OAAQ,IACfpb,EAAEjB,QAAU,EACnB7B,EAAEiX,GAAW,CAACiH,OAAQte,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,KAExC9C,EAAEiX,GAAW,CAACiH,OACVte,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAQ,CAAC,CAACoC,OAAQpC,EAAME,OAAO4B,cAAcyT,OACrDtT,OAAOT,EAAEQ,MAAM,MAI5B,MACJ,QAEyB,IAAbR,EAAEjB,OAGF7B,EAAEiX,IAAW,EACO,IAAbnU,EAAEjB,OAGT7B,EAAEiX,GAAWrX,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOwB,EAAE,IAI/B9C,EAAEiX,GACErX,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAQ,CAAC,CAACoC,OAAQpC,EAAME,OAAO4B,cAAcyT,OACrDtT,OAAOT,EAAEQ,MAAM,OASxC,OAAOtD,GAIX,SAASme,GAAiB7c,KAAyBI,GAC/C,IAAI0c,EAAW1c,EACX2c,EAAa,GACjB,GAAI,EAAI3c,EAAKG,QAAUqB,MAAMC,QAAQzB,EAAK,IAAK,CAC/B9B,OAAAgP,EAAA,EAAAhP,CAAS8B,EAAK,GAAG,GAAI,OAG7B2c,EAAQZ,GAAUnc,EAAO,GAAjBmc,IAAwB/b,EAAK,GAAG4B,MAAM,IAC9C8a,EAAWA,EAAS9a,MAAM,IAGlC,MAAO,CAAC+a,QAAOD,YAIZ,MAAME,GAAkB,CAAChd,EAAsB7B,IAAiB,IAAIiC,KACvE,MAAM2c,MAACA,EAADD,SAAQA,GAAYD,GAAiB7c,KAAUI,GACrD,OAAQJ,EAAME,OAAO+c,IAAY9e,EAAM4e,KAAUD,IAIxCI,GAAoBC,GAAmB,CAACnd,EAAsB7B,IAAiB,IAAIiC,KAC5F,MAAM2c,MAACA,EAADD,SAAQA,GAAYD,GAAiB7c,KAAUI,GACrD,OAAQJ,EAAME,OAAO+c,IAAYE,EAAWJ,KAAUD,ICxO3C,IAAAM,GAToB,CAAC,CAChCjf,KAAM,SACNqE,GDQuB,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAInE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,GAEvC,MAAMiG,IAACA,EAADC,IAAMA,GAAOiI,KAAoBnO,GACvC,IAAI1B,EAAa,GASjB,OARI4R,EAAUjK,KACN,EAAIjG,EAAKG,QACT7B,EAAEqF,KAAK,CAAC3B,OAAQpC,EAAME,OAAO4B,cAAc6L,aAAcvN,EAAK4B,MAAM,IACpEtD,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOtB,IAEpBA,EAAIJ,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOsG,IAGrB5H,ICvBR,CACCP,KAAM,UACNqE,GD0B0B,CAACxC,EAAsB7B,IAAiB,IAAIiC,KAGtE9B,OAAA6P,EAAA,EAAA7P,CAAkB,iBAAkB8B,EAAM,GAE1C,MAAMiG,EAAM+H,KAAWhO,GACjB1B,EAAe,GACrB,IAAIkD,MAAMC,QAAQwE,GAiBd,MAAM,IAAI7F,MAAM,mEAhBhB,IAAK,IAAI5C,EAAI,EAAGA,EAAIyI,EAAI9F,OAAQ3C,IAAK,CACjC,MAAM4D,EAAI6E,EAAIzI,GACRmI,EAAImJ,EAASlP,EAATkP,EAAsB,GAAM,EAAM,CACxC,CAAC,QAAS5Q,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,IACvB,CAAC,SAAU5D,GACX,CAAC,SAAUU,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOqG,IACxB,CAAC,UAAW/H,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAO1B,OAAA+C,EAAA,EAAA/C,CAAS0B,GAAOmD,YACvC/C,EAAK4B,MAAM,IAEb,EAAI5B,EAAKG,QAAUqB,MAAMC,QAAQkE,GACjCrH,EAAEqF,QAAQgC,GAEVrH,EAAEqF,KAAKgC,GAOnB,OAAOzH,OAAA+C,EAAA,EAAA/C,CAAS0B,EACX,CAAC,CAACoC,OAAQpC,EAAME,OAAO4B,cAAc6L,WACrC1L,OAAOvD,EAAEqG,IAAIwX,GAAK,CAAC,CAACna,OAAQpC,EAAME,OAAO4B,cAAcuD,OAAQkX,SE7BzD,IAAAc,GA9BsB,CAAC,CAClClf,KAAM,IACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAClCjX,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,IAEzB,CACCpX,KAAM,OACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CACH,CAACnT,OAAQ,UACTmT,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,MAGjD,CACCrD,KAAM,QACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,GAGlC,CACH,CAACnT,OAAQ,WACTmT,EAAK,MACDA,EAAKvT,MAAM,GAAG+C,IAAIvD,GAAKlD,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOwB,OCvBrC,IAAA8b,GAHwB,GCOzB,SAAUC,GAAQrd,EAAwBsd,GACpDtd,EAAOoW,OAASpW,EAAOoW,OAAS,IAAIrU,OAAOmb,IAC3Cld,EAAOqW,QAAUrW,EAAOqW,QAAU,IAAItU,OAAOob,IAC7Cnd,EAAOsW,SAAWtW,EAAOsW,SAAW,IAAIvU,OAAOqb,IAE/C,MAAMG,EACFnf,OAAO2K,QAAQuU,EAAQC,YACtB1Y,IAAIvD,IAAC,CAAMrD,KAAMqD,EAAE,GAAIgB,GAAI0a,GAAiB1b,EAAE,OAWnD,OATAtB,EAAOoW,MAAQpW,EAAOoW,MAAMrU,OACxB,CAAC9D,KAAM+B,EAAO4B,cAAc6L,SAAUnL,GAAI0a,GAAiBM,EAAQE,iBAChED,GAGPvd,EAAO8F,2BAA6BgX,GACpC9c,EAAO+c,IAAMO,EAAQP,IACrB/c,EAAOyd,YAAcH,EAAQE,YAEtBxd,ECrBJ,MAAM0d,GAAc,CAAC5d,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAE1C,IAAIyd,EAAwBzd,EAAK,GAYjC,MAXuB,iBAAZyd,GAAgD,mBAAjBA,EAAQC,OAC9CD,EAAUE,QAAQC,QAAQH,IAE9BA,EAAUA,EAAQC,KAAK/X,IACnB,IAEI,OADAgK,EAAO/P,EAAP+P,CAAkB3P,EAAK,GAAI2F,GACpBA,EACT,MAAO0P,GACL,OAAOsI,QAAQE,OAAOxI,OAUrByI,IAJeN,GAAY,MAIb,CAAC5d,EAAsB7B,IAAiB,IAAIiC,KAGnE9B,OAAA6P,EAAA,EAAA7P,CAAkB,cAAe8B,EAAM,EAAG,GAE1C,IAAIyd,EAAwBzd,EAAK,GAYjC,MAXuB,iBAAZyd,GAAgD,mBAAjBA,EAAQC,OAC9CD,EAAUE,QAAQC,QAAQH,IAE9BA,EAAUA,EAAQC,KAAK/X,IACnB,IAEI,OADAiK,EAAOhQ,EAAPgQ,CAAkB5P,EAAK,GAAI2F,GACpBA,EACT,MAAO0P,GACL,OAAOsI,QAAQE,OAAOxI,QASrB0I,IAHeD,GAAY,MAGnB,CAACle,EAAsB7B,IAAiB,IAAIiC,KAG7D9B,OAAA6P,EAAA,EAAA7P,CAAkB,QAAS8B,EAAM,EAAG,GAEpC,IAAIyd,EAAwBzd,EAAK,GAIjC,GAHuB,iBAAZyd,GAAgD,mBAAjBA,EAAQC,OAC9CD,EAAUE,QAAQC,QAAQH,IAEP,mBAAZzd,EAAK,GACZyd,EAAUA,EAAQC,KAAK1d,EAAK,GAAIA,EAAK,QAClC,CACH,GAAuB,mBAAZA,EAAK,GACZ,MAAM,IAAII,MAAM,6DAEpBqd,EAAUA,EAAQC,KAAK1d,EAAK,IAEhC,OAAOyd,IAKEO,IAHSD,KAGK,CAACne,EAAsB7B,IAAiB,IAAIiC,KAGnE,MAAMie,EAAgCje,EAAK4B,MAAM,GACjD,IAAK,IAAIpE,EAAI,EAAGA,EAAIygB,EAAS9d,OAAQ3C,IACN,iBAAhBygB,EAASzgB,IAAwD,mBAA7BygB,EAASzgB,GAAWkgB,OAC/DO,EAASzgB,GAAKmgB,QAAQC,QAAQK,EAASzgB,KAG/C,OAAOmgB,QAAQO,IAAID,KAKVE,IAHeH,KAGD,CAACpe,EAAsB7B,IAAiB,IAAIiC,KAGnE,MAAMie,EAAgCje,EAAK4B,MAAM,GACjD,IAAK,IAAIpE,EAAI,EAAGA,EAAIygB,EAAS9d,OAAQ3C,IACN,iBAAhBygB,EAASzgB,IAAwD,mBAA7BygB,EAASzgB,GAAWkgB,OAC/DO,EAASzgB,GAAKmgB,QAAQC,QAAQK,EAASzgB,KAO/C,MAAM4gB,EAAW9e,GAAoB,IAAIqe,QAAQ,CAACU,EAAKC,IAAQhf,EAAEoe,KAAKY,EAAKD,IAG3E,MAFiBE,IAA4BH,EAAOT,QAAQO,IAAIK,EAAG5Z,IAAIyZ,KAEhEI,CAAQP,KAKNQ,IAHeN,KAGA,CAACve,EAAsB7B,IAAiB,IAAIiC,KAIpE9B,OAAA6P,EAAA,EAAA7P,CAAkB,eAAgB8B,EAAM,GAExC,IAAIyd,EAAwBzd,EAAK,GACV,iBAAZyd,GAAgD,mBAAjBA,EAAQC,OAC9CD,EAAUE,QAAQC,QAAQH,IAE9B,MAAMiB,EAAU1e,EAAK4B,MAAM,GAC3B,IAAK,IAAIpE,EAAI,EAAGA,EAAIkhB,EAAQve,OAAQ3C,IAChC,GAA0B,mBAAfkhB,EAAQlhB,GAAmB,CAClC,MAAMmI,EAAI+Y,EAAQlhB,GAClBkhB,EAAQlhB,GAAK,KAAMmI,GAG3B,IAAIrG,EAAIme,EACR,IAAK,MAAMhgB,KAAKihB,EACZpf,EAAIA,EAAEoe,KAAKjgB,GAEf,OAAO6B,IAKEqf,IAHgBF,KAGD,CAAC7e,EAAsB7B,IAAiB,IAAIiC,KAIpE9B,OAAA6P,EAAA,EAAA7P,CAAkB,eAAgB8B,EAAM,GAExC,IAAIyd,EAAwBzd,EAAK,GACV,iBAAZyd,GAAgD,mBAAjBA,EAAQC,OAC9CD,EAAUE,QAAQC,QAAQH,IAE9B,MAAMiB,EAAU1e,EAAK4B,MAAM,GAC3B,IAAK,IAAIpE,EAAI,EAAGA,EAAIkhB,EAAQve,OAAQ3C,IAChC,GAA0B,mBAAfkhB,EAAQlhB,GAAmB,CAClC,MAAMmI,EAAI+Y,EAAQlhB,GAClBkhB,EAAQlhB,GAAK,KAAMmI,GAI3B,MAAMiZ,EAAY,IAAIpd,MAAMkd,EAAQve,QAC9B0e,EAAY,IAAIrd,MAAMkd,EAAQve,QAE9B2e,EAA0B,GAChC,IAAK,IAAIthB,EAAI,EAAGA,EAAIkhB,EAAQve,OAAQ3C,IAChCshB,EAAGnb,KAAK,IAAIga,QAAa,CAACC,EAAcC,KACpCe,EAAUphB,GAAMmI,KACZ,IAAIoZ,EAAmBL,EAAQlhB,GAAGmI,GAChB,iBAAPoZ,GAAsC,mBAAZA,EAAGrB,OACpCqB,EAAKpB,QAAQC,QAAQmB,IAGzBA,EACCrB,KAAKtc,GAAKwc,EAAQxc,IAClB4d,MAAM3J,GAAKwI,EAAOxI,MAEvBwJ,EAAUrhB,GAAKqgB,KASvB,OALAJ,EAAQC,KACJ/X,GAAKiZ,EAAUvC,QAAQ4C,GAAKA,EAAEtZ,IAC9B0P,GAAKwJ,EAAUxC,QAAQ4C,GAAKA,EAAE5J,KAG3ByJ,IAEkBH,KC1Jd,IAAAO,GAxBoB,CAAC,CAChCnhB,KAAM,eACNqE,GAAIob,IACL,CACCzf,KAAM,eACNqE,GAAI0b,IACL,CACC/f,KAAM,QACNqE,GAAI2b,IACL,CACChgB,KAAM,eACNqE,GAAI4b,IACL,CACCjgB,KAAM,eACNqE,GAAI+b,IACL,CACCpgB,KAAM,gBACNqE,GAAIqc,IACL,CACC1gB,KAAM,gBACNqE,GAAIuc,KCSO,IAAAQ,GA3BsB,CAAC,CAClCphB,KAAM,aACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,aAAciX,EAAM,EAAG,GAElC,CAAC,CAACnT,OAAQ,gBACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,MAGd,CACCpX,KAAM,aACNqE,GAAI,CAACxC,EAAsB7B,IAAkBoX,IAGzCjX,OAAA6P,EAAA,EAAA7P,CAAkB,aAAciX,EAAM,EAAG,GAElC,CAAC,CAACnT,OAAQ,gBACb9D,OAAAgP,EAAA,EAAAhP,CAAM0B,EAAOuV,EAAK,IAClBA,EAAK,OCrBF,IAAAiK,GAHwB,GCGzB,SAAUC,GAAQvf,GAI5B,OAHAA,EAAOoW,OAASpW,EAAOoW,OAAS,IAAIrU,OAAOqd,IAC3Cpf,EAAOqW,QAAUrW,EAAOqW,QAAU,IAAItU,OAAOsd,IAC7Crf,EAAOsW,SAAWtW,EAAOsW,SAAW,IAAIvU,OAAOud,IACxCtf,4QCSJ,MAAMwf,GAAwC,CACjDja,KAAM,QACNJ,MAAO,SACPC,UAAW,aACXE,QAAS,WACTG,OAAQ,UACR5D,OAAQ,UAERsE,IAAK,OACLC,IAAK,OACLqZ,KAAM,QACNC,KAAM,QACNC,GAAI,MACJtK,KAAM,QAENrQ,IAAK,aACL4a,OAAQ,UACRlb,KAAM,QACNmb,MAAO,SAEPpb,GAAI,MACJqb,KAAM,QAENC,MAAO,SACPC,QAAS,YACTjb,MAAO,SACPkb,QAAS,YAET1hB,IAAK,OACL2hB,OAAQ,gBACRC,KAAM,cACNlb,IAAK,OACLpH,KAAM,QAENgM,IAAK,OACLuW,IAAK,OACLC,GAAI,MAEJ9Z,SAAU,aACV+Z,OAAQ,UACR9W,MAAO,SACP0V,MAAO,SAEPzR,SAAU,YAGD8S,GAAgC,CACzC/c,yBAAyB,EACzBgd,gBAAgB,EAChBjT,eAAe,EACfD,cAAc,EACd7L,cAAc,EACdsK,kBAAkB,EAClB4B,6BAA6B,EAC7B3E,4BAA4B,EAC5B8E,eAAe,EACf5H,mBAAmB,EACnBua,oBAAoB,EACpBxgB,aAAc,EAEd2B,cAAe4d,GACflJ,QAAS,GACTD,OAAQ,GACRD,MAAO,IAKX,SAASsK,GAAU1gB,EAAwB2gB,EAAc9V,EAAwCK,GAC7F,MAAO,CACHL,QAA4B,iBAAZA,EAAuB,CAACA,GAAWA,EACnDK,OAAQA,GAAU,GAElBP,MAAO,EACPC,IAAK,EACLF,KAAM,EAEN3K,UAAW,EAEXgD,OAAQ,CAAC,CAACI,cAAc,EAAOF,MAAO0d,IAEtC1e,SAAU,IAAIwG,IAAyBzI,EAAOqW,OAAOxR,IAAIvD,GAAK,CAACA,EAAErD,KAAMqD,KACvEsE,QAAS,IAAI6C,IAAwBzI,EAAOoW,MAAMvR,IAAIvD,GAAK,CAACA,EAAErD,KAAMqD,KACpEgC,UAAW,IAAImF,IAA0BzI,EAAOsW,QAAQzR,IAAIvD,GAAK,CAACA,EAAErD,KAAMqD,KAE1EtB,UAKR,SAAS4gB,GAAW9gB,EAAsB+K,EAAwCK,GAO9E,OANApL,EAAM+K,QAA6B,iBAAZA,EAAuB,CAACA,GAAWA,EAC1D/K,EAAMoL,OAASA,GAAU,GACzBpL,EAAM6K,MAAQ,EACd7K,EAAM8K,IAAM,EACZ9K,EAAM4K,KAAO,EACb5K,EAAMC,UAAY,EACXD,EAML,SAAU+gB,GAAYC,GACxB,IAAI9gB,EAAS8gB,GAAQ1iB,OAAOwF,OAAO,GAAI2c,IACnCnd,EAAmB,GACnB2d,EAAqB,GAEzB,MAAM5M,EAAO,CAACrU,EAAsBL,KAChC,GAAIO,EAAOwgB,eACP,IAAK,IAAI9iB,EAAI,EAAGA,EAAI+B,EAAEY,OAAQ3C,IAC1B+B,EAAE/B,GAAKU,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOL,EAAE/B,IAIjC,OAAIsC,EAAOygB,mBACa,IAAbhhB,EAAEY,OAAeZ,EAAE,GAAKA,EAExBA,EAAEA,EAAEY,OAAS,IAItB8e,EAA4B,CAACtU,KAA2CK,KAC1E,MAAMpL,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GACzE,OAAOiJ,EAAKrU,EAAOihB,EAAQhf,OAAOgM,EAAMjO,MAgD5C,OA7CAqf,EAAE6B,YAAe5T,KACb,MAAMtN,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAc,IAChE,OAAO+Q,EAAKrU,EAAOihB,EAAQhf,OAAOqL,MAErC+R,EAAU8B,KAAO,MACd,MAAMnhB,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAc,IAChE+Q,EAAKrU,EAAOihB,EAAQjf,MAAM,IAC1B,MAAMof,EAAgC,CAACrW,KAA2CK,KAC9E0V,GAAW9gB,EAAO+K,EAASK,GACpBiJ,EAAKrU,EAAOiO,EAAMjO,KAG7B,OADCohB,EAAcC,KAAOD,EACfA,IAEX/B,EAAEiC,WAAcT,KACZvd,EAAchF,OAAOwF,OAAO,GAAI+c,GAAW,IACpCxB,IAEXA,EAAEkC,cAAiBV,KACfvd,EAAchF,OAAOwF,OAAO,GAAIR,EAAaud,GAAW,IACjDxB,IAEXA,EAAEmC,WAAa,EAACzW,KAA2CK,KACvD,MAAMpL,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GAEzE,OADA6V,EAAUhT,EAAMjO,GACTqf,IAEXA,EAAEoC,cAAiBnU,KACf2T,EAAU3T,EACH+R,IAEXA,EAAEqC,cAAgB,EAAC3W,KAA2CK,KAC1D,MAAMpL,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GAEzE,OADA6V,EAAUA,EAAQhf,OAAOgM,EAAMjO,IACxBqf,IAEXA,EAAEsC,iBAAoBrU,KAClB2T,EAAUA,EAAQhf,OAAOqL,GAClB+R,IAEXA,EAAEhJ,QAAWuL,KACT1hB,EAAS0hB,EAAU1hB,GACZmf,IAGJA,EAIL,SAAUwC,GAAiBb,GAC7B,IAAI9gB,EAAS8gB,GAAQ1iB,OAAOwF,OAAO,GAAI2c,IACnCnd,EAAmB,GACnB2d,EAAqB,GAEzB,MAAM5M,EAAO,CAAOrU,EAAsBL,IAAgBmiB,GAAAlJ,UAAA,qBACtD,GAAI1Y,EAAOwgB,eACP,IAAK,IAAI9iB,EAAI,EAAGA,EAAI+B,EAAEY,OAAQ3C,IAC1B+B,EAAE/B,GAAKU,OAAA+C,EAAA,EAAA/C,CAAS0B,EAAOL,EAAE/B,IAEL,iBAAT+B,EAAE/B,IAA4B,OAAT+B,EAAE/B,IAA6C,mBAAtB+B,EAAE/B,GAAWkgB,OAClEne,EAAE/B,SAAW+B,EAAE/B,IAK3B,OAAIsC,EAAOygB,mBACa,IAAbhhB,EAAEY,OAAeZ,EAAE,GAAKA,EAExBA,EAAEA,EAAEY,OAAS,KAItB8e,EAAiC,CAAOtU,KAA2CK,IAAiB0W,GAAAlJ,UAAA,qBACtG,MAAM5Y,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GACzE,OAAOiJ,EAAKrU,EAAOihB,EAAQhf,OAAOgM,EAAMjO,OAiE5C,OA9DAqf,EAAE6B,YAAe5T,KACb,MAAMtN,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAc,IAChE,OAAO+Q,EAAKrU,EAAOihB,EAAQhf,OAAOqL,MAErC+R,EAAU8B,KAAO,MACd,MAaMnhB,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAc,IAChE+Q,EAAKrU,EAAOihB,EAAQjf,MAAM,IAC1B,MAAMof,EAAqC,CAAOrW,KAA2CK,IAAiB0W,GAAAlJ,UAAA,qBAE1G,OADAkI,GAAW9gB,EAAO+K,EAASK,GACpBiJ,EAAKrU,EAAOiO,EAAMjO,MAO7B,OADCohB,EAAcC,KAJ2B,EAACtW,KAA2CK,KAClF0V,GAAW9gB,EAAO+K,EAASK,GApBd,EAAC2W,EAAqBpiB,KACnC,GAAIO,EAAOwgB,eACP,IAAK,IAAI9iB,EAAI,EAAGA,EAAI+B,EAAEY,OAAQ3C,IAC1B+B,EAAE/B,GAAKU,OAAA+C,EAAA,EAAA/C,CAASyjB,EAAMpiB,EAAE/B,IAIhC,OAAIsC,EAAOygB,mBACa,IAAbhhB,EAAEY,OAAeZ,EAAE,GAAKA,EAExBA,EAAEA,EAAEY,OAAS,IAWjByhB,CAAShiB,EAAOiO,EAAMjO,MAG1BohB,IAEX/B,EAAEiC,WAAcT,KACZvd,EAAchF,OAAOwF,OAAO,GAAI+c,GAAW,IACpCxB,IAEXA,EAAEkC,cAAiBV,KACfvd,EAAchF,OAAOwF,OAAO,GAAIR,EAAaud,GAAW,IACjDxB,IAEXA,EAAEmC,WAAa,EAACzW,KAA2CK,KACvD,MAAMpL,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GAEzE,OADA6V,EAAUhT,EAAMjO,GACTqf,IAEXA,EAAEoC,cAAiBnU,KACf2T,EAAU3T,EACH+R,IAEXA,EAAEqC,cAAgB,EAAC3W,KAA2CK,KAC1D,MAAMpL,EAAQ4gB,GAAU1gB,EAAQ5B,OAAOwF,OAAO,GAAIR,GAAcyH,EAASK,GAEzE,OADA6V,EAAUA,EAAQhf,OAAOgM,EAAMjO,IACxBqf,IAEXA,EAAEsC,iBAAoBrU,KAClB2T,EAAUA,EAAQhf,OAAOqL,GAClB+R,IAEXA,EAAEhJ,QAAWuL,KACT1hB,EAAS0hB,EAAU1hB,GACZmf,IAGJA,EAKJ,MAAM4C,GAAI,MACb,MAAM/hB,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAKjD,OAHAvgB,EAAOwgB,gBAAiB,EACxBxgB,EAAOygB,oBAAqB,EAErBI,GAAY7gB,IANN,GAWJgiB,GAAI,MACb,IAAIhiB,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAY/C,OAXAvgB,EAAO4B,cAAgBxD,OAAOwF,OAAO,GAAI5D,EAAO4B,cAAe,CAC3D6L,SAAU,aAMdzN,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,OAKd8N,eAAgB,EAEhB+S,GAAY7gB,IAbN,GAgBJiiB,GAAKD,GACLE,GAAOF,GAKPG,GAAU,MACnB,IAAIniB,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAY/C,OAXAvgB,EAAO4B,cAAgBxD,OAAOwF,OAAO,GAAI5D,EAAO4B,cAAe,CAC3D6L,SAAU,aAMdzN,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,OAKd8N,eAAgB,EAEhB6T,GAAiB3hB,IAbL,GAiBVoiB,GAAWD,GAEXE,GAAaF,GAIbG,GAAK,MACd,IAAItiB,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAa/C,OAZAvgB,EAAO4B,cAAgBxD,OAAOwF,OAAO,GAAI5D,EAAO4B,cAAe,CAC3D6L,SAAU,aAMdzN,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,OAKd8N,eAAgB,EACvB9N,EAAOygB,oBAAqB,EAErBI,GAAY7gB,IAdL,GAoBLuiB,GAAW,MACpB,IAAIviB,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAa/C,OAZAvgB,EAAO4B,cAAgBxD,OAAOwF,OAAO,GAAI5D,EAAO4B,cAAe,CAC3D6L,SAAU,aAMdzN,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,OAKd8N,eAAgB,EACvB9N,EAAOygB,oBAAqB,EAErBkB,GAAiB3hB,IAdJ,GAmBlB,SAAUwiB,GAAiBlF,GAC7B,IAAItd,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAU/C,OAJAvgB,EAASqd,GADTrd,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,MAIOsd,IAErBxP,eAAgB,EAEhB+S,GAAY7gB,GAKjB,SAAUyiB,GAAuBnF,GACnC,IAAItd,EAAyB5B,OAAOwF,OAAO,GAAI2c,IAU/C,OAJAvgB,EAASqd,GADTrd,EAASuf,GADTvf,EAASgc,GADThc,EAASuY,GADTvY,EAASmW,GAAYnW,MAIOsd,IAErBxP,eAAgB,EAEhB6T,GAAiB3hB,GCxZtB,SAAU0iB,GAAcR,EAA0DvB,EAAkBgC,EAAc,aACpH,MAAMC,EAAQC,SAASC,iCAAiCH,OAClDrG,EAAK,GACX,IAAK,IAAI5e,EAAI,EAAGA,EAAIklB,EAAMviB,OAAQ3C,IAC9B4e,EAAGzY,KAAK+e,EAAMllB,GAAGqlB,WAGrB,OADAb,EAAOA,EAAKb,cAAcV,GAAW,KACzBrE,EAAG/T,KAAK,OCjBxB/K,EAAAQ,EAAA0B,EAAA,qCAAAsjB,KAAAxlB,EAAAQ,EAAA0B,EAAA,kCAAAujB,KAAAzlB,EAAAQ,EAAA0B,EAAA,mCAAAwjB,KAAA1lB,EAAAQ,EAAA0B,EAAA,yCAAA8f,KAAAhiB,EAAAQ,EAAA0B,EAAA,kCAAA6gB,KAAA/iB,EAAAQ,EAAA0B,EAAA,gCAAAmhB,KAAArjB,EAAAQ,EAAA0B,EAAA,qCAAAiiB,KAAAnkB,EAAAQ,EAAA0B,EAAA,sBAAAqiB,KAAAvkB,EAAAQ,EAAA0B,EAAA,sBAAAsiB,KAAAxkB,EAAAQ,EAAA0B,EAAA,uBAAAuiB,KAAAzkB,EAAAQ,EAAA0B,EAAA,yBAAAwiB,KAAA1kB,EAAAQ,EAAA0B,EAAA,4BAAAyiB,KAAA3kB,EAAAQ,EAAA0B,EAAA,6BAAA0iB,KAAA5kB,EAAAQ,EAAA0B,EAAA,+BAAA2iB,KAAA7kB,EAAAQ,EAAA0B,EAAA,uBAAA4iB,KAAA9kB,EAAAQ,EAAA0B,EAAA,6BAAA6iB,KAAA/kB,EAAAQ,EAAA0B,EAAA,wBAAA8iB,KAAAhlB,EAAAQ,EAAA0B,EAAA,8BAAA+iB,KAAAjlB,EAAAQ,EAAA0B,EAAA,kCAAAgjB,KAAAllB,EAAAQ,EAAA0B,EAAA,gCAAAyW,KAAA3Y,EAAAQ,EAAA0B,EAAA,sCAAA6Y,KAAA/a,EAAAQ,EAAA0B,EAAA,oCAAAsc,KAAAxe,EAAAQ,EAAA0B,EAAA,+BAAA2d,KAAA7f,EAAAQ,EAAA0B,EAAA,sCAAA6f,KAqCO,MAAMyD,GAAmB,CAC5BG,KAAMnO,GACNoO,WAAYhL,GACZiL,SAAU3H,GACVqB,IAAKG,GACLoG,WAAYlE,IAGH6D,GAAgB,CACzBE,KAAMzN,GACN0N,WAAY/K,GACZgL,SAAUvH,GACViB,IAAKI,GACLmG,WAAYjE,IAGH6D,GAAiB,CAC1BC,KAAMxN,GACNyN,WAAY9K,GACZ+K,SAAUtH,GACVgB,IAAKK,GACLkG,WAAYhE","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         CapturedScopes,\r\n         SxMacroInfo }        from './types';\r\nimport { isSymbol }           from './ast';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveUnquote(state: SxParserState, r: SxToken[]) {\r\n    for (let i = 0; i < r.length; i++) {\r\n        const symUnquote = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.unquote);\r\n        if (symUnquote) {\r\n            r = r.slice(0, i).concat([evaluate(state, (r[i] as SxToken[])[1])], r.slice(i + 1));\r\n        }\r\n        if (Array.isArray(r[i])) {\r\n            r = r.slice(0);\r\n            r[i] = resolveUnquote(state, r[i] as SxToken[]);\r\n        }\r\n    }\r\n    return resolveSplice(state, r);\r\n}\r\n\r\n\r\nexport function resolveSplice(state: SxParserState, r: SxToken[]) {\r\n    if (state.config.enableSplice) {\r\n        for (let i = r.length - 1; i >= 0; i--) {\r\n            const symSplice = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.splice);\r\n            if (symSplice) {\r\n                r = r.slice(0, i).concat((r[i] as SxToken[])[1], r.slice(i + 1));\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol, r: SxToken[]) {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    let lastErr = null;\r\n    if (macroInfo) {\r\n        let m: SxMacroInfo | undefined = macroInfo;\r\n        const r1 = r.slice(1);\r\n        while (m) {\r\n            if (m.formalArgs) {\r\n                const matchResult = matchMacroArgs(state, x.symbol, m.formalArgs, Boolean(m.lastIsSpread), r1);\r\n                if (! matchResult.error) {\r\n                    return {\r\n                        fn: m.fn(state, x.symbol, matchResult.formalArgs as SxSymbol[]),\r\n                        actualArgs: r.slice(0, 1).concat(matchResult.actualArgs as SxToken[]),\r\n                    };\r\n                }\r\n                lastErr = matchResult.error;\r\n                m = m.next;\r\n            } else {\r\n                return {\r\n                    fn: m.fn(state, x.symbol),\r\n                    actualArgs: r,\r\n                };\r\n            }\r\n        }\r\n        if (lastErr) {\r\n            throw new Error(lastErr);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (localScope.capturedScopes &&\r\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\r\n            return localScope.capturedScopes[x.symbol];\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\r\n    const capturedScopes: CapturedScopes = {};\r\n    for (const n of names) {\r\n        const scope = resolveValueSymbolScope(state, n, true);\r\n        if (scope === null) {\r\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\r\n        }\r\n        capturedScopes[n.symbol] = scope;\r\n    }\r\n    return capturedScopes;\r\n}\r\n\r\n\r\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\r\n    const a: CapturedScopes[] = [];\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope.capturedScopes) {\r\n            a.unshift(localScope.capturedScopes);\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\r\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function matchMacroArgs(\r\n        state: SxParserState, macroName: string,\r\n        formalArgs: SxSymbol[], lastIsSpread: boolean, actualArgs: SxToken[]) {\r\n\r\n    formalArgs = formalArgs.slice(0);\r\n    actualArgs = actualArgs.slice(0);\r\n    if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n        return ({ error: `[SX] macro call (${macroName}): Actual args too short: actual ${\r\n            actualArgs.length} / formal ${formalArgs.length}.` });\r\n    }\r\n    for (let i = formalArgs.length - (lastIsSpread ? 2 : 1); i >= 0; i--) {\r\n        let nm = formalArgs[i].symbol;\r\n        if (nm.startsWith('!')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (! isSymbol(actualArgs[i])) {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n            }\r\n        } else if (nm.startsWith('<') && nm.endsWith('>')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1, -1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (isSymbol(actualArgs[i], nm)) {\r\n                formalArgs = formalArgs.slice(0, i).concat(formalArgs.slice(i + 1));\r\n                actualArgs = actualArgs.slice(0, i).concat(actualArgs.slice(i + 1));\r\n            } else {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not expected symbol.` });\r\n            }\r\n        } else {\r\n            const tpos = nm.lastIndexOf(':');\r\n            if (0 < tpos) {\r\n                const tname = nm.slice(tpos + 1);\r\n                switch (tname) {\r\n                case 'number':\r\n                    if (typeof actualArgs[i] !== 'number') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not number.` });\r\n                    }\r\n                    break;\r\n                case 'string':\r\n                    if (typeof actualArgs[i] !== 'string') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not string.` });\r\n                    }\r\n                    break;\r\n                case 'function':\r\n                    if (! (Array.isArray(actualArgs[i]) && isSymbol((actualArgs[i] as any)[0]))) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not function.` });\r\n                    }\r\n                    break;\r\n                case 'list':\r\n                    if (! Array.isArray(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not list.` });\r\n                    }\r\n                    break;\r\n                case 'symbol':\r\n                    if (! isSymbol(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n                    }\r\n                    break;\r\n                case 'any':\r\n                    break;\r\n                default:\r\n                    return ({ error: `[SX] macro call (${macroName}): Formal arg(${i}: ${nm}) is unknown type ${tname}.` });\r\n                }\r\n                formalArgs[i].symbol = formalArgs[i].symbol.slice(0, tpos);\r\n            }\r\n        }\r\n    }\r\n    return ({ formalArgs, actualArgs });\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && (typeof tail[0] === 'object') && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (Array.isArray(tail[3]) && (typeof tail[3][0] === 'object') && tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (                                 ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail[4] ... [N+4]\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (                                                                  ;; fnBody\r\n                //         ($until cond                                                   ;; tail[1]\r\n                //             ($clisp-let (tempsym1 ... tempsymN)                        ;;\r\n                //                 expr1 ... exprN-1                                      ;; front\r\n                //                 ($set tempsym1   rArgs1) ... ($set tempsymN   rArgsN)  ;; tail[4] ... [N+4]\r\n                //                 ($set     sym1 tempsym1) ... ($set     symN tempsymN)  ;;\r\n                //             )                                                          ;;\r\n                //         )                                                              ;;\r\n                //         expr1 ... exprN-1                                              ;; front\r\n                //         t-expr                                                         ;; tail[2]\r\n                //     )\r\n\r\n                const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n                const tempVarsSyms = formalArgs.map((a, idx) => ({symbol: `${varBaseName}_$i${idx}_${a.symbol}`}));\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        [{symbol: state.config.reservedNames.let}, [...tempVarsSyms],\r\n                            ...front,\r\n                            ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, tempVarsSyms[idx], x])),\r\n                            ...(tempVarsSyms.map((x, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, formalArgs[idx], x])),\r\n                        ],\r\n                    ],\r\n                    ...front,\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.backquote) {\r\n                    r = r.slice(1, 2)[0];\r\n                    if (Array.isArray(r)) {\r\n                        r = resolveUnquote(state, r);\r\n                    }\r\n                    return r;\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, evaluate(state, r.slice(1, 2)[0]));\r\n                }\r\n            }\r\n\r\n            const sprs = [];\r\n            for (let i = 1; i < r.length; i++) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    sprs.push(i);\r\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    r[i] = Array.isArray(a) ? a : [a];\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n            for (const i of sprs.reverse()) {\r\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol }     from './types';\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function backquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.backquote}, x];\r\n}\r\n\r\n\r\nexport function isBackquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.backquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function wrapByUnquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.unquote}, x];\r\n}\r\n\r\n\r\nexport function isUnquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.unquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function splice(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.splice}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken }            from '../types';\r\nimport { isSymbol }           from '../ast';\r\nimport { resolveSplice,\r\n         resolveMacro,\r\n         resolveValueSymbol,\r\n         getScope }           from '../evaluate';\r\nimport { setEvaluationCount } from '../errors';\r\n\r\n\r\n\r\nexport function applyMacros(state: SxParserState, tok: SxToken) {\r\n    let r: SxToken = tok;\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                break;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function stripQuote(state: SxParserState, tok: SxToken) {\r\n    if (! (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote))) {\r\n        throw new Error(`[SX] stripQuote: token is not quoted.`);\r\n    }\r\n    return (tok as any)[1];\r\n}\r\n\r\n\r\nexport function stripQuoteOrPass(state: SxParserState, tok: SxToken) {\r\n    if (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote)) {\r\n        return (tok as any)[1];\r\n    } else {\r\n        return tok;\r\n    }\r\n}\r\n\r\n\r\nexport function getScope_stateApplied(state: SxParserState) {\r\n    return (function() { return getScope(state); });\r\n}\r\n\r\n\r\nexport function resolveValueSymbol_dynamic(state: SxParserState, name: string) {\r\n    return (function(){ return resolveValueSymbol(state, {symbol: name}); });\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string, formalArgs?: SxSymbol[]) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n\r\n    formalArgs?: SxSymbol[];\r\n    lastIsSpread?: boolean;\r\n    next?: SxMacroInfo;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n\r\n    // TODO: overloading\r\n    // formalArgs?: SxSymbol[];\r\n    // lastIsSpread?: boolean;\r\n    // next?: SxFuncInfo;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;           // { [s: string]: any; };\r\n    capturedScopes?: CapturedScopes;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    backquote: string;\r\n    unquote: string;\r\n    spread: string;\r\n    splice: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n    call: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    isSymbol: string;\r\n    gensym: string;\r\n    raise: string;\r\n    catch: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableSplice: boolean;\r\n    enableShorthands: boolean;\r\n    enableVerbatimStringLiteral: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n\r\n    // TODO: debug info\r\n    // _fileName?: string;\r\n    // _line?: number;\r\n    // _col?: number;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\n\r\nexport type CompilerOperator = (r: SxToken[], args: SxToken[]) => string;\r\n\r\n\r\nexport interface CompilerContext {\r\n    _$_vars: any[];\r\n    varsCount: number;\r\n    varNames: Map<string, string>;\r\n    varNamesCount: number;\r\n    varDefs: string;\r\n    ops: Map<string, CompilerOperator>;\r\n    makeScope: (scoped: () => void) => void;\r\n    compileToken: (body: any[], i: number) => string;\r\n}\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n\r\n\r\nexport interface SExpressionRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n}\r\n\r\n\r\nexport interface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => SExpressionRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => SExpressionAsyncRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         SxFuncInfo,\r\n         CompilerOperator,\r\n         CompilerContext  }           from './types';\r\nimport { isSymbol }                   from './ast';\r\nimport { getCapturedScopes,\r\n         optimizeTailCall }           from './evaluate';\r\nimport { applyMacros,\r\n         stripQuoteOrPass,\r\n         resolveValueSymbol_dynamic } from './compile.ops/helpers';\r\nimport { registerOperators }          from './compile.ops';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction compileCore(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[], _$_vars: any[]) {\r\n\r\n    function makeScope(scoped: () => void) {\r\n        const varNamesCopy = new Map<string, string>();\r\n        for (const x of ctx.varNames.entries()) {\r\n            varNamesCopy.set(x[0], x[1]);\r\n        }\r\n        scoped();\r\n        ctx.varNames = varNamesCopy;\r\n    }\r\n\r\n\r\n    function compileValue(b: any) {\r\n        let compFnBody = '';\r\n        if (b === null) {\r\n            compFnBody += '(null)';\r\n        } else if (b === void 0) {\r\n            compFnBody += '(void 0)';\r\n        } else switch (typeof b) {\r\n        case 'boolean': case 'number':\r\n            compFnBody += `(${String(b)})`;\r\n            break;\r\n        case 'object':\r\n            if (isSymbol(b)) {\r\n                const sym = b as SxSymbol;\r\n                if (ctx.varNames.has(sym.symbol)) {\r\n                    compFnBody += `(${ctx.varNames.get(sym.symbol)})`;\r\n                } else {\r\n                    _$_vars[ctx.varsCount] = sym.symbol;\r\n                    compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n                }\r\n                break;\r\n            } else {}\r\n            // FALL_THRU\r\n        default:\r\n            _$_vars[ctx.varsCount] = b;\r\n            compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n            break;\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    function compileToken(body: any[], i: number) {\r\n        let compFnBody = '';\r\n        const b = body[i];\r\n        if (Array.isArray(b)) {\r\n            if (0 < b.length) {\r\n                const r: SxToken = applyMacros(state, b);\r\n                if (Array.isArray(r)) {\r\n                    if (0 < r.length) {\r\n                        if (isSymbol(r[0])) {\r\n                            const sym = r[0] as SxSymbol;\r\n                            const args = r.slice(1);\r\n                            if (ops.has(sym.symbol)) {\r\n                                compFnBody += (ops.get(sym.symbol) as CompilerOperator)(r, args);\r\n                            } else {\r\n                                if (sym.symbol === state.config.reservedNames.spread) {\r\n                                    compFnBody += `...(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else if (state.funcMap.has(sym.symbol)) {\r\n                                    _$_vars[ctx.varsCount] = (state.funcMap.get(sym.symbol) as SxFuncInfo).fn(state, '');\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                } else if (ctx.varNames.has(sym.symbol)) {\r\n                                    compFnBody += `(${String(ctx.varNames.get(sym.symbol))})(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else {\r\n                                    _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, sym.symbol);\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])()(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            switch (typeof r[0]) {\r\n                            case 'function':\r\n                                _$_vars[ctx.varsCount] = r[0];\r\n                                compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                    r.slice(1).map((x, idx, arr) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                break;\r\n                            default:\r\n                                throw new Error(`[SX] compileToken: First item of list is not a function: ${JSON.stringify(r[0])}.`);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        compFnBody += '([])';\r\n                    }\r\n                } else {\r\n                    compFnBody += compileValue(b);\r\n                }\r\n            } else {\r\n                compFnBody += '([])';\r\n            }\r\n        } else {\r\n            compFnBody += compileValue(b);\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    const ctx: CompilerContext = {\r\n        _$_vars,\r\n        varsCount: 1,\r\n        varNames: new Map<string, string>(),\r\n        varNamesCount: 0,\r\n        varDefs: 'var x0;',\r\n        ops: new Map<string, CompilerOperator>(),\r\n        makeScope,\r\n        compileToken,\r\n    };\r\n\r\n    registerOperators(state, ctx);\r\n    const ops = ctx.ops;\r\n\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n    if (capturedScopes) {\r\n        for (const x in capturedScopes) {\r\n            if (Object.hasOwnProperty.call(capturedScopes, x)) {\r\n                _$_vars[ctx.varsCount++] = x;\r\n                _$_vars[ctx.varsCount] = capturedScopes[x];\r\n                ctx.varNames.set(x, `(_$_vars[${String(ctx.varsCount)}][_$_vars[${String(ctx.varsCount - 1)}]])`);\r\n                ctx.varsCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    const compFormalArgs = `${formalArgs.map((x, i) => {\r\n        ctx.varNames.set(formalArgs[i].symbol, 'a' + i);\r\n        return `${(lastIsSpread && i === formalArgs.length - 1) ? '...' : ''}a${i}`;\r\n    }).join(',')}`;\r\n\r\n    const compFnBodyRoot = `return(${fnBody.map((x, i) => compileToken(fnBody, i)).join(',')})`;\r\n    return `(function(${compFormalArgs}){\"strict\";${ctx.varDefs}${compFnBodyRoot}})`;\r\n}\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction evalCompiledLambda(_$_state: SxParserState, _$_vars: any[], code: string) {\r\n    // tslint:disable-next-line:no-eval\r\n    _$_vars[0] = eval(code);\r\n    return _$_vars[0];\r\n}\r\n\r\n\r\nexport function compileLambda(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[]) {\r\n    // tslint:disable-next-line:variable-name\r\n    const _$_vars: any[] = [];\r\n    return evalCompiledLambda(state, _$_vars, compileCore(state, formalArgs, lastIsSpread, fnBody, _$_vars));\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         CompilerContext }            from '../types';\r\nimport { isSymbol }                   from '../ast';\r\nimport { checkParamsLength }          from '../errors';\r\nimport { stripQuote,\r\n         stripQuoteOrPass,\r\n         getScope_stateApplied,\r\n         resolveValueSymbol_dynamic } from './helpers';\r\n\r\n\r\n\r\nexport function registerOperators(state: SxParserState, ctx: CompilerContext) {\r\n    const {\r\n        _$_vars,\r\n        ops,\r\n        makeScope,\r\n        compileToken,\r\n    } = ctx;\r\n\r\n\r\n    ops.set(state.config.reservedNames.quote, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        _$_vars[ctx.varsCount] = r[1];\r\n        compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.self, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        compFnBody += `((_$_vars[0])(${\r\n            args.map(x => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if condition 't-expr 'f-expr)\r\n        //  -> (if condition is true ) S expr  : t-expr\r\n        //  -> (if condition is false) S expr  : f-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if', args, 2, 3);\r\n        compFnBody += `(${compileToken(r, 1)}?(${\r\n            compileToken([stripQuote(state, r[2])], 0)}):(${\r\n            compileToken([stripQuote(state, r[3])], 0)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if-null', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if-null condition 'null-expr)\r\n        //  -> (if condition is not null ) S expr  : condition\r\n        //  -> (if condition is null)      S expr  : null-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if-null', args, 2, 2);\r\n        compFnBody += `((()=>{let _$_rv=${compileToken(r, 1)};return _$_rv?_$_rv:(${\r\n            compileToken([stripQuote(state, r[2])], 0)}});})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__cond', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        //  -> (if (eval condI) is true ) S expr  : exprI\r\n        //  -> (if no matched)            S expr  : null\r\n        let compFnBody = '';\r\n        {\r\n            checkParamsLength('compileToken:$__cond', args, 1);\r\n            compFnBody += `(`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `${compileToken([stripQuote(state, args[p])], 0)}?(${\r\n                    compileToken([stripQuote(state, args[p + 1])], 0)}):(`;\r\n            }\r\n            compFnBody += `null`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `)`;\r\n            }\r\n            compFnBody += `)`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__while', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__repeat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n        //  -> (if n > 0) S expr  : exprN\r\n        //  -> (else)     S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__repeat', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__repeat : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_n)=>{let _$_rv=null;for(let ${name}=0;${name}<_$_n;${name}++){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__for', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n        //  -> (if list.length > 0) S expr  : exprN\r\n        //  -> (else)               S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__for', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__for : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_l)=>{let _$_rv=null;for(const ${name} of _$_l){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__scope', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n        //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n        //  -> (else)               S expr  : exprN\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__scope', args, 2);\r\n        // r[1]: isBlockLocal\r\n        // r[2]: returnMultiple\r\n        if (! Array.isArray(r[3])) {\r\n            throw new Error(`[SX] compileToken: $__scope : args[2] is not array.`);\r\n        }\r\n        makeScope(() => {\r\n            for (const x of stripQuote(state, r[3]) as any[]) {\r\n                let name = '';\r\n                if (Array.isArray(x)) {\r\n                    if (x.length < 1) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is too short.`);\r\n                    }\r\n                    if (! isSymbol(x[0])) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?][0] is not symbol.`);\r\n                    }\r\n                    name = x[0].symbol;\r\n                    compFnBody += `(${'v' + ctx.varNamesCount}=${compileToken(x, 1)})`;\r\n                } else {\r\n                    if (! isSymbol(x)) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is not symbol.`);\r\n                    }\r\n                    name = x.symbol;\r\n                }\r\n                ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n                ctx.varNames.set(x.symbol, 'v' + ctx.varNamesCount++);\r\n            }\r\n            const s = `${r.slice(4).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}`;\r\n            compFnBody += r[2] ? `[${s}]` : `(${s})`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__try', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__try 'expr 'catch-expr)\r\n        //  ->                               S expr  : expr\r\n        //  -> (if error is raised in expr)  S expr  : catch-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__try', args, 1, 2);\r\n        compFnBody += `((()=>{try{${\r\n            compileToken([stripQuote(state, r[1])], 0)}}catch(e${\r\n            ctx.varNamesCount}){let e${ctx.varNamesCount + 1}=(_$_vars[${String(ctx.varsCount)}])();`;\r\n        _$_vars[ctx.varsCount++] = getScope_stateApplied(state);\r\n        makeScope(() => {\r\n            ctx.varNames.set('$error', 'e' + ctx.varNamesCount++);\r\n            ctx.varNames.set('$parent', 'e' + ctx.varNamesCount++);\r\n            compFnBody += `${\r\n                compileToken([stripQuote(state, r[2])], 0)}}})())`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.raise, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($raise 'expr)\r\n        //  -> S expr  : -\r\n        let compFnBody = '';\r\n        compFnBody += `((()=>{throw ${\r\n            compileToken([stripQuoteOrPass(state, r[1])], 0)}})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$boolean', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($boolean any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$boolean', args, 1, 1);\r\n        compFnBody += `((x0=${compileToken(args, 0)\r\n            }),(Array.isArray(x0)&&x0.length===0?false:boolean(x0)))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__get', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__get', args, 1);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__get : operand is not symbol: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = symName;\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        compFnBody += `((${vName})${r.slice(2).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                compileToken(arr, idx)}]`).join('')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__let', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__let 'nameStrOrSymbol expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__let', args, 2, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__let : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        if (! ctx.varNames.has(name)) {\r\n            ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n            ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\r\n        }\r\n        compFnBody += `(${ctx.varNames.get(name)}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__set', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__set', args, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ?\r\n            quoted.symbol :\r\n            (typeof quoted === 'string' ?\r\n                quoted :\r\n                (Array.isArray(quoted) ?\r\n                    (isSymbol(quoted[0]) ?\r\n                        quoted[0].symbol :\r\n                        (typeof quoted[0] === 'string' ? quoted[0] : null)\r\n                    ) :\r\n                    null\r\n                )\r\n            );\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__set : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = symName;\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        compFnBody += `((${vName})${(Array.isArray(quoted) ? quoted.slice(1) : []).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                compileToken(arr, idx)}]`).join('')}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.not, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$not', args, 1, 1);\r\n        compFnBody += `(!${compileToken(args, 0)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__and 'expr1 ... 'exprN)\r\n        //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n        //  -> (else)                                                     S expr  : expr-i (false left most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__and', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('&&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__or 'expr1 ... 'exprN)\r\n        //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n        //  -> (else)                                                  S expr  : expr-i (false right most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__or', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('||')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('===', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($eq arg1 arg2)\r\n        //  -> (if arg1 === arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:===', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('===')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not-eq arg1 arg2)\r\n        //  -> (if arg1 !== arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (== a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (!= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (< a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (> a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$concat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($concat listOrString1 ... listOrStringN)\r\n        //  -> S expr  : listOrString\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$concat', args, 1);\r\n        let w1 = '';\r\n        if (Array.isArray(args[0]) && isSymbol((args[0] as any)[0], state.config.reservedNames.spread)) {\r\n            const w0 = compileToken(args[0] as any, 1);\r\n            w1 = `(${w0}[0]).concat((${w0}.length>1?${w0}[1]:(typeof ${w0}[0]==='string'?'':[])),`;\r\n        } else {\r\n            w1 = `${compileToken(args as any, 0)}.concat(`;\r\n        }\r\n        compFnBody += `(${w1}${\r\n            args.slice(1).map((x, idx, arr) => compileToken(arr, idx)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('+', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (+ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:+', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n            };return _$_rv.reduce((x,y)=>x+y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('+')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('-', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (- number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:-', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return (_$_rv.length>1?(_$_rv.reduce((x,y)=>x-y)):(_$_rv.length>0?-_$_rv[0]:NaN));})())`;\r\n        } else {\r\n            compFnBody += `(${r.length > 2 ?\r\n                args.map((x, idx, arr) => compileToken(arr, idx)).join('-') :\r\n                `-(${String(compileToken(r, 1))})`})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('*', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (* number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:*', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x*y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('*')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('**', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (** number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:**', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x**y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('**')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('/', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (/ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:/', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x/y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('/')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('%', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (% number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:%', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x%y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('%')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<< number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-not', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-not number)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-not', args, 1, 1);\r\n        compFnBody += `(~(${compileToken(r, 1)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-and numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-and', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-or numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-or', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('|')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-xor', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-xor numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-xor', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('^')})`;\r\n        return compFnBody;\r\n    });\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         ScriptTerminationError } from './types';\r\nimport { quote,\r\n         backquote,\r\n         wrapByUnquote,\r\n         spread,\r\n         splice }                 from './ast';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if ((! disableEscape) && ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[], disableEscape?: boolean): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof, disableEscape));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof, disableEscape);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^0[XxOoBb][0-9]*$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|(0[XxOoBb][0-9]+)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (state.config.enableShorthands) {\r\n        let m: RegExpMatchArray | null = null;\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        if (m = s.match(/^::([^=:][^=]+)=$/)) {\r\n            // ::foo:bar:baz= -> ($splice ($set (foo bar baz)))\r\n            const ws = m[1].split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.set},\r\n                        ws\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^::([^@:][^@]+)@([^@:]+)$/)) {\r\n            // ::foo:bar@baz -> ($splice ($call ($get foo bar) baz))\r\n            const ws = m[1].split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.call},\r\n                        [{symbol: state.config.reservedNames.get}, ...ws],\r\n                        {symbol: m[2]},\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^::([^:].+)$/)) {\r\n            // ::foo:bar:baz -> ($get foo bar baz)\r\n            const ws = m[1].split(':');\r\n            const z = [{symbol: state.config.reservedNames.get}, ...ws];\r\n            return z as any;\r\n        }\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string,\r\n        disableEscape: boolean\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs, disableEscape);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs, disableEscape);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs, disableEscape);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs, disableEscape);\r\n        }\r\n\r\n        getChar(state, eofSeqs, disableEscape);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new ScriptTerminationError('parseStringOrComment');\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState, disableEscape: boolean): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')', disableEscape).strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner = parseStringOrComment(state, ['\"\"\"'], '%%%(', ')', false);\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')', false).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')', false).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\": case \"`\": case ',':\r\n            {\r\n                getChar(state);\r\n                const ahead = lookAhead(state);\r\n                let isSpliceUnquote = false;\r\n                if (ch === ',' && ahead === '@') {\r\n                    getChar(state);\r\n                    isSpliceUnquote = true;\r\n                }\r\n                skipWhitespaces(state);\r\n                const ret = (ch === \"'\" ?\r\n                        quote :\r\n                        (ch === \"`\" ? backquote : wrapByUnquote))\r\n                    (state, parseOneToken(state)\r\n                );\r\n                return (isSpliceUnquote ? splice(state, ret) : ret);\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state, false);\r\n                }\r\n            }\r\n\r\n        case '@':\r\n            if (state.config.enableVerbatimStringLiteral) {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '\"') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseString(state, true);\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\": case \"`\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push((ch === \"'\" ? quote : backquote)(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         FatalError,\r\n         CapturedScopes,\r\n         SxMacroInfo}         from '../../types';\r\nimport { isSymbol,\r\n         quote }              from '../../ast';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         collectCapturedVariables,\r\n         getCapturedScopes,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber,\r\n         matchMacroArgs }     from '../../evaluate';\r\nimport { compileLambda }      from '../../compile';\r\nimport { checkParamsLength }  from '../../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr = cdr.slice(0);\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    const scope: any = {};\r\n    if (Array.isArray(car)) {\r\n        for (const x of car) {\r\n            if (Array.isArray(x)) {\r\n                const kv = $$firstAndSecond(...x);\r\n                const kvSym = isSymbol(kv.car);\r\n                scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n            } else {\r\n                const xSym = isSymbol(x);\r\n                scope[xSym ? xSym.symbol : String(x)] = null;\r\n            }\r\n        }\r\n    }\r\n    installScope(state, scope, isBlockLocal, capturedScopes);\r\n\r\n    try {\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    installScope(state, getGlobalScope(state).scope, true);\r\n    try {\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : exprN\r\n    checkParamsLength('$__capture', args, 1);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let r: SxToken = null;\r\n\r\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\r\n    installScope(state, {}, true, capturedScopes);\r\n    try {\r\n        for (const x of args.slice(1)) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        // TODO: add type checking\r\n        // TODO: pass \"this\" to the $__scope variable.\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $$__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(1);\r\n    return compileLambda(state, formalArgs, lastIsSpread, fnBody);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $comp$__lambda(state, name)(...args.slice(1));\r\n\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($refun 'name)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__refun', args, 1, 1);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const info = state.funcMap.get(car.symbol);\r\n    if (!info) {\r\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\r\n    }\r\n    return info.fn(state, car.symbol);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defmacro = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defmacro', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const formalArgs: SxSymbol[] = args[1];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__defmacro: Invalid argument(s): args[1] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(2);\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = (fArgs: SxSymbol[]) => (...aArgs: any[]) => {\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(fArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === fArgs.length - 1) ?\r\n                        aArgs.slice(index) : aArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n\r\n    const m: SxMacroInfo = {\r\n        name: car.symbol,\r\n        fn: (st: SxParserState, nm: string, fArgs: SxSymbol[]) => (list: SxToken[]) => fn(fArgs)(...(list.slice(1))),\r\n        formalArgs,\r\n        lastIsSpread,\r\n    };\r\n    if (state.macroMap.has(car.symbol)) {\r\n        let curr = state.macroMap.get(car.symbol);\r\n        (curr as SxMacroInfo).next = m;\r\n        if (curr && curr.formalArgs) {\r\n            if (curr.formalArgs.length < formalArgs.length) {\r\n                state.macroMap.set(car.symbol, m);\r\n                m.next = curr;\r\n            } else {\r\n                let prev = curr;\r\n                curr = curr.next;\r\n                while (curr) {\r\n                    if (curr.formalArgs) {\r\n                        if (curr.formalArgs.length < formalArgs.length) {\r\n                            prev.next = m;\r\n                            m.next = curr;\r\n                            break;\r\n                        }\r\n                    }\r\n                    prev = curr;\r\n                    curr = curr.next;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        state.macroMap.set(car.symbol, m);\r\n    }\r\n    return fn;\r\n};\r\n\r\n\r\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($apply fn arg1 ... argN)\r\n    //  -> S expr  : fn'\r\n    checkParamsLength('$apply', args, 1);\r\n\r\n    const car: () => any = $$first(...args);\r\n    if (typeof car !== 'function') {\r\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\r\n    }\r\n\r\n    return (\r\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\r\n    );\r\n};\r\nexport const $$apply = $apply(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    return Function.prototype.apply.call(\r\n        car[sym ? sym.symbol : evaluate(state, cdr) as any],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $symbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($symbol)\r\n    // S expression: ($symbol name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$symbol', args, 1, 1);\r\n\r\n    if (typeof args[0] === 'string') {\r\n        return {symbol: args[0]};\r\n    } else {\r\n        throw new Error(`[SX] $symbol: Invalid argument(s): item(s) of args[0] is not string.`);\r\n    }\r\n};\r\nexport const $$symbol = $symbol(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__gensym = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__gensym)\r\n    // S expression: ($__gensym name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$__gensym', args, 0, 1);\r\n\r\n    const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n    const tempVarSym = ({symbol: `${varBaseName}_$gensym`});\r\n    if (args.length === 1) {\r\n        const a = isSymbol(args[0]);\r\n        if (a) {\r\n            $__let(state, '')(a, tempVarSym);\r\n        } else if (typeof args[0] === 'string') {\r\n            $__let(state, '')({symbol: args[0]}, tempVarSym);\r\n        } else {\r\n            throw new Error(`[SX] $__gensym: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n        }\r\n    }\r\n    return tempVarSym;\r\n};\r\n\r\n\r\nexport const $isSymbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-symbol x)\r\n    // S expression: ($is-symbol x name)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isSymbol', args, 1, 2);\r\n\r\n    if (args.length === 1) {\r\n        return (isSymbol(args[0]) ? true : false);\r\n    } else {\r\n        if (typeof args[1] === 'string') {\r\n            return (isSymbol(args[0], args[1]) ? true : false);\r\n        } else {\r\n            throw new Error(`[SX] $isSymbol: Invalid argument(s): item(s) of args[1] is not string.`);\r\n        }\r\n    }\r\n};\r\nexport const $$isSymbol = $isSymbol(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $now = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($now)\r\n    //  -> S expr  : number\r\n    return Date.now();\r\n};\r\nexport const $$now = $now(null as any, null as any);\r\n\r\n\r\nexport const $datetimeFromIso = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-from-iso str)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeFromIso', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    if (! /^(?:(?:-[0-9]{6,})|[0-9]{4,})-(?:[0-1][0-9])-(?:[0-3][0-9])(?:T(?:[0-2][0-9])(?:[:](?:[0-6][0-9])(?:[:](?:[0-6][0-9])(?:.[0-9]{1,})?)?)?(?:Z|[-+][0-9]{2}(?:[:]?[0-6][0-9])?)?)?$/.test(s)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime (pattern unmatched): ${s}.`);\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeFromIso = $datetimeFromIso(null as any, null as any);\r\n\r\n\r\nexport const $datetime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime year month1-12 day)\r\n    // S expression: ($datetime year month1-12 day hours)\r\n    // S expression: ($datetime year month1-12 day hours minutes)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetime', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n        s += 'Z';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetime: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetime = $datetime(null as any, null as any);\r\n\r\n\r\nexport const $datetimeLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-lc year month1-12 day)\r\n    // S expression: ($datetime-lc year month1-12 day hours)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeLc', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n    } else {\r\n        s += 'T00:00:00.000';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeLc: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeLc = $datetimeLc(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToIsoString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-iso-string number)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$datetimeToIsoString', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid datetime: ${n}.`);\r\n    }\r\n    return dt.toISOString();\r\n};\r\nexport const $$datetimeToIsoString = $datetimeToIsoString(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponents = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponents', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getUTCFullYear(),\r\n        dt.getUTCMonth() + 1,\r\n        dt.getUTCDate(),\r\n        dt.getUTCHours(),\r\n        dt.getUTCMinutes(),\r\n        dt.getUTCSeconds(),\r\n        dt.getUTCMilliseconds(),\r\n        0, // TZ\r\n        dt.getUTCDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponents = $datetimeToComponents(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponentsLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components-lc number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponentsLc', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getFullYear(),\r\n        dt.getMonth() + 1,\r\n        dt.getDate(),\r\n        dt.getHours(),\r\n        dt.getMinutes(),\r\n        dt.getSeconds(),\r\n        dt.getMilliseconds(),\r\n        -dt.getTimezoneOffset(), // time difference between local time and UTC time, in minutes.\r\n                                 // If your time zone is UTC+2:00, +120 will be returned.\r\n        dt.getDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponentsLc = $datetimeToComponentsLc(null as any, null as any);\r\n\r\n\r\nexport const $match = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($match pattern-str string)\r\n    // S expression: ($match pattern-str options-str string)\r\n    //  -> S expr  : array\r\n    checkParamsLength('$match', args, 2, 3);\r\n\r\n    if (args.length === 2) {\r\n        const m = new RegExp(args[0]);\r\n        return m.exec(args[1]);\r\n    } else {\r\n        const m = new RegExp(args[0], args[1]);\r\n        return m.exec(args[2]);\r\n    }\r\n};\r\nexport const $$match = $match(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n\r\n\r\nexport const $consoleTrace = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-trace expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.trace(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTrace = $consoleTrace(null as any, null as any);\r\n\r\n\r\nexport const $consoleTime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time)\r\n    // S expression: ($console-time label)\r\n    //  -> S expr  : null\r\n    console.time(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTime = $consoleTime(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeEnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-end)\r\n    // S expression: ($console-time-end label)\r\n    //  -> S expr  : null\r\n    console.timeEnd(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeEnd = $consoleTimeEnd(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-log label)\r\n    // S expression: ($console-time-log label value ... value)\r\n    //  -> S expr  : null\r\n    (console as any).timeLog(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeLog = $consoleTimeLog(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__capture',\r\n    fn: ops.$__capture,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$$__lambda',\r\n    fn: ops.$comp$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$$__defun',\r\n    fn: ops.$comp$__defun,\r\n}, {\r\n    name: '$__refun',\r\n    fn: ops.$__refun,\r\n}, {\r\n    name: '$__defmacro',\r\n    fn: ops.$__defmacro,\r\n}, {\r\n    name: '$apply',\r\n    fn: ops.$apply,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$symbol',\r\n    fn: ops.$symbol,\r\n}, {\r\n    name: '$__gensym',\r\n    fn: ops.$__gensym,\r\n}, {\r\n    name: '$is-symbol',\r\n    fn: ops.$isSymbol,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$now',\r\n    fn: ops.$now,\r\n}, {\r\n    name: '$datetime-from-iso',\r\n    fn: ops.$datetimeFromIso,\r\n}, {\r\n    name: '$datetime',\r\n    fn: ops.$datetime,\r\n}, {\r\n    name: '$datetime-lc',\r\n    fn: ops.$datetimeLc,\r\n}, {\r\n    name: '$datetime-to-iso-string',\r\n    fn: ops.$datetimeToIsoString,\r\n}, {\r\n    name: '$datetime-to-components',\r\n    fn: ops.$datetimeToComponents,\r\n}, {\r\n    name: '$datetime-to-components-lc',\r\n    fn: ops.$datetimeToComponentsLc,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$match',\r\n    fn: ops.$match,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}, {\r\n    name: '$console-trace',\r\n    fn: ops.$consoleTrace,\r\n}, {\r\n    name: '$console-time',\r\n    fn: ops.$consoleTime,\r\n}, {\r\n    name: '$console-time-end',\r\n    fn: ops.$consoleTimeEnd,\r\n}, {\r\n    name: '$console-time-log',\r\n    fn: ops.$consoleTimeLog,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState }     from '../../types';\r\nimport { isSymbol,\r\n         quote }             from '../../ast';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$capture',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__capture'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($$__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$refun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($refun name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '<-',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (<- name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defmacro',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defmacro name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defmacro'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$gensym',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($gensym)\r\n        // S expression: ($gensym name)\r\n        //  -> S expr  : ($__gensym 'name)\r\n        return [\r\n            {symbol: '$__gensym'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState }     from '../../types';\r\nimport { isSymbol,\r\n         quote }             from '../../ast';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$incl',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($incl name)\r\n        //  -> S expr  : ($set name ($add name 1))\r\n        checkParamsLength('$incl', list, 2, 2);\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], 1],\r\n        ];\r\n    },\r\n}, {\r\n    name: '++',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (++ name)\r\n        //  -> S expr  : ($set name ($add name 1))\r\n        checkParamsLength('++', list, 2, 2);\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], 1],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$decl',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($decl name)\r\n        //  -> S expr  : ($set name ($add name -1))\r\n        checkParamsLength('$decl', list, 2, 2);\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], -1],\r\n        ];\r\n    },\r\n}, {\r\n    name: '--',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (-- name)\r\n        //  -> S expr  : ($set name ($add name -1))\r\n        checkParamsLength('--', list, 2, 2);\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], -1],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$incln',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($incln name v)\r\n        //  -> S expr  : ($set name ($add name v))\r\n        checkParamsLength('$incln', list, 3, 3);\r\n        if (typeof list[2] !== 'number') {\r\n            throw new Error(`[SX] $incln: Invalid parameter: arg(1) is not number.`);\r\n        }\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], list[2]],\r\n        ];\r\n    },\r\n}, {\r\n    name: '+=',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (++ name)\r\n        //  -> S expr  : ($set name ($add name v))\r\n        checkParamsLength('+=', list, 3, 3);\r\n        if (typeof list[2] !== 'number') {\r\n            throw new Error(`[SX] +=: Invalid parameter: arg(1) is not number.`);\r\n        }\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], list[2]],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$decln',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($decln name v)\r\n        //  -> S expr  : ($set name ($add name -v))\r\n        checkParamsLength('$decln', list, 3, 3);\r\n        if (typeof list[2] !== 'number') {\r\n            throw new Error(`[SX] $decln: Invalid parameter: arg(1) is not number.`);\r\n        }\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\r\n        ];\r\n    },\r\n}, {\r\n    name: '-=',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (-- name)\r\n        //  -> S expr  : ($set name ($add name -v))\r\n        checkParamsLength('-=', list, 3, 3);\r\n        if (typeof list[2] !== 'number') {\r\n            throw new Error(`[SX] -=: Invalid parameter: arg(1) is not number.`);\r\n        }\r\n\r\n        return [{symbol: '$set'},\r\n            list[1],\r\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2017, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport class Query<T> {\r\n    public constructor(public data: T[]) {\r\n    }\r\n\r\n    public orderBy(condition: Array<string | string[/* colName: string, ('asc' | 'desc') */]> | ((a: T, b: T) => number)): Query<T> {\r\n        let fn: (a: T, b: T) => number;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (typeof c === 'string') {\r\n                        if (x[c] > y[c]) return 1;\r\n                        if (x[c] < y[c]) return -1;\r\n                    } else {\r\n                        const desc = c[1] === 'desc' ? -1 : 1;\r\n                        if (x[c[0]] > y[c[0]]) return 1 * desc;\r\n                        if (x[c[0]] < y[c[0]]) return -1 * desc;\r\n                    }\r\n                }\r\n                return 0;\r\n            };\r\n        } else {\r\n            fn = condition;\r\n        }\r\n        return new Query(this.data.slice(0).sort(fn));\r\n    }\r\n\r\n    public groupBy(condition: string[/* colName: string */] | ((a: T, b: T, index: number, array: T[]) => boolean)): Query<T[]> {\r\n        let fn: (a: T, b: T, index: number, array: T[]) => boolean;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (x[c] !== y[c]) return false;\r\n                }\r\n                return true;\r\n            };\r\n        } else{\r\n            fn = condition;\r\n        }\r\n        const r: T[][] = [];\r\n        let start = 0;\r\n        let i = 1;\r\n        for (; i < this.data.length; i++) {\r\n            if (! fn(this.data[start], this.data[i], i, this.data)) {\r\n                r.push(this.data.slice(start, i));\r\n                start = i;\r\n            }\r\n        }\r\n        r.push(this.data.slice(start, i));\r\n        return new Query(r);\r\n    }\r\n\r\n    public groupEvery(n: number | {single: number, first?: number, intermediate: number, last?: number}): Query<T[]> {\r\n        if (typeof n === 'number') {\r\n            return this.groupBy((a, b, index, array) => {\r\n                if ((index % n) === 0) return false;\r\n                return true;\r\n            });\r\n        } else {\r\n            const w = Object.assign({first: n.intermediate, last: n.intermediate}, n);\r\n            const r = this.groupBy((a, b, index, array) => {\r\n                if (w.single >= array.length) {\r\n                    if ((index % w.single) === 0) return false;\r\n                    return true;\r\n                } else if (index <= w.first) {\r\n                    if ((index % w.first) === 0) return false;\r\n                    return true;\r\n                } else {\r\n                    if (((index - w.first) % w.intermediate) === 0) return false;\r\n                    return true;\r\n                }\r\n            });\r\n            if (r.data.length === 1) {\r\n                if (w.single < r.data[0].length) {\r\n                    r.data.push([]);\r\n                }\r\n            } else {\r\n                if (w.first < r.data[0].length) {\r\n                    // case of w.first === 0\r\n                    r.data.unshift([]);\r\n                }\r\n            }\r\n            if (r.data.length > 1) {\r\n                if (r.data[r.data.length - 1].length > w.last) {\r\n                    r.data.push([]);\r\n                }\r\n            }\r\n            return r;\r\n        }\r\n    }\r\n\r\n    public where(fn: (value: T, index: number, array: T[]) => boolean): Query<T> {\r\n        return new Query(this.data.filter(fn));\r\n    }\r\n\r\n    public select(): T[];\r\n    public select<R>(fn: (value: T, index: number, array: T[]) => R): R[];\r\n    public select<R>(fn?: (value: T, index: number, array: T[]) => R): Array<R | T> {\r\n        return fn ? this.data.map(fn) : this.data as any;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function query<T>(data: T[]): Query<T> {\r\n    return new Query<T>(data);\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber,\r\n         evaluate }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\nimport { query }             from '../../../lib/data';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $replaceAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($replace-all src-string match-string replacement-string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$replaceAll', args, 3, 3);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {\r\n        return args[0].split(args[1]).join(args[2]);\r\n    }\r\n    throw new Error(`[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.`);\r\n};\r\nexport const $$replaceAll = $replaceAll(null as any, null as any);\r\n\r\n\r\nexport const $split = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($split src-string match-string)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$split', args, 2, 2);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string') {\r\n        return args[0].split(args[1]);\r\n    }\r\n    throw new Error(`[SX] $split: Invalid argument type: args[0] or [1] is not string.`);\r\n};\r\nexport const $$split = $split(null as any, null as any);\r\n\r\n\r\nexport const $join = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($join '(str1 ... strN) separator)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$join', args, 1, 2);\r\n\r\n    if (typeof Array.isArray(args[0])) {\r\n        if (args.length > 1) {\r\n            if (typeof args[1] === 'string') {\r\n                return args[0].join(args[1]);\r\n            }\r\n            throw new Error(`[SX] $join: Invalid argument type: args[1] is not string.`);\r\n        } else {\r\n            return args[0].join();\r\n        }\r\n    }\r\n    throw new Error(`[SX] $join: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$join = $join(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\nexport const $push = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($push list value)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$push', args, 2, 2);\r\n\r\n    if (typeof Array.isArray(args[0])) {\r\n        args[0].push(args[1]);\r\n        return args[0];\r\n    }\r\n    throw new Error(`[SX] $push: Invalid argument type: args[1] is not array.`);\r\n};\r\nexport const $$push = $push(null as any, null as any);\r\n\r\n\r\nexport const $pop = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($pop list)\r\n    //  -> S expr  : value\r\n    checkParamsLength('$pop', args, 1, 1);\r\n\r\n    if (typeof Array.isArray(args[0])) {\r\n        const v = args[0].pop();\r\n        return v;\r\n    }\r\n    throw new Error(`[SX] $pop: Invalid argument type: args[1] is not array.`);\r\n};\r\nexport const $$pop = $pop(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n\r\n\r\nexport const $groupEvery = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-every optionsOrNumber (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-every', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-every: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupEvery(car).select();\r\n};\r\nexport const $$groupEvery = $groupEvery(null as any, null as any);\r\n\r\n\r\nexport const $groupBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-by conditions (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupBy(car).select();\r\n};\r\nexport const $$groupBy = $groupBy(null as any, null as any);\r\n\r\n\r\nexport const $orderBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($order-by conditions (x1 ... xN))\r\n    //  -> S expr  : (x1 ... xN)\r\n    checkParamsLength('$order-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $order-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).orderBy(car).select();\r\n};\r\nexport const $$orderBy = $orderBy(null as any, null as any);\r\n\r\n\r\nexport const $where = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($where (-> (v index array) ... boolean) (x1 ... xN))\r\n    //  -> S expr  : (x'1 ... x'M)\r\n    checkParamsLength('$where', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (typeof args[0] !== 'function') {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[0] is not function.`);\r\n    }\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).where(car).select();\r\n};\r\nexport const $$where = $where(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$replace-all',\r\n    fn: ops.$replaceAll,\r\n}, {\r\n    name: '$split',\r\n    fn: ops.$split,\r\n}, {\r\n    name: '$join',\r\n    fn: ops.$join,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$push',\r\n    fn: ops.$push,\r\n}, {\r\n    name: '$pop',\r\n    fn: ops.$pop,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}, {\r\n    name: '$group-every',\r\n    fn: ops.$groupEvery,\r\n}, {\r\n    name: '$group-by',\r\n    fn: ops.$groupBy,\r\n}, {\r\n    name: '$order-by',\r\n    fn: ops.$orderBy,\r\n}, {\r\n    name: '$where',\r\n    fn: ops.$where,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState } from '../../types';\r\nimport { isSymbol }      from '../../ast';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken }           from '../../types';\r\nimport { isSymbol,\r\n         quote }             from '../../ast';\r\nimport { evaluate,\r\n         getScope }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$array', quote(state, car)],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            case 'setInnerText':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__text: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__text: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__text:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState } from '../../types';\r\nimport { quote }         from '../../ast';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $__let,\r\n         $__set  }           from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState }     from '../../types';\r\nimport { quote }             from '../../ast';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig,\r\n         SExpressionTemplateFn,\r\n         SExpressionAsyncTemplateFn } from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    backquote: '$backquote',\r\n    unquote: '$unquote',\r\n    spread: '$spread',\r\n    splice: '$splice',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n    call: '$call',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    isSymbol: '$is-symbol',\r\n    gensym: '$gensym',\r\n    raise: '$raise',\r\n    catch: '$catch',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableSplice: true,\r\n    enableShorthands: true,\r\n    enableVerbatimStringLiteral: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\n\r\n\r\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fRepl;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && s[i] !== null && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const execSync = (stat: SxParserState, s: SxToken[]) => {\r\n            if (config.enableEvaluate) {\r\n                for (let i = 0; i < s.length; i++) {\r\n                    s[i] = evaluate(stat, s[i]);\r\n                }\r\n            }\r\n\r\n            if (config.returnMultipleRoot) {\r\n                return s.length === 1 ? s[0] : s;\r\n            } else {\r\n                return s[s.length - 1];\r\n            }\r\n        };\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        const fReplSync: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return execSync(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fReplSync;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n    config.reservedNames = Object.assign({}, config.reservedNames, {\r\n        Template: '$concat',\r\n    });\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n    config.reservedNames = Object.assign({}, config.reservedNames, {\r\n        Template: '$concat',\r\n    });\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n    config.reservedNames = Object.assign({}, config.reservedNames, {\r\n        Template: '$concat',\r\n    });\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n    config.reservedNames = Object.assign({}, config.reservedNames, {\r\n        Template: '$concat',\r\n    });\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SExpressionTemplateFn,\r\n         SExpressionAsyncTemplateFn } from './types';\r\n\r\n\r\n\r\nexport function runScriptTags(lisp: SExpressionTemplateFn | SExpressionAsyncTemplateFn, globals?: object, contentType = 'text/lisp') {\r\n    const codes = document.querySelectorAll(`script[type=\"${contentType}\"]`);\r\n    const cs = [];\r\n    for (let i = 0; i < codes.length; i++) {\r\n        cs.push(codes[i].innerHTML);\r\n    }\r\n    lisp = lisp.appendGlobals(globals || {});\r\n    return lisp(cs.join('\\n'));\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\nexport * from './s-exp/browser';\r\n\r\n\r\nexport { default as installCore }         from './s-exp/operators/core';\r\nexport { default as installArithmetic }   from './s-exp/operators/arithmetic';\r\nexport { default as installSequence }     from './s-exp/operators/sequence';\r\nexport { default as installJsx }          from './s-exp/operators/jsx';\r\nexport { default as installConcurrent }   from './s-exp/operators/concurrent';\r\n\r\n\r\nimport { default as coreOperators }       from './s-exp/operators/core/core.operator';\r\nimport { default as coreMacros }          from './s-exp/operators/core/core.macro';\r\nimport { default as coreSymbols }         from './s-exp/operators/core/core.symbol';\r\n\r\nimport { default as arithmeticOperators } from './s-exp/operators/arithmetic/arithmetic.operator';\r\nimport { default as arithmeticMacros }    from './s-exp/operators/arithmetic/arithmetic.macro';\r\nimport { default as arithmeticSymbols }   from './s-exp/operators/arithmetic/arithmetic.symbol';\r\n\r\nimport { default as sequenceOperators }   from './s-exp/operators/sequence/sequence.operator';\r\nimport { default as sequenceMacros }      from './s-exp/operators/sequence/sequence.macro';\r\nimport { default as sequenceSymbols }     from './s-exp/operators/sequence/sequence.symbol';\r\n\r\nimport { default as jsxOperators }        from './s-exp/operators/jsx/jsx.operator';\r\nimport { default as jsxMacros }           from './s-exp/operators/jsx/jsx.macro';\r\nimport { default as jsxSymbols }          from './s-exp/operators/jsx/jsx.symbol';\r\n\r\nimport { default as concurrentOperators } from './s-exp/operators/concurrent/concurrent.operator';\r\nimport { default as concurrentMacros }    from './s-exp/operators/concurrent/concurrent.macro';\r\nimport { default as concurrentSymbols }   from './s-exp/operators/concurrent/concurrent.symbol';\r\n\r\n\r\nexport const builtinOperators = {\r\n    core: coreOperators,\r\n    arithmetic: arithmeticOperators,\r\n    sequence: sequenceOperators,\r\n    jsx: jsxOperators,\r\n    concurrent: concurrentOperators,\r\n};\r\n\r\nexport const builtinMacros = {\r\n    core: coreMacros,\r\n    arithmetic: arithmeticMacros,\r\n    sequence: sequenceMacros,\r\n    jsx: jsxMacros,\r\n    concurrent: concurrentMacros,\r\n};\r\n\r\nexport const builtinSymbols = {\r\n    core: coreSymbols,\r\n    arithmetic: arithmeticSymbols,\r\n    sequence: sequenceSymbols,\r\n    jsx: jsxSymbols,\r\n    concurrent: concurrentSymbols,\r\n};\r\n"],"sourceRoot":""}