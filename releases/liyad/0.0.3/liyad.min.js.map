{"version":3,"sources":["webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/operators/core.fn.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx.ts","webpack://liyad/./src/s-exp/operators/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence.ts","webpack://liyad/./src/s-exp/operators/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic.ts","webpack://liyad/./src/s-exp/operators/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core.macro.ts","webpack://liyad/./src/s-exp/operators/core.operator.ts","webpack://liyad/./src/s-exp/operators/core.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","x","_typeof","symbol","state","config","reservedNames","quote","Array","isArray","length","q","isSymbol","_types","_evaluate","$car","args","_key","arguments","arg0","slice","car","$cdr","$$car","_key2","cdr","$cons","$$cdr","_key3","unshift","$first","$$cons","_key4","$$first","$second","_key5","$$second","$rest","_key6","$firstAndSecond","$$rest","_key7","$$firstAndSecond","$atom","_key8","$eq","$$atom","apply","undefined","_$$firstAndSecond","$notEq","$$eq","_$$firstAndSecond2","$list","$$notEq","_len9","_key9","$__scope","$$list","_key10","isBlockLocal","returnMultiple","_toConsumableArray","_$$firstAndSecond3","scope","_iteratorNormalCompletion","_step","_iterator","iterator","next","done","kv","kvSym","String","evaluate","xSym","installScope","_iteratorNormalCompletion2","_step2","_iterator2","_x","push","_iteratorNormalCompletion3","_step3","_iterator3","_x2","uninstallScope","$__lambda","$__globalScope","_key11","_$$firstAndSecond4","getGlobalScope","_iteratorNormalCompletion4","_step4","_iterator4","_iteratorNormalCompletion5","_step5","_iterator5","_x3","_key12","Error","formalArgs","_step6","_iterator6","_iteratorNormalCompletion6","fa","fnBody","enableTailCallOptimization","optimizeTailCall","fn","actualArgs","_key13","self","concat","map","index","$boolean","$__defun","_key14","_fn","funcMap","set","st","nm","$__if","$$boolean","$__cond","$__while","_key15","_iteratorNormalCompletion7","_step7","_iterator7","$__doWhile","_key16","_iteratorNormalCompletion8","_step8","_iterator8","$__until","_key17","$$not","_iteratorNormalCompletion9","_step9","_iterator9","$__doUntil","_key18","_iteratorNormalCompletion10","_step10","_iterator10","$__repeat","_key19","sym","resolveValueSymbolScope","Number","_iteratorNormalCompletion11","_step11","_iterator11","$__for","_key20","list","_step12","_iterator12","_iteratorNormalCompletion12","_step13","_iterator13","_iteratorNormalCompletion13","$__get","_key21","v","resolveValueSymbol","$__let","$__set","path","Boolean","$not","$and","_len22","_key22","reduce","prev","curr","$or","$$and","_len23","_key23","$ambiguousEq","$$or","_$$firstAndSecond5","$$ambiguousEq","$ambiguousNotEq","$lt","$$ambiguousNotEq","_$$firstAndSecond6","$le","$$lt","_$$firstAndSecond7","$gt","$$le","_$$firstAndSecond8","$ge","$$gt","_$$firstAndSecond9","$isList","$$ge","$isString","$$isList","$isNumber","$$isString","$isNaN","$$isNumber","isNaN","$isFinite","$$isNaN","isFinite","$isInteger","$$isFinite","isInteger","$toString","$$isInteger","$toNumber","$$toString","$$toNumber","scopes","pop","front","tail","if","until","idx","let","resolveMacro","_sym","eval","resolveFunctionSymbol","JSON","stringify","wrapExternalValue","a","dotted","strippedCommentValue","macroInfo","macroMap","funcInfo","funcSymbolResolverFallback","raiseOnUnresolvedSymbol","nullIfNotDefined","localScope","globalScope","getScope","symInfo","symbolMap","valueSymbolResolverFallback","_core","$__outputIf","_r","Template","$__outputForOf","z","$__toObject","keyName","$jsxProps","styles","split","matched","exec","classes","_classes","_c","f","join","__html","getJsxTagsParams","children","props","$jsxStandardTag","_state$config","_getJsxTagsParams","jsx","$jsxComponentTag","component","_state$config2","_getJsxTagsParams2","symbols","macros","ops","_interopRequireWildcard","funcs","lsxConf","_jsx2","default","_jsx4","_jsx6","components","entries","_jsx7","_config$funcs","jsxFlagment","JsxFragment","$length","$concat","$$length","$slice","$$concat","_len2","$$slice","_sequence2","_sequence4","_sequence6","$bitNot","$bitAnd","$$bitNot","$bitOr","$$bitAnd","$bitXor","$$bitOr","$add","$$bitXor","_len4","$sub","$$add","$mul","$$sub","$sup","$$mul","Math","pow","$div","$$sup","$mod","$$div","$max","$$mod","max","$min","$$max","min","$avg","$$min","_len10","$floor","$$avg","floor","$ceil","$$floor","ceil","$round","$$ceil","round","$$round","_arithmetic2","_arithmetic4","_arithmetic6","Infinity","NaN","_core2","_core4","_core6","skipWhitespaces","ch","lookAhead","isEOF","getChar","parseList","parseOneToken","parseSingleLineComment","aheads","lookAheads","parseMultiLineComment","lookCurrentLineHint","isSpace","trim","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","line","pos","strings","virtualEof","eof","values","_ch","eofSeq","_ch2","ch1","ch2","fromCodePoint","parseInt","_ch3","chs","parseNumber","parseSymbol","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","parseString","parseHereDoc","attrs","inner","stripComments","comment","enableHereDoc","isHereDoc","ahs","listStopChar","initialList","assign","defaultConfig","SExpression","_parser","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","not","and","or","enableEvaluate","returnMultipleRoot","Map","parse","S","L","LS","lisp","LM","keys","_sExpression","forEach"],"mappings":"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","file":"liyad.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 25);\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    strippedCommentValue: any;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol }           from '../types';\r\nimport { evaluate,\r\n         resolveValueSymbol,\r\n         resolveValueSymbolScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall}    from '../evaluate';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car atomOrNilOrNull arg2 ... argN)\r\n    //  -> S expr  : null\r\n    // S expression: ($car '(first second ... last) arg2 ... argN)\r\n    //  -> S expr  : first\r\n    const arg0: any = args.slice(0, 1);\r\n    const car: any = (arg0.length === 1 && Array.isArray(arg0)) ? arg0.slice(0, 1) : [];\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr atomOrNilOrNull arg2 ... argN)\r\n    //  -> S expr  : null\r\n    // S expression: ($cdr '(first second ... last) arg2 ... argN)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($cdr '(first) arg2 ... argN)\r\n    //  -> S expr  : null\r\n    const arg0: any = args.slice(0, 1);\r\n    let cdr: any = (arg0.length === 1 && Array.isArray(arg0)) ? args.slice(1) : [];\r\n    if (cdr.length === 0) {\r\n        cdr = null;\r\n    }\r\n    return cdr;\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else if (cdr === null) {\r\n        return [car];\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car);\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2 ...)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2 ...)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        const scope: any = {};\r\n        if (Array.isArray(car)) {\r\n            for (const x of car) {\r\n                if (Array.isArray(x)) {\r\n                    const kv = $$firstAndSecond(...x);\r\n                    const kvSym = isSymbol(kv.car);\r\n                    scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n                } else {\r\n                    const xSym = isSymbol(x);\r\n                    scope[xSym ? xSym.symbol : String(x)] = null;\r\n                }\r\n            }\r\n        }\r\n        installScope(state, scope, isBlockLocal);\r\n\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    const returnMultiple = $$first(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        installScope(state, getGlobalScope(state), true);\r\n\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    if (args.length < 2) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument length: expected: ${3} / args: ${args.length}.`);\r\n    }\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    for (const fa of formalArgs) {\r\n        if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if (actualArgs.length < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => {\r\n                return [x.symbol, actualArgs[index]];\r\n            })),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    const car: SxSymbol = $$first(...args);\r\n    if (args.length < 3) {\r\n        throw new Error(`[SX] $__defun: Invalid argument length: expected: ${3} / args: ${args.length}.`);\r\n    }\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        r = evaluate(state, args[2]);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = Number($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = Number($$second(...args));\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    if (args.length === 0) return null;\r\n\r\n    let sym = isSymbol(args[0]);\r\n    let v = resolveValueSymbol(state, sym ? sym : {symbol: String(args[0])});\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        switch (typeof args[i]) {\r\n        case 'object':\r\n            sym = isSymbol(args[i]);\r\n            if (sym) {\r\n                v = v[evaluate(state, sym) as any];\r\n            } else {\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n            break;\r\n        case 'string':\r\n            v = v[args[i]];\r\n            break;\r\n        case 'number':\r\n            if (args[i] >= 0) {\r\n                v = v[args[i]];\r\n            } else {\r\n                v = v[v.length + args[i]];\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    if (args.length < 2) return null;\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    if (args.length < 2) return null;\r\n\r\n    let path: any = [];\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let i = 0;\r\n    for (; i < path.length - 1; i++) {\r\n        switch (typeof path[i]) {\r\n        case 'object':\r\n            sym = isSymbol(path[i]);\r\n            if (sym) {\r\n                scope = scope[evaluate(state, sym) as any];\r\n            } else {\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n            break;\r\n        case 'string':\r\n            scope = scope[path[i]];\r\n            break;\r\n        case 'number':\r\n            if (path[i] >= 0) {\r\n                scope = scope[path[i]];\r\n            } else {\r\n                scope = scope[scope.length + path[i]];\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    for (; i < path.length; i++) {\r\n        switch (typeof path[i]) {\r\n        case 'object':\r\n            sym = isSymbol(path[i]);\r\n            if (sym) {\r\n                scope[evaluate(state, sym) as any] = args[1];\r\n            } else {\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n            break;\r\n        case 'string':\r\n            scope[path[i]] = args[1];\r\n            break;\r\n        case 'number':\r\n            if (path[i] >= 0) {\r\n                scope[path[i]] = args[1];\r\n            } else {\r\n                scope[scope.length + path[i]] = args[1];\r\n            }\r\n            break;\r\n        default:\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\nexport const $and = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    (args as any[]).reduce((prev, curr) => prev && curr, true);\r\nexport const $$and = $and(null as any, null as any);\r\n\r\n\r\nexport const $or = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    (args as any[]).reduce((prev, curr) => prev || curr, false);\r\nexport const $$or = $or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return Number(car) < Number(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return Number(car) <= Number(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return Number(car) > Number(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return Number(car) >= Number(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Number.isNaN(Number($$first(...args)));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Number.isFinite(Number($$first(...args)));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Number.isInteger(Number($$first(...args)));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Number($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol } from './types';\r\n\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean): any {\r\n    state.scopes.push({isBlockLocal, scope});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            for (let i = r.length - 1; i > 0; i--) {\r\n                r[i] = evaluate(state, r[i]);\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        if (Array.isArray((r as SxDottedPair).cdr)) {\r\n            const a = ((r as SxDottedPair).cdr as any[]).slice(0);\r\n            a.unshift((r as SxDottedPair).car);\r\n            r = evaluate(state, a);\r\n        } else {\r\n            r = {\r\n                car: evaluate(state, (r as SxDottedPair).car),\r\n                cdr: evaluate(state, (r as SxDottedPair).cdr),\r\n            };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = state.config.strippedCommentValue;\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }  from '../types';\r\nimport { evaluate,\r\n         getScope }  from '../evaluate';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean } from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$parent', getScope(state)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        r[keyName] = classes.map(c => (c === null || c === void 0) ? \"\" : String(c));\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let f = '';\r\n                            if (Array.isArray(c)) {\r\n                                f = c\r\n                                    .map(z => evaluate(state, z))\r\n                                    .map(z => (z === null || z === void 0) ? \"\" : String(z))\r\n                                    .join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                f = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + f;\r\n                            else classes = f;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState } from '../types';\r\nimport { $$first }       from './core.fn';\r\n\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return car.length();\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return car.concat(...args.slice(1));\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    args.slice(2).slice(Number(args[0]), Number(args[1]));\r\nexport const $$slice = $slice(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo} from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState } from '../types';\r\nimport { $$first }       from './core.fn';\r\n\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return ~Number(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) & Number(curr), Number(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) | Number(curr), Number(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) ^ Number(curr), Number(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    args.reduce((prev, curr) => Number(prev) + Number(curr), 0);\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -Number(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => Number(prev) - Number(curr), Number(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) * Number(curr), Number(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) ** Number(curr), Number(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) / Number(curr), Number(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => Number(prev) % Number(curr), Number(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Math.max(...args);\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Math.min(...args);\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    args.length > 0 ? args.reduce((prev, curr) => Number(prev) + Number(curr), 0) / args.length : null;\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Math.floor(Number($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Math.ceil(Number($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    return Math.round(Number($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => +Infinity},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => -Infinity},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$and',\r\n    fn: ops.$and,\r\n}, {\r\n    name: '$or',\r\n    fn: ops.$or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new Error(`[SX] parseStringOrComment: Unexpected termination of script.`);\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return state.config.stripComments ?\r\n        state.config.strippedCommentValue :\r\n        { comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0] };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return state.config.stripComments ?\r\n        state.config.strippedCommentValue :\r\n        { comment: parseStringOrComment(state, ['|#'], null, ')').strings[0] };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            getChar(state);\r\n            skipWhitespaces(state);\r\n            return {dotted: parseOneToken(state)};\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            attrs = parseList(state, '}', [{symbol: '@'}]);\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseOneToken: Unexpected termination of script.`);\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]) {\r\n    const r: SxToken[] = initialList.slice(0);\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            return r;\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length === 0 || Array.isArray(r[r.length - 1])) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: t});\r\n                    }\r\n                } else {\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseList: Unexpected termination of script.`);\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                r.push(quote(state, parseOneToken(state)));\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            r.push(parseSingleLineComment(state));\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    r.push(parseMultiLineComment(state));\r\n                } else {\r\n                    getChar(state);\r\n                    r.push(parseSingleLineComment(state));\r\n                }\r\n            }\r\n            break;\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }          from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    strippedCommentValue: [],\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nexport function SExpression(config: SxParserConfig): (strings: TemplateStringsArray, ...values: any[]) => SxToken {\r\n    return (strings: TemplateStringsArray, ...values: any[]) => {\r\n        const state: SxParserState = {\r\n            strings: typeof strings === 'string' ? [strings] : strings,\r\n            values: values || [],\r\n\r\n            index: 0,\r\n            pos: 0,\r\n            line: 0,\r\n\r\n            scopes: [{isBlockLocal: false, scope: {}}],\r\n\r\n            macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n            funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n            symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n            config,\r\n        };\r\n\r\n        const s = parse(state);\r\n\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): (strings: TemplateStringsArray, ...values: any[]) => R {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    return SExpression(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n"],"sourceRoot":""}