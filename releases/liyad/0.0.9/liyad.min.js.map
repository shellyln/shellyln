{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/core/core.fn.ts","webpack://liyad/./src/s-exp/operators/core/core.operator.ts","webpack://liyad/./src/s-exp/operators/core/core.macro.ts","webpack://liyad/./src/s-exp/operators/core/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core/index.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic/index.ts","webpack://liyad/./src/lib/data.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence/index.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx/index.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent/index.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","quote","state","x","symbol","config","reservedNames","spread","isSymbol","FatalError","Error","[object Object]","message","super","MaxEvaluationCountError","ScriptTerminationError","where","isEOF","ch","isSpace","trim","length","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","lookCurrentLineHint","line","index","pos","strings","slice","getChar","virtualEof","eof","values","v","split","eofSeq","ch1","ch2","String","fromCodePoint","Number","parseInt","lookAheads","chs","push","lookAhead","skipWhitespaces","parseNumber","parseSymbol","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","parseList","parseString","parseHereDoc","attrs","q","inner","parseSingleLineComment","comment","parseMultiLineComment","parseOneToken","aheads","enableSpread","dotted","enableHereDoc","isHereDoc","sym","Template","ahs","a","Array","isArray","wrapExternalValue","listStopChar","initialList","unshift","pop","car","cdr","stripComments","parse","setEvaluationCount","evalCount","maxEvalCount","checkParamsLength","args","min","max","toNumber","NaN","resolveMacro","macroInfo","macroMap","fn","resolveValueSymbolScope","nullIfNotDefined","scopes","localScope","scope","isBlockLocal","globalScope","getGlobalScope","getScope","resolveValueSymbol","symInfo","symbolMap","valueSymbolResolverFallback","raiseOnUnresolvedSymbol","installScope","uninstallScope","evaluate","eval","sprs","reverse","concat","funcInfo","funcMap","funcSymbolResolverFallback","resolveFunctionSymbol","JSON","stringify","$car","$$first","$cdr","$cons","$$firstAndSecond","$first","$second","$$second","$last","$rest","$firstAndSecond","$atom","$eq","$notEq","$list","$__scope","returnMultiple","scopeInstalled","kv","kvSym","xSym","$__lambda","formalArgs","lastIsSpread","fa","fnBody","enableTailCallOptimization","front","tail","if","self","until","map","idx","let","optimizeTailCall","actualArgs","$apply","apply","$raise","$pipe","$__let","$__set","path","subst","inprog","last","$boolean","Boolean","$$boolean","$not","$$not","$__and","prev","curr","$__or","$ambiguousEq","$$ambiguousEq","$ambiguousNotEq","$lt","$le","$gt","$ge","$isList","$isString","$isNumber","$isNaN","isNaN","$isFinite","isFinite","$isInteger","isInteger","$toString","$toNumber","$objectAssign","assign","$jsonStringify","$jsonParse","$consoleLog","console","log","$consoleError","error","core_operator","set","st","nm","Function","e","list","keyName","core_macro","core_symbol","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","install","funcs","macros","symbols","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","reduce","$bitOr","$bitXor","$add","$sub","$mul","$sup","Math","pow","$div","$mod","$max","$min","$avg","$floor","floor","$ceil","ceil","$round","round","$abs","abs","$sign","sign","arithmetic_operator","arithmetic_macro","arithmetic_symbol","arithmetic_install","Query","data","this","condition","y","desc","sort","start","groupBy","b","array","w","first","intermediate","single","filter","query","$length","$trim","$trimHead","trimLeft","$trimTail","trimRight","$replaceAll","join","$split","$join","$concat","$slice","$top","$tail","$__at","$reverse","$reverseDestructive","$find","find","$filter","$map","$reduce","$reduceFromTail","reduceRight","$sort","$sortDestructive","$groupEvery","groupEvery","select","$groupBy","$orderBy","orderBy","$where","sequence_operator","stop","step","from","sequence_macro","sequence_symbol","sequence_install","$jsxProps","styles","matched","exec","classes","z","cs","forEach","fragment","__html","__text","getJsxTagsParams","children","props","$jsxStandardTag","jsx","$jsxComponentTag","component","jsx_operator","jsx_macro","jsx_symbol","jsx_install","lsxConf","components","entries","jsxFlagment","JsxFragment","$__letAsync","promise","then","Promise","resolve","reject","$__setAsync","$then","$resolveAll","promises","all","$resolveAny","invert","res","rej","ps","firstOf","$resolvePipe","lambdas","$resolveFork","resolvers","rejectors","pa","lp","catch","f","concurrent_operator","concurrent_macro","concurrent_symbol","concurrent_install","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","not","and","or","defaultConfig","enableEvaluate","returnMultipleRoot","initState","globals","Map","resetState","SExpression","conf","startup","evaluateAST","ast","repl","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","installer","SExpressionAsync","__awaiter","S","L","LS","lisp","L_async","LS_async","lisp_async","LM","LM_async","LSX","LSX_async","__webpack_exports__"],"mappings":"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","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    spread: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote,\r\n         spread,\r\n         ScriptTerminationError } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new ScriptTerminationError('parseStringOrComment');\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push(quote(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol }           from './types';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean): any {\r\n    state.scopes.push({isBlockLocal, scope});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            const sprs = [];\r\n            for (let i = 1; i < r.length; i++) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    sprs.push(i);\r\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    r[i] = Array.isArray(a) ? a : [a];\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n            for (const i of sprs.reverse()) {\r\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol,\r\n         quote,\r\n         FatalError }         from '../../types';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }           from '../../evaluate';\r\nimport { checkParamsLength }  from '../../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n    let scopeInstalled = false;\r\n\r\n    try {\r\n        const scope: any = {};\r\n        if (Array.isArray(car)) {\r\n            for (const x of car) {\r\n                if (Array.isArray(x)) {\r\n                    const kv = $$firstAndSecond(...x);\r\n                    const kvSym = isSymbol(kv.car);\r\n                    scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n                } else {\r\n                    const xSym = isSymbol(x);\r\n                    scope[xSym ? xSym.symbol : String(x)] = null;\r\n                }\r\n            }\r\n        }\r\n        installScope(state, scope, isBlockLocal);\r\n        scopeInstalled = true;\r\n\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        if (scopeInstalled) {\r\n            uninstallScope(state);\r\n        }\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        installScope(state, getGlobalScope(state).scope, true);\r\n\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($apply fn arg1 ... argN)\r\n    //  -> S expr  : fn'\r\n    checkParamsLength('$apply', args, 1);\r\n\r\n    const car: () => any = $$first(...args);\r\n    if (typeof car !== 'function') {\r\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\r\n    }\r\n\r\n    return (\r\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\r\n    );\r\n};\r\nexport const $$apply = $apply(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    return Function.prototype.apply.call(\r\n        car[sym ? sym.symbol : evaluate(state, cdr) as any],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$apply',\r\n    fn: ops.$apply,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol }          from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2017, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport class Query<T> {\r\n    public constructor(public data: T[]) {\r\n    }\r\n\r\n    public orderBy(condition: Array<string | string[/* colName: string, ('asc' | 'desc') */]> | ((a: T, b: T) => number)): Query<T> {\r\n        let fn: (a: T, b: T) => number;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (typeof c === 'string') {\r\n                        if (x[c] > y[c]) return 1;\r\n                        if (x[c] < y[c]) return -1;\r\n                    } else {\r\n                        const desc = c[1] === 'desc' ? -1 : 1;\r\n                        if (x[c[0]] > y[c[0]]) return 1 * desc;\r\n                        if (x[c[0]] < y[c[0]]) return -1 * desc;\r\n                    }\r\n                }\r\n                return 0;\r\n            };\r\n        } else {\r\n            fn = condition;\r\n        }\r\n        return new Query(this.data.slice(0).sort(fn));\r\n    }\r\n\r\n    public groupBy(condition: string[/* colName: string */] | ((a: T, b: T, index: number, array: T[]) => boolean)): Query<T[]> {\r\n        let fn: (a: T, b: T, index: number, array: T[]) => boolean;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (x[c] !== y[c]) return false;\r\n                }\r\n                return true;\r\n            };\r\n        } else{\r\n            fn = condition;\r\n        }\r\n        const r: T[][] = [];\r\n        let start = 0;\r\n        let i = 1;\r\n        for (; i < this.data.length; i++) {\r\n            if (! fn(this.data[start], this.data[i], i, this.data)) {\r\n                r.push(this.data.slice(start, i));\r\n                start = i;\r\n            }\r\n        }\r\n        r.push(this.data.slice(start, i));\r\n        return new Query(r);\r\n    }\r\n\r\n    public groupEvery(n: number | {single: number, first?: number, intermediate: number, last?: number}): Query<T[]> {\r\n        if (typeof n === 'number') {\r\n            return this.groupBy((a, b, index, array) => {\r\n                if ((index % n) === 0) return false;\r\n                return true;\r\n            });\r\n        } else {\r\n            const w = Object.assign({first: n.intermediate, last: n.intermediate}, n);\r\n            const r = this.groupBy((a, b, index, array) => {\r\n                if (w.single >= array.length) {\r\n                    if ((index % w.single) === 0) return false;\r\n                    return true;\r\n                } else if (index <= w.first) {\r\n                    if ((index % w.first) === 0) return false;\r\n                    return true;\r\n                } else {\r\n                    if (((index - w.first) % w.intermediate) === 0) return false;\r\n                    return true;\r\n                }\r\n            });\r\n            if (r.data.length === 1) {\r\n                if (w.single < r.data[0].length) {\r\n                    r.data.push([]);\r\n                }\r\n            } else {\r\n                if (w.first < r.data[0].length) {\r\n                    // case of w.first === 0\r\n                    r.data.unshift([]);\r\n                }\r\n            }\r\n            if (r.data.length > 1) {\r\n                if (r.data[r.data.length - 1].length > w.last) {\r\n                    r.data.push([]);\r\n                }\r\n            }\r\n            return r;\r\n        }\r\n    }\r\n\r\n    public where(fn: (value: T, index: number, array: T[]) => boolean): Query<T> {\r\n        return new Query(this.data.filter(fn));\r\n    }\r\n\r\n    public select(): T[];\r\n    public select<R>(fn: (value: T, index: number, array: T[]) => R): R[];\r\n    public select<R>(fn?: (value: T, index: number, array: T[]) => R): Array<R | T> {\r\n        return fn ? this.data.map(fn) : this.data as any;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function query<T>(data: T[]): Query<T> {\r\n    return new Query<T>(data);\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber,\r\n         evaluate }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\nimport { query }             from '../../../lib/data';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $replaceAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($replace-all src-string match-string replacement-string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$replaceAll', args, 3, 3);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {\r\n        return args[0].split(args[1]).join(args[2]);\r\n    }\r\n    throw new Error(`[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.`);\r\n};\r\nexport const $$replaceAll = $replaceAll(null as any, null as any);\r\n\r\n\r\nexport const $split = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($split src-string match-string)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$split', args, 2, 2);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string') {\r\n        return args[0].split(args[1]);\r\n    }\r\n    throw new Error(`[SX] $split: Invalid argument type: args[0] or [1] is not string.`);\r\n};\r\nexport const $$split = $split(null as any, null as any);\r\n\r\n\r\nexport const $join = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($join '(str1 ... strN) separator)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$join', args, 1, 2);\r\n\r\n    if (typeof Array.isArray(args[0])) {\r\n        if (args.length > 1) {\r\n            if (typeof args[1] === 'string') {\r\n                return args[0].join(args[1]);\r\n            }\r\n            throw new Error(`[SX] $join: Invalid argument type: args[1] is not string.`);\r\n        } else {\r\n            return args[0].join();\r\n        }\r\n    }\r\n    throw new Error(`[SX] $join: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$join = $join(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n\r\n\r\nexport const $groupEvery = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-every optionsOrNumber (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-every', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-every: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupEvery(car).select();\r\n};\r\nexport const $$groupEvery = $groupEvery(null as any, null as any);\r\n\r\n\r\nexport const $groupBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-by conditions (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupBy(car).select();\r\n};\r\nexport const $$groupBy = $groupBy(null as any, null as any);\r\n\r\n\r\nexport const $orderBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($order-by conditions (x1 ... xN))\r\n    //  -> S expr  : (x1 ... xN)\r\n    checkParamsLength('$order-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $order-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).orderBy(car).select();\r\n};\r\nexport const $$orderBy = $orderBy(null as any, null as any);\r\n\r\n\r\nexport const $where = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($where (-> (v index array) ... boolean) (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$where', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (typeof args[0] !== 'function') {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[0] is not function.`);\r\n    }\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).where(car).select();\r\n};\r\nexport const $$where = $where(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$replace-all',\r\n    fn: ops.$replaceAll,\r\n}, {\r\n    name: '$split',\r\n    fn: ops.$split,\r\n}, {\r\n    name: '$join',\r\n    fn: ops.$join,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}, {\r\n    name: '$group-every',\r\n    fn: ops.$groupEvery,\r\n}, {\r\n    name: '$group-by',\r\n    fn: ops.$groupBy,\r\n}, {\r\n    name: '$order-by',\r\n    fn: ops.$orderBy,\r\n}, {\r\n    name: '$where',\r\n    fn: ops.$where,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         isSymbol } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }          from '../../types';\r\nimport { evaluate,\r\n         getScope }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$array', quote(state, car)],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            case 'setInnerText':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__text: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__text: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__text:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $__let,\r\n         $__set  }           from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote }             from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    spread: '$spread',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\r\n}\r\n\r\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n\r\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n"],"sourceRoot":""}