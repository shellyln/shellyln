{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/core.fn.ts","webpack://liyad/./src/s-exp/operators/jsx.fn.ts","webpack://liyad/./src/index.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/operators/core.ts","webpack://liyad/./src/s-exp/operators/core.operator.ts","webpack://liyad/./src/s-exp/operators/core.macro.ts","webpack://liyad/./src/s-exp/operators/core.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic.ts","webpack://liyad/./src/s-exp/operators/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence.ts","webpack://liyad/./src/s-exp/operators/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx.ts","webpack://liyad/./src/s-exp/operators/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent.ts","webpack://liyad/./src/s-exp/operators/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent.symbol.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","x","_typeof","symbol","quote","state","config","reservedNames","isQuoted","Array","isArray","length","q","isSymbol","spread","FatalError","_Error","message","_classCallCheck","this","Error","MaxEvaluationCountError","_FatalError","setEvaluationCount","evalCount","maxEvalCount","_types","checkParamsLength","args","min","max","toNumber","NaN","Number","resolveMacro","resolveFunctionSymbol","resolveValueSymbolScope","resolveValueSymbol","installScope","scope","isBlockLocal","scopes","push","uninstallScope","pop","getScope","getGlobalScope","optimizeTailCall","formalArgs","fnBody","front","slice","tail","if","self","until","concat","_toConsumableArray","map","idx","let","evaluate","_errors","sym","_sym","eval","symSpr","a","fn","JSON","stringify","apply","undefined","wrapExternalValue","cdr","_a","unshift","car","dotted","macroInfo","macroMap","funcInfo","funcMap","v","funcSymbolResolverFallback","raiseOnUnresolvedSymbol","nullIfNotDefined","localScope","globalScope","symInfo","symbolMap","valueSymbolResolverFallback","_evaluate","$car","_key","arguments","$$first","$cdr","$$car","_key2","$cons","$$cdr","_key3","$$firstAndSecond","_$$firstAndSecond","$first","$$cons","_key4","$second","_key5","$$second","$last","_key6","$rest","$$last","_key7","$firstAndSecond","$$rest","_key8","$atom","_key9","$eq","$$atom","_key10","_$$firstAndSecond2","$notEq","$$eq","_key11","_$$firstAndSecond3","$list","$$notEq","_len12","_key12","$__scope","$$list","_key13","returnMultiple","_$$firstAndSecond4","scopeInstalled","_iteratorNormalCompletion","_step","_iterator","iterator","next","done","kv","kvSym","String","xSym","_iteratorNormalCompletion2","_step2","_iterator2","_x","_iteratorNormalCompletion3","_step3","_iterator3","_x2","$__lambda","$__globalScope","_key14","_iteratorNormalCompletion4","_step4","_iterator4","_iteratorNormalCompletion5","_step5","_iterator5","_x3","_key15","lastIsSpread","fa","enableSpread","enableTailCallOptimization","actualArgs","_key16","index","$pipe","$__defun","_key17","_fn","set","st","nm","$__try","_key18","e","$raise","$__if","_key19","$$boolean","$__ifNull","_key20","_$$firstAndSecond5","$$ambiguousEq","$__cond","_key21","$__while","_key22","_iteratorNormalCompletion6","_step6","_iterator6","$__doWhile","_key23","_iteratorNormalCompletion7","_step7","_iterator7","$__until","_key24","$$not","_iteratorNormalCompletion8","_step8","_iterator8","$__doUntil","_key25","_iteratorNormalCompletion9","_step9","_iterator9","$__repeat","_key26","_iteratorNormalCompletion10","_step10","_iterator10","$__for","_key27","list","_step11","_iterator11","_iteratorNormalCompletion11","_step12","_iterator12","_iteratorNormalCompletion12","_key28","$boolean","$$pipe","$__get","_key29","inprog","$__let","_key30","$__set","_key31","path","subst","last","_key32","Boolean","$not","_key33","$__and","_key34","prev","curr","$__or","$$__and","_key35","$ambiguousEq","$$__or","_key36","_$$firstAndSecond6","$ambiguousNotEq","$lt","$$ambiguousNotEq","_key37","_$$firstAndSecond7","$le","$$lt","_key38","_$$firstAndSecond8","$gt","$$le","_key39","_$$firstAndSecond9","$ge","$$gt","_key40","_$$firstAndSecond10","$isList","$$ge","_key41","$isString","$$isList","_key42","$isNumber","$$isString","_key43","$isNaN","$$isNumber","_key44","isNaN","$isFinite","$$isNaN","_key45","isFinite","$isInteger","$$isFinite","_key46","isInteger","$toString","$$isInteger","_key47","$toNumber","$$toString","_key48","$objectAssign","$$toNumber","$__toObject","_key49","_step13","_iterator13","_iteratorNormalCompletion13","keyName","_key50","assign","$jsonStringify","$$objectAssign","_key51","$jsonParse","$$jsonStringify","_key52","parse","$consoleLog","$$jsonParse","_console","console","log","$consoleError","$$consoleLog","_console2","error","$$consoleError","_core","$__outputIf","_r","Template","$__outputForOf","z","$jsxProps","styles","split","matched","exec","classes","cs","forEach","fragment","join","__html","getJsxTagsParams","children","props","$jsxStandardTag","_state$config","_getJsxTagsParams","jsx","$jsxComponentTag","component","_state$config2","_getJsxTagsParams2","keys","_sExpression","SExpression","SExpressionAsync","LSX","lsxConf","defaultConfig","_core2","default","_arithmetic2","_sequence2","_jsx2","stripComments","LSX_async","_concurrent2","_parser","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","not","and","or","enableEvaluate","enableHereDoc","returnMultipleRoot","symbols","macros","funcs","initState","globals","strings","values","pos","line","Map","startup","f","setGlobals","appendGlobals","setStartup","appendStartup","_len4","then","_context","sent","S","L","L_async","LS","lisp","LS_async","lisp_async","LM","LM_async","skipWhitespaces","ch","lookAhead","isEOF","getChar","parseList","parseOneToken","parseSingleLineComment","aheads","lookAheads","parseMultiLineComment","_aheads4","lookCurrentLineHint","isSpace","trim","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","virtualEof","eof","_ch","eofSeq","_ch2","ch1","ch2","fromCodePoint","parseInt","_ch3","chs","parseNumber","parseSymbol","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","parseString","parseHereDoc","attrs","inner","comment","_aheads","isHereDoc","ahs","listStopChar","initialList","_core4","_core6","ops","_interopRequireWildcard","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","_arithmetic4","_arithmetic6","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","$bitOr","$bitXor","$add","$sub","$mul","$sup","$div","$mod","$max","$min","$avg","$floor","$ceil","$round","$abs","$sign","$$bitLShift","$$bitSRShift","$$bitURShift","$$bitNot","reduce","$$bitAnd","$$bitOr","$$bitXor","$$add","$$sub","$$mul","Math","pow","$$sup","$$div","$$mod","$$max","$$min","$$avg","floor","$$floor","ceil","$$ceil","round","$$round","abs","$$abs","sign","$$sign","_sequence4","_sequence6","$range","$length","$trim","$trimHead","$trimTail","$concat","$slice","$top","$tail","$__at","$reverse","$reverseDestructive","$find","$filter","$map","$reduce","$reduceFromTail","$sort","$sortDestructive","start","stop","step","from","$$length","$$trim","trimLeft","$$trimHead","trimRight","$$trimTail","$$concat","$$slice","$$top","$$tail","$$__at","reverse","$$reverse","$$reverseDestructive","find","$$find","filter","$$filter","$$map","$$reduce","reduceRight","$$reduceFromTail","sort","$$sort","$$sortDestructive","_jsx4","_jsx6","components","entries","_jsx7","_config$funcs","jsxFlagment","JsxFragment","_concurrent4","_concurrent6","$__letAsync","$__setAsync","$then","$resolveAll","$resolveAny","$resolvePipe","$resolveFork","promise","Promise","resolve","reject","$$__letAsync","$$__setAsync","$$then","promises","all","$$resolveAll","invert","res","rej","ps","firstOf","$$resolveAny","lambdas","$$resolvePipe","resolvers","rejectors","pa","_i","lp","catch","_loop","$$resolveFork"],"mappings":"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","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    spread: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol }           from './types';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean): any {\r\n    state.scopes.push({isBlockLocal, scope});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            for (let i = r.length - 1; i > 0; i--) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    let a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    a = Array.isArray(a) ? a : [a];\r\n                    r = (r as SxToken[]).slice(0, i).concat(a, r.slice(i + 1));\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        if (Array.isArray((r as SxDottedPair).cdr)) {\r\n            const a = ((r as SxDottedPair).cdr as any[]).slice(0);\r\n            a.unshift((r as SxDottedPair).car);\r\n            r = evaluate(state, a);\r\n        } else {\r\n            r = {\r\n                car: evaluate(state, (r as SxDottedPair).car),\r\n                cdr: evaluate(state, (r as SxDottedPair).cdr),\r\n            };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol,\r\n         quote,\r\n         FatalError }         from '../types';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }           from '../evaluate';\r\nimport { checkParamsLength }  from '../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n    let scopeInstalled = false;\r\n\r\n    try {\r\n        const scope: any = {};\r\n        if (Array.isArray(car)) {\r\n            for (const x of car) {\r\n                if (Array.isArray(x)) {\r\n                    const kv = $$firstAndSecond(...x);\r\n                    const kvSym = isSymbol(kv.car);\r\n                    scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n                } else {\r\n                    const xSym = isSymbol(x);\r\n                    scope[xSym ? xSym.symbol : String(x)] = null;\r\n                }\r\n            }\r\n        }\r\n        installScope(state, scope, isBlockLocal);\r\n        scopeInstalled = true;\r\n\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        if (scopeInstalled) {\r\n            uninstallScope(state);\r\n        }\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        installScope(state, getGlobalScope(state).scope, true);\r\n\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { evaluate,\r\n         getScope }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    spread: '$spread',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\n\r\ninterface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n}\r\n\r\nexport function SExpression(config: SxParserConfig): SExpressionTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n\r\n        const s = startup.concat(parse(state));\r\n\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    }) as any;\r\n\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n\r\nexport function SExpressionAsync(config: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n\r\n        const s = startup.concat(parse(state));\r\n\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    }) as any;\r\n\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote,\r\n         spread } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new Error(`[SX] parseStringOrComment: Unexpected termination of script.`);\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            attrs = parseList(state, '}', [{symbol: '@'}]);\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseOneToken: Unexpected termination of script.`);\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]) {\r\n    const r: SxToken[] = initialList.slice(0);\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            return r;\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length === 0 || Array.isArray(r[r.length - 1])) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: t});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseList: Unexpected termination of script.`);\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push(quote(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber,\r\n         evaluate }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         isSymbol } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $__let,\r\n         $__set  }           from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote }             from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n"],"sourceRoot":""}