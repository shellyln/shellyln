{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/index.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic.ts","webpack://liyad/./src/s-exp/operators/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent.ts","webpack://liyad/./src/s-exp/operators/core.fn.ts","webpack://liyad/./src/s-exp/operators/core.macro.ts","webpack://liyad/./src/s-exp/operators/core.operator.ts","webpack://liyad/./src/s-exp/operators/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core.ts","webpack://liyad/./src/s-exp/operators/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx.ts","webpack://liyad/./src/s-exp/operators/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/s-exp/types.ts"],"names":[],"mappings":"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","file":"liyad.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol }           from './types';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean): any {\r\n    state.scopes.push({isBlockLocal, scope});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            for (let i = r.length - 1; i > 0; i--) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    let a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    a = Array.isArray(a) ? a : [a];\r\n                    r = (r as SxToken[]).slice(0, i).concat(a, r.slice(i + 1));\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        if (Array.isArray((r as SxDottedPair).cdr)) {\r\n            const a = ((r as SxDottedPair).cdr as any[]).slice(0);\r\n            a.unshift((r as SxDottedPair).car);\r\n            r = evaluate(state, a);\r\n        } else {\r\n            r = {\r\n                car: evaluate(state, (r as SxDottedPair).car),\r\n                cdr: evaluate(state, (r as SxDottedPair).cdr),\r\n            };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $__let,\r\n         $__set  }           from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote }             from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol,\r\n         quote,\r\n         FatalError }         from '../types';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }           from '../evaluate';\r\nimport { checkParamsLength }  from '../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n    let scopeInstalled = false;\r\n\r\n    try {\r\n        const scope: any = {};\r\n        if (Array.isArray(car)) {\r\n            for (const x of car) {\r\n                if (Array.isArray(x)) {\r\n                    const kv = $$firstAndSecond(...x);\r\n                    const kvSym = isSymbol(kv.car);\r\n                    scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n                } else {\r\n                    const xSym = isSymbol(x);\r\n                    scope[xSym ? xSym.symbol : String(x)] = null;\r\n                }\r\n            }\r\n        }\r\n        installScope(state, scope, isBlockLocal);\r\n        scopeInstalled = true;\r\n\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        if (scopeInstalled) {\r\n            uninstallScope(state);\r\n        }\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        installScope(state, getGlobalScope(state).scope, true);\r\n\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { evaluate,\r\n         getScope }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber,\r\n         evaluate }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         isSymbol } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote,\r\n         spread } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new Error(`[SX] parseStringOrComment: Unexpected termination of script.`);\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            attrs = parseList(state, '}', [{symbol: '@'}]);\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseOneToken: Unexpected termination of script.`);\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]) {\r\n    const r: SxToken[] = initialList.slice(0);\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            return r;\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length === 0 || Array.isArray(r[r.length - 1])) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: t});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new Error(`[SX] parseList: Unexpected termination of script.`);\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push(quote(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    spread: '$spread',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\n\r\ninterface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n}\r\n\r\nexport function SExpression(config: SxParserConfig): SExpressionTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n\r\n        const s = startup.concat(parse(state));\r\n\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    }) as any;\r\n\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n\r\nexport function SExpressionAsync(config: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n\r\n        const s = startup.concat(parse(state));\r\n\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    }) as any;\r\n\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    spread: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n"],"sourceRoot":""}