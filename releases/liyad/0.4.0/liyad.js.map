{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/index.ts","webpack://liyad/./src/lib/data.ts","webpack://liyad/./src/s-exp/ast.ts","webpack://liyad/./src/s-exp/browser.ts","webpack://liyad/./src/s-exp/compile.ops/helpers.ts","webpack://liyad/./src/s-exp/compile.ops/index.ts","webpack://liyad/./src/s-exp/compile.ts","webpack://liyad/./src/s-exp/consts.ts","webpack://liyad/./src/s-exp/defaults.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/interpreters/index.ts","webpack://liyad/./src/s-exp/interpreters/presets/lisp.ts","webpack://liyad/./src/s-exp/interpreters/presets/lsx.ts","webpack://liyad/./src/s-exp/interpreters/presets/s-exp.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic/index.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent/index.ts","webpack://liyad/./src/s-exp/operators/core/core.fn.ts","webpack://liyad/./src/s-exp/operators/core/core.macro.ts","webpack://liyad/./src/s-exp/operators/core/core.operator.ts","webpack://liyad/./src/s-exp/operators/core/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core/index.ts","webpack://liyad/./src/s-exp/operators/jsx/index.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence/index.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.symbol.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/s-exp/types.ts"],"names":[],"mappings":"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","file":"liyad.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport * from './s-exp/types';\nexport * from './s-exp/ast';\nexport * from './s-exp/s-expression';\nexport * from './s-exp/browser';\n\n\nexport { default as installCore }         from './s-exp/operators/core';\nexport { default as installArithmetic }   from './s-exp/operators/arithmetic';\nexport { default as installSequence }     from './s-exp/operators/sequence';\nexport { default as installJsx }          from './s-exp/operators/jsx';\nexport { default as installConcurrent }   from './s-exp/operators/concurrent';\n\n\nimport { default as coreOperators }       from './s-exp/operators/core/core.operator';\nimport { default as coreMacros }          from './s-exp/operators/core/core.macro';\nimport { default as coreSymbols }         from './s-exp/operators/core/core.symbol';\n\nimport { default as arithmeticOperators } from './s-exp/operators/arithmetic/arithmetic.operator';\nimport { default as arithmeticMacros }    from './s-exp/operators/arithmetic/arithmetic.macro';\nimport { default as arithmeticSymbols }   from './s-exp/operators/arithmetic/arithmetic.symbol';\n\nimport { default as sequenceOperators }   from './s-exp/operators/sequence/sequence.operator';\nimport { default as sequenceMacros }      from './s-exp/operators/sequence/sequence.macro';\nimport { default as sequenceSymbols }     from './s-exp/operators/sequence/sequence.symbol';\n\nimport { default as jsxOperators }        from './s-exp/operators/jsx/jsx.operator';\nimport { default as jsxMacros }           from './s-exp/operators/jsx/jsx.macro';\nimport { default as jsxSymbols }          from './s-exp/operators/jsx/jsx.symbol';\n\nimport { default as concurrentOperators } from './s-exp/operators/concurrent/concurrent.operator';\nimport { default as concurrentMacros }    from './s-exp/operators/concurrent/concurrent.macro';\nimport { default as concurrentSymbols }   from './s-exp/operators/concurrent/concurrent.symbol';\n\n\nexport const builtinOperators = {\n    core: coreOperators,\n    arithmetic: arithmeticOperators,\n    sequence: sequenceOperators,\n    jsx: jsxOperators,\n    concurrent: concurrentOperators,\n};\n\nexport const builtinMacros = {\n    core: coreMacros,\n    arithmetic: arithmeticMacros,\n    sequence: sequenceMacros,\n    jsx: jsxMacros,\n    concurrent: concurrentMacros,\n};\n\nexport const builtinSymbols = {\n    core: coreSymbols,\n    arithmetic: arithmeticSymbols,\n    sequence: sequenceSymbols,\n    jsx: jsxSymbols,\n    concurrent: concurrentSymbols,\n};\n","// Copyright (c) 2017, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport class Query<T> {\n    public constructor(public data: T[]) {\n    }\n\n    public orderBy(condition: Array<string | string[/* colName: string, ('asc' | 'desc') */]> | ((a: T, b: T) => number)): Query<T> {\n        let fn: (a: T, b: T) => number;\n        if (Array.isArray(condition)) {\n            fn = (x: T, y: T) => {\n                for (const c of condition) {\n                    if (typeof c === 'string') {\n                        if (x[c] > y[c]) return 1;\n                        if (x[c] < y[c]) return -1;\n                    } else {\n                        const desc = c[1] === 'desc' ? -1 : 1;\n                        if (x[c[0]] > y[c[0]]) return 1 * desc;\n                        if (x[c[0]] < y[c[0]]) return -1 * desc;\n                    }\n                }\n                return 0;\n            };\n        } else {\n            fn = condition;\n        }\n        return new Query(this.data.slice(0).sort(fn));\n    }\n\n    public groupBy(condition: string[/* colName: string */] | ((a: T, b: T, index: number, array: T[]) => boolean)): Query<T[]> {\n        let fn: (a: T, b: T, index: number, array: T[]) => boolean;\n        if (Array.isArray(condition)) {\n            fn = (x: T, y: T) => {\n                for (const c of condition) {\n                    if (x[c] !== y[c]) return false;\n                }\n                return true;\n            };\n        } else{\n            fn = condition;\n        }\n        const r: T[][] = [];\n        let start = 0;\n        let i = 1;\n        for (; i < this.data.length; i++) {\n            if (! fn(this.data[start], this.data[i], i, this.data)) {\n                r.push(this.data.slice(start, i));\n                start = i;\n            }\n        }\n        r.push(this.data.slice(start, i));\n        return new Query(r);\n    }\n\n    public groupEvery(n: number | {single: number, first?: number, intermediate: number, last?: number}): Query<T[]> {\n        if (typeof n === 'number') {\n            return this.groupBy((a, b, index, array) => {\n                if ((index % n) === 0) return false;\n                return true;\n            });\n        } else {\n            const w = Object.assign({first: n.intermediate, last: n.intermediate}, n);\n            const r = this.groupBy((a, b, index, array) => {\n                if (w.single >= array.length) {\n                    if ((index % w.single) === 0) return false;\n                    return true;\n                } else if (index <= w.first) {\n                    if ((index % w.first) === 0) return false;\n                    return true;\n                } else {\n                    if (((index - w.first) % w.intermediate) === 0) return false;\n                    return true;\n                }\n            });\n            if (r.data.length === 1) {\n                if (w.single < r.data[0].length) {\n                    r.data.push([]);\n                }\n            } else {\n                if (w.first < r.data[0].length) {\n                    // case of w.first === 0\n                    r.data.unshift([]);\n                }\n            }\n            if (r.data.length > 1) {\n                if (r.data[r.data.length - 1].length > w.last) {\n                    r.data.push([]);\n                }\n            }\n            return r;\n        }\n    }\n\n    public where(fn: (value: T, index: number, array: T[]) => boolean): Query<T> {\n        return new Query(this.data.filter(fn));\n    }\n\n    public select(): T[];\n    public select<R>(fn: (value: T, index: number, array: T[]) => R): R[];\n    public select<R>(fn?: (value: T, index: number, array: T[]) => R): Array<R | T> {\n        return fn ? this.data.map(fn) : this.data as any;\n    }\n}\n\n\n\nexport function query<T>(data: T[]): Query<T> {\n    return new Query<T>(data);\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol }     from './types';\n\n\n\nexport function quote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.quote}, x];\n}\n\n\nexport function isQuoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.quote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function backquote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.backquote}, x];\n}\n\n\nexport function isBackquoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.backquote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function wrapByUnquote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.unquote}, x];\n}\n\n\nexport function isUnquoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.unquote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function spread(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.spread}, x];\n}\n\n\nexport function splice(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.splice}, x];\n}\n\n\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\n        if (name !== void 0) {\n            return x.symbol === name ? x : null;\n        } else {\n            return x;\n        }\n    }\n    return null;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from './types';\n\n\n\nexport function runScriptTags(lisp: SExpressionTemplateFn | SExpressionAsyncTemplateFn, globals?: object, contentType = 'text/lisp') {\n    const codes = document.querySelectorAll(`script[type=\"${contentType}\"]`);\n    const cs = [];\n    for (let i = 0; i < codes.length; i++) {\n        cs.push(codes[i].innerHTML);\n    }\n    lisp = lisp.appendGlobals(globals || {});\n    return lisp(cs.join('\\n'));\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxToken }             from '../types';\nimport { isSymbol }            from '../ast';\nimport { resolveSplice,\n         resolveMacro,\n         resolveValueSymbol,\n         getScope }            from '../evaluate';\nimport { setEvaluationCount,\n         checkUnsafeVarNamesEx,\n         checkUnsafeVarNames } from '../errors';\n\n\n\nexport function applyMacros(state: SxParserState, tok: SxToken) {\n    let r: SxToken = tok;\n    for (;;) {\n        if (Array.isArray(r)) {\n            if (r.length === 0) {\n                break;\n            }\n            r = resolveSplice(state, r);\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                const m = resolveMacro(state, sym, r);\n                if (m) {\n                    r = m.fn(m.actualArgs as SxToken[]);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        setEvaluationCount(state);\n    }\n    return r;\n}\n\n\nexport function stripQuote(state: SxParserState, tok: SxToken) {\n    if (! (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote))) {\n        throw new Error(`[SX] stripQuote: token is not quoted.`);\n    }\n    return (tok as any)[1];\n}\n\n\nexport function stripQuoteOrPass(state: SxParserState, tok: SxToken) {\n    if (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote)) {\n        return (tok as any)[1];\n    } else {\n        return tok;\n    }\n}\n\n\nexport function getScope_stateApplied(state: SxParserState) {\n    return (function() { return getScope(state); });\n}\n\n\nexport function resolveValueSymbol_dynamic(state: SxParserState, varName: string) {\n    checkUnsafeVarNames('(compiler)resolveValueSymbol_dynamic', varName);\n    return (function(){ return resolveValueSymbol(state, {symbol: varName}); });\n}\n\nexport function checkUnsafeVarNames_dynamic(name: string) {\n    return (function(varName: string){ return checkUnsafeVarNames(name, varName); });\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         CompilerContext }             from '../types';\nimport { isSymbol }                    from '../ast';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx,\n         checkUnsafeVarNames }         from '../errors';\nimport { stripQuote,\n         stripQuoteOrPass,\n         getScope_stateApplied,\n         resolveValueSymbol_dynamic,\n         checkUnsafeVarNames_dynamic } from './helpers';\n\n\n\nexport function registerOperators(state: SxParserState, ctx: CompilerContext) {\n    const {\n        _$_vars,\n        ops,\n        makeScope,\n        compileToken,\n    } = ctx;\n\n\n    ops.set(state.config.reservedNames.quote, function(r: SxToken[], args: SxToken[]) {\n        let compFnBody = '';\n        _$_vars[ctx.varsCount] = r[1];\n        compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.self, function(r: SxToken[], args: SxToken[]) {\n        let compFnBody = '';\n        compFnBody += `((_$_vars[0])(${\n            args.map(x => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__if', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__if condition 't-expr 'f-expr)\n        //  -> (if condition is true ) S expr  : t-expr\n        //  -> (if condition is false) S expr  : f-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__if', args, 2, 3);\n        compFnBody += `(${compileToken(r, 1)}?(${\n            compileToken([stripQuote(state, r[2])], 0)}):(${\n            compileToken([stripQuote(state, r[3])], 0)}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__if-null', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__if-null condition 'null-expr)\n        //  -> (if condition is not null ) S expr  : condition\n        //  -> (if condition is null)      S expr  : null-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__if-null', args, 2, 2);\n        compFnBody += `((()=>{let _$_rv=${compileToken(r, 1)};return _$_rv?_$_rv:(${\n            compileToken([stripQuote(state, r[2])], 0)}});})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__cond', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n        //  -> (if (eval condI) is true ) S expr  : exprI\n        //  -> (if no matched)            S expr  : null\n        let compFnBody = '';\n        {\n            checkParamsLength('compileToken:$__cond', args, 1);\n            compFnBody += `(`;\n            for (let p = 0; p < args.length; p += 2) {\n                compFnBody += `${compileToken([stripQuote(state, args[p])], 0)}?(${\n                    compileToken([stripQuote(state, args[p + 1])], 0)}):(`;\n            }\n            compFnBody += `null`;\n            for (let p = 0; p < args.length; p += 2) {\n                compFnBody += `)`;\n            }\n            compFnBody += `)`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('$__while', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__while 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__while', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;while(${\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n            }}return _$_rv})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__do-while', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__do-until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(${\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__until', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__until 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;while(!${\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n            }}return _$_rv})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__do-until', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__do-until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(!${\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__repeat', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\n        //  -> (if n > 0) S expr  : exprN\n        //  -> (else)     S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__repeat', args, 2);\n        if (! isSymbol(args[0])) {\n            throw new Error(`[SX] compileToken: $__repeat : args[0] is not symbol.`);\n        }\n        makeScope(() => {\n            const name = 'v' + ctx.varNamesCount++;\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\n            compFnBody += `(((_$_n)=>{let _$_rv=null;for(let ${name}=0;${name}<_$_n;${name}++){_$_rv=${\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n                }}return _$_rv})(${compileToken(args, 1)}))`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__for', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__for 'x list 'expr1 ... 'exprN)\n        //  -> (if list.length > 0) S expr  : exprN\n        //  -> (else)               S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__for', args, 2);\n        if (! isSymbol(args[0])) {\n            throw new Error(`[SX] compileToken: $__for : args[0] is not symbol.`);\n        }\n        makeScope(() => {\n            const name = 'v' + ctx.varNamesCount++;\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\n            compFnBody += `(((_$_l)=>{let _$_rv=null;for(const ${name} of _$_l){_$_rv=${\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n                }}return _$_rv})(${compileToken(args, 1)}))`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__scope', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\n        //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n        //  -> (else)               S expr  : exprN\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__scope', args, 2);\n        // r[1]: isBlockLocal\n        // r[2]: returnMultiple\n        if (! Array.isArray(r[3])) {\n            throw new Error(`[SX] compileToken: $__scope : args[2] is not array.`);\n        }\n        makeScope(() => {\n            for (const x of stripQuote(state, r[3]) as any[]) {\n                let name = '';\n                if (Array.isArray(x)) {\n                    if (x.length < 1) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is too short.`);\n                    }\n                    if (! isSymbol(x[0])) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?][0] is not symbol.`);\n                    }\n                    name = x[0].symbol;\n                    compFnBody += `(${'v' + ctx.varNamesCount}=${compileToken(x, 1)})`;\n                } else {\n                    if (! isSymbol(x)) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is not symbol.`);\n                    }\n                    name = x.symbol;\n                }\n                ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\n                ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\n            }\n            const s = `${r.slice(4).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}`;\n            compFnBody += r[2] ? `[${s}]` : `(${s})`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__try', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__try 'expr 'catch-expr)\n        //  ->                               S expr  : expr\n        //  -> (if error is raised in expr)  S expr  : catch-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__try', args, 1, 2);\n        compFnBody += `((()=>{try{${\n            compileToken([stripQuote(state, r[1])], 0)}}catch(e${\n            ctx.varNamesCount}){let e${ctx.varNamesCount + 1}=(_$_vars[${String(ctx.varsCount)}])();`;\n        _$_vars[ctx.varsCount++] = getScope_stateApplied(state);\n        makeScope(() => {\n            ctx.varNames.set('$error', 'e' + ctx.varNamesCount++);\n            ctx.varNames.set('$parent', 'e' + ctx.varNamesCount++);\n            compFnBody += `${\n                compileToken([stripQuote(state, r[2])], 0)}}})())`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.raise, function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($raise 'expr)\n        //  -> S expr  : -\n        let compFnBody = '';\n        compFnBody += `((()=>{throw ${\n            compileToken([stripQuoteOrPass(state, r[1])], 0)}})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$boolean', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($boolean any)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:$boolean', args, 1, 1);\n        compFnBody += `((x0=${compileToken(args, 0)\n            }),(Array.isArray(x0)&&x0.length===0?false:boolean(x0)))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__get', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__get', args, 1);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__get : operand is not symbol: ${JSON.stringify(r[1])}.`);\n        }\n        let vName = '';\n        if (ctx.varNames.has(name)) {\n            vName = ctx.varNames.get(name) as string;\n        } else {\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\n        }\n        const regToVars = (symName: string) => {\n            _$_vars[ctx.varsCount] = symName;\n            return `_$_vars[${String(ctx.varsCount++)}]`;\n        };\n        compFnBody += `((${vName})${r.slice(2).map((x, idx, arr) => `[${\n            isSymbol(arr[idx]) ?\n                regToVars((arr as any)[idx].symbol) :\n                compileToken(arr, idx)}]`).join('')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__let', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__let 'nameStrOrSymbol expr)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__let', args, 2, 2);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__let : operand is not rvalue: ${JSON.stringify(r[1])}.`);\n        }\n        if (! ctx.varNames.has(name)) {\n            ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\n            ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\n        }\n        compFnBody += `(${ctx.varNames.get(name)}=${compileToken(r, 2)})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__set', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__set 'nameOrListOfNameOrIndex expr)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__set', args, 2);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ?\n            quoted.symbol :\n            (typeof quoted === 'string' ?\n                quoted :\n                (Array.isArray(quoted) ?\n                    (isSymbol(quoted[0]) ?\n                        quoted[0].symbol :\n                        (typeof quoted[0] === 'string' ? quoted[0] : null)\n                    ) :\n                    null\n                )\n            );\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__set : operand is not rvalue: ${JSON.stringify(r[1])}.`);\n        }\n        let vName = '';\n        if (ctx.varNames.has(name)) {\n            vName = ctx.varNames.get(name) as string;\n        } else {\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\n        }\n        const regToVars = (symName: string) => {\n            _$_vars[ctx.varsCount] = checkUnsafeVarNames('compileToken:$__set', symName);\n            return `_$_vars[${String(ctx.varsCount++)}]`;\n        };\n        let checkNameCalled = false;\n        let checkNamePos = '';\n        const checkName = (str: string) => {\n            if (! checkNameCalled) {\n                _$_vars[ctx.varsCount] = checkUnsafeVarNames_dynamic('compileToken:$__set');\n                checkNamePos = String(ctx.varsCount++);\n                checkNameCalled = true;\n            }\n            return `(_$_vars[${checkNamePos}](${str}))`;\n        };\n        compFnBody += `((${vName})${(Array.isArray(quoted) ? quoted.slice(1) : []).map((x, idx, arr) => `[${\n            isSymbol(arr[idx]) ?\n                regToVars((arr as any)[idx].symbol) :\n                checkName(compileToken(arr, idx))}]`).join('')}=${compileToken(r, 2)})`;\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.not, function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($not any)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:$not', args, 1, 1);\n        compFnBody += `(!${compileToken(args, 0)})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__and', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__and 'expr1 ... 'exprN)\n        //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\n        //  -> (else)                                                     S expr  : expr-i (false left most)\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__and', args, 1);\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('&&')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__or', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__or 'expr1 ... 'exprN)\n        //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\n        //  -> (else)                                                  S expr  : expr-i (false right most)\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__or', args, 1);\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('||')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('===', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($eq arg1 arg2)\n        //  -> (if arg1 === arg2)  S expr  : true\n        //  -> (else)              S expr  : false\n        let compFnBody = '';\n        checkParamsLength('compileToken:===', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('===')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('!==', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($not-eq arg1 arg2)\n        //  -> (if arg1 !== arg2)  S expr  : true\n        //  -> (else)              S expr  : false\n        let compFnBody = '';\n        checkParamsLength('compileToken:!==', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!==')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('==', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (== a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:==', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('==')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('!=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (!= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:!=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('<', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (< a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('<=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (<= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (> a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$concat', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($concat listOrString1 ... listOrStringN)\n        //  -> S expr  : listOrString\n        let compFnBody = '';\n        checkParamsLength('compileToken:$concat', args, 1);\n        let w1 = '';\n        if (Array.isArray(args[0]) && isSymbol((args[0] as any)[0], state.config.reservedNames.spread)) {\n            const w0 = compileToken(args[0] as any, 1);\n            w1 = `(${w0}[0]).concat((${w0}.length>1?${w0}[1]:(typeof ${w0}[0]==='string'?'':[])),`;\n        } else {\n            w1 = `${compileToken(args as any, 0)}.concat(`;\n        }\n        compFnBody += `(${w1}${\n            args.slice(1).map((x, idx, arr) => compileToken(arr, idx)).join(',')}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('+', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (+ number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:+', args, 1);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n            };return _$_rv.reduce((x,y)=>x+y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('+')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('-', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (- number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:-', args, 1);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return (_$_rv.length>1?(_$_rv.reduce((x,y)=>x-y)):(_$_rv.length>0?-_$_rv[0]:NaN));})())`;\n        } else {\n            compFnBody += `(${r.length > 2 ?\n                args.map((x, idx, arr) => compileToken(arr, idx)).join('-') :\n                `-(${String(compileToken(r, 1))})`})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('*', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (* number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:*', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x*y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('*')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('**', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (** number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:**', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x**y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('**')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('/', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (/ number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:/', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x/y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('/')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('%', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (% number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:%', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x%y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('%')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('<<', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (<< number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:<<', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<<')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>> number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:>>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>>>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>>> number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:>>>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-not', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-not number)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-not', args, 1, 1);\n        compFnBody += `(~(${compileToken(r, 1)}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-and', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-and numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-and', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('&')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-or', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-or numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-or', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('|')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-xor', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-xor numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-xor', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('^')})`;\n        return compFnBody;\n    });\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         SxFuncInfo,\n         CompilerOperator,\n         CompilerContext  }           from './types';\nimport { isSymbol }                   from './ast';\nimport { getCapturedScopes,\n         optimizeTailCall }           from './evaluate';\nimport { checkUnsafeVarNamesEx }      from './errors';\nimport { applyMacros,\n         stripQuoteOrPass,\n         resolveValueSymbol_dynamic } from './compile.ops/helpers';\nimport { registerOperators }          from './compile.ops';\n\n\n\n// tslint:disable-next-line:variable-name\nfunction compileCore(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[], _$_vars: any[]) {\n\n    function makeScope(scoped: () => void) {\n        const varNamesCopy = new Map<string, string>();\n        for (const x of ctx.varNames.entries()) {\n            varNamesCopy.set(x[0], x[1]);\n        }\n        scoped();\n        ctx.varNames = varNamesCopy;\n    }\n\n\n    function compileValue(b: any) {\n        let compFnBody = '';\n        if (b === null) {\n            compFnBody += '(null)';\n        } else if (b === void 0) {\n            compFnBody += '(void 0)';\n        } else switch (typeof b) {\n        case 'boolean': case 'number':\n            compFnBody += `(${String(b)})`;\n            break;\n        case 'object':\n            if (isSymbol(b)) {\n                const sym = b as SxSymbol;\n                checkUnsafeVarNamesEx('(compiler)compileValue', ctx.varNames, sym.symbol);\n                if (ctx.varNames.has(sym.symbol)) {\n                    compFnBody += `(${ctx.varNames.get(sym.symbol)})`;\n                } else {\n                    _$_vars[ctx.varsCount] = sym.symbol;\n                    compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n                }\n                break;\n            } else {}\n            // FALL_THRU\n        default:\n            _$_vars[ctx.varsCount] = b;\n            compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n            break;\n        }\n        return compFnBody;\n    }\n\n\n    function compileToken(body: any[], i: number) {\n        let compFnBody = '';\n        const b = body[i];\n        if (Array.isArray(b)) {\n            if (0 < b.length) {\n                const r: SxToken = applyMacros(state, b);\n                if (Array.isArray(r)) {\n                    if (0 < r.length) {\n                        if (isSymbol(r[0])) {\n                            const sym = r[0] as SxSymbol;\n                            const args = r.slice(1);\n                            checkUnsafeVarNamesEx('(compiler)compileToken', ops, sym.symbol);\n                            if (ops.has(sym.symbol)) {\n                                compFnBody += (ops.get(sym.symbol) as CompilerOperator)(r, args);\n                            } else {\n                                if (sym.symbol === state.config.reservedNames.spread) {\n                                    compFnBody += `...(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\n                                } else if (state.funcMap.has(sym.symbol)) {\n                                    _$_vars[ctx.varsCount] = (state.funcMap.get(sym.symbol) as SxFuncInfo).fn(state, '');\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                } else if (ctx.varNames.has(sym.symbol)) {\n                                    compFnBody += `(${String(ctx.varNames.get(sym.symbol))})(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\n                                } else {\n                                    _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, sym.symbol);\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])()(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                }\n                            }\n                        } else {\n                            switch (typeof r[0]) {\n                            case 'function':\n                                _$_vars[ctx.varsCount] = r[0];\n                                compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\n                                    r.slice(1).map((x, idx, arr) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                break;\n                            default:\n                                throw new Error(`[SX] compileToken: First item of list is not a function: ${JSON.stringify(r[0])}.`);\n                            }\n                        }\n                    } else {\n                        compFnBody += '([])';\n                    }\n                } else {\n                    compFnBody += compileValue(b);\n                }\n            } else {\n                compFnBody += '([])';\n            }\n        } else {\n            compFnBody += compileValue(b);\n        }\n        return compFnBody;\n    }\n\n\n    const ctx: CompilerContext = {\n        _$_vars,\n        varsCount: 1,\n        varNames: new Map<string, string>(),\n        varNamesCount: 0,\n        varDefs: 'var x0;',\n        ops: new Map<string, CompilerOperator>(),\n        makeScope,\n        compileToken,\n    };\n\n    registerOperators(state, ctx);\n    const ops = ctx.ops;\n\n    if (state.config.enableTailCallOptimization) {\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\n    }\n\n    // set 'this' object\n    ctx.varNames.set(state.config.reservedNames.thiz, `(this===(Function('return this')())?null:(this===void 0?null:this))`);\n\n    const capturedScopes = getCapturedScopes(state);\n    if (capturedScopes) {\n        for (const x in capturedScopes) {\n            if (Object.prototype.hasOwnProperty.call(capturedScopes, x)) {\n                _$_vars[ctx.varsCount++] = x;\n                _$_vars[ctx.varsCount] = capturedScopes[x];\n                ctx.varNames.set(x, `(_$_vars[${String(ctx.varsCount)}][_$_vars[${String(ctx.varsCount - 1)}]])`);\n                ctx.varsCount++;\n            }\n        }\n    }\n\n    const compFormalArgs = `${formalArgs.map((x, i) => {\n        ctx.varNames.set(formalArgs[i].symbol, 'a' + i);\n        return `${(lastIsSpread && i === formalArgs.length - 1) ? '...' : ''}a${i}`;\n    }).join(',')}`;\n\n    const compFnBodyRoot = `return(${fnBody.map((x, i) => compileToken(fnBody, i)).join(',')})`;\n    return `(function(${compFormalArgs}){\"strict\";${ctx.varDefs}${compFnBodyRoot}})`;\n}\n\n\n// tslint:disable-next-line:variable-name\nfunction evalCompiledLambda(_$_state: SxParserState, _$_vars: any[], code: string) {\n    // tslint:disable-next-line:no-eval\n    _$_vars[0] = eval(code);\n    return _$_vars[0];\n}\n\n\nexport function compileLambda(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[]) {\n    // tslint:disable-next-line:variable-name\n    const _$_vars: any[] = [];\n    return evalCompiledLambda(state, _$_vars, compileCore(state, formalArgs, lastIsSpread, fnBody, _$_vars));\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n// tslint:disable-next-line:function-constructor\nexport const globalObj = Function('return this')();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxReservedNames,\n         SxParserConfig } from './types';\n\n\n\nexport const defaultReservedNames: SxReservedNames = {\n    eval: '$eval',\n    quote: '$quote',\n    backquote: '$backquote',\n    unquote: '$unquote',\n    spread: '$spread',\n    splice: '$splice',\n\n    car: '$car',\n    cdr: '$cdr',\n    cons: '$cons',\n    atom: '$atom',\n    eq: '$eq',\n    list: '$list',\n\n    let: '$clisp-let',\n    lambda: '$lambda',\n    self: '$self',\n    defun: '$defun',\n    thiz: '$this',\n\n    if: '$if',\n    cond: '$cond',\n\n    while: '$while',\n    doWhile: '$do-while',\n    until: '$until',\n    doUntil: '$do-until',\n\n    get: '$get',\n    defvar: '$clisp-defvar',\n    setq: '$clisp-setq',\n    set: '$set',\n    call: '$call',\n\n    not: '$not',\n    and: '$and',\n    or: '$or',\n\n    isSymbol: '$is-symbol',\n    gensym: '$gensym',\n    raise: '$raise',\n    catch: '$catch',\n\n    Template: 'Template',\n};\n\nexport const defaultConfig: SxParserConfig = {\n    raiseOnUnresolvedSymbol: false,\n    enableEvaluate: true,\n    enableHereDoc: true,\n    enableSpread: true,\n    enableSplice: true,\n    enableShorthands: true,\n    enableVerbatimStringLiteral: true,\n    enableTailCallOptimization: true,\n    enableRegExpMatchOperators: true,\n    enableCompilationOperators: true,\n    stripComments: false,\n    wrapExternalValue: true,\n    returnMultipleRoot: false,\n    maxEvalCount: 0,\n\n    reservedNames: defaultReservedNames,\n    symbols: [],\n    macros: [],\n    funcs: [],\n};\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         MaxEvaluationCountError } from './types';\nimport { globalObj }               from './consts';\n\n\n\nexport function setEvaluationCount(state: SxParserState) {\n    state.evalCount++;\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\n        throw new MaxEvaluationCountError();\n    }\n}\n\n\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\n    if (args.length < min) {\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\n    }\n    if (max && max < args.length) {\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\n    }\n    return args;\n}\n\n\nconst objConstructor = ({}).constructor; // NOTE: objConstructor            === Object\nconst funConstructor = Function;         // NOTE: ({}).toString.constructor === Function\n\nexport function checkUnsafeVarNames(name: string, varName: string) {\n    if (varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (objConstructor.hasOwnProperty(varName)) {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'call' || varName === 'arguments' || varName === 'caller') {\n        // NOTE: arguments, caller are not accessible in strict mode\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    return varName;\n}\n\n\nexport function checkUnsafeVarNamesEx(name: string, target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (objConstructor.hasOwnProperty(varName)) {\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            if (con.hasOwnProperty(varName)) {\n                throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n            }\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        if (!target.hasOwnProperty(varName)) {\n            // function's prototypes' members\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    return varName;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxExternalValue,\n         SxSymbol,\n         SxDottedPair,\n         SxDottedFragment,\n         SxToken,\n         SxScope,\n         CapturedScopes,\n         SxMacroInfo }           from './types';\nimport { isSymbol }              from './ast';\nimport { setEvaluationCount,\n         checkUnsafeVarNamesEx } from './errors';\n\n\n\nexport function toNumber(x: any) {\n    switch (typeof x) {\n    case 'object': case 'symbol': case 'function':\n        return NaN;\n    default:\n        return Number(x);\n    }\n}\n\n\nexport function resolveUnquote(state: SxParserState, r: SxToken[]) {\n    for (let i = 0; i < r.length; i++) {\n        const symUnquote = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.unquote);\n        if (symUnquote) {\n            r = r.slice(0, i).concat([evaluate(state, (r[i] as SxToken[])[1])], r.slice(i + 1));\n        }\n        if (Array.isArray(r[i])) {\n            r = r.slice(0);\n            r[i] = resolveUnquote(state, r[i] as SxToken[]);\n        }\n    }\n    return resolveSplice(state, r);\n}\n\n\nexport function resolveSplice(state: SxParserState, r: SxToken[]) {\n    if (state.config.enableSplice) {\n        for (let i = r.length - 1; i >= 0; i--) {\n            const symSplice = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.splice);\n            if (symSplice) {\n                r = r.slice(0, i).concat((r[i] as SxToken[])[1], r.slice(i + 1));\n            }\n        }\n    }\n    return r;\n}\n\n\nexport function resolveMacro(state: SxParserState, x: SxSymbol, r: SxToken[]) {\n    const macroInfo = state.macroMap.get(x.symbol);\n    let lastErr = null;\n    if (macroInfo) {\n        let m: SxMacroInfo | undefined = macroInfo;\n        const r1 = r.slice(1);\n        while (m) {\n            if (m.formalArgs) {\n                const matchResult = matchMacroArgs(state, x.symbol, m.formalArgs, Boolean(m.lastIsSpread), r1);\n                if (! matchResult.error) {\n                    return {\n                        fn: m.fn(state, x.symbol, matchResult.formalArgs as SxSymbol[]),\n                        actualArgs: r.slice(0, 1).concat(matchResult.actualArgs as SxToken[]),\n                    };\n                }\n                lastErr = matchResult.error;\n                m = m.next;\n            } else {\n                return {\n                    fn: m.fn(state, x.symbol),\n                    actualArgs: r,\n                };\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n    }\n    return false;\n}\n\n\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\n    if (typeof x === 'function') {\n        return x;\n    }\n    const funcInfo = state.funcMap.get(x.symbol);\n    if (funcInfo) {\n        return funcInfo.fn(state, x.symbol);\n    } else {\n        const v = resolveValueSymbol(state, x);\n        if (typeof v === 'function') {\n            return v;\n        }\n        if (state.config.funcSymbolResolverFallback) {\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\n        }\n        if (state.config.raiseOnUnresolvedSymbol) {\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\n        }\n        return x.symbol;\n    }\n}\n\n\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\n    for (let i = state.scopes.length - 1; i > 0; i--) {\n        const localScope: SxScope = state.scopes[i];\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\n            return localScope.scope;\n        }\n        if (localScope.capturedScopes &&\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\n            return localScope.capturedScopes[x.symbol];\n        }\n        if (! localScope.isBlockLocal) {\n            break;\n        }\n    }\n    const globalScope = getGlobalScope(state);\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\n        return globalScope.scope;\n    }\n    return nullIfNotDefined ? null : getScope(state).scope;\n}\n\n\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\n    const scope = resolveValueSymbolScope(state, x, true);\n    if (scope) {\n        return scope[x.symbol];\n    }\n    const symInfo = state.symbolMap.get(x.symbol);\n    if (symInfo) {\n        return symInfo.fn(state, x.symbol);\n    } else {\n        if (state.config.valueSymbolResolverFallback) {\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\n        }\n        if (state.config.raiseOnUnresolvedSymbol) {\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\n        }\n        return x.symbol;\n    }\n}\n\n\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\n    const capturedScopes: CapturedScopes = {};\n    for (const n of names) {\n        const scope = resolveValueSymbolScope(state, n, true);\n        if (scope === null) {\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\n        }\n        checkUnsafeVarNamesEx('collectCapturedVariables', capturedScopes, n.symbol);\n        capturedScopes[n.symbol] = scope;\n    }\n    return capturedScopes;\n}\n\n\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\n    const a: CapturedScopes[] = [];\n    for (let i = state.scopes.length - 1; i > 0; i--) {\n        const localScope: SxScope = state.scopes[i];\n        if (localScope.capturedScopes) {\n            a.unshift(localScope.capturedScopes);\n        }\n        if (! localScope.isBlockLocal) {\n            break;\n        }\n    }\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\n}\n\n\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\n}\n\n\nexport function uninstallScope(state: SxParserState): any {\n    if (state.scopes.length < 2) {\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\n    }\n    return state.scopes.pop();\n}\n\n\nexport function getScope(state: SxParserState) {\n    return state.scopes[state.scopes.length - 1];\n}\n\n\nexport function getGlobalScope(state: SxParserState) {\n    return state.scopes[0];\n}\n\n\nexport function matchMacroArgs(\n        state: SxParserState, macroName: string,\n        formalArgs: SxSymbol[], lastIsSpread: boolean, actualArgs: SxToken[]) {\n\n    formalArgs = formalArgs.slice(0);\n    actualArgs = actualArgs.slice(0);\n    if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\n        return ({ error: `[SX] macro call (${macroName}): Actual args too short: actual ${\n            actualArgs.length} / formal ${formalArgs.length}.` });\n    }\n    for (let i = formalArgs.length - (lastIsSpread ? 2 : 1); i >= 0; i--) {\n        let nm = formalArgs[i].symbol;\n        if (nm.startsWith('!')) {\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1);\n            nm = formalArgs[i].symbol;\n\n            if (! isSymbol(actualArgs[i])) {\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\n            }\n        } else if (nm.startsWith('<') && nm.endsWith('>')) {\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1, -1);\n            nm = formalArgs[i].symbol;\n\n            if (isSymbol(actualArgs[i], nm)) {\n                formalArgs = formalArgs.slice(0, i).concat(formalArgs.slice(i + 1));\n                actualArgs = actualArgs.slice(0, i).concat(actualArgs.slice(i + 1));\n            } else {\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not expected symbol.` });\n            }\n        } else {\n            const tpos = nm.lastIndexOf(':');\n            if (0 < tpos) {\n                const tname = nm.slice(tpos + 1);\n                switch (tname) {\n                case 'number':\n                    if (typeof actualArgs[i] !== 'number') {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not number.` });\n                    }\n                    break;\n                case 'string':\n                    if (typeof actualArgs[i] !== 'string') {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not string.` });\n                    }\n                    break;\n                case 'function':\n                    if (! (Array.isArray(actualArgs[i]) && isSymbol((actualArgs[i] as any)[0]))) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not function.` });\n                    }\n                    break;\n                case 'list':\n                    if (! Array.isArray(actualArgs[i])) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not list.` });\n                    }\n                    break;\n                case 'symbol':\n                    if (! isSymbol(actualArgs[i])) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\n                    }\n                    break;\n                case 'any':\n                    break;\n                default:\n                    return ({ error: `[SX] macro call (${macroName}): Formal arg(${i}: ${nm}) is unknown type ${tname}.` });\n                }\n                formalArgs[i].symbol = formalArgs[i].symbol.slice(0, tpos);\n            }\n        }\n    }\n    return ({ formalArgs, actualArgs });\n}\n\n\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //    formalArgs: 'sym1 ... 'symN\n    //        fnBody: 'expr1 ... 'exprN\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\n        const front = fnBody.slice(0, fnBody.length - 1);\n        const tail = fnBody[fnBody.length - 1];\n        if (tail && (typeof tail[0] === 'object') && tail[0].symbol === state.config.reservedNames.if) {\n            // S expression: ($if cond t-expr f-expr)\n            if (Array.isArray(tail[3]) && (typeof tail[3][0] === 'object') && tail[3][0].symbol === state.config.reservedNames.self) {\n                // S expression (recursive):\n                //     (                                 ;; fnBody\n                //         expr1 ... exprN-1             ;; front\n                //         ($if cond                     ;; tail[0] [1]\n                //             t-expr                    ;;     [2]\n                //             ($self                    ;;     [3]\n                //                 rArgs1 ... rArgsN) )  ;; tail[4] ... [N+4]\n                //     )\n                //\n                //  -> S exp (tail call optimization):\n                //     (                                                                  ;; fnBody\n                //         ($until cond                                                   ;; tail[1]\n                //             ($clisp-let (tempsym1 ... tempsymN)                        ;;\n                //                 expr1 ... exprN-1                                      ;; front\n                //                 ($set tempsym1   rArgs1) ... ($set tempsymN   rArgsN)  ;; tail[4] ... [N+4]\n                //                 ($set     sym1 tempsym1) ... ($set     symN tempsymN)  ;;\n                //             )                                                          ;;\n                //         )                                                              ;;\n                //         expr1 ... exprN-1                                              ;; front\n                //         t-expr                                                         ;; tail[2]\n                //     )\n\n                const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\n                const tempVarsSyms = formalArgs.map((a, idx) => ({symbol: `${varBaseName}_$i${idx}_${a.symbol}`}));\n\n                return [\n                    [{symbol: state.config.reservedNames.until}, tail[1],\n                        [{symbol: state.config.reservedNames.let}, [...tempVarsSyms],\n                            ...front,\n                            ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\n                                [{symbol: state.config.reservedNames.set}, tempVarsSyms[idx], x])),\n                            ...(tempVarsSyms.map((x, idx) =>\n                                [{symbol: state.config.reservedNames.set}, formalArgs[idx], x])),\n                        ],\n                    ],\n                    ...front,\n                    tail[2],\n                ];\n            }\n        }\n    }\n    return fnBody;\n}\n\n\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\n    setEvaluationCount(state);\n\n    if (x === null || x === void 0) {\n        return x;\n    }\n    let r: SxToken = x;\n\n    for (;;) {\n        if (Array.isArray(r)) {\n            if (r.length === 0) {\n                return r;\n            }\n            r = resolveSplice(state, r);\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                const m = resolveMacro(state, sym, r);\n                if (m) {\n                    r = m.fn(m.actualArgs as SxToken[]);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        setEvaluationCount(state);\n    }\n\n    if (Array.isArray(r)) {\n        r = r.slice(0);\n        if (0 < r.length) {\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                if (sym.symbol === state.config.reservedNames.quote) {\n                    return r.slice(1, 2)[0];\n                }\n                if (sym.symbol === state.config.reservedNames.backquote) {\n                    r = r.slice(1, 2)[0];\n                    if (Array.isArray(r)) {\n                        r = resolveUnquote(state, r);\n                    }\n                    return r;\n                }\n                if (sym.symbol === state.config.reservedNames.eval) {\n                    return evaluate(state, evaluate(state, r.slice(1, 2)[0]));\n                }\n            }\n\n            const sprs = [];\n            for (let i = 1; i < r.length; i++) {\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\n                if (symSpr) {\n                    sprs.push(i);\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\n                    r[i] = Array.isArray(a) ? a : [a];\n                } else {\n                    r[i] = evaluate(state, r[i]);\n                }\n            }\n            for (const i of sprs.reverse()) {\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\n            }\n\n            let fn: any;\n            if (typeof r[0] === 'function') {\n                fn = r[0];\n            } else if (sym) {\n                fn = resolveFunctionSymbol(state, sym);\n            } else {\n                fn = evaluate(state, r[0]);\n            }\n\n            if (typeof fn === 'function') {\n                r = (fn as any)(...(r.slice(1)));\n            } else {\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\n            }\n        }\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\n        r = (r as SxExternalValue).value;\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\n        r = resolveValueSymbol(state, r as SxSymbol);\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\n        const car = evaluate(state, (r as SxDottedPair).car);\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\n        if (Array.isArray(cdr)) {\n            const a = (cdr as any[]).slice(0);\n            a.unshift(car);\n            r = a;\n        } else {\n            r = { car, cdr };\n        }\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\n        r = [\n            evaluate(state, (r as SxDottedFragment).dotted),\n        ];\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\n        r = [];\n    }\n\n    return r;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxFuncInfo,\n         SxSymbolInfo,\n         SxParserConfig,\n         SxParserState,\n         SxToken,\n         SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from '../types';\nimport { parse }                      from '../parser';\nimport { evaluate }                   from '../evaluate';\nimport { defaultConfig }              from '../defaults';\n\n\n\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\n    return {\n        strings: typeof strings === 'string' ? [strings] : strings,\n        values: values || [],\n\n        index: 0,\n        pos: 0,\n        line: 0,\n\n        evalCount: 0,\n\n        scopes: [{isBlockLocal: false, scope: globals}],\n\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\n\n        config,\n    };\n}\n\n\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\n    state.strings = typeof strings === 'string' ? [strings] : strings;\n    state.values = values || [];\n    state.index = 0;\n    state.pos = 0;\n    state.line = 0;\n    state.evalCount = 0;\n    return state;\n}\n\n\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\n    let config = conf || Object.assign({}, defaultConfig);\n    let globalScope: any = {};\n    let startup: SxToken[] = [];\n\n    const exec = (state: SxParserState, s: SxToken[]) => {\n        if (config.enableEvaluate) {\n            for (let i = 0; i < s.length; i++) {\n                s[i] = evaluate(state, s[i]);\n            }\n        }\n\n        if (config.returnMultipleRoot) {\n            return s.length === 1 ? s[0] : s;\n        } else {\n            return s[s.length - 1];\n        }\n    };\n\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        return exec(state, startup.concat(parse(state)));\n    }) as any;\n\n    f.evaluateAST = (ast: SxToken[]) => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        return exec(state, startup.concat(ast));\n    };\n    (f as any).repl = () => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        exec(state, startup.slice(0));\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return exec(state, parse(state));\n        }) as any;\n        (fRepl as any).sync = fRepl;\n        return fRepl;\n    };\n    f.setGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globals || {});\n        return f;\n    };\n    f.appendGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globalScope, globals || {});\n        return f;\n    };\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = parse(state);\n        return f;\n    };\n    f.setStartupAST = (ast: SxToken[]) => {\n        startup = ast;\n        return f;\n    };\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = startup.concat(parse(state));\n        return f;\n    };\n    f.appendStartupAST = (ast: SxToken[]) => {\n        startup = startup.concat(ast);\n        return f;\n    };\n    f.install = (installer) => {\n        config = installer(config);\n        return f;\n    };\n\n    return f;\n}\n\n\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\n    let config = conf || Object.assign({}, defaultConfig);\n    let globalScope: any = {};\n    let startup: SxToken[] = [];\n\n    const exec = async (state: SxParserState, s: SxToken[]) => {\n        if (config.enableEvaluate) {\n            for (let i = 0; i < s.length; i++) {\n                s[i] = evaluate(state, s[i]);\n\n                if (typeof s[i] === 'object' && s[i] !== null && typeof (s[i] as any).then === 'function') {\n                    s[i] = await s[i];\n                }\n            }\n        }\n\n        if (config.returnMultipleRoot) {\n            return s.length === 1 ? s[0] : s;\n        } else {\n            return s[s.length - 1];\n        }\n    };\n\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        return exec(state, startup.concat(parse(state)));\n    }) as any;\n\n    f.evaluateAST = (ast: SxToken[]) => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        return exec(state, startup.concat(ast));\n    };\n    (f as any).repl = () => {\n        const execSync = (stat: SxParserState, s: SxToken[]) => {\n            if (config.enableEvaluate) {\n                for (let i = 0; i < s.length; i++) {\n                    s[i] = evaluate(stat, s[i]);\n                }\n            }\n\n            if (config.returnMultipleRoot) {\n                return s.length === 1 ? s[0] : s;\n            } else {\n                return s[s.length - 1];\n            }\n        };\n        const state = initState(config, Object.assign({}, globalScope), '');\n        exec(state, startup.slice(0));\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return exec(state, parse(state));\n        }) as any;\n        const fReplSync: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return execSync(state, parse(state));\n        }) as any;\n        (fRepl as any).sync = fReplSync;\n        return fRepl;\n    };\n    f.setGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globals || {});\n        return f;\n    };\n    f.appendGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globalScope, globals || {});\n        return f;\n    };\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = parse(state);\n        return f;\n    };\n    f.setStartupAST = (ast: SxToken[]) => {\n        startup = ast;\n        return f;\n    };\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = startup.concat(parse(state));\n        return f;\n    };\n    f.appendStartupAST = (ast: SxToken[]) => {\n        startup = startup.concat(ast);\n        return f;\n    };\n    f.install = (installer) => {\n        config = installer(config);\n        return f;\n    };\n\n    return f;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig }   from '../../types';\nimport installCore          from '../../operators/core';\nimport installArithmetic    from '../../operators/arithmetic';\nimport installSequence      from '../../operators/sequence';\nimport installConcurrent    from '../../operators/concurrent';\nimport { SExpression,\n         SExpressionAsync } from '../../interpreters';\nimport { defaultConfig }    from '../../defaults';\n\n\n\nexport const L = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n\n    return SExpression(config);\n})();\n\nexport const LS = L;\nexport const lisp = L;\n\n\n\n// tslint:disable-next-line:variable-name\nexport const L_async = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n\n    return SExpressionAsync(config);\n})();\n\n// tslint:disable-next-line:variable-name\nexport const LS_async = L_async;\n// tslint:disable-next-line:variable-name\nexport const lisp_async = L_async;\n\n\n\nexport const LM = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n    config.returnMultipleRoot = true;\n\n    return SExpression(config);\n})();\n\n\n\n// tslint:disable-next-line:variable-name\nexport const LM_async = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n    config.returnMultipleRoot = true;\n\n    return SExpressionAsync(config);\n})();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig,\n         SxToken,\n         LsxConfig,\n         SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from '../../types';\nimport installCore          from '../../operators/core';\nimport installArithmetic    from '../../operators/arithmetic';\nimport installSequence      from '../../operators/sequence';\nimport installJsx           from '../../operators/jsx';\nimport installConcurrent    from '../../operators/concurrent';\nimport { SExpression,\n         SExpressionAsync } from '../../interpreters';\nimport { defaultConfig }    from '../../defaults';\n\n\n\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n    config = installJsx(config, lsxConf);\n\n    config.stripComments = true;\n\n    return SExpression(config) as any;\n}\n\n\n\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n    config = installJsx(config, lsxConf);\n\n    config.stripComments = true;\n\n    return SExpressionAsync(config) as any;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport { SExpression }    from '../../interpreters';\nimport { defaultConfig }  from '../../defaults';\n\n\n\nexport const S = (() => {\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config.enableEvaluate = false;\n    config.returnMultipleRoot = true;\n\n    return SExpression(config);\n})();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { toNumber }          from '../../evaluate';\nimport { checkParamsLength } from '../../errors';\nimport { $$first,\n         $$firstAndSecond }  from '../core/core.fn';\n\n\n\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (<< number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitLShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car << cdr : 0;\n    } else {\n        return cdr > -32 ? car >>> (-cdr) : 0;\n    }\n};\nexport const $$bitLShift = $bitLShift(null as any, null as any);\n\n\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>> number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitSRShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\n    } else {\n        return cdr > -32 ? car << (-cdr) : 0;\n    }\n};\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\n\n\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>>> number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitURShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car >>> cdr : 0;\n    } else {\n        return cdr > -32 ? car << (-cdr) : 0;\n    }\n};\nexport const $$bitURShift = $bitURShift(null as any, null as any);\n\n\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-not number)\n    //  -> S expr  : number\n    checkParamsLength('$bitNot', args, 1, 1);\n\n    const car = $$first(...args);\n    return ~toNumber(car);\n};\nexport const $$bitNot = $bitNot(null as any, null as any);\n\n\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-and numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitAnd', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\n};\nexport const $$bitAnd = $bitAnd(null as any, null as any);\n\n\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-or numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitOr', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\n};\nexport const $$bitOr = $bitOr(null as any, null as any);\n\n\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-xor numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitXor', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\n};\nexport const $$bitXor = $bitXor(null as any, null as any);\n\n\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (+ number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$add', args, 1);\n\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\n};\nexport const $$add = $add(null as any, null as any);\n\n\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (- number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$sub', args, 1);\n\n    const car = $$first(...args);\n    const last = args.slice(1);\n    if (last.length === 0) {\n        // negate\n        return -toNumber(car);\n    } else {\n        // subtract\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\n    }\n};\nexport const $$sub = $sub(null as any, null as any);\n\n\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (* number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$mul', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\n};\nexport const $$mul = $mul(null as any, null as any);\n\n\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (** number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$sup', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\n};\nexport const $$sup = $sup(null as any, null as any);\n\n\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (/ number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$div', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\n};\nexport const $$div = $div(null as any, null as any);\n\n\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (% number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$mod', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\n};\nexport const $$mod = $mod(null as any, null as any);\n\n\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($max val1 ... valN)\n    //  -> S expr  : value\n    return Math.max(...(args.map(x => toNumber(x))));\n};\nexport const $$max = $max(null as any, null as any);\n\n\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($min val1 ... valN)\n    //  -> S expr  : value\n    return Math.min(...(args.map(x => toNumber(x))));\n};\nexport const $$min = $min(null as any, null as any);\n\n\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($avg val1 ... valN)\n    //  -> S expr  : value\n    const a = args.map(x => toNumber(x));\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\n};\nexport const $$avg = $avg(null as any, null as any);\n\n\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($floor number)\n    //  -> S expr  : number\n    checkParamsLength('$floor', args, 1, 1);\n\n    return Math.floor(toNumber($$first(...args)));\n};\nexport const $$floor = $floor(null as any, null as any);\n\n\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($ceil number)\n    //  -> S expr  : number\n    checkParamsLength('$ceil', args, 1, 1);\n\n    return Math.ceil(toNumber($$first(...args)));\n};\nexport const $$ceil = $ceil(null as any, null as any);\n\n\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($round number)\n    //  -> S expr  : number\n    checkParamsLength('$round', args, 1, 1);\n\n    return Math.round(toNumber($$first(...args)));\n};\nexport const $$round = $round(null as any, null as any);\n\n\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($abs number)\n    //  -> S expr  : number\n    checkParamsLength('$abs', args, 1, 1);\n\n    return Math.abs(toNumber($$first(...args)));\n};\nexport const $$abs = $abs(null as any, null as any);\n\n\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sign number)\n    //  -> S expr  : number\n    checkParamsLength('$sign', args, 1, 1);\n\n    return Math.sign(toNumber($$first(...args)));\n};\nexport const $$sign = $sign(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { isSymbol,\n         quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$incl',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($incl name)\n        //  -> S expr  : ($set name ($add name 1))\n        checkParamsLength('$incl', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], 1],\n        ];\n    },\n}, {\n    name: '++',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (++ name)\n        //  -> S expr  : ($set name ($add name 1))\n        checkParamsLength('++', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], 1],\n        ];\n    },\n}, {\n    name: '$decl',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($decl name)\n        //  -> S expr  : ($set name ($add name -1))\n        checkParamsLength('$decl', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -1],\n        ];\n    },\n}, {\n    name: '--',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (-- name)\n        //  -> S expr  : ($set name ($add name -1))\n        checkParamsLength('--', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -1],\n        ];\n    },\n}, {\n    name: '$incln',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($incln name v)\n        //  -> S expr  : ($set name ($add name v))\n        checkParamsLength('$incln', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] $incln: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], list[2]],\n        ];\n    },\n}, {\n    name: '+=',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (++ name v)\n        //  -> S expr  : ($set name ($add name v))\n        checkParamsLength('+=', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] +=: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], list[2]],\n        ];\n    },\n}, {\n    name: '$decln',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($decln name v)\n        //  -> S expr  : ($set name ($add name -v))\n        checkParamsLength('$decln', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] $decln: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\n        ];\n    },\n}, {\n    name: '-=',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (-- name)\n        //  -> S expr  : ($set name ($add name -v))\n        checkParamsLength('-=', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] -=: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './arithmetic.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '<<',\n    fn: ops.$bitLShift,\n}, {\n    name: '$bit-l-shift',\n    fn: ops.$bitLShift,\n}, {\n    name: '>>',\n    fn: ops.$bitSRShift,\n}, {\n    name: '$bit-sr-shift',\n    fn: ops.$bitSRShift,\n}, {\n    name: '>>>',\n    fn: ops.$bitURShift,\n}, {\n    name: '$bit-ur-shift',\n    fn: ops.$bitURShift,\n}, {\n    name: '$bit-not',\n    fn: ops.$bitNot,\n}, {\n    name: '$bit-and',\n    fn: ops.$bitAnd,\n}, {\n    name: '$bit-or',\n    fn: ops.$bitOr,\n}, {\n    name: '$bit-xor',\n    fn: ops.$bitXor,\n}, {\n    name: '+',\n    fn: ops.$add,\n}, {\n    name: '$add',\n    fn: ops.$add,\n}, {\n    name: '$sum',\n    fn: ops.$add,\n}, {\n    name: '-',\n    fn: ops.$sub,\n}, {\n    name: '$sub',\n    fn: ops.$sub,\n}, {\n    name: '$neg',\n    fn: ops.$sub,\n}, {\n    name: '*',\n    fn: ops.$mul,\n}, {\n    name: '$mul',\n    fn: ops.$mul,\n}, {\n    name: '**',\n    fn: ops.$sup,\n}, {\n    name: '$sup',\n    fn: ops.$sup,\n}, {\n    name: '/',\n    fn: ops.$div,\n}, {\n    name: '$div',\n    fn: ops.$div,\n}, {\n    name: '%',\n    fn: ops.$mod,\n}, {\n    name: '$mod',\n    fn: ops.$mod,\n}, {\n    name: '$max',\n    fn: ops.$max,\n}, {\n    name: '$min',\n    fn: ops.$min,\n}, {\n    name: '$avg',\n    fn: ops.$avg,\n}, {\n    name: '$floor',\n    fn: ops.$floor,\n}, {\n    name: '$ceil',\n    fn: ops.$ceil,\n}, {\n    name: '$round',\n    fn: ops.$round,\n}, {\n    name: '$abs',\n    fn: ops.$abs,\n}, {\n    name: '$sign',\n    fn: ops.$sign,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './arithmetic.operator';\nimport macros             from './arithmetic.macro';\nimport symbols            from './arithmetic.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { checkParamsLength } from '../../errors';\nimport { $__let,\n         $__set  }           from '../core/core.fn';\n\n\n\n// tslint:disable-next-line:variable-name\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\n    //  -> S expr  : promise\n    checkParamsLength('$__letAsync', args, 2, 2);\n\n    let promise: Promise<any> = args[1];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    promise = promise.then(v => {\n        try {\n            $__let(state, '')(args[0], v);\n            return v;\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    });\n    return promise;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__letAsync = $__letAsync(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\n    //  -> S expr  : promise\n    checkParamsLength('$__setAsync', args, 2, 2);\n\n    let promise: Promise<any> = args[1];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    promise = promise.then(v => {\n        try {\n            $__set(state, '')(args[0], v);\n            return v;\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    });\n    return promise;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__setAsync = $__setAsync(null as any, null as any);\n\n\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\n    //  -> S expr  : promise\n    checkParamsLength('$then', args, 2, 3);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    if (typeof args[2] === 'function') {\n        promise = promise.then(args[1], args[2]);\n    } else {\n        if (typeof args[1] !== 'function') {\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\n        }\n        promise = promise.then(args[1]);\n    }\n    return promise;\n};\nexport const $$then = $then(null as any, null as any);\n\n\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-all promise1 ... promiseN)\n    //  -> S expr  : promise\n    const promises: Array<Promise<any>> = args.slice(0);\n    for (let i = 0; i < promises.length; i++) {\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\n            promises[i] = Promise.resolve(promises[i]);\n        }\n    }\n    return Promise.all(promises);\n};\nexport const $$resolveAll = $resolveAll(null as any, null as any);\n\n\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-any promise1 ... promiseN)\n    //  -> S expr  : promise\n    const promises: Array<Promise<any>> = args.slice(0);\n    for (let i = 0; i < promises.length; i++) {\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\n            promises[i] = Promise.resolve(promises[i]);\n        }\n    }\n\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\n    // firstOf: This will return the value of the first fulfilled promise,\n    //          or if all reject, an array of rejection reasons.\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\n\n    return firstOf(promises);\n};\nexport const $$resolveAny = $resolveAny(null as any, null as any);\n\n\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\n    //  -> S expr  : promise\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\n    checkParamsLength('$resolvePipe', args, 1);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    const lambdas = args.slice(1);\n    for (let i = 0; i < lambdas.length; i++) {\n        if (typeof lambdas[i] !== 'function') {\n            const v = lambdas[i];\n            lambdas[i] = () => v;\n        }\n    }\n    let p = promise;\n    for (const l of lambdas) {\n        p = p.then(l);\n    }\n    return p;\n};\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\n\n\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\n    checkParamsLength('$resolveFork', args, 1);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    const lambdas = args.slice(1);\n    for (let i = 0; i < lambdas.length; i++) {\n        if (typeof lambdas[i] !== 'function') {\n            const v = lambdas[i];\n            lambdas[i] = () => v;\n        }\n    }\n\n    const resolvers = new Array(lambdas.length);\n    const rejectors = new Array(lambdas.length);\n\n    const pa: Array<Promise<any>> = [];\n    for (let i = 0; i < lambdas.length; i++) {\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\n            resolvers[i] = (v: any) => {\n                let lp: Promise<any> = lambdas[i](v);\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\n                    lp = Promise.resolve(lp);\n                }\n\n                lp\n                .then(x => resolve(x))\n                .catch(e => reject(e));\n            };\n            rejectors[i] = reject;\n        }));\n    }\n\n    promise.then(\n        v => resolvers.forEach(f => f(v)),\n        e => rejectors.forEach(f => f(e))\n    );\n\n    return pa;\n};\nexport const $$resolveFork = $resolveFork(null as any, null as any);\n\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$let-async',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let-async nameStrOrSymbol promise)\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\n        checkParamsLength('$let-async', list, 3, 3);\n\n        return [{symbol: '$__let-async'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$set-async',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\n        checkParamsLength('$set-async', list, 3, 3);\n\n        return [{symbol: '$__set-async'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './concurrent.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$__let-async',\n    fn: ops.$__letAsync,\n}, {\n    name: '$__set-async',\n    fn: ops.$__setAsync,\n}, {\n    name: '$then',\n    fn: ops.$then,\n}, {\n    name: '$resolve-all',\n    fn: ops.$resolveAll,\n}, {\n    name: '$resolve-any',\n    fn: ops.$resolveAny,\n}, {\n    name: '$resolve-pipe',\n    fn: ops.$resolvePipe,\n}, {\n    name: '$resolve-fork',\n    fn: ops.$resolveFork,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './concurrent.operator';\nimport macros             from './concurrent.macro';\nimport symbols            from './concurrent.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         FatalError,\n         CapturedScopes,\n         SxMacroInfo }           from '../../types';\nimport { globalObj }             from '../../consts';\nimport { isSymbol,\n         quote }                 from '../../ast';\nimport { evaluate,\n         resolveValueSymbolScope,\n         collectCapturedVariables,\n         getCapturedScopes,\n         getScope,\n         getGlobalScope,\n         installScope,\n         uninstallScope,\n         optimizeTailCall,\n         toNumber }              from '../../evaluate';\nimport { compileLambda }         from '../../compile';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx } from '../../errors';\n\n\n\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($car '(first second ... last))\n    //  -> S expr  : first\n    checkParamsLength('$car', args, 1, 1);\n\n    const car = $$first(...args);\n    if (! Array.isArray(car)) {\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\n    }\n    if (car.length === 0) {\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\n    }\n    return car[0];\n};\nexport const $$car = $car(null as any, null as any);\n\n\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($cdr '(first second ... last))\n    //  -> S expr  : (second ... last)\n    checkParamsLength('$cdr', args, 1, 1);\n\n    const car = $$first(...args);\n    if (! Array.isArray(car)) {\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is not array.`);\n    }\n    if (car.length === 0) {\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is nil.`);\n    }\n    return car.slice(1);\n};\nexport const $$cdr = $cdr(null as any, null as any);\n\n\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\n    //  -> S expr  : (arg1 arg2-item1 ...)\n    // S expression: ($cons arg1 nilOrNull ... argN)\n    //  -> S expr  : (arg1)\n    // S expression: ($cons arg1 arg2 ... argN)\n    //  -> S expr  : arg1.arg2\n    checkParamsLength('$cons', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    if (car === null) {\n        car = [];\n    }\n    if (cdr === null) {\n        cdr = [];\n    }\n\n    if (Array.isArray(cdr)) {\n        cdr = cdr.slice(0);\n        cdr.unshift(car);\n        return cdr;\n    } else {\n        return {car, cdr};\n    }\n};\nexport const $$cons = $cons(null as any, null as any);\n\n\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($first first second ... last)\n    //  -> S expr  : first\n    // S expression: ($first)\n    //  -> S expr  : null\n    const car: any = args.slice(0, 1);\n    return (car.length === 1) ? car[0] : null;\n};\nexport const $$first = $first(null as any, null as any);\n\n\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($second first second ... last)\n    //  -> S expr  : second\n    // S expression: ($second first)\n    //  -> S expr  : null\n    const cdr: any = args.slice(1, 2);\n    return (cdr.length === 1) ? cdr[0] : null;\n};\nexport const $$second = $second(null as any, null as any);\n\n\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($last first second ... last)\n    //  -> S expr  : last\n    // S expression: ($last)\n    //  -> S expr  : null\n    const car: any = args.slice(args.length - 1, args.length);\n    return (car.length === 1) ? car[0] : null;\n};\nexport const $$last = $last(null as any, null as any);\n\n\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($rest first second ... last)\n    //  -> S expr  : (second ... last)\n    // S expression: ($rest first)\n    //  -> S expr  : null\n    const cdr: any = args.slice(1);\n    return (0 < cdr.length) ? cdr : null;\n};\nexport const $$rest = $rest(null as any, null as any);\n\n\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($first-and-second first second ... last)\n    //  -> S expr  : first.second\n    let car: any = args.slice(0, 1);\n    car = (car.length === 1) ? car[0] : null;\n\n    let cdr: any = args.slice(1, 2);\n    cdr = (cdr.length === 1) ? cdr[0] : null;\n\n    return {car, cdr};\n};\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\n\n\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($atom arg1 ...)\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\n    //  -> (if arg1 is nil or anything else) S expr  : true\n    checkParamsLength('$atom', args, 1, 1);\n\n    const car = $$first(...args);\n\n    if (car === null || car === void 0) {\n        return true;\n    }\n    if (Array.isArray(car)) {\n        if (car.length === 0) return  true;\n        else                  return false;\n    }\n\n    switch (typeof car) {\n    case 'number': case 'string': case 'function': case 'boolean':\n        return true;\n    case 'object':\n        return isSymbol(car) ? true : false;\n    }\n    return false;\n};\nexport const $$atom = $atom(null as any, null as any);\n\n\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($eq arg1 arg2)\n    //  -> (if arg1 === arg2)  S expr  : true\n    //  -> (else)              S expr  : false\n    checkParamsLength('$eq', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return car === cdr;\n};\nexport const $$eq = $eq(null as any, null as any);\n\n\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($not-eq arg1 arg2)\n    //  -> (if arg1 !== arg2)  S expr  : true\n    //  -> (else)              S expr  : false\n    checkParamsLength('$notEq', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return car !== cdr;\n};\nexport const $$notEq = $notEq(null as any, null as any);\n\n\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\n    // S expression: ($list arg1 ... argN)\n    //  -> S expr  : (arg1 ... argN)\n    args.slice(0);\nexport const $$list = $list(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n    //  -> (else)               S expr  : exprN\n    checkParamsLength('$__scope', args, 3);\n\n    const isBlockLocal = $$first(...args);\n    const returnMultiple = $$second(...args);\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\n    let r: SxToken = null;\n\n    const scope: any = {};\n    if (Array.isArray(car)) {\n        for (const x of car) {\n            if (Array.isArray(x)) {\n                const kv = $$firstAndSecond(...x);\n                const kvSym = isSymbol(kv.car);\n                const kvName = kvSym ? kvSym.symbol : String(kv.car);\n                checkUnsafeVarNamesEx('$__scope', scope, kvName);\n                scope[kvName] = evaluate(state, kv.cdr);\n            } else {\n                const xSym = isSymbol(x);\n                const xName = xSym ? xSym.symbol : String(x);\n                checkUnsafeVarNamesEx('$__scope', scope, xName);\n                scope[xName] = null;\n            }\n        }\n    }\n    installScope(state, scope, isBlockLocal, capturedScopes);\n\n    try {\n        if (4 < args.length) {\n            if (returnMultiple) {\n                r = [];\n                for (const x of args.slice(3)) {\n                    r.push(evaluate(state, x));\n                }\n            } else {\n                for (const x of args.slice(3)) {\n                    r = evaluate(state, x);\n                }\n            }\n        } else {\n            r = evaluate(state, cdr);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n    //  -> (else)               S expr  : exprN\n    checkParamsLength('$__globalScope', args, 1);\n\n    const returnMultiple = $$first(...args);\n    const cdr = $$second(...args);\n    let r: SxToken = null;\n\n    installScope(state, getGlobalScope(state).scope, true);\n    try {\n        if (2 < args.length) {\n            if (returnMultiple) {\n                r = [];\n                for (const x of args.slice(1)) {\n                    r.push(evaluate(state, x));\n                }\n            } else {\n                for (const x of args.slice(1)) {\n                    r = evaluate(state, x);\n                }\n            }\n        } else {\n            r = evaluate(state, cdr);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : exprN\n    checkParamsLength('$__capture', args, 1);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let r: SxToken = null;\n\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\n    installScope(state, {}, true, capturedScopes);\n    try {\n        for (const x of args.slice(1)) {\n            r = evaluate(state, x);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : fn\n    checkParamsLength('$__lambda', args, 2);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    let fnBody = args.slice(1);\n    if (state.config.enableTailCallOptimization) {\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\n    }\n\n    const capturedScopes = getCapturedScopes(state);\n\n    const fn = function(this: any, ...actualArgs: any[]) {\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\n            throw new Error(`[SX] func call: Actual args too short: actual ${\n                actualArgs.length} / formal ${formalArgs.length}.`);\n        }\n        // TODO: add type checking\n        return $__scope(state, name, capturedScopes)(false, false, [\n            [state.config.reservedNames.self, fn],\n            [state.config.reservedNames.thiz, this === globalObj || this === void 0 ? null : quote(state, this)],\n            ...(formalArgs.map((x: SxSymbol, index) => [\n                x.symbol,\n                quote(state,\n                    (lastIsSpread && index === formalArgs.length - 1) ?\n                        actualArgs.slice(index) : actualArgs[index]\n                )\n            ])),\n        ], ...fnBody);\n    };\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $comp$__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : fn\n    checkParamsLength('$$__lambda', args, 2);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $$__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    const fnBody = args.slice(1);\n    return compileLambda(state, formalArgs, lastIsSpread, fnBody);\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$__defun', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const fn = $__lambda(state, name)(...args.slice(1));\n\n    checkUnsafeVarNamesEx('$__defun', state.funcMap, car.symbol);\n    // TODO: overloading\n    state.funcMap.set(car.symbol, {\n        name: car.symbol,\n        fn: (st, nm) => fn,\n        // formalArgs: ,\n        // lastIsSpread: ,\n        // next: ,\n    });\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $comp$__defun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$$__defun', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const fn = $comp$__lambda(state, name)(...args.slice(1));\n\n    checkUnsafeVarNamesEx('$$__defun', state.funcMap, car.symbol);\n    // TODO: overloading\n    state.funcMap.set(car.symbol, {\n        name: car.symbol,\n        fn: (st, nm) => fn,\n        // formalArgs: ,\n        // lastIsSpread: ,\n        // next: ,\n    });\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($refun 'name)\n    //  -> S expr  : fn\n    checkParamsLength('$__refun', args, 1, 1);\n\n    const car: SxSymbol = $$first(...args);\n\n    checkUnsafeVarNamesEx('$__refun', state.funcMap, car.symbol);\n    const info = state.funcMap.get(car.symbol);\n    if (!info) {\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\n    }\n    return info.fn(state, car.symbol);\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__defmacro = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$__defmacro', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const formalArgs: SxSymbol[] = args[1];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__defmacro: Invalid argument(s): args[1] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    const fnBody = args.slice(2);\n    const capturedScopes = getCapturedScopes(state);\n\n    const fn = (fArgs: SxSymbol[]) => (...aArgs: any[]) => {\n        return $__scope(state, name, capturedScopes)(false, false, [\n            [state.config.reservedNames.self, fn],\n            ...(fArgs.map((x: SxSymbol, index) => [\n                x.symbol,\n                quote(state,\n                    (lastIsSpread && index === fArgs.length - 1) ?\n                        aArgs.slice(index) : aArgs[index]\n                )\n            ])),\n        ], ...fnBody);\n    };\n\n    const m: SxMacroInfo = {\n        name: car.symbol,\n        fn: (st: SxParserState, nm: string, fArgs: SxSymbol[]) => (list: SxToken[]) => fn(fArgs)(...(list.slice(1))),\n        formalArgs,\n        lastIsSpread,\n    };\n\n    checkUnsafeVarNamesEx('$__defmacro', state.macroMap, car.symbol);\n\n    if (state.macroMap.has(car.symbol)) {\n        let curr = state.macroMap.get(car.symbol);\n        (curr as SxMacroInfo).next = m;\n        if (curr && curr.formalArgs) {\n            if (curr.formalArgs.length < formalArgs.length) {\n                state.macroMap.set(car.symbol, m);\n                m.next = curr;\n            } else {\n                let prev = curr;\n                curr = curr.next;\n                while (curr) {\n                    if (curr.formalArgs) {\n                        if (curr.formalArgs.length < formalArgs.length) {\n                            prev.next = m;\n                            m.next = curr;\n                            break;\n                        }\n                    }\n                    prev = curr;\n                    curr = curr.next;\n                }\n            }\n        }\n    } else {\n        state.macroMap.set(car.symbol, m);\n    }\n    return fn;\n};\n\n\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($apply fn arg1 ... argN)\n    //  -> S expr  : fn'\n    checkParamsLength('$apply', args, 1);\n\n    const car: () => any = $$first(...args);\n    if (typeof car !== 'function') {\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\n    }\n\n    return (\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\n    );\n};\nexport const $$apply = $apply(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\n    //  -> S expr  : fn\n    checkParamsLength('$__call', args, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    const sym = isSymbol(cdr);\n    const xName = sym ? sym.symbol : evaluate(state, cdr) as any;\n\n    checkUnsafeVarNamesEx('$__call', car, xName);\n\n    return Function.prototype.apply.call(\n        car[xName],\n        car,\n        args.slice(2)\n    );\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__try 'expr 'catch-expr)\n    //  ->                               S expr  : expr\n    //  -> (if error is raised in expr)  S expr  : catch-expr\n    checkParamsLength('$__try', args, 1, 2);\n\n    let r: SxToken = [];\n    try {\n        r = evaluate(state, args[0]);\n    } catch (e) {\n        if (e instanceof FatalError) {\n            throw e;\n        }\n        if (1 < args.length) {\n            r = $__scope(state, name)(true, false, [\n                ['$error', quote(state, e)],\n                ['$parent', quote(state, getScope(state))],\n            ], args[1]);\n        } else {\n            r = null;\n        }\n    }\n    return r;\n};\n\n\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($raise 'expr)\n    //  -> S expr  : -\n    const car = $$first(...args);\n    throw car;\n};\nexport const $$raise = $raise(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__if condition 't-expr 'f-expr)\n    //  -> (if condition is true ) S expr  : t-expr\n    //  -> (if condition is false) S expr  : f-expr\n    checkParamsLength('$__if', args, 2, 3);\n\n    const car = $$first(...args);\n    let r: SxToken = [];\n    if ($$boolean(car)) {\n        r = evaluate(state, args[1]);\n    } else {\n        if (2 < args.length) {\n            r = evaluate(state, args[2]);\n        } else {\n            r = null;\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__if-null condition 'null-expr)\n    //  -> (if condition is not null ) S expr  : condition\n    //  -> (if condition is null)      S expr  : null-expr\n    checkParamsLength('$__ifNull', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    let r: SxToken = [];\n    if (! $$ambiguousEq(car, null)) {\n        r = car;\n    } else {\n        r = evaluate(state, cdr);\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n    //  -> (if (eval condI) is true ) S expr  : exprI\n    //  -> (if no matched)            S expr  : null\n    checkParamsLength('$__cond', args, 1);\n\n    for (let i = 0; i < args.length - 1; i += 2) {\n        const c = args[i];\n        const x = args[i + 1];\n        if ($$boolean(evaluate(state, c))) {\n            return evaluate(state, x);\n        }\n    }\n    return null;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__while', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    while ($$boolean(evaluate(state, car))) {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__doWhile', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n\n    do {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    } while ($$boolean(evaluate(state, car)));\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__until', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    while ($$not(evaluate(state, car))) {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__doUntil', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    do {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    } while ($$not(evaluate(state, car)));\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\n    //  -> (if n > 0) S expr  : exprN\n    //  -> (else)     S expr  : null\n    checkParamsLength('$__repeat', args, 2);\n\n    const sym = isSymbol($$first(...args));\n    if (! sym) {\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\n    }\n\n    checkUnsafeVarNamesEx('$__repeat', {}, sym.symbol); // NOTE: pass dummy target object.\n    const scope = resolveValueSymbolScope(state, sym, false);\n\n    const n = toNumber($$second(...args));\n    const cdr = args.slice(2);\n    let r: SxToken = null;\n    for (let i = 0; i < n; i++) {\n        scope[sym.symbol] = i;\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\n    //  -> (if list.length > 0) S expr  : exprN\n    //  -> (else)               S expr  : null\n    checkParamsLength('$__for', args, 2);\n\n    const sym = isSymbol($$first(...args));\n    if (! sym) {\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\n    }\n\n    checkUnsafeVarNamesEx('$__for', {}, sym.symbol); // NOTE: pass dummy target object.\n    const scope = resolveValueSymbolScope(state, sym, false);\n\n    const list = $$second(...args);\n    if (! Array.isArray(list)) {\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\n    }\n\n    const cdr = args.slice(2);\n    let r: SxToken = null;\n    for (const q of list) {\n        scope[sym.symbol] = q;\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__get v fn1 ... fnN)\n    //  -> S expr  : any\n    checkParamsLength('$pipe', args, 1);\n\n    let v = args[0];\n    for (let i = 1; i < args.length; i++) {\n        v = args[i](v);\n    }\n    return v;\n};\nexport const $$pipe = $pipe(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n    //  -> S expr  : any\n    checkParamsLength('$__get', args, 1);\n\n    let v: any = null;\n    let sym = isSymbol(args[0]);\n\n    if (!sym) {\n        switch (typeof args[0]) {\n        case 'string': case 'number':\n            sym = {symbol: String(args[0])};\n            break;\n        default:\n            v = evaluate(state, args[0]);\n            break;\n        }\n    }\n\n    if (sym) {\n        const scope = resolveValueSymbolScope(state, sym, true);\n        if (! scope) {\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\n        }\n        v = scope[sym.symbol];\n    }\n\n    for (let i = 1; i < args.length; i++) {\n        let q: any = args[i];\n        let inprog = true;\n        while (inprog) {\n            switch (typeof q) {\n            case 'function':\n                v = q(v);\n                inprog = false;\n                break;\n            case 'object':\n                if (Array.isArray(q)) {\n                    q = evaluate(state, q);\n                } else {\n                    sym = isSymbol(q);\n                    if (sym) {\n                        q = sym.symbol;\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\n                        q = evaluate(state, q);\n                    } else {\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\n                    }\n                }\n                break;\n            case 'number':\n                if (q < 0) {\n                    q = v.length + q;\n                }\n                // FALL_THRU\n            case 'string':\n                checkUnsafeVarNamesEx('$__get', v, q);\n                v = v[q];\n                inprog = false;\n                break;\n            default:\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\n            }\n        }\n    }\n    return v;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__let 'nameStrOrSymbol expr)\n    //  -> S expr  : any\n    checkParamsLength('$__let', args, 2, 2);\n\n    let sym = isSymbol($$first(...args));\n\n    if (! sym) {\n        if (typeof args[0] === 'string') {\n            sym = {symbol: args[0]};\n        } else {\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\n        }\n    }\n\n    checkUnsafeVarNamesEx('$__let', {}, sym.symbol); // NOTE: pass dummy target object.\n\n    const scope = resolveValueSymbolScope(state, sym, false);\n    scope[sym.symbol] = args[1];\n\n    return args[1];\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\n    //  -> S expr  : any\n    checkParamsLength('$__set', args, 2, 2);\n\n    let path: any = [];\n\n    if (Array.isArray(args[0])) {\n        path = args[0];\n    } else {\n        path.push(args[0]);\n    }\n\n    let sym = isSymbol(path[0]);\n\n    if (! sym) {\n        if (typeof path[0] === 'string') {\n            checkUnsafeVarNamesEx('$__set', {}, path[0]); // NOTE: pass dummy target object.\n            sym = {symbol: path[0]};\n        } else {\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n        }\n    }\n\n    let scope = resolveValueSymbolScope(state, sym, true);\n    if (scope === null) {\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\n    }\n\n    let subst = false;\n\n    for (let i = 0; i < path.length; i++) {\n        let q: any = path[i];\n        let inprog = true;\n        const last = i === path.length - 1;\n        while (inprog) {\n            switch (typeof q) {\n            case 'function':\n                scope = q(scope);\n                inprog = false;\n                break;\n            case 'object':\n                if (Array.isArray(q)) {\n                    q = evaluate(state, q);\n                } else {\n                    sym = isSymbol(q);\n                    if (sym) {\n                        q = sym.symbol;\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\n                        q = evaluate(state, q);\n                    } else {\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n                    }\n                }\n                break;\n            case 'number':\n                if (q < 0) {\n                    q = scope.length + q;\n                }\n                // FALL_THRU\n            case 'string':\n                checkUnsafeVarNamesEx('$__set', scope, q);\n                if (last) {\n                    scope[q] = args[1];\n                    subst = true;\n                } else {\n                    scope = scope[q];\n                }\n                inprog = false;\n                break;\n            default:\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n            }\n        }\n    }\n\n    if (! subst) {\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\n    }\n\n    return args[1];\n};\n\n\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($boolean any)\n    //  -> S expr  : boolean\n    checkParamsLength('$boolean', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car) && car.length === 0) return false;\n    else return Boolean(car);\n};\nexport const $$boolean = $boolean(null as any, null as any);\n\n\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($not any)\n    //  -> S expr  : boolean\n    checkParamsLength('$not', args, 1, 1);\n\n    return ! $$boolean(...args);\n};\nexport const $$not = $not(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__and 'expr1 ... 'exprN)\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\n    //  -> (else)                                                     S expr  : expr-i (false left most)\n    checkParamsLength('$__and', args, 1);\n\n    let prev = null;\n    for (let i = 0; i < args.length; i++) {\n        const curr = evaluate(state, args[i]);\n        if (! $$boolean(curr)) {\n            return curr;\n        }\n        prev = curr;\n    }\n    return prev;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__and = $__and(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__or 'expr1 ... 'exprN)\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\n    //  -> (else)                                                  S expr  : expr-i (false right most)\n    checkParamsLength('$__or', args, 1);\n\n    let prev = null;\n    for (let i = 0; i < args.length; i++) {\n        const curr = evaluate(state, args[i]);\n        if ($$boolean(curr)) {\n            return curr;\n        }\n        prev = curr;\n    }\n    return prev;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__or = $__or(null as any, null as any);\n\n\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (== a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$ambiguousEq', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car) && car.length === 0) car = null;\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\n    if (car === void 0) car = null;\n    if (cdr === void 0) cdr = null;\n    // tslint:disable-next-line:triple-equals\n    return car == cdr;\n};\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\n\n\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (!= a b)\n    //  -> S expr  : boolean\n    return ! $$ambiguousEq(...args);\n};\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\n\n\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (< a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$lt', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) < toNumber(cdr);\n};\nexport const $$lt = $lt(null as any, null as any);\n\n\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (<= a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$le', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) <= toNumber(cdr);\n};\nexport const $$le = $le(null as any, null as any);\n\n\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (> a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$gt', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) > toNumber(cdr);\n};\nexport const $$gt = $gt(null as any, null as any);\n\n\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>= a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$ge', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) >= toNumber(cdr);\n};\nexport const $$ge = $ge(null as any, null as any);\n\n\nexport const $typeof = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($typeof x)\n    //  -> S expr  : 'null' | 'bigint' | 'boolean' | 'function' | 'number' | 'string' | 'undefined' |\n    //               'js-symbol' | 'list' | 'object'\n    checkParamsLength('$typeof', args, 1, 1);\n\n    const car = $$first(...args);\n    if (car === null) {\n        return 'null';\n    }\n    const tyName = typeof car;\n    switch (tyName) {\n    case 'object':\n        if (Array.isArray(car)) {\n            return 'list';\n        } else {\n            return 'object';\n        }\n    case 'symbol':\n        return 'js-symbol';\n    default:\n        return tyName;\n    }\n};\nexport const $$typeof = $typeof(null as any, null as any);\n\n\nexport const $symbol = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($symbol)\n    // S expression: ($symbol name)\n    //  -> S expr  : symbol\n    checkParamsLength('$symbol', args, 1, 1);\n\n    if (typeof args[0] === 'string') {\n        return {symbol: args[0]};\n    } else {\n        throw new Error(`[SX] $symbol: Invalid argument(s): item(s) of args[0] is not string.`);\n    }\n};\nexport const $$symbol = $symbol(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__gensym = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__gensym)\n    // S expression: ($__gensym name)\n    //  -> S expr  : symbol\n    checkParamsLength('$__gensym', args, 0, 1);\n\n    const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\n    const tempVarSym = ({symbol: `${varBaseName}_$gensym`});\n    if (args.length === 1) {\n        const a = isSymbol(args[0]);\n        if (a) {\n            $__let(state, '')(a, tempVarSym);\n        } else if (typeof args[0] === 'string') {\n            $__let(state, '')({symbol: args[0]}, tempVarSym);\n        } else {\n            throw new Error(`[SX] $__gensym: Invalid argument(s): item(s) of args[0] is not symbol.`);\n        }\n    }\n    return tempVarSym;\n};\n\n\nexport const $isSymbol = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-symbol x)\n    // S expression: ($is-symbol x name)\n    //  -> S expr  : boolean\n    checkParamsLength('$isSymbol', args, 1, 2);\n\n    if (args.length === 1) {\n        return (isSymbol(args[0]) ? true : false);\n    } else {\n        if (typeof args[1] === 'string') {\n            return (isSymbol(args[0], args[1]) ? true : false);\n        } else {\n            throw new Error(`[SX] $isSymbol: Invalid argument(s): item(s) of args[1] is not string.`);\n        }\n    }\n};\nexport const $$isSymbol = $isSymbol(null as any, null as any);\n\n\nexport const $isNull = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-null x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNull', args, 1, 1);\n\n    return $$first(...args) === null;\n};\nexport const $$isNull = $isNull(null as any, null as any);\n\n\nexport const $isNil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-nil x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNil', args, 1, 1);\n\n    const car = $$first(...args);\n    return Array.isArray(car) && car.length === 0;\n};\nexport const $$isNil = $isNil(null as any, null as any);\n\n\nexport const $isUndefined = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-undefined x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isUndefined', args, 1, 1);\n\n    return $$first(...args) === void 0;\n};\nexport const $$isUndefined = $isUndefined(null as any, null as any);\n\n\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-list x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isList', args, 1, 1);\n\n    return Array.isArray($$first(...args));\n};\nexport const $$isList = $isList(null as any, null as any);\n\n\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-string x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isString', args, 1, 1);\n\n    return typeof $$first(...args) === 'string';\n};\nexport const $$isString = $isString(null as any, null as any);\n\n\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-number x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNumber', args, 1, 1);\n\n    return typeof $$first(...args) === 'number';\n};\nexport const $$isNumber = $isNumber(null as any, null as any);\n\n\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-NaN x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNaN', args, 1, 1);\n\n    return Number.isNaN($$first(...args));\n};\nexport const $$isNaN = $isNaN(null as any, null as any);\n\n\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-finate x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isFinite', args, 1, 1);\n\n    return Number.isFinite($$first(...args));\n};\nexport const $$isFinite = $isFinite(null as any, null as any);\n\n\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-integer x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isInteger', args, 1, 1);\n\n    return Number.isInteger($$first(...args));\n};\nexport const $$isInteger = $isInteger(null as any, null as any);\n\n\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($to-string x)\n    //  -> S expr  : string\n    checkParamsLength('$toString', args, 1, 1);\n\n    return String($$first(...args));\n};\nexport const $$toString = $toString(null as any, null as any);\n\n\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($to-number x)\n    //  -> S expr  : number\n    checkParamsLength('$toNumber', args, 1, 1);\n\n    return toNumber($$first(...args));\n};\nexport const $$toNumber = $toNumber(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__# '(name value...)...)\n    //  -> JSON    : {name: value, ...}\n    const r: any = {};\n    for (const x of args) {\n        if (Array.isArray(x) && 0 < x.length) {\n            const sym = isSymbol(x[0]);\n            const keyName =\n                sym ? sym.symbol :\n                String(evaluate(state, x[0]));\n\n            checkUnsafeVarNamesEx('$__#', r, keyName);\n            if (x.length === 1) {\n                // S expression: (# ... (keyName) ...)\n                //  -> JSON    : {..., keyName: true, ...}\n                r[keyName] = true;\n            } else if (x.length === 2) {\n                // S expression: (# ... (keyName value) ...)\n                //  -> JSON    : {..., keyName: value, ...}\n                r[keyName] = evaluate(state, x[1]);\n            } else {\n                // S expression: (# ... (keyName value1 value2 ...) ...)\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\n                r[keyName] =\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                    .concat(x.slice(1)));\n            }\n        } else {\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\n        }\n    }\n    return r;\n};\n\n\nconst assignBlacklist = [\n    globalObj,\n    (Object as any).__proto__,\n    ({} as any).__proto__,\n    (Function as any).__proto__,\n];\n\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($object-assign x)\n    //  -> S expr  : string\n    checkParamsLength('$objectAssign', args, 1);\n\n    if (assignBlacklist.includes(args[0])) {\n        throw new Error(`[SX] $objectAssign: Invalid argument: args[0] is blacklisted object.`);\n    }\n    return Object.assign(args[0], ...(args.slice(1)));\n};\nexport const $$objectAssign = $objectAssign(null as any, null as any);\n\n\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($json-stringify x)\n    //  -> S expr  : string\n    checkParamsLength('$jsonStringify', args, 1, 1);\n\n    return JSON.stringify($$first(...args));\n};\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\n\n\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($json-parse x)\n    //  -> S expr  : object\n    checkParamsLength('$jsonParse', args, 1, 1);\n\n    const s = $$first(...args);\n    if (typeof s !== 'string') {\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\n    }\n    return JSON.parse(s);\n};\nexport const $$jsonParse = $jsonParse(null as any, null as any);\n\n\nexport const $now = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($now)\n    //  -> S expr  : number\n    return Date.now();\n};\nexport const $$now = $now(null as any, null as any);\n\n\nexport const $datetimeFromIso = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-from-iso str)\n    //  -> S expr  : number\n    checkParamsLength('$datetimeFromIso', args, 1, 1);\n\n    const s = $$first(...args);\n    if (typeof s !== 'string') {\n        throw new Error(`[SX] $datetimeFromIso: Invalid argument(s): args[0] is not string.`);\n    }\n    if (! /^(?:(?:-[0-9]{6,})|[0-9]{4,})-(?:[0-1][0-9])-(?:[0-3][0-9])(?:T(?:[0-2][0-9])(?:[:](?:[0-6][0-9])(?:[:](?:[0-6][0-9])(?:.[0-9]{1,})?)?)?(?:Z|[-+][0-9]{2}(?:[:]?[0-6][0-9])?)?)?$/.test(s)) {\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime (pattern unmatched): ${s}.`);\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetimeFromIso = $datetimeFromIso(null as any, null as any);\n\n\nexport const $datetime = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime year month1-12 day)\n    // S expression: ($datetime year month1-12 day hours)\n    // S expression: ($datetime year month1-12 day hours minutes)\n    // S expression: ($datetime year month1-12 day hours minutes seconds)\n    // S expression: ($datetime year month1-12 day hours minutes seconds milliseconds)\n    //  -> S expr  : number\n    checkParamsLength('$datetime', args, 3, 7);\n\n    let s = '';\n    const year = Number(args[0]);\n    if (year >= 0) {\n        s += String(year).padStart(4, '0');\n    } else {\n        s += '-' + String(-year).padStart(6, '0');\n    }\n    // month1\n    s += '-' + String(Number(args[1])).padStart(2, '0');\n    // day\n    s += '-' + String(Number(args[2])).padStart(2, '0');\n    // hours\n    if (args.length >= 4) {\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\n        // minutes\n        if (args.length >= 5) {\n            s += ':' + String(Number(args[4])).padStart(2, '0');\n        } else {\n            s += ':00';\n        }\n        // seconds\n        if (args.length >= 6) {\n            s += ':' + String(Number(args[5])).padStart(2, '0');\n        }\n        // milliseconds\n        if (args.length >= 7) {\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\n        }\n        s += 'Z';\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetime: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetime = $datetime(null as any, null as any);\n\n\nexport const $datetimeLc = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-lc year month1-12 day)\n    // S expression: ($datetime-lc year month1-12 day hours)\n    // S expression: ($datetime-lc year month1-12 day hours minutes)\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds)\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds milliseconds)\n    //  -> S expr  : number\n    checkParamsLength('$datetimeLc', args, 3, 7);\n\n    let s = '';\n    const year = Number(args[0]);\n    if (year >= 0) {\n        s += String(year).padStart(4, '0');\n    } else {\n        s += '-' + String(-year).padStart(6, '0');\n    }\n    // month1\n    s += '-' + String(Number(args[1])).padStart(2, '0');\n    // day\n    s += '-' + String(Number(args[2])).padStart(2, '0');\n    // hours\n    if (args.length >= 4) {\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\n        // minutes\n        if (args.length >= 5) {\n            s += ':' + String(Number(args[4])).padStart(2, '0');\n        } else {\n            s += ':00';\n        }\n        // seconds\n        if (args.length >= 6) {\n            s += ':' + String(Number(args[5])).padStart(2, '0');\n        }\n        // milliseconds\n        if (args.length >= 7) {\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\n        }\n    } else {\n        s += 'T00:00:00.000';\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetimeLc: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetimeLc = $datetimeLc(null as any, null as any);\n\n\nexport const $datetimeToIsoString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-iso-string number)\n    //  -> S expr  : string\n    checkParamsLength('$datetimeToIsoString', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToIsoString: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToIsoString: Invalid datetime: ${n}.`);\n    }\n    return dt.toISOString();\n};\nexport const $$datetimeToIsoString = $datetimeToIsoString(null as any, null as any);\n\n\nexport const $datetimeToComponents = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-components number)\n    //  -> S expr  : list\n    checkParamsLength('$datetimeToComponents', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToComponents: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToComponents: Invalid datetime: ${n}.`);\n    }\n    return ([\n        dt.getUTCFullYear(),\n        dt.getUTCMonth() + 1,\n        dt.getUTCDate(),\n        dt.getUTCHours(),\n        dt.getUTCMinutes(),\n        dt.getUTCSeconds(),\n        dt.getUTCMilliseconds(),\n        0, // TZ\n        dt.getUTCDay(),\n    ]);\n};\nexport const $$datetimeToComponents = $datetimeToComponents(null as any, null as any);\n\n\nexport const $datetimeToComponentsLc = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-components-lc number)\n    //  -> S expr  : list\n    checkParamsLength('$datetimeToComponentsLc', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid datetime: ${n}.`);\n    }\n    return ([\n        dt.getFullYear(),\n        dt.getMonth() + 1,\n        dt.getDate(),\n        dt.getHours(),\n        dt.getMinutes(),\n        dt.getSeconds(),\n        dt.getMilliseconds(),\n        -dt.getTimezoneOffset(), // time difference between local time and UTC time, in minutes.\n                                 // If your time zone is UTC+2:00, +120 will be returned.\n        dt.getDay(),\n    ]);\n};\nexport const $$datetimeToComponentsLc = $datetimeToComponentsLc(null as any, null as any);\n\n\nexport const $match = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($match pattern-str string)\n    // S expression: ($match pattern-str options-str string)\n    //  -> S expr  : array\n    checkParamsLength('$match', args, 2, 3);\n\n    if (! state.config.enableRegExpMatchOperators) {\n        throw new Error(`[SX] $match: Operator is disabled by configuration.`);\n    }\n\n    if (args.length === 2) {\n        const m = new RegExp(args[0]);\n        return m.exec(args[1]);\n    } else {\n        const m = new RegExp(args[0], args[1]);\n        return m.exec(args[2]);\n    }\n};\nexport const $$match = $match(null as any, null as any);\n\n\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-log expr1 ... exprN)\n    //  -> S expr  : null\n    console.log(...args);\n    return null;\n};\nexport const $$consoleLog = $consoleLog(null as any, null as any);\n\n\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-error expr1 ... exprN)\n    //  -> S expr  : null\n    console.error(...args);\n    return null;\n};\nexport const $$consoleError = $consoleError(null as any, null as any);\n\n\nexport const $consoleTrace = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-trace expr1 ... exprN)\n    //  -> S expr  : null\n    console.trace(...args);\n    return null;\n};\nexport const $$consoleTrace = $consoleTrace(null as any, null as any);\n\n\nexport const $consoleTime = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time)\n    // S expression: ($console-time label)\n    //  -> S expr  : null\n    console.time(...args);\n    return null;\n};\nexport const $$consoleTime = $consoleTime(null as any, null as any);\n\n\nexport const $consoleTimeEnd = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time-end)\n    // S expression: ($console-time-end label)\n    //  -> S expr  : null\n    console.timeEnd(...args);\n    return null;\n};\nexport const $$consoleTimeEnd = $consoleTimeEnd(null as any, null as any);\n\n\nexport const $consoleTimeLog = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time-log label)\n    // S expression: ($console-time-log label value ... value)\n    //  -> S expr  : null\n    (console as any).timeLog(...args);\n    return null;\n};\nexport const $$consoleTimeLog = $consoleTimeLog(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { isSymbol,\n         quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$scope',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            list[1],\n            list[2],\n            ...(list.slice(3).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$local',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($local ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            true,\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$global',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($__global expr1 ... exprN)\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\n        return [{symbol: '$__global'},\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$clisp-let', // alias of $local\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            true,\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$capture',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__capture'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$closure',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\n        const symUse = isSymbol(list[2], 'use');\n        if (! symUse) {\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\n        }\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\n            quote(state, list[1]),\n            ...(list.slice(4).map(x => quote(state, x))),\n        ])];\n    },\n}, {\n    name: '|->',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        return [{symbol: '$closure'},\n            ...list.slice(1),\n        ];\n    },\n}, {\n    name: '$lambda',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '->',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$defun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__defun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$refun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($refun name)\n        //  -> S expr  : ($__refun 'name)\n        return [{symbol: '$__refun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '<-',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (<- name)\n        //  -> S expr  : ($__refun 'name)\n        return [{symbol: '$__refun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$defmacro',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($defmacro name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__defmacro'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$call',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($call thisArg symbol arg1 ... argN)\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\n        checkParamsLength('$call', list, 3);\n\n        return [{symbol: '$__call'},\n            list[1],\n            quote(state, list[2]),\n            ...(list.slice(3)),\n        ];\n    },\n}, {\n    name: '$try',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($try expr catch-expr)\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\n        return [{symbol: '$__try'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$if',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($if cond t-expr f-expr)\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\n        return [{symbol: '$__if'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$if-null',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($if-null cond null-expr)\n        //  -> S expr  : ($__if-null cont 'null-expr)\n        return [{symbol: '$__if-null'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '??',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (?? cond null-expr)\n        //  -> S expr  : ($__if-null cont 'null-expr)\n        return [{symbol: '$__if-null'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$cond',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($cond cond1 expr1 ... condN exprN)\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n        return [{symbol: '$__cond'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$while',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($while condition expr1 exprN)\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\n        return [{symbol: '$__while'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$do-while',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($do-while condition expr1 exprN)\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\n        return [{symbol: '$__do-while'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$until',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($until condition expr1 exprN)\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\n        return [{symbol: '$__until'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$do-until',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($do-until condition expr1 exprN)\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\n        return [{symbol: '$__do-until'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$repeat',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($repeat i of n-times expr1 exprN)\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\n        const symOf = isSymbol(list[2], 'of');\n        if (! symOf) {\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\n        }\n        return [{symbol: '$__repeat'},\n            quote(state, list[1]),\n            list[3],\n            ...(list.slice(4).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$for',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($for x of list expr1 exprN)\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\n        const symOf = isSymbol(list[2], 'of');\n        if (! symOf) {\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\n        }\n        return [{symbol: '$__for'},\n            quote(state, list[1]),\n            list[3],\n            ...(list.slice(4).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$get',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n        return [{symbol: '$__get'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$let',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let nameStrOrSymbol expr)\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\n        checkParamsLength('$let', list, 3, 3);\n\n        return [{symbol: '$__let'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$clisp-defvar',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let nameStrOrSymbol expr)\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\n        checkParamsLength('$clisp-defvar', list, 3, 3);\n\n        return [{symbol: '$global'},\n            [{symbol: '$__let'},\n                quote(state, list[1]),\n                list[2]\n            ],\n        ];\n    },\n}, {\n    name: '$set',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($set nameOrListOfNameOrIndex expr)\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\n        checkParamsLength('$set', list, 3, 3);\n\n        return [{symbol: '$__set'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$clisp-setq', // alias of $set\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($clisp-setq symbol expr)\n        //  -> S expr  : ($__set 'symbol expr)\n        checkParamsLength('$clisp-setq', list, 3, 3);\n\n        return [{symbol: '$__set'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$and',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($and expr1 ... exprN)\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\n        return [{symbol: '$__and'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$or',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($or expr1 ... exprN)\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\n        return [{symbol: '$__or'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$gensym',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($gensym)\n        // S expression: ($gensym name)\n        //  -> S expr  : ($__gensym 'name)\n        return [\n            {symbol: '$__gensym'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '#',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (# (name value...)...)\n        //  -> S expr  : ($__# '(name value...)...)\n        return [\n            {symbol: '$__#'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\nexport const compilationMacros: SxMacroInfo[] = [{\n    name: '$$closure',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($$__lambda '(sym1 ... symN) 'expr ... 'expr) )\n        const symUse = isSymbol(list[2], 'use');\n        if (! symUse) {\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\n        }\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$$__lambda'},\n            quote(state, list[1]),\n            ...(list.slice(4).map(x => quote(state, x))),\n        ])];\n    },\n}, {\n    name: '|=>',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        return [{symbol: '$$closure'},\n            ...list.slice(1),\n        ];\n    },\n}, {\n    name: '$$lambda',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '=>',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$$defun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$defun name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__defun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\n// for backword compatibility\nexport default ([] as SxMacroInfo[]).concat(macros, compilationMacros);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './core.fn';\n\n\n\nexport const operators: SxFuncInfo[] = [{\n    name: '$car',\n    fn: ops.$car,\n}, {\n    name: '$cdr',\n    fn: ops.$cdr,\n}, {\n    name: '$cons',\n    fn: ops.$cons,\n}, {\n    name: '$first',\n    fn: ops.$first,\n}, {\n    name: '$second',\n    fn: ops.$second,\n}, {\n    name: '$last',\n    fn: ops.$last,\n}, {\n    name: '$progn', // alias of $last\n    fn: ops.$last,\n}, {\n    name: '$rest',\n    fn: ops.$rest,\n}, {\n    name: '$first-and-second',\n    fn: ops.$firstAndSecond,\n}, {\n    name: '$atom',\n    fn: ops.$atom,\n}, {\n    name: '$eq',\n    fn: ops.$eq,\n}, {\n    name: '===',\n    fn: ops.$eq,\n}, {\n    name: '$not-eq',\n    fn: ops.$notEq,\n}, {\n    name: '!==',\n    fn: ops.$notEq,\n}, {\n    name: '$list',\n    fn: ops.$list,\n}, {\n    name: '$__scope',\n    fn: ops.$__scope,\n}, {\n    name: '$__global',\n    fn: ops.$__globalScope,\n}, {\n    name: '$__capture',\n    fn: ops.$__capture,\n}, {\n    name: '$__lambda',\n    fn: ops.$__lambda,\n}, {\n    name: '$__defun',\n    fn: ops.$__defun,\n}, {\n    name: '$__refun',\n    fn: ops.$__refun,\n}, {\n    name: '$__defmacro',\n    fn: ops.$__defmacro,\n}, {\n    name: '$apply',\n    fn: ops.$apply,\n}, {\n    name: '$__call',\n    fn: ops.$__call,\n}, {\n    name: '$__try',\n    fn: ops.$__try,\n}, {\n    name: '$raise',\n    fn: ops.$raise,\n}, {\n    name: '$__if',\n    fn: ops.$__if,\n}, {\n    name: '$__if-null',\n    fn: ops.$__ifNull,\n}, {\n    name: '$__cond',\n    fn: ops.$__cond,\n}, {\n    name: '$__while',\n    fn: ops.$__while,\n}, {\n    name: '$__do-while',\n    fn: ops.$__doWhile,\n}, {\n    name: '$__until',\n    fn: ops.$__until,\n}, {\n    name: '$__do-until',\n    fn: ops.$__doUntil,\n}, {\n    name: '$__repeat',\n    fn: ops.$__repeat,\n}, {\n    name: '$__for',\n    fn: ops.$__for,\n}, {\n    name: '$pipe',\n    fn: ops.$pipe,\n}, {\n    name: '$__get',\n    fn: ops.$__get,\n}, {\n    name: '$__let',\n    fn: ops.$__let,\n}, {\n    name: '$__set',\n    fn: ops.$__set,\n}, {\n    name: '$boolean',\n    fn: ops.$boolean,\n}, {\n    name: '$not',\n    fn: ops.$not,\n}, {\n    name: '$__and',\n    fn: ops.$__and,\n}, {\n    name: '$__or',\n    fn: ops.$__or,\n}, {\n    name: '==',\n    fn: ops.$ambiguousEq,\n}, {\n    name: '!=',\n    fn: ops.$ambiguousNotEq,\n}, {\n    name: '<',\n    fn: ops.$lt,\n}, {\n    name: '<=',\n    fn: ops.$le,\n}, {\n    name: '>',\n    fn: ops.$gt,\n}, {\n    name: '>=',\n    fn: ops.$ge,\n}, {\n    name: '$typeof',\n    fn: ops.$typeof,\n}, {\n    name: '$symbol',\n    fn: ops.$symbol,\n}, {\n    name: '$__gensym',\n    fn: ops.$__gensym,\n}, {\n    name: '$is-symbol',\n    fn: ops.$isSymbol,\n}, {\n    name: '$is-null',\n    fn: ops.$isNull,\n}, {\n    name: '$is-nil',\n    fn: ops.$isNil,\n}, {\n    name: '$is-undefined',\n    fn: ops.$isUndefined,\n}, {\n    name: '$is-list',\n    fn: ops.$isList,\n}, {\n    name: '$is-string',\n    fn: ops.$isString,\n}, {\n    name: '$is-number',\n    fn: ops.$isNumber,\n}, {\n    name: '$is-NaN',\n    fn: ops.$isNaN,\n}, {\n    name: '$is-finite',\n    fn: ops.$isFinite,\n}, {\n    name: '$is-integer',\n    fn: ops.$isInteger,\n}, {\n    name: '$to-string',\n    fn: ops.$toString,\n}, {\n    name: '$to-number',\n    fn: ops.$toNumber,\n}, {\n    name: '$__#',\n    fn: ops.$__toObject,\n}, {\n    name: '$object-assign',\n    fn: ops.$objectAssign,\n}, {\n    name: '$json-stringify',\n    fn: ops.$jsonStringify,\n}, {\n    name: '$now',\n    fn: ops.$now,\n}, {\n    name: '$datetime-from-iso',\n    fn: ops.$datetimeFromIso,\n}, {\n    name: '$datetime',\n    fn: ops.$datetime,\n}, {\n    name: '$datetime-lc',\n    fn: ops.$datetimeLc,\n}, {\n    name: '$datetime-to-iso-string',\n    fn: ops.$datetimeToIsoString,\n}, {\n    name: '$datetime-to-components',\n    fn: ops.$datetimeToComponents,\n}, {\n    name: '$datetime-to-components-lc',\n    fn: ops.$datetimeToComponentsLc,\n}, {\n    name: '$json-parse',\n    fn: ops.$jsonParse,\n}, {\n    name: '$match',\n    fn: ops.$match,\n}, {\n    name: '$console-log',\n    fn: ops.$consoleLog,\n}, {\n    name: '$console-error',\n    fn: ops.$consoleError,\n}, {\n    name: '$console-trace',\n    fn: ops.$consoleTrace,\n}, {\n    name: '$console-time',\n    fn: ops.$consoleTime,\n}, {\n    name: '$console-time-end',\n    fn: ops.$consoleTimeEnd,\n}, {\n    name: '$console-time-log',\n    fn: ops.$consoleTimeLog,\n}];\n\n\nexport const compilationOperators: SxFuncInfo[] = [{\n    name: '$$__lambda',\n    fn: ops.$comp$__lambda,\n}, {\n    name: '$$__defun',\n    fn: ops.$comp$__defun,\n}];\n\n\n// for backword compatibility\nexport default ([] as SxFuncInfo[]).concat(operators, compilationOperators);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\n\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\n\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\n\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\n\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\n\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\n\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\n];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig }       from '../../types';\nimport { operators,\n         compilationOperators } from './core.operator';\nimport { macros,\n         compilationMacros }    from './core.macro';\nimport symbols                  from './core.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || [])\n        .concat(operators)\n        .concat(config.enableCompilationOperators ? compilationOperators : []);\n    config.macros = (config.macros || [])\n        .concat(macros)\n        .concat(config.enableCompilationOperators ? compilationMacros : []);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig,\n         LsxConfig }        from '../../types';\nimport operators            from './jsx.operator';\nimport macros               from './jsx.macro';\nimport symbols              from './jsx.symbol';\n\nimport { $jsxStandardTag,\n         $jsxComponentTag } from './jsx.fn';\n\n\n\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n\n    const components =\n        Object.entries(lsxConf.components)\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\n\n    config.funcs = config.funcs.concat(\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\n        ...components\n    );\n\n    config.funcSymbolResolverFallback = $jsxStandardTag;\n    config.jsx = lsxConf.jsx;\n    config.JsxFragment = lsxConf.jsxFlagment;\n\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxToken }               from '../../types';\nimport { isSymbol,\n         quote }                 from '../../ast';\nimport { evaluate,\n         getScope }              from '../../evaluate';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx } from '../../errors';\nimport { $$first,\n         $$firstAndSecond,\n         $__scope,\n         $$boolean }             from '../core/core.fn';\n\n\n\n// tslint:disable-next-line:variable-name\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__outputIf cond 'expr)\n    //  -> (if cond is true ) S expr  : expr\n    //  -> (if cond is false) S expr  : ()\n    checkParamsLength('$__outputIf', args, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    let r: SxToken = [];\n    if ($$boolean(car)) {\n        if (2 < args.length) {\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\n            r = evaluate(state, r);\n        } else {\n            r = evaluate(state, cdr);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__outputForOf list 'expr)\n    //  -> S expr  : (Template expr ... expr)\n    checkParamsLength('$__outputForOf', args, 2);\n\n    const car = $$first(...args);\n    const r: SxToken[] = [];\n    if (Array.isArray(car)) {\n        for (let i = 0; i < car.length; i++) {\n            const x = car[i];\n            const v = $__scope(state, name)(true, true, [\n                ['$data', quote(state, x)],\n                ['$index', i],\n                ['$array', quote(state, car)],\n                ['$parent', quote(state, getScope(state).scope)],\n            ], ...args.slice(1));\n\n            if (2 < args.length && Array.isArray(v)) {\n                r.push(...v);\n            } else {\n                r.push(v);\n            }\n        }\n    } else {\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\n    }\n    // All of r items are already evaluated.\n    return evaluate(state,\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\n};\n\n\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (@ (name value...)...)\n    //  -> JSON    : {name: value, ...}\n    const r: any = {};\n    for (const x of args) {\n        if (Array.isArray(x) && 0 < x.length) {\n            const sym = isSymbol(x[0]);\n            const keyName =\n                sym ? sym.symbol :\n                String(evaluate(state, x[0]));\n            switch (keyName) {\n            case 'style':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (style) ...)\n                        //  -> JSON    : {..., style: \"\", ...}\n                        r[keyName] = \"\";\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\n                        const styles: object = {};\n                        for (const s of x.slice(1)) {\n                            if (Array.isArray(s) && 1 < s.length) {\n                                const styleName = String(evaluate(state, s[0]));\n                                checkUnsafeVarNamesEx('$jsxProps', styles, styleName);\n                                styles[styleName] = String(evaluate(state, s[1]));\n                            } else if (typeof s === 'string') {\n                                for (const v of s.split(';')) {\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\n                                    if (matched) {\n                                        checkUnsafeVarNamesEx('$jsxProps', styles, matched[1]);\n                                        styles[matched[1]] = matched[2];\n                                    }\n                                }\n                            }\n                        }\n                        r[keyName] = styles;\n                    }\n                }\n                break;\n            case 'class': case 'styleClass':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (class) ...)\n                        //  -> JSON    : {..., class: [], ...}\n                        r[keyName] = [];\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\n                        let classes: any[] = [];\n                        for (const c of x.slice(1)) {\n                            if (Array.isArray(c)) {\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\n                            } else if (typeof c === 'string') {\n                                classes = classes.concat(c.split(' '));\n                            }\n                        }\n                        const cs: string[] = [];\n                        const fn: (a: any[]) => void = (a) => a\n                            .forEach(c => (c === null || c === void 0) ?\n                                void 0 :\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\n                        fn(classes);\n                        r[keyName] = cs;\n                    }\n                }\n                break;\n            case 'className':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (class) ...)\n                        //  -> JSON    : {..., class: \"\", ...}\n                        r[keyName] = '';\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\n                        let classes: string = '';\n                        for (const c of x.slice(1)) {\n                            let fragment = '';\n                            if (Array.isArray(c)) {\n                                const cs: string[] = [];\n                                const fn: (a: any[]) => void = (a) => a\n                                    .map(z => evaluate(state, z))\n                                    .forEach(z => (z === null || z === void 0) ?\n                                        void 0 :\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\n                                fn(c);\n                                fragment = cs.join(' ');\n                            } else if (typeof c === 'string') {\n                                fragment = c;\n                            }\n                            if (0 < classes.length) classes += ' ' + fragment;\n                            else classes = fragment;\n                        }\n                        r[keyName] = classes;\n                    }\n                }\n                break;\n            case 'dangerouslySetInnerHTML':\n                {\n                    if (x.length === 1) {\n                        r[keyName] = {__html: ''};\n                    } else if (x.length >= 2) {\n                        r[keyName] = {__html: evaluate(state, x[1])};\n                    } else {\n                        r[keyName] = {__html:\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)))\n                        };\n                    }\n                }\n                break;\n            case 'setInnerText':\n                {\n                    if (x.length === 1) {\n                        r[keyName] = {__text: ''};\n                    } else if (x.length >= 2) {\n                        r[keyName] = {__text: evaluate(state, x[1])};\n                    } else {\n                        r[keyName] = {__text:\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)))\n                        };\n                    }\n                }\n                break;\n            default:\n                {\n                    checkUnsafeVarNamesEx('$jsxProps', r, keyName);\n                    if (x.length === 1) {\n                        // S expression: (@ ... (keyName) ...)\n                        //  -> JSON    : {..., keyName: true, ...}\n                        r[keyName] = true;\n                    } else if (x.length === 2) {\n                        // S expression: (@ ... (keyName value) ...)\n                        //  -> JSON    : {..., keyName: value, ...}\n                        r[keyName] = evaluate(state, x[1]);\n                    } else {\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\n                        r[keyName] =\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)));\n                    }\n                }\n                break;\n            }\n        } else {\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\n        }\n    }\n    return r;\n};\n\n\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\n    let children = args;\n    let props: any = {};\n    if (0 < args.length && Array.isArray(args[0])) {\n        const sym = isSymbol(args[0][0], '@');\n\n        if (sym) {\n            props = $jsxProps(state, '')(...args[0].slice(1));\n            children = children.slice(1);\n        }\n    }\n    return {props, children};\n}\n\n\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\n    const {props, children} = getJsxTagsParams(state, ...args);\n    return (state.config.jsx as any)(name, props, ...children);\n};\n\n\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\n    const {props, children} = getJsxTagsParams(state, ...args);\n    return (state.config.jsx as any)(component, props, ...children);\n};\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState } from '../../types';\nimport { quote }         from '../../ast';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '@',\n    fn: (state: SxParserState, name: string) => (list) => {\n        return quote(state, list);\n    },\n}, {\n    name: '$=if',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($=if cond expr)\n        //  -> S expr  : ($=__if cond 'expr)\n        return [\n            {symbol: '$=__if'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$=for',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($=for list expr)\n        //  -> S expr  : ($=__for list 'expr)\n        return [\n            {symbol: '$=__for'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './jsx.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$=__if',\n    fn: ops.$__outputIf,\n}, {\n    name: '$=__for',\n    fn: ops.$__outputForOf,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './sequence.operator';\nimport macros             from './sequence.macro';\nimport symbols            from './sequence.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { toNumber,\n         evaluate }          from '../../evaluate';\nimport { checkParamsLength } from '../../errors';\nimport { $$first,\n         $$firstAndSecond }  from '../core/core.fn';\nimport { query }             from '../../../lib/data';\n\n\n\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($range start end)\n    // S expression: ($range start end step)\n    //  -> S expr  : list\n    checkParamsLength('$range', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    const start = toNumber(car) || 0;\n    const stop = toNumber(cdr) || 0;\n\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\n\n    state.evalCount += n;\n    evaluate(state, 0);\n    return Array.from({length: n}, (x, i) => start + i * step);\n};\n\n\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($length listOrString)\n    //  -> S expr  : number\n    checkParamsLength('$length', args, 1, 1);\n\n    const car = $$first(...args);\n    switch (typeof car) {\n    case 'object':\n        if (! ('length' in car)) {\n            break;\n        }\n        // FALL_THRU\n    case 'string':\n        return car.length;\n    }\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\n};\nexport const $$length = $length(null as any, null as any);\n\n\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim string)\n    //  -> S expr  : string\n    checkParamsLength('$trim', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trim();\n    }\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trim = $trim(null as any, null as any);\n\n\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim-head string)\n    //  -> S expr  : string\n    checkParamsLength('$trimHead', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trimLeft();\n    }\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trimHead = $trimHead(null as any, null as any);\n\n\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim-tail string)\n    //  -> S expr  : string\n    checkParamsLength('$trimTail', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trimRight();\n    }\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trimTail = $trimTail(null as any, null as any);\n\n\nexport const $replaceAll = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($replace-all src-string match-string replacement-string)\n    //  -> S expr  : string\n    checkParamsLength('$replaceAll', args, 3, 3);\n\n    if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {\n        return args[0].split(args[1]).join(args[2]);\n    }\n    throw new Error(`[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.`);\n};\nexport const $$replaceAll = $replaceAll(null as any, null as any);\n\n\nexport const $split = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($split src-string match-string)\n    //  -> S expr  : (string ... string)\n    checkParamsLength('$split', args, 2, 2);\n\n    if (typeof args[0] === 'string' && typeof args[1] === 'string') {\n        return args[0].split(args[1]);\n    }\n    throw new Error(`[SX] $split: Invalid argument type: args[0] or [1] is not string.`);\n};\nexport const $$split = $split(null as any, null as any);\n\n\nexport const $join = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($join '(str1 ... strN) separator)\n    //  -> S expr  : (string ... string)\n    checkParamsLength('$join', args, 1, 2);\n\n    if (typeof Array.isArray(args[0])) {\n        if (args.length > 1) {\n            if (typeof args[1] === 'string') {\n                return args[0].join(args[1]);\n            }\n            throw new Error(`[SX] $join: Invalid argument type: args[1] is not string.`);\n        } else {\n            return args[0].join();\n        }\n    }\n    throw new Error(`[SX] $join: Invalid argument type: args[0] is not array.`);\n};\nexport const $$join = $join(null as any, null as any);\n\n\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($concat listOrString1 ... listOrStringN)\n    //  -> S expr  : listOrString\n    checkParamsLength('$concat', args, 1);\n\n    const car = $$first(...args);\n    switch (typeof car) {\n    case 'object':\n        if (! ('concat' in car)) {\n            break;\n        }\n        // FALL_THRU\n    case 'string':\n        return car.concat(...args.slice(1));\n    }\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\n};\nexport const $$concat = $concat(null as any, null as any);\n\n\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($slice start end listOrString)\n    // S expression: ($slice start listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$slice', args, 2, 3);\n\n    if (args.length === 3) {\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\n        }\n    }\n    if (args.length === 2) {\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n            return args[1].slice(toNumber(args[0]));\n        }\n    }\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\n};\nexport const $$slice = $slice(null as any, null as any);\n\n\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($top n listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$top', args, 2, 2);\n\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n        return args[1].slice(0, toNumber(args[0]));\n    }\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\n};\nexport const $$top = $top(null as any, null as any);\n\n\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($tail n listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$tail', args, 2, 2);\n\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n        const n = -toNumber(args[0]);\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\n    }\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\n};\nexport const $$tail = $tail(null as any, null as any);\n\n\nexport const $push = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($push list value)\n    //  -> S expr  : list\n    checkParamsLength('$push', args, 2, 2);\n\n    if (typeof Array.isArray(args[0])) {\n        args[0].push(args[1]);\n        return args[0];\n    }\n    throw new Error(`[SX] $push: Invalid argument type: args[1] is not array.`);\n};\nexport const $$push = $push(null as any, null as any);\n\n\nexport const $pop = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($pop list)\n    //  -> S expr  : value\n    checkParamsLength('$pop', args, 1, 1);\n\n    if (typeof Array.isArray(args[0])) {\n        const v = args[0].pop();\n        return v;\n    }\n    throw new Error(`[SX] $pop: Invalid argument type: args[1] is not array.`);\n};\nexport const $$pop = $pop(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__at index listOrString)\n    //  -> S expr  : any\n    checkParamsLength('$__at', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return cdr[car];\n};\n// tslint:disable-next-line:variable-name\nexport const $$__at = $__at(null as any, null as any);\n\n\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reverse listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$reverse', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car)) {\n        return car.slice(0).reverse();\n    }\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reverse = $reverse(null as any, null as any);\n\n\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reverse! listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$reverse!', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car)) {\n        return car.reverse();\n    }\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\n\n\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($find list (lambda (v index array) (... boolean)))\n    //  -> S expr  : list\n    checkParamsLength('$find', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.find(cdr);\n    }\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\n};\nexport const $$find = $find(null as any, null as any);\n\n\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\n    //  -> S expr  : list\n    checkParamsLength('$filter', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.filter(cdr);\n    }\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\n};\nexport const $$filter = $filter(null as any, null as any);\n\n\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($map list (lambda (v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$map', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.map(cdr);\n    }\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\n};\nexport const $$map = $map(null as any, null as any);\n\n\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$reduce', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        if (args.length < 3) {\n            return car.reduce(cdr);\n        } else {\n            return car.reduce(cdr, args[2]);\n        }\n    }\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reduce = $reduce(null as any, null as any);\n\n\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$reduceFromTail', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        if (args.length < 3) {\n            return car.reduceRight(cdr);\n        } else {\n            return car.reduceRight(cdr, args[2]);\n        }\n    }\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\n\n\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\n    //  -> S expr  : list\n    checkParamsLength('$sort', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.slice(0).sort(cdr);\n    }\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\n};\nexport const $$sort = $sort(null as any, null as any);\n\n\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\n    //  -> S expr  : list\n    checkParamsLength('$sort!', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.sort(cdr);\n    }\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\n};\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\n\n\nexport const $groupEvery = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($group-every optionsOrNumber (x1 ... xN))\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\n    checkParamsLength('$group-every', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $group-every: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).groupEvery(car).select();\n};\nexport const $$groupEvery = $groupEvery(null as any, null as any);\n\n\nexport const $groupBy = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($group-by conditions (x1 ... xN))\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\n    checkParamsLength('$group-by', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $group-by: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).groupBy(car).select();\n};\nexport const $$groupBy = $groupBy(null as any, null as any);\n\n\nexport const $orderBy = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($order-by conditions (x1 ... xN))\n    //  -> S expr  : (x1 ... xN)\n    checkParamsLength('$order-by', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $order-by: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).orderBy(car).select();\n};\nexport const $$orderBy = $orderBy(null as any, null as any);\n\n\nexport const $where = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($where (-> (v index array) ... boolean) (x1 ... xN))\n    //  -> S expr  : (x'1 ... x'M)\n    checkParamsLength('$where', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (typeof args[0] !== 'function') {\n        throw new Error(`[SX] $where: Invalid argument type: args[0] is not function.`);\n    }\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $where: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).where(car).select();\n};\nexport const $$where = $where(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState } from '../../types';\nimport { isSymbol }      from '../../ast';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$[',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($[ index ] listOrObject)\n        //  -> S expr  : ($__at listOrObject)\n        const symOf = isSymbol(list[2], ']');\n        if (! symOf) {\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\n        }\n        return [{symbol: '$__at'},\n            list[1],\n            list[3],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './sequence.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$range',\n    fn: ops.$range,\n}, {\n    name: '$length',\n    fn: ops.$length,\n}, {\n    name: '$trim',\n    fn: ops.$trim,\n}, {\n    name: '$trim-head',\n    fn: ops.$trimHead,\n}, {\n    name: '$trim-tail',\n    fn: ops.$trimTail,\n}, {\n    name: '$replace-all',\n    fn: ops.$replaceAll,\n}, {\n    name: '$split',\n    fn: ops.$split,\n}, {\n    name: '$join',\n    fn: ops.$join,\n}, {\n    name: '$concat',\n    fn: ops.$concat,\n}, {\n    name: '$slice',\n    fn: ops.$slice,\n}, {\n    name: '$top',\n    fn: ops.$top,\n}, {\n    name: '$tail',\n    fn: ops.$tail,\n}, {\n    name: '$push',\n    fn: ops.$push,\n}, {\n    name: '$pop',\n    fn: ops.$pop,\n}, {\n    name: '$__at',\n    fn: ops.$__at,\n}, {\n    name: '$reverse',\n    fn: ops.$reverse,\n}, {\n    name: '$reverse!',\n    fn: ops.$reverseDestructive,\n}, {\n    name: '$find',\n    fn: ops.$find,\n}, {\n    name: '$filter',\n    fn: ops.$filter,\n}, {\n    name: '$map',\n    fn: ops.$map,\n}, {\n    name: '$reduce',\n    fn: ops.$reduce,\n}, {\n    name: '$reduce-from-head',\n    fn: ops.$reduce,\n}, {\n    name: '$reduce-from-tail',\n    fn: ops.$reduceFromTail,\n}, {\n    name: '$sort',\n    fn: ops.$sort,\n}, {\n    name: '$sort!',\n    fn: ops.$sortDestructive,\n}, {\n    name: '$group-every',\n    fn: ops.$groupEvery,\n}, {\n    name: '$group-by',\n    fn: ops.$groupBy,\n}, {\n    name: '$order-by',\n    fn: ops.$orderBy,\n}, {\n    name: '$where',\n    fn: ops.$where,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxEof,\n         SxExternalValue,\n         SxSymbol,\n         SxDottedFragment,\n         SxComment,\n         SxToken,\n         SxChar,\n         ScriptTerminationError } from './types';\nimport { quote,\n         backquote,\n         wrapByUnquote,\n         spread,\n         splice }                 from './ast';\n\n\n\nfunction isEOF(ch: SxChar): boolean {\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\n}\n\n\nfunction isSpace(ch: SxChar): boolean {\n    return typeof ch === 'string' && ch.trim().length === 0;\n}\n\n\nfunction isNumberFirstChar(ch: SxChar): boolean {\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\n}\n\n\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\n}\n\n\nfunction isSymbolFirstChar(ch: SxChar): boolean {\n    return typeof ch === 'string' &&\n        !isSpace(ch) &&\n        !isNumberFirstChar(ch);\n}\n\n\n\nfunction lookCurrentLineHint(state: SxParserState): string {\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\n        state.strings.length > state.index ?\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\n}\n\n\nfunction getChar(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\n    if (state.strings.length <= state.index) {\n        return {eof: true};\n    }\n    if (state.strings[state.index].length <= state.pos) {\n        if ((! state.values) || (state.values.length <= state.index)) {\n            state.pos = 0;\n            state.index++;\n            return getChar(state);\n        } else {\n            const ch = {value: state.values[state.index]};\n            state.pos = 0;\n            state.index++;\n            return ch;\n        }\n    }\n    if (virtualEof) {\n        for (const v of virtualEof) {\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\n            if (ch === v) {\n                state.pos += v.length;\n                state.line += ch.split('\\n').length - 1;\n                return { eof: false , eofSeq: v };\n            }\n        }\n    }\n    {\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\n        state.pos++;\n\n        if (ch === '\\n') {\n            state.line++;\n        }\n\n        if ((! disableEscape) && ch === '\\\\') {\n            if (state.strings[state.index].length <= state.pos) {\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\n            state.pos++;\n\n            switch (ch) {\n            case 'b':\n                ch = '\\b';\n                break;\n            case 't':\n                ch = '\\t';\n                break;\n            case 'n':\n                ch = '\\n';\n                break;\n            case 'v':\n                ch = '\\v';\n                break;\n            case 'f':\n                ch = '\\f';\n                break;\n            case 'r':\n                ch = '\\r';\n                break;\n            case 'U': case 'u':\n                {\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\n                        let ch1 = '';\n                        for (let i = 0; i < 6; i++) {\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\n                            if (ch2 === '}') {\n                                if (i === 0) {\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                                }\n                                state.pos += i;\n                                break;\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                            }\n                            ch1 += ch2;\n                        }\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        state.pos++;\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\n                    } else {\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        state.pos += 4;\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\n                    }\n                }\n                break;\n            }\n        }\n        return ch;\n    }\n}\n\n\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[], disableEscape?: boolean): SxChar[] {\n    const index = state.index;\n    const pos = state.pos;\n    const line = state.line;\n    const chs: SxChar[] = [];\n\n    try {\n        for (let i = 0; i < n; i++) {\n            chs.push(getChar(state, virtualEof, disableEscape));\n        }\n    } finally {\n        state.index = index;\n        state.pos = pos;\n        state.line = line;\n    }\n\n    return chs;\n}\n\n\nfunction lookAhead(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\n    const index = state.index;\n    const pos = state.pos;\n    const line = state.line;\n    let ch: SxChar;\n\n    try {\n        ch = getChar(state, virtualEof, disableEscape);\n    } finally {\n        state.index = index;\n        state.pos = pos;\n        state.line = line;\n    }\n\n    return ch;\n}\n\n\nfunction skipWhitespaces(state: SxParserState): void {\n    let ch = lookAhead(state);\n    while (!isEOF(ch) && isSpace(ch)) {\n        getChar(state);\n        ch = lookAhead(state);\n    }\n}\n\n\n\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\n    let s = '';\n    let ch = lookAhead(state, virtualEof);\n\n    while (! isEOF(ch)) {\n        if (typeof ch === 'string') {\n            if (/^0[XxOoBb][0-9]*$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n\n        ch = lookAhead(state, virtualEof);\n    }\n\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|(0[XxOoBb][0-9]+)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n    }\n    return Number(s);\n}\n\n\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\n    let s = '';\n    let ch = lookAhead(state, virtualEof);\n\n    while (! isEOF(ch)) {\n        if (typeof ch === 'string') {\n            if (isSpace(ch)) {\n                break;\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\n                break;\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else {\n                break;\n            }\n        } else {\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                getChar(state, virtualEof);\n                const v = (ch as SxExternalValue).value;\n                s += String(ch);\n            } else {\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n        }\n\n        ch = lookAhead(state, virtualEof);\n    }\n\n    if (state.config.enableShorthands) {\n        let m: RegExpMatchArray | null = null;\n        // tslint:disable-next-line:no-conditional-assignment\n        if (m = s.match(/^:((?:\\:[^=:]+?)+?)=$/)) {\n            // ::foo:bar:baz= -> ($splice ($set (foo bar baz)))\n            const ws = m[1].slice(1).split(':');\n            const z =\n                [{symbol: state.config.reservedNames.splice},\n                    [{symbol: state.config.reservedNames.set},\n                        ws\n                    ]\n                ];\n            return z as any;\n        }\n        // tslint:disable-next-line:no-conditional-assignment\n        else if (m = s.match(/^:((?:\\:[^@:]+?)+?)@([^@:]+?)$/)) {\n            // ::foo:bar@baz -> ($splice ($call ($get foo bar) baz))\n            const ws = m[1].slice(1).split(':');\n            const z =\n                [{symbol: state.config.reservedNames.splice},\n                    [{symbol: state.config.reservedNames.call},\n                        [{symbol: state.config.reservedNames.get}, ...ws],\n                        {symbol: m[2]},\n                    ]\n                ];\n            return z as any;\n        }\n        // tslint:disable-next-line:no-conditional-assignment\n        else if (m = s.match(/^:((?:\\:[^:]+?)+?)$/)) {\n            // ::foo:bar:baz -> ($get foo bar baz)\n            const ws = m[1].slice(1).split(':');\n            const z = [{symbol: state.config.reservedNames.get}, ...ws];\n            return z as any;\n        }\n    }\n\n    return {symbol: s};\n}\n\n\nfunction parseStringOrComment(\n        state: SxParserState, eof: string[],\n        valuesStartSeq: string | null,\n        valuesStopChar: string,\n        disableEscape: boolean,\n        allowPhysicalEof: boolean,\n    ): { strings: string[], values: any[] } {\n\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\n    const strings: string[] = [];\n    const values: any[] = [];\n\n    for (;;) {\n        let s = '';\n        let ch = lookAhead(state, eofSeqs, disableEscape);\n\n        while (! isEOF(ch)) {\n            if (typeof ch === 'string') {\n                getChar(state, eofSeqs, disableEscape);\n                s += ch;\n            } else {\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                    getChar(state, eofSeqs, disableEscape);\n                    const v = (ch as SxExternalValue).value;\n                    s += String(ch);\n                } else {\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                }\n            }\n\n            ch = lookAhead(state, eofSeqs, disableEscape);\n        }\n\n        getChar(state, eofSeqs, disableEscape);\n\n        if ((ch as SxEof).eof === true) {\n            if (! allowPhysicalEof) {\n                throw new ScriptTerminationError('parseStringOrComment');\n            }\n        }\n\n        strings.push(s);\n\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\n            values.push(parseList(state, valuesStopChar, []));\n        } else {\n            break;\n        }\n    }\n\n    return { strings, values };\n}\n\n\nfunction parseString(state: SxParserState, disableEscape: boolean): string {\n    return parseStringOrComment(state, ['\"'], null, ')', disableEscape, false).strings[0];\n}\n\n\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\n    const q: SxToken[] = [symbol];\n\n    if (attrs) {\n        q.push(attrs);\n    }\n\n    const inner = parseStringOrComment(state, ['\"\"\"'], '%%%(', ')', false, false);\n    for (let i = 0; i < inner.strings.length; i++) {\n        q.push(inner.strings[i]);\n        if (i < inner.values.length) {\n            q.push(inner.values[i]);\n        }\n    }\n\n    return q;\n}\n\n\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\n    return {\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')', false, true).strings[0]\n    };\n}\n\n\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\n    return {\n        comment: parseStringOrComment(state, ['|#'], null, ')', false, false).strings[0]\n    };\n}\n\n\nfunction parseOneToken(state: SxParserState): SxToken {\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case ')':\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n\n        case '(':\n            getChar(state);\n            return parseList(state, ')', []);\n\n        case \"'\": case \"`\": case ',':\n            {\n                getChar(state);\n                const ahead = lookAhead(state);\n                let isSpliceUnquote = false;\n                if (ch === ',' && ahead === '@') {\n                    getChar(state);\n                    isSpliceUnquote = true;\n                }\n                skipWhitespaces(state);\n                const ret = (ch === \"'\" ?\n                        quote :\n                        (ch === \"`\" ? backquote : wrapByUnquote))\n                    (state, parseOneToken(state)\n                );\n                return (isSpliceUnquote ? splice(state, ret) : ret);\n            }\n\n        case \".\":\n            {\n                getChar(state);\n                const aheads = lookAheads(state, 2);\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\n                    getChar(state);\n                    getChar(state);\n                    skipWhitespaces(state);\n                    return spread(state, parseOneToken(state));\n                } else {\n                    skipWhitespaces(state);\n                    return {dotted: parseOneToken(state)};\n                }\n            }\n\n        case ';':\n            getChar(state);\n            return parseSingleLineComment(state);\n\n        case '#':\n            {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '|') {\n                    getChar(state);\n                    getChar(state);\n                    return parseMultiLineComment(state);\n                } else {\n                    return parseSymbol(state);\n                }\n            }\n\n        case '\"':\n            {\n                getChar(state);\n                const aheads = lookAheads(state, 4);\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\n                    let isHereDoc = true;\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\n                        // here doc\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\n                        if (aheads[2] === '+' || aheads[2] === '-') {\n                            if (! isNumberAfterSignChar(aheads[3])) {\n                                isHereDoc = false;\n                            }\n                        }\n                        // here doc\n                    } else if (isSymbolFirstChar(aheads[2])) {\n                        isHereDoc = false;\n                    } else {\n                        // here doc\n                    }\n                    getChar(state);\n                    getChar(state);\n\n                    let sym: SxSymbol | number | null = null;\n                    let attrs: SxToken[] | null = null;\n                    if (isHereDoc) {\n                        sym = {symbol: state.config.reservedNames.Template};\n                    } else {\n                        sym = parseSymbol(state, ['@']);\n                        if (sym === null) {\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        if (typeof sym === 'number') {\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        const ahs = lookAheads(state, 2);\n                        if (ahs[0] === '@') {\n                            if (ahs[1] !== '{') {\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                            }\n                            getChar(state);\n                            getChar(state);\n                            const a = parseList(state, '}', [{symbol: '@'}]);\n                            if (Array.isArray(a)) {\n                                attrs = a;\n                            }\n                        }\n                    }\n\n                    return parseHereDoc(state, sym, attrs);\n                } else {\n                    return parseString(state, false);\n                }\n            }\n\n        case '@':\n            if (state.config.enableVerbatimStringLiteral) {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '\"') {\n                    getChar(state);\n                    getChar(state);\n                    return parseString(state, true);\n                }\n            }\n            // FALL_THRU\n\n        default:\n            if (typeof ch !== 'string') {\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                    getChar(state);\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\n                } else {\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                }\n            } else if (isSpace(ch)) {\n                break;\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\n                if (ch === '+' || ch === '-') {\n                    const aheads = lookAheads(state, 2);\n                    if (! isNumberAfterSignChar(aheads[1])) {\n                        return parseSymbol(state);\n                    }\n                }\n                return parseNumber(state);\n            } else if (isSymbolFirstChar(ch)) {\n                return parseSymbol(state);\n            } else {\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    throw new ScriptTerminationError('parseOneToken');\n}\n\n\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\n    const r: SxToken[] = initialList.slice(0);\n    let dotted = false;\n\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case listStopChar:\n            getChar(state);\n            if (dotted) {\n                return r[0];\n            } else {\n                return r;\n            }\n\n        default:\n            {\n                const t = parseOneToken(state);\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\n                    if (r.length !== 1) {\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                    }\n                    dotted = true;\n                    if (Array.isArray(t)) {\n                        t.unshift(r.pop() as SxToken);\n                        r.push(t);\n                    } else {\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\n                    }\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\n                    if (! state.config.stripComments) {\n                        r.push(t);\n                    }\n                } else {\n                    if (dotted) {\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                    }\n                    r.push(t);\n                }\n            }\n            break;\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    throw new ScriptTerminationError('parseList');\n}\n\n\n\nexport function parse(state: SxParserState) {\n    const r: SxToken[] = [];\n\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case '(':\n            getChar(state);\n            r.push(parseList(state, ')', []));\n            break;\n\n        case \"'\": case \"`\":\n            {\n                getChar(state);\n                skipWhitespaces(state);\n                for (;;) {\n                    const t = parseOneToken(state);\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\n                        if (! state.config.stripComments) {\n                            r.push(t);\n                        }\n                    } else {\n                        r.push((ch === \"'\" ? quote : backquote)(state, t));\n                        break;\n                    }\n                }\n                break;\n            }\n\n        case ';':\n            getChar(state);\n            if (state.config.stripComments) {\n                parseSingleLineComment(state);\n            } else {\n                r.push(parseSingleLineComment(state));\n            }\n            break;\n\n        case '#':\n            {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '|') {\n                    getChar(state);\n                    getChar(state);\n                    if (state.config.stripComments) {\n                        parseMultiLineComment(state);\n                    } else {\n                        r.push(parseMultiLineComment(state));\n                    }\n                } else {\n                    getChar(state);\n                    if (state.config.stripComments) {\n                        parseSingleLineComment(state);\n                    } else {\n                        r.push(parseSingleLineComment(state));\n                    }\n                }\n            }\n            break;\n\n        case '\"':\n            {\n                const aheads = lookAheads(state, 3);\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\n                    r.push(parseOneToken(state));\n                    break;\n                }\n            }\n            // FALL_THRU\n\n        default:\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    return r;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport * from './defaults';\nexport * from './interpreters';\nexport * from './interpreters/presets/s-exp';\nexport * from './interpreters/presets/lisp';\nexport * from './interpreters/presets/lsx';\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport type SxMacro = (state: SxParserState, name: string, formalArgs?: SxSymbol[]) => (list: SxToken[]) => SxToken;\n\nexport interface SxMacroInfo {\n    name: string;\n    fn: SxMacro;\n\n    formalArgs?: SxSymbol[];\n    lastIsSpread?: boolean;\n    next?: SxMacroInfo;\n}\n\n\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\n\nexport interface SxFuncInfo {\n    name: string;\n    fn: SxFunc;\n\n    // TODO: overloading\n    // formalArgs?: SxSymbol[];\n    // lastIsSpread?: boolean;\n    // next?: SxFuncInfo;\n}\n\n\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\n\nexport interface SxSymbolInfo {\n    name: string;\n    fn: SxSymbolResolver;\n}\n\n\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\n\nexport interface SxScope {\n    isBlockLocal: boolean;\n    scope: any;           // { [s: string]: any; };\n    capturedScopes?: CapturedScopes;\n}\n\n\nexport interface SxReservedNames {\n    eval: string;\n    quote: string;\n    backquote: string;\n    unquote: string;\n    spread: string;\n    splice: string;\n\n    car: string;\n    cdr: string;\n    cons: string;\n    atom: string;\n    eq: string;\n    list: string;\n\n    let: string;\n    lambda: string;\n    self: string;\n    defun: string;\n    thiz: string;\n\n    if: string;\n    cond: string;\n\n    while: string;\n    doWhile: string;\n    until: string;\n    doUntil: string;\n\n    get: string;\n    defvar: string;\n    setq: string;\n    set: string;\n    call: string;\n\n    not: string;\n    and: string;\n    or: string;\n\n    isSymbol: string;\n    gensym: string;\n    raise: string;\n    catch: string;\n\n    Template: string;\n}\n\nexport interface SxParserConfig {\n    raiseOnUnresolvedSymbol: boolean;\n    enableEvaluate: boolean;\n    enableHereDoc: boolean;\n    enableSpread: boolean;\n    enableSplice: boolean;\n    enableShorthands: boolean;\n    enableVerbatimStringLiteral: boolean;\n    enableTailCallOptimization: boolean;\n    enableRegExpMatchOperators: boolean; // IMPORTANT: Turn off to prevent ReDoS when executing untrusted code\n    enableCompilationOperators: boolean; // IMPORTANT: Turn off to prevent DoS when executing untrusted code\n    stripComments: boolean;\n    wrapExternalValue: boolean;\n    reservedNames: SxReservedNames;\n    returnMultipleRoot: boolean;\n    maxEvalCount: number;                // IMPORTANT: Set positive value to prevent DoS when executing untrusted code\n\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\n    JsxFragment?: any;\n\n    funcs: SxFuncInfo[];\n    macros: SxMacroInfo[];\n    symbols: SxSymbolInfo[];\n\n    funcSymbolResolverFallback?: SxFunc;\n    valueSymbolResolverFallback?: SxSymbolResolver;\n}\n\nexport interface SxParserState {\n    strings: TemplateStringsArray | string[];\n    values: any[];\n\n    index: number;\n    pos: number;\n    line: number;\n\n    evalCount: number;\n\n    scopes: SxScope[];\n\n    macroMap: Map<string, SxMacroInfo>;\n    funcMap: Map<string, SxFuncInfo>;\n    symbolMap: Map<string, SxSymbolInfo>;\n\n    config: SxParserConfig;\n}\n\nexport interface SxEof {\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\n    eofSeq?: string;\n}\n\nexport interface SxExternalValue {\n    value: any;\n}\n\nexport interface SxSymbol {\n    'symbol': string;\n\n    // TODO: debug info\n    // _fileName?: string;\n    // _line?: number;\n    // _col?: number;\n}\n\nexport interface SxComment {\n    comment: string;\n}\n\nexport interface SxDottedPair {\n    car: SxToken; // left\n    cdr: SxToken; // right\n}\n\nexport interface SxDottedFragment {\n    dotted: SxToken; // right\n}\n\n\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\nexport type SxChar = string | SxEof | SxExternalValue;\nexport type SxAtom = SxSymbol | string | number | boolean | null;\nexport type SxList = SxDottedPair | SxAtom[];\n\n\n\nexport type CompilerOperator = (r: SxToken[], args: SxToken[]) => string;\n\n\nexport interface CompilerContext {\n    _$_vars: any[];\n    varsCount: number;\n    varNames: Map<string, string>;\n    varNamesCount: number;\n    varDefs: string;\n    ops: Map<string, CompilerOperator>;\n    makeScope: (scoped: () => void) => void;\n    compileToken: (body: any[], i: number) => string;\n}\n\n\nexport interface LsxConfig {\n    jsx: (comp: any, props: any, ...children: any[]) => any;\n    jsxFlagment: any;\n    components: object;\n}\n\n\nexport class FatalError extends Error {\n    public constructor(message?: string | undefined) {\n        super(message);\n    }\n}\n\n\nexport class MaxEvaluationCountError extends FatalError {\n    public constructor() {\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\n    }\n}\n\n\nexport class ScriptTerminationError extends FatalError {\n    public constructor(where: string) {\n        super(`[SX] ${where}: Unexpected termination of script.`);\n    }\n}\n\n\nexport interface SExpressionRepl<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => R;\n}\n\n\nexport interface SExpressionTemplateFn<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\n    evaluateAST: (ast: SxToken[]) => R;\n    repl: () => SExpressionRepl<R>;\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\n}\n\n\nexport interface SExpressionAsyncRepl<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\n}\n\n\nexport interface SExpressionAsyncTemplateFn<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\n    repl: () => SExpressionAsyncRepl<R>;\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\n}\n"],"sourceRoot":""}