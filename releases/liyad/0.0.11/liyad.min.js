!function(e,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports.liyad=n():e.liyad=n()}(window,function(){return function(e){var n={};function r(t){if(n[t])return n[t].exports;var o=n[t]={i:t,l:!1,exports:{}};return e[t].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,n){if(1&n&&(e=r(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)r.d(t,o,function(n){return e[n]}.bind(null,o));return t},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},r.p="",r(r.s=0)}([function(e,n,r){e.exports=r(1)},function(e,n,r){"use strict";function t(e,n){return[{symbol:e.config.reservedNames.quote},n]}function o(e,n){return[{symbol:e.config.reservedNames.spread},n]}function s(e,n){return e&&"object"==typeof e&&Object.prototype.hasOwnProperty.call(e,"symbol")?void 0!==n?e.symbol===n?e:null:e:null}r.r(n);class a extends Error{constructor(e){super(e)}}class i extends a{constructor(){super("[SX] evaluate: The maximum count of evaluations has been exceeded.")}}class l extends a{constructor(e){super(`[SX] ${e}: Unexpected termination of script.`)}}function c(e){return"object"==typeof e&&Object.prototype.hasOwnProperty.call(e,"eof")}function f(e){return"string"==typeof e&&0===e.trim().length}function u(e){return"string"==typeof e&&/^[0-9\+\-]$/.test(e)}function m(e){return"string"==typeof e&&/^[0-9]$/.test(e)}function y(e){return"string"==typeof e&&!f(e)&&!u(e)}function p(e){return`line: ${e.line} / strings: ${e.index} / pos: ${e.pos} :${e.strings.length>e.index?e.strings[e.index].slice(e.pos,e.pos+20):""}`}function g(e,n){if(e.strings.length<=e.index)return{eof:!0};if(e.strings[e.index].length<=e.pos){if(!e.values||e.values.length<=e.index)return e.pos=0,e.index++,g(e);{const n={value:e.values[e.index]};return e.pos=0,e.index++,n}}if(n)for(const r of n){const n=e.strings[e.index].slice(e.pos,e.pos+r.length);if(n===r)return e.pos+=r.length,e.line+=n.split("\n").length-1,{eof:!1,eofSeq:r}}{let n=e.strings[e.index].slice(e.pos,e.pos+1);if(e.pos++,"\n"===n&&e.line++,"\\"===n){if(e.strings[e.index].length<=e.pos)throw new Error(`[SX] getChar: Invalid syntax at: ${p(e)}.`);switch(n=e.strings[e.index].slice(e.pos,e.pos+1),e.pos++,n){case"b":n="\b";break;case"t":n="\t";break;case"n":n="\n";break;case"v":n="\v";break;case"f":n="\f";break;case"r":n="\r";break;case"U":case"u":if("{"===e.strings[e.index].slice(e.pos,e.pos+1)){let r="";for(let n=0;n<6;n++){const t=e.strings[e.index].slice(e.pos+n,e.pos+1+n);if("}"===t){if(0===n)throw new Error(`[SX] getChar: Invalid syntax at: ${p(e)}.`);e.pos+=n;break}if(!/^[0-9A-Fa-f]{1}$/.test(r))throw new Error(`[SX] getChar: Invalid syntax at: ${p(e)}.`);r+=t}if("}"!==e.strings[e.index].slice(e.pos,e.pos+1))throw new Error(`[SX] getChar: Invalid syntax at: ${p(e)}.`);e.pos++,n=String.fromCodePoint(Number.parseInt(r,16))}else{const r=e.strings[e.index].slice(e.pos,e.pos+4);if(!/^[0-9A-Fa-f]{4}$/.test(r))throw new Error(`[SX] getChar: Invalid syntax at: ${p(e)}.`);e.pos+=4,n=String.fromCodePoint(Number.parseInt(r,16))}}}return n}}function d(e,n,r){const t=e.index,o=e.pos,s=e.line,a=[];try{for(let t=0;t<n;t++)a.push(g(e,r))}finally{e.index=t,e.pos=o,e.line=s}return a}function $(e,n){const r=e.index,t=e.pos,o=e.line;let s;try{s=g(e,n)}finally{e.index=r,e.pos=t,e.line=o}return s}function h(e){let n=$(e);for(;!c(n)&&f(n);)g(e),n=$(e)}function b(e,n){let r="",t=$(e,n);for(;!c(t)&&"string"==typeof t&&/^[0-9\+\-\.EeInfinityNaN]+$/.test(r+t);)g(e,n),r+=t,t=$(e,n);if(!/^([\+\-]?\d*\.?\d+(?:[Ee][\+\-]?\d+)?)|([\+\-]Infinity)|(NaN)$/.test(r))throw new Error(`[SX] parseNumber: Invalid syntax at: ${p(e)}.`);return Number(r)}function w(e,n){let r="",t=$(e,n);for(;!c(t);){if("string"==typeof t){if(f(t))break;if("#"===t&&"|"===d(e,2,n)[1])break;if(!/^[^.;()"]+$/.test(r+t))break;g(e,n),r+=t}else{if("object"!=typeof t||!Object.prototype.hasOwnProperty.call(t,"value"))throw new Error(`[SX] parseSymbol: Invalid syntax at: ${p(e)}.`);g(e,n);t.value;r+=String(t)}t=$(e,n)}return{symbol:r}}function v(e,n,r,t){const o=r?[...n,r]:n,s=[],a=[];for(;;){let n="",i=$(e,o);for(;!c(i);){if("string"==typeof i)g(e,o),n+=i;else{if("object"!=typeof i||!Object.prototype.hasOwnProperty.call(i,"value"))throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${p(e)}.`);g(e,o);i.value;n+=String(i)}i=$(e,o)}if(g(e,o),!0===i.eof)throw new l("parseStringOrComment");if(s.push(n),i.eofSeq!==r)break;a.push(I(e,t,[]))}return{strings:s,values:a}}function _(e){return v(e,['"'],null,")").strings[0]}function S(e,n,r){const t=[n];r&&t.push(r);const o=v(e,['"""'],"%%%(",")");for(let e=0;e<o.strings.length;e++)t.push(o.strings[e]),e<o.values.length&&t.push(o.values[e]);return t}function A(e){return{comment:v(e,["\r","\n"],null,")").strings[0]}}function E(e){return{comment:v(e,["|#"],null,")").strings[0]}}function j(e){h(e);let n=$(e);for(;!c(n);){switch(n){case")":throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`);case"(":return g(e),I(e,")",[]);case"'":return g(e),h(e),t(e,j(e));case".":{g(e);const n=d(e,2);return e.config.enableSpread&&"."===n[0]&&"."===n[1]?(g(e),g(e),h(e),o(e,j(e))):(h(e),{dotted:j(e)})}case'"':{g(e);const n=d(e,4);if(e.config.enableHereDoc&&'"'===n[0]&&'"'===n[1]){let r=!0;c(n[2])||f(n[2])||(u(n[2])?"+"!==n[2]&&"-"!==n[2]||m(n[3])||(r=!1):y(n[2])&&(r=!1)),g(e),g(e);let t=null,o=null;if(r)t={symbol:e.config.reservedNames.Template};else{if(null===(t=w(e,["@"])))throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`);if("number"==typeof t)throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`);const n=d(e,2);if("@"===n[0]){if("{"!==n[1])throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`);g(e),g(e);const r=I(e,"}",[{symbol:"@"}]);Array.isArray(r)&&(o=r)}}return S(e,t,o)}return _(e)}case";":return g(e),A(e);case"#":return"|"===d(e,2)[1]?(g(e),g(e),E(e)):w(e);default:if("string"!=typeof n){if("object"==typeof n&&Object.prototype.hasOwnProperty.call(n,"value"))return g(e),e.config.wrapExternalValue?n:n.value;throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`)}if(f(n))break;if(u(n)){if("+"===n||"-"===n){if(!m(d(e,2)[1]))return w(e)}return b(e)}if(y(n))return w(e);throw new Error(`[SX] parseOneToken: Invalid syntax at: ${p(e)}.`)}h(e),n=$(e)}throw new l("parseOneToken")}function I(e,n,r){const t=r.slice(0);let o=!1;h(e);let s=$(e);for(;!c(s);){switch(s){case n:return g(e),o?t[0]:t;default:{const n=j(e);if("object"==typeof n&&Object.prototype.hasOwnProperty.call(n,"dotted")){if(1!==t.length)throw new Error(`[SX] parseList: Invalid syntax at: ${p(e)}.`);o=!0,Array.isArray(n)?(n.unshift(t.pop()),t.push(n)):t.push({car:t.pop(),cdr:n.dotted})}else if("object"==typeof n&&Object.prototype.hasOwnProperty.call(n,"comment"))e.config.stripComments||t.push(n);else{if(o)throw new Error(`[SX] parseList: Invalid syntax at: ${p(e)}.`);t.push(n)}}}h(e),s=$(e)}throw new l("parseList")}function x(e){const n=[];h(e);let r=$(e);for(;!c(r);){switch(r){case"(":g(e),n.push(I(e,")",[]));break;case"'":for(g(e),h(e);;){const r=j(e);if("object"!=typeof r||!Object.prototype.hasOwnProperty.call(r,"comment")){n.push(t(e,r));break}e.config.stripComments||n.push(r)}break;case";":g(e),e.config.stripComments?A(e):n.push(A(e));break;case"#":"|"===d(e,2)[1]?(g(e),g(e),e.config.stripComments?E(e):n.push(E(e))):(g(e),e.config.stripComments?A(e):n.push(A(e)));break;case'"':{const r=d(e,3);if('"'===r[1]&&'"'===r[2]){n.push(j(e));break}}default:throw new Error(`[SX] parseInitialState: Invalid syntax at: ${p(e)}.`)}h(e),r=$(e)}return n}function O(e){if(e.evalCount++,e.config.maxEvalCount&&e.config.maxEvalCount<e.evalCount)throw new i}function N(e,n,r,t){if(n.length<r)throw new Error(`[SX] ${e}: Invalid argument length: expected: ${r} / args: ${n.length}.`);if(t&&t<n.length)throw new Error(`[SX] ${e}: Invalid argument length: expected: ${t} / args: ${n.length}.`);return!0}function X(e){switch(typeof e){case"object":case"symbol":case"function":return NaN;default:return Number(e)}}function k(e,n){const r=e.macroMap.get(n.symbol);return!!r&&r.fn(e,n.symbol)}function P(e,n,r){for(let r=e.scopes.length-1;r>0;r--){const t=e.scopes[r];if(t&&Object.prototype.hasOwnProperty.call(t.scope,n.symbol))return t.scope;if(!t.isBlockLocal)break}const t=q(e);return Object.prototype.hasOwnProperty.call(t.scope,n.symbol)?t.scope:r?null:F(e).scope}function M(e,n){const r=P(e,n,!0);if(r)return r[n.symbol];const t=e.symbolMap.get(n.symbol);if(t)return t.fn(e,n.symbol);if(e.config.valueSymbolResolverFallback)return e.config.valueSymbolResolverFallback(e,n.symbol);if(e.config.raiseOnUnresolvedSymbol)throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${n.symbol}.`);return n.symbol}function T(e,n,r){e.scopes.push({isBlockLocal:r,scope:n})}function C(e){if(e.scopes.length<2)throw new Error("[SX] uninstallScope: Unable to pop stack.");return e.scopes.pop()}function F(e){return e.scopes[e.scopes.length-1]}function q(e){return e.scopes[0]}function L(e,n){if(O(e),null===n||void 0===n)return n;let r=n;for(;Array.isArray(r);){{if(0===r.length)return r;const n=s(r[0]);if(!n)break;{const t=k(e,n);if(!t)break;r=t(r)}}O(e)}if(Array.isArray(r)){if(0<(r=r.slice(0)).length){const n=s(r[0]);if(n){if(n.symbol===e.config.reservedNames.quote)return r.slice(1,2)[0];if(n.symbol===e.config.reservedNames.eval)return L(e,r[1])}const t=[];for(let n=1;n<r.length;n++){if(Array.isArray(r[n])&&s(r[n][0],e.config.reservedNames.spread)){t.push(n);const o=L(e,r[n][1]);r[n]=Array.isArray(o)?o:[o]}else r[n]=L(e,r[n])}for(const e of t.reverse())r=r.slice(0,e).concat(r[e],r.slice(e+1));let o;if("function"!=typeof(o="function"==typeof r[0]?r[0]:n?function(e,n){if("function"==typeof n)return n;const r=e.funcMap.get(n.symbol);if(r)return r.fn(e,n.symbol);{const r=M(e,n);if("function"==typeof r)return r;if(e.config.funcSymbolResolverFallback)return e.config.funcSymbolResolverFallback(e,n.symbol);if(e.config.raiseOnUnresolvedSymbol)throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${n.symbol}.`);return n.symbol}}(e,n):L(e,r[0])))throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);r=o(...r.slice(1))}}else if(e.config.wrapExternalValue&&Object.prototype.hasOwnProperty.call(r,"value"))r=r.value;else if(Object.prototype.hasOwnProperty.call(r,"symbol"))r=M(e,r);else if(Object.prototype.hasOwnProperty.call(r,"car")){const n=L(e,r.car),t=L(e,r.cdr);if(Array.isArray(t)){const e=t.slice(0);e.unshift(n),r=e}else r={car:n,cdr:t}}else Object.prototype.hasOwnProperty.call(r,"dotted")?r=[L(e,r.dotted)]:Object.prototype.hasOwnProperty.call(r,"comment")&&(r=[]);return r}const R=(e,n)=>(...e)=>{N("$car",e,1,1);const n=G(...e);if(!Array.isArray(n))throw new Error("[SX] $car: Invalid argument(s): args[0] is not array.");if(0===n.length)throw new Error("[SX] $car: Invalid argument(s): args[0] is nil.");return n[0]},U=(R(),(e,n)=>(...e)=>{N("$cdr",e,1,1);const n=G(...e);if(!Array.isArray(n))throw new Error("[SX] $car: Invalid argument(s): args[0] is not array.");if(0===n.length)throw new Error("[SX] $car: Invalid argument(s): args[0] is nil.");return n.slice(1)}),V=(U(),(e,n)=>(...e)=>{N("$cons",e,2,2);let{car:n,cdr:r}=W(...e);return null===n&&(n=[]),null===r&&(r=[]),Array.isArray(r)?(r.unshift(n),r):{car:n,cdr:r}}),B=(V(),(e,n)=>(...e)=>{const n=e.slice(0,1);return 1===n.length?n[0]:null}),G=(...e)=>{const n=e.slice(0,1);return 1===n.length?n[0]:null},H=(e,n)=>(...e)=>{const n=e.slice(1,2);return 1===n.length?n[0]:null},J=(...e)=>{const n=e.slice(1,2);return 1===n.length?n[0]:null},Y=(e,n)=>(...e)=>{const n=e.slice(e.length-1,e.length);return 1===n.length?n[0]:null},z=(e,n)=>(...e)=>{const n=e.slice(1);return 0<n.length?n:null},D=(e,n)=>(...e)=>{let n=e.slice(0,1);n=1===n.length?n[0]:null;let r=e.slice(1,2);return{car:n,cdr:r=1===r.length?r[0]:null}},W=(...e)=>{let n=e.slice(0,1);n=1===n.length?n[0]:null;let r=e.slice(1,2);return{car:n,cdr:r=1===r.length?r[0]:null}},K=(e,n)=>(...e)=>{N("$atom",e,1,1);const n=G(...e);if(null===n||void 0===n)return!0;if(Array.isArray(n))return 0===n.length;switch(typeof n){case"number":case"string":case"function":case"boolean":return!0;case"object":return!!s(n)}return!1},Q=(K(),(e,n)=>(...e)=>{N("$eq",e,2,2);const{car:n,cdr:r}=W(...e);return n===r}),Z=(Q(),(e,n)=>(...e)=>{N("$notEq",e,2,2);const{car:n,cdr:r}=W(...e);return n!==r}),ee=(Z(),(e,n)=>(...e)=>e.slice(0)),ne=(e,n)=>(...n)=>{N("$__scope",n,3);const r=G(...n),t=J(...n),{car:o,cdr:a}=W(...n.slice(2));let i=null,l=!1;try{const c={};if(Array.isArray(o))for(const n of o)if(Array.isArray(n)){const r=W(...n),t=s(r.car);c[t?t.symbol:String(r.car)]=L(e,r.cdr)}else{const e=s(n);c[e?e.symbol:String(n)]=null}if(T(e,c,r),l=!0,4<n.length)if(t){i=[];for(const r of n.slice(3))i.push(L(e,r))}else for(const r of n.slice(3))i=L(e,r);else i=L(e,a)}finally{l&&C(e)}return i},re=(e,n)=>(...n)=>{N("$__lambda",n,2);const r=n[0];if(!Array.isArray(r))throw new Error("[SX] $__lambda: Invalid argument(s): args[0] is not array.");let o=!1;for(let n=0;n<r.length;n++){const t=r[n];if(n===r.length-1&&e.config.enableSpread&&Array.isArray(t)&&s(t[0],e.config.reservedNames.spread)){if(!s(t[1]))throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${n}] is not symbol.`);r[n]=t[1],o=!0}else if(!s(t))throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${n}] is not symbol.`)}let a=n.slice(1);e.config.enableTailCallOptimization&&(a=function(e,n,r){if(Array.isArray(r[r.length-1])){const t=r.slice(0,r.length-1),o=r[r.length-1];if(o&&o[0].symbol===e.config.reservedNames.if&&o[3][0].symbol===e.config.reservedNames.self)return[[{symbol:e.config.reservedNames.until},o[1],...t,...o[3].slice(1).map((r,t)=>[{symbol:e.config.reservedNames.let},n[t],r])],o[2]]}return r}(e,r,a));const i=(...n)=>{if(n.length+(o?1:0)<r.length)throw new Error(`[SX] func call: Actual args too short: actual ${n.length} / formal ${r.length}.`);return ne(e)(!1,!1,[[e.config.reservedNames.self,i],...r.map((s,a)=>[s.symbol,t(e,o&&a===r.length-1?n.slice(a):n[a])])],...a)};return i},te=(e,n)=>(...e)=>{N("$apply",e,1);const n=G(...e);if("function"!=typeof n)throw new Error("[SX] $apply: Invalid argument(s): args[0] is not function.");return(...r)=>n.apply(null,e.slice(1).concat(r))},oe=(te(),(e,n)=>(...e)=>{throw G(...e)}),se=(oe(),(e,n)=>(...e)=>{N("$pipe",e,1);let n=e[0];for(let r=1;r<e.length;r++)n=e[r](n);return n}),ae=(se(),(e,n)=>(...n)=>{N("$__let",n,2,2);let r=s(G(...n));if(!r){if("string"!=typeof n[0])throw new Error("[SX] $__let: Invalid argument(s): invalid name.");r={symbol:n[0]}}return P(e,r,!1)[r.symbol]=n[1],n[1]}),ie=(e,n)=>(...n)=>{N("$__set",n,2,2);let r=[];Array.isArray(n[0])?r=n[0]:r.push(n[0]);let t=s(r[0]);if(!t){if("string"!=typeof r[0])throw new Error("[SX] $__set: Invalid argument(s): invalid name.");t={symbol:r[0]}}let o=P(e,t,!0);if(null===o)throw new Error(`[SX] $__set: Unresolved symbol: ${t.symbol}.`);let a=!1;for(let i=0;i<r.length;i++){let l=r[i],c=!0;const f=i===r.length-1;for(;c;)switch(typeof l){case"function":o=l(o),c=!1;break;case"object":if(Array.isArray(l))l=L(e,l);else if(t=s(l))l=t.symbol;else{if(!Object.prototype.hasOwnProperty.call(l,"value"))throw new Error("[SX] $__set: Invalid argument(s): invalid name.");l=L(e,l)}break;case"number":l<0&&(l=o.length+l);case"string":f?(o[l]=n[1],a=!0):o=o[l],c=!1;break;default:throw new Error("[SX] $__set: Invalid argument(s): invalid name.")}}if(!a)throw new Error("[SX] $__set: Invalid argument(s): last path is not lvalue.");return n[1]},le=(e,n)=>(...e)=>{N("$boolean",e,1,1);const n=G(...e);return(!Array.isArray(n)||0!==n.length)&&Boolean(n)},ce=le(),fe=(e,n)=>(...e)=>(N("$not",e,1,1),!ce(...e)),ue=fe(),me=(e,n)=>(...n)=>{N("$__and",n,1);let r=null;for(let t=0;t<n.length;t++){const o=L(e,n[t]);if(!ce(o))return o;r=o}return r},ye=(me(null),(e,n)=>(...n)=>{N("$__or",n,1);let r=null;for(let t=0;t<n.length;t++){const o=L(e,n[t]);if(ce(o))return o;r=o}return r}),pe=(ye(null),(e,n)=>(...e)=>{N("$ambiguousEq",e,2,2);let{car:n,cdr:r}=W(...e);return Array.isArray(n)&&0===n.length&&(n=null),Array.isArray(r)&&0===r.length&&(r=null),void 0===n&&(n=null),void 0===r&&(r=null),n==r}),ge=pe(),de=(e,n)=>(...e)=>!ge(...e),$e=(de(),(e,n)=>(...e)=>{N("$lt",e,2,2);const{car:n,cdr:r}=W(...e);return X(n)<X(r)}),he=($e(),(e,n)=>(...e)=>{N("$le",e,2,2);const{car:n,cdr:r}=W(...e);return X(n)<=X(r)}),be=(he(),(e,n)=>(...e)=>{N("$gt",e,2,2);const{car:n,cdr:r}=W(...e);return X(n)>X(r)}),we=(be(),(e,n)=>(...e)=>{N("$ge",e,2,2);const{car:n,cdr:r}=W(...e);return X(n)>=X(r)}),ve=(we(),(e,n)=>(...e)=>(N("$isList",e,1,1),Array.isArray(G(...e)))),_e=(ve(),(e,n)=>(...e)=>(N("$isString",e,1,1),"string"==typeof G(...e))),Se=(_e(),(e,n)=>(...e)=>(N("$isNumber",e,1,1),"number"==typeof G(...e))),Ae=(Se(),(e,n)=>(...e)=>(N("$isNaN",e,1,1),Number.isNaN(G(...e)))),Ee=(Ae(),(e,n)=>(...e)=>(N("$isFinite",e,1,1),Number.isFinite(G(...e)))),je=(Ee(),(e,n)=>(...e)=>(N("$isInteger",e,1,1),Number.isInteger(G(...e)))),Ie=(je(),(e,n)=>(...e)=>(N("$toString",e,1,1),String(G(...e)))),xe=(Ie(),(e,n)=>(...e)=>(N("$toNumber",e,1,1),X(G(...e)))),Oe=(xe(),(e,n)=>(...e)=>(N("$objectAssign",e,1),Object.assign(e[0],...e.slice(1)))),Ne=(Oe(),(e,n)=>(...e)=>(N("$jsonStringify",e,1,1),JSON.stringify(G(...e)))),Xe=(Ne(),(e,n)=>(...e)=>{N("$jsonParse",e,1,1);const n=G(...e);if("string"!=typeof n)throw new Error("[SX] $jsonParse: Invalid argument(s): args[0] is not string.");return JSON.parse(n)}),ke=(Xe(),(e,n)=>(...e)=>(console.log(...e),null)),Pe=(ke(),(e,n)=>(...e)=>(console.error(...e),null));Pe();var Me=[{name:"$car",fn:R},{name:"$cdr",fn:U},{name:"$cons",fn:V},{name:"$first",fn:B},{name:"$second",fn:H},{name:"$last",fn:Y},{name:"$progn",fn:Y},{name:"$rest",fn:z},{name:"$first-and-second",fn:D},{name:"$atom",fn:K},{name:"$eq",fn:Q},{name:"===",fn:Q},{name:"$not-eq",fn:Z},{name:"!==",fn:Z},{name:"$list",fn:ee},{name:"$__scope",fn:ne},{name:"$__global",fn:(e,n)=>(...n)=>{N("$__globalScope",n,1);const r=G(...n),t=J(...n);let o=null;try{if(T(e,q(e).scope,!0),2<n.length)if(r){o=[];for(const r of n.slice(1))o.push(L(e,r))}else for(const r of n.slice(1))o=L(e,r);else o=L(e,t)}finally{C(e)}return o}},{name:"$__lambda",fn:re},{name:"$__defun",fn:(e,n)=>(...n)=>{N("$__defun",n,3);const r=G(...n),t=re(e)(...n.slice(1));return e.funcMap.set(r.symbol,{name:r.symbol,fn:(e,n)=>t}),t}},{name:"$apply",fn:te},{name:"$__call",fn:(e,n)=>(...n)=>{N("$__call",n,2);const{car:r,cdr:t}=W(...n),o=s(t);return Function.prototype.apply.call(r[o?o.symbol:L(e,t)],r,n.slice(2))}},{name:"$__try",fn:(e,n)=>(...n)=>{N("$__try",n,1,2);let r=[];try{r=L(e,n[0])}catch(o){if(o instanceof a)throw o;r=1<n.length?ne(e)(!0,!1,[["$error",t(e,o)],["$parent",t(e,F(e))]],n[1]):null}return r}},{name:"$raise",fn:oe},{name:"$__if",fn:(e,n)=>(...n)=>{N("$__if",n,2,3);const r=G(...n);let t=[];return t=ce(r)?L(e,n[1]):2<n.length?L(e,n[2]):null}},{name:"$__if-null",fn:(e,n)=>(...n)=>{N("$__ifNull",n,2,2);const{car:r,cdr:t}=W(...n);let o=[];return o=ge(r,null)?L(e,t):r}},{name:"$__cond",fn:(e,n)=>(...n)=>{N("$__cond",n,1);for(let r=0;r<n.length-1;r+=2){const t=n[r],o=n[r+1];if(ce(L(e,t)))return L(e,o)}return null}},{name:"$__while",fn:(e,n)=>(...n)=>{N("$__while",n,1);const r=G(...n),t=n.slice(1);let o=null;for(;ce(L(e,r));)for(const n of t)o=L(e,n);return o}},{name:"$__do-while",fn:(e,n)=>(...n)=>{N("$__doWhile",n,1);const r=G(...n),t=n.slice(1);let o=null;do{for(const n of t)o=L(e,n)}while(ce(L(e,r)));return o}},{name:"$__until",fn:(e,n)=>(...n)=>{N("$__until",n,1);const r=G(...n),t=n.slice(1);let o=null;for(;ue(L(e,r));)for(const n of t)o=L(e,n);return o}},{name:"$__do-until",fn:(e,n)=>(...n)=>{N("$__doUntil",n,1);const r=G(...n),t=n.slice(1);let o=null;do{for(const n of t)o=L(e,n)}while(ue(L(e,r)));return o}},{name:"$__repeat",fn:(e,n)=>(...n)=>{N("$__repeat",n,2);const r=s(G(...n));if(!r)throw new Error("[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.");const t=P(e,r,!1),o=X(J(...n)),a=n.slice(2);let i=null;for(let n=0;n<o;n++){t[r.symbol]=n;for(const n of a)i=L(e,n)}return i}},{name:"$__for",fn:(e,n)=>(...n)=>{N("$__for",n,2);const r=s(G(...n));if(!r)throw new Error("[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.");const t=P(e,r,!1),o=J(...n);if(!Array.isArray(o))throw new Error("[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.");const a=n.slice(2);let i=null;for(const n of o){t[r.symbol]=n;for(const n of a)i=L(e,n)}return i}},{name:"$pipe",fn:se},{name:"$__get",fn:(e,n)=>(...n)=>{N("$__get",n,1);let r=null,t=s(n[0]);if(!t)switch(typeof n[0]){case"string":case"number":t={symbol:String(n[0])};break;default:r=L(e,n[0])}if(t){const n=P(e,t,!0);if(!n)throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol "${t.symbol}" is not defined.`);r=n[t.symbol]}for(let o=1;o<n.length;o++){let a=n[o],i=!0;for(;i;)switch(typeof a){case"function":r=a(r),i=!1;break;case"object":if(Array.isArray(a))a=L(e,a);else if(t=s(a))a=t.symbol;else{if(!Object.prototype.hasOwnProperty.call(a,"value"))throw new Error("[SX] $__get: Invalid argument(s): invalid name path.");a=L(e,a)}break;case"number":a<0&&(a=r.length+a);case"string":r=r[a],i=!1;break;default:throw new Error("[SX] $__get: Invalid argument(s): invalid name path.")}}return r}},{name:"$__let",fn:ae},{name:"$__set",fn:ie},{name:"$boolean",fn:le},{name:"$not",fn:fe},{name:"$__and",fn:me},{name:"$__or",fn:ye},{name:"==",fn:pe},{name:"!=",fn:de},{name:"<",fn:$e},{name:"<=",fn:he},{name:">",fn:be},{name:">=",fn:we},{name:"$is-list",fn:ve},{name:"$is-string",fn:_e},{name:"$is-number",fn:Se},{name:"$is-NaN",fn:Ae},{name:"$is-finite",fn:Ee},{name:"$is-integer",fn:je},{name:"$to-string",fn:Ie},{name:"$to-number",fn:xe},{name:"$__#",fn:(e,n)=>(...n)=>{const r={};for(const t of n){if(!(Array.isArray(t)&&0<t.length))throw new Error("[SX] $__toObject: Invalid argument(s): args[?] is not array.");{const n=s(t[0]),o=n?n.symbol:String(L(e,t[0]));1===t.length?r[o]=!0:2===t.length?r[o]=L(e,t[1]):r[o]=L(e,[{symbol:e.config.reservedNames.list}].concat(t.slice(1)))}}return r}},{name:"$object-assign",fn:Oe},{name:"$json-stringify",fn:Ne},{name:"$json-parse",fn:Xe},{name:"$console-log",fn:ke},{name:"$console-error",fn:Pe}];var Te=[{name:"$scope",fn:(e,n)=>n=>[{symbol:"$__scope"},n[1],n[2],...n.slice(3).map(n=>t(e,n))]},{name:"$local",fn:(e,n)=>n=>[{symbol:"$__scope"},!0,!1,...n.slice(1).map(n=>t(e,n))]},{name:"$global",fn:(e,n)=>n=>[{symbol:"$__global"},!1,...n.slice(1).map(n=>t(e,n))]},{name:"$clisp-let",fn:(e,n)=>n=>[{symbol:"$__scope"},!0,!1,...n.slice(1).map(n=>t(e,n))]},{name:"$lambda",fn:(e,n)=>n=>[{symbol:"$__lambda"},...n.slice(1).map(n=>t(e,n))]},{name:"->",fn:(e,n)=>n=>[{symbol:"$__lambda"},...n.slice(1).map(n=>t(e,n))]},{name:"$defun",fn:(e,n)=>n=>[{symbol:"$__defun"},...n.slice(1).map(n=>t(e,n))]},{name:"$call",fn:(e,n)=>n=>(N("$call",n,3),[{symbol:"$__call"},n[1],t(e,n[2]),...n.slice(3)])},{name:"$try",fn:(e,n)=>n=>[{symbol:"$__try"},...n.slice(1).map(n=>t(e,n))]},{name:"$if",fn:(e,n)=>n=>[{symbol:"$__if"},n[1],...n.slice(2).map(n=>t(e,n))]},{name:"$if-null",fn:(e,n)=>n=>[{symbol:"$__if-null"},n[1],...n.slice(2).map(n=>t(e,n))]},{name:"??",fn:(e,n)=>n=>[{symbol:"$__if-null"},n[1],...n.slice(2).map(n=>t(e,n))]},{name:"$cond",fn:(e,n)=>n=>[{symbol:"$__cond"},...n.slice(1).map(n=>t(e,n))]},{name:"$while",fn:(e,n)=>n=>[{symbol:"$__while"},...n.slice(1).map(n=>t(e,n))]},{name:"$do-while",fn:(e,n)=>n=>[{symbol:"$__do-while"},...n.slice(1).map(n=>t(e,n))]},{name:"$until",fn:(e,n)=>n=>[{symbol:"$__until"},...n.slice(1).map(n=>t(e,n))]},{name:"$do-until",fn:(e,n)=>n=>[{symbol:"$__do-until"},...n.slice(1).map(n=>t(e,n))]},{name:"$repeat",fn:(e,n)=>n=>{if(!s(n[2],"of"))throw new Error("[SX] $repeat: Invalid syntax: missing 'of' keyword.");return[{symbol:"$__repeat"},t(e,n[1]),n[3],...n.slice(4).map(n=>t(e,n))]}},{name:"$for",fn:(e,n)=>n=>{if(!s(n[2],"of"))throw new Error("[SX] $for: Invalid syntax: missing 'of' keyword.");return[{symbol:"$__for"},t(e,n[1]),n[3],...n.slice(4).map(n=>t(e,n))]}},{name:"$get",fn:(e,n)=>n=>[{symbol:"$__get"},...n.slice(1).map(n=>t(e,n))]},{name:"$let",fn:(e,n)=>n=>(N("$let",n,3,3),[{symbol:"$__let"},t(e,n[1]),n[2]])},{name:"$clisp-defvar",fn:(e,n)=>n=>(N("$clisp-defvar",n,3,3),[{symbol:"$global"},[{symbol:"$__let"},t(e,n[1]),n[2]]])},{name:"$set",fn:(e,n)=>n=>(N("$set",n,3,3),[{symbol:"$__set"},t(e,n[1]),n[2]])},{name:"$clisp-setq",fn:(e,n)=>n=>(N("$clisp-setq",n,3,3),[{symbol:"$__set"},t(e,n[1]),n[2]])},{name:"$and",fn:(e,n)=>n=>[{symbol:"$__and"},...n.slice(1).map(n=>t(e,n))]},{name:"$or",fn:(e,n)=>n=>[{symbol:"$__or"},...n.slice(1).map(n=>t(e,n))]},{name:"#",fn:(e,n)=>n=>[{symbol:"$__#"},...n.slice(1).map(n=>t(e,n))]}];var Ce=[{name:"nil",fn:(e,n)=>[]},{name:"null",fn:(e,n)=>null},{name:"undefined",fn:(e,n)=>void 0},{name:"true",fn:(e,n)=>!0},{name:"#true",fn:(e,n)=>!0},{name:"#t",fn:(e,n)=>!0},{name:"false",fn:(e,n)=>!1},{name:"#false",fn:(e,n)=>!1},{name:"#f",fn:(e,n)=>!1},{name:"#Number:Infinity",fn:(e,n)=>Number.POSITIVE_INFINITY},{name:"+Infinity",fn:(e,n)=>Number.POSITIVE_INFINITY},{name:"-Infinity",fn:(e,n)=>Number.NEGATIVE_INFINITY},{name:"#Number:Epsilon",fn:(e,n)=>Number.EPSILON},{name:"#Number:MaxValue",fn:(e,n)=>Number.MAX_VALUE},{name:"#Number:MinValue",fn:(e,n)=>Number.MIN_VALUE},{name:"#Number:MinSafeInteger",fn:(e,n)=>Number.MAX_SAFE_INTEGER},{name:"#Number:MinSafeInteger",fn:(e,n)=>Number.MIN_SAFE_INTEGER},{name:"NaN",fn:(e,n)=>Number.NaN}];function Fe(e){return e.funcs=(e.funcs||[]).concat(Me),e.macros=(e.macros||[]).concat(Te),e.symbols=(e.symbols||[]).concat(Ce),e}const qe=(e,n)=>(...e)=>{N("$bitLShift",e,2,2);let{car:n,cdr:r}=W(...e);return n=X(n),0<=(r=X(r))?r<32?n<<r:0:r>-32?n>>>-r:0},Le=(qe(),(e,n)=>(...e)=>{N("$bitSRShift",e,2,2);let{car:n,cdr:r}=W(...e);return n=X(n),0<=(r=X(r))?r<32?n>>r:2147483648&n?-1:0:r>-32?n<<-r:0}),Re=(Le(),(e,n)=>(...e)=>{N("$bitURShift",e,2,2);let{car:n,cdr:r}=W(...e);return n=X(n),0<=(r=X(r))?r<32?n>>>r:0:r>-32?n<<-r:0}),Ue=(Re(),(e,n)=>(...e)=>{return N("$bitNot",e,1,1),~X(G(...e))}),Ve=(Ue(),(e,n)=>(...e)=>{N("$bitAnd",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)&X(n),X(n))}),Be=(Ve(),(e,n)=>(...e)=>{N("$bitOr",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)|X(n),X(n))}),Ge=(Be(),(e,n)=>(...e)=>{N("$bitXor",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)^X(n),X(n))}),He=(Ge(),(e,n)=>(...e)=>(N("$add",e,1),e.reduce((e,n)=>X(e)+X(n),0))),Je=(He(),(e,n)=>(...e)=>{N("$sub",e,1);const n=G(...e);return 0===e.slice(1).length?-X(n):e.slice(1).reduce((e,n)=>X(e)-X(n),X(n))}),Ye=(Je(),(e,n)=>(...e)=>{N("$mul",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)*X(n),X(n))}),ze=(Ye(),(e,n)=>(...e)=>{N("$sup",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>Math.pow(X(e),X(n)),X(n))}),De=(ze(),(e,n)=>(...e)=>{N("$div",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)/X(n),X(n))}),We=(De(),(e,n)=>(...e)=>{N("$mod",e,2);const n=G(...e);return e.slice(1).reduce((e,n)=>X(e)%X(n),X(n))}),Ke=(We(),(e,n)=>(...e)=>Math.max(...e.map(e=>X(e)))),Qe=(Ke(),(e,n)=>(...e)=>Math.min(...e.map(e=>X(e)))),Ze=(Qe(),(e,n)=>(...e)=>{const n=e.map(e=>X(e));return n.length>0?n.reduce((e,n)=>e+n,0)/n.length:NaN}),en=(Ze(),(e,n)=>(...e)=>(N("$floor",e,1,1),Math.floor(X(G(...e))))),nn=(en(),(e,n)=>(...e)=>(N("$ceil",e,1,1),Math.ceil(X(G(...e))))),rn=(nn(),(e,n)=>(...e)=>(N("$round",e,1,1),Math.round(X(G(...e))))),tn=(rn(),(e,n)=>(...e)=>(N("$abs",e,1,1),Math.abs(X(G(...e))))),on=(tn(),(e,n)=>(...e)=>(N("$sign",e,1,1),Math.sign(X(G(...e)))));on();var sn=[{name:"<<",fn:qe},{name:"$bit-l-shift",fn:qe},{name:">>",fn:Le},{name:"$bit-sr-shift",fn:Le},{name:">>>",fn:Re},{name:"$bit-ur-shift",fn:Re},{name:"$bit-not",fn:Ue},{name:"$bit-and",fn:Ve},{name:"$bit-or",fn:Be},{name:"$bit-xor",fn:Ge},{name:"+",fn:He},{name:"$add",fn:He},{name:"$sum",fn:He},{name:"-",fn:Je},{name:"$sub",fn:Je},{name:"$neg",fn:Je},{name:"*",fn:Ye},{name:"$mul",fn:Ye},{name:"**",fn:ze},{name:"$sup",fn:ze},{name:"/",fn:De},{name:"$div",fn:De},{name:"%",fn:We},{name:"$mod",fn:We},{name:"$max",fn:Ke},{name:"$min",fn:Qe},{name:"$avg",fn:Ze},{name:"$floor",fn:en},{name:"$ceil",fn:nn},{name:"$round",fn:rn},{name:"$abs",fn:tn},{name:"$sign",fn:on}];var an=[];var ln=[];function cn(e){return e.funcs=(e.funcs||[]).concat(sn),e.macros=(e.macros||[]).concat(an),e.symbols=(e.symbols||[]).concat(ln),e}class fn{constructor(e){this.data=e}orderBy(e){let n;return n=Array.isArray(e)?(n,r)=>{for(const t of e)if("string"==typeof t){if(n[t]>r[t])return 1;if(n[t]<r[t])return-1}else{const e="desc"===t[1]?-1:1;if(n[t[0]]>r[t[0]])return 1*e;if(n[t[0]]<r[t[0]])return-1*e}return 0}:e,new fn(this.data.slice(0).sort(n))}groupBy(e){let n;n=Array.isArray(e)?(n,r)=>{for(const t of e)if(n[t]!==r[t])return!1;return!0}:e;const r=[];let t=0,o=1;for(;o<this.data.length;o++)n(this.data[t],this.data[o],o,this.data)||(r.push(this.data.slice(t,o)),t=o);return r.push(this.data.slice(t,o)),new fn(r)}groupEvery(e){if("number"==typeof e)return this.groupBy((n,r,t,o)=>t%e!=0);{const n=Object.assign({first:e.intermediate,last:e.intermediate},e),r=this.groupBy((e,r,t,o)=>n.single>=o.length?t%n.single!=0:t<=n.first?t%n.first!=0:(t-n.first)%n.intermediate!=0);return 1===r.data.length?n.single<r.data[0].length&&r.data.push([]):n.first<r.data[0].length&&r.data.unshift([]),r.data.length>1&&r.data[r.data.length-1].length>n.last&&r.data.push([]),r}}where(e){return new fn(this.data.filter(e))}select(e){return e?this.data.map(e):this.data}}function un(e){return new fn(e)}const mn=(e,n)=>(...e)=>{N("$length",e,1,1);const n=G(...e);switch(typeof n){case"object":if(!("length"in n))break;case"string":return n.length}throw new Error("[SX] $length: Invalid argument type: object has no property 'length'.")},yn=(mn(),(e,n)=>(...e)=>{N("$trim",e,1,1);const n=G(...e);if("string"==typeof n)return n.trim();throw new Error("[SX] $trim: Invalid argument type: args[0] is not string.")}),pn=(yn(),(e,n)=>(...e)=>{N("$trimHead",e,1,1);const n=G(...e);if("string"==typeof n)return n.trimLeft();throw new Error("[SX] $trimHead: Invalid argument type: args[0] is not string.")}),gn=(pn(),(e,n)=>(...e)=>{N("$trimTail",e,1,1);const n=G(...e);if("string"==typeof n)return n.trimRight();throw new Error("[SX] $trimTail: Invalid argument type: args[0] is not string.")}),dn=(gn(),(e,n)=>(...e)=>{if(N("$replaceAll",e,3,3),"string"==typeof e[0]&&"string"==typeof e[1]&&"string"==typeof e[2])return e[0].split(e[1]).join(e[2]);throw new Error("[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.")}),$n=(dn(),(e,n)=>(...e)=>{if(N("$split",e,2,2),"string"==typeof e[0]&&"string"==typeof e[1])return e[0].split(e[1]);throw new Error("[SX] $split: Invalid argument type: args[0] or [1] is not string.")}),hn=($n(),(e,n)=>(...e)=>{if(N("$join",e,1,2),Array.isArray(e[0]),e.length>1){if("string"==typeof e[1])return e[0].join(e[1]);throw new Error("[SX] $join: Invalid argument type: args[1] is not string.")}return e[0].join()}),bn=(hn(),(e,n)=>(...e)=>{N("$concat",e,1);const n=G(...e);switch(typeof n){case"object":if(!("concat"in n))break;case"string":return n.concat(...e.slice(1))}throw new Error("[SX] $concat: Invalid argument type: object has no property 'concat'.")}),wn=(bn(),(e,n)=>(...e)=>{if(N("$slice",e,2,3),3===e.length&&("string"==typeof e[2]||Array.isArray(e[2])))return e[2].slice(X(e[0]),X(e[1]));if(2===e.length&&("string"==typeof e[1]||Array.isArray(e[1])))return e[1].slice(X(e[0]));throw new Error(`[SX] $slice: Invalid argument type: args[${e.length-1}] is not string or array.`)}),vn=(wn(),(e,n)=>(...e)=>{if(N("$top",e,2,2),"string"==typeof e[1]||Array.isArray(e[1]))return e[1].slice(0,X(e[0]));throw new Error("[SX] $top: Invalid argument type: args[1] is not string or array.")}),_n=(vn(),(e,n)=>(...e)=>{if(N("$tail",e,2,2),"string"==typeof e[1]||Array.isArray(e[1])){const n=-X(e[0]);return e[1].slice(n>=0||Number.isNaN(n)?e[1].length:n)}throw new Error("[SX] $tail: Invalid argument type: args[1] is not string or array.")}),Sn=(_n(),(e,n)=>(...e)=>{N("$__at",e,2,2);const{car:n,cdr:r}=W(...e);return r[n]}),An=(Sn(),(e,n)=>(...e)=>{N("$reverse",e,1,1);const n=G(...e);if(Array.isArray(n))return n.slice(0).reverse();throw new Error("[SX] $reverse: Invalid argument type: args[0] is not array.")}),En=(An(),(e,n)=>(...e)=>{N("$reverse!",e,1,1);const n=G(...e);if(Array.isArray(n))return n.reverse();throw new Error("[SX] $reverse!: Invalid argument type: args[0] is not array.")}),jn=(En(),(e,n)=>(...e)=>{N("$find",e,2,2);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return n.find(r);throw new Error("[SX] $find: Invalid argument type: args[0] is not array.")}),In=(jn(),(e,n)=>(...e)=>{N("$filter",e,2,2);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return n.filter(r);throw new Error("[SX] $filter: Invalid argument type: args[0] is not array.")}),xn=(In(),(e,n)=>(...e)=>{N("$map",e,2,2);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return n.map(r);throw new Error("[SX] $map: Invalid argument type: args[0] is not array.")}),On=(xn(),(e,n)=>(...e)=>{N("$reduce",e,2,3);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return e.length<3?n.reduce(r):n.reduce(r,e[2]);throw new Error("[SX] $reduce: Invalid argument type: args[0] is not array.")}),Nn=(On(),(e,n)=>(...e)=>{N("$reduceFromTail",e,2,3);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return e.length<3?n.reduceRight(r):n.reduceRight(r,e[2]);throw new Error("[SX] $reduceFromTail: Invalid argument type: args[0] is not array.")}),Xn=(Nn(),(e,n)=>(...e)=>{N("$sort",e,2,2);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return n.slice(0).sort(r);throw new Error("[SX] $sort: Invalid argument type: args[0] is not array.")}),kn=(Xn(),(e,n)=>(...e)=>{N("$sort!",e,2,2);const{car:n,cdr:r}=W(...e);if(Array.isArray(n))return n.sort(r);throw new Error("[SX] $sort!: Invalid argument type: args[0] is not array.")}),Pn=(kn(),(e,n)=>(...e)=>{N("$group-every",e,2,2);const{car:n,cdr:r}=W(...e);if(!Array.isArray(r))throw new Error("[SX] $group-every: Invalid argument type: args[1] is not array.");return un(r).groupEvery(n).select()}),Mn=(Pn(),(e,n)=>(...e)=>{N("$group-by",e,2,2);const{car:n,cdr:r}=W(...e);if(!Array.isArray(r))throw new Error("[SX] $group-by: Invalid argument type: args[1] is not array.");return un(r).groupBy(n).select()}),Tn=(Mn(),(e,n)=>(...e)=>{N("$order-by",e,2,2);const{car:n,cdr:r}=W(...e);if(!Array.isArray(r))throw new Error("[SX] $order-by: Invalid argument type: args[1] is not array.");return un(r).orderBy(n).select()}),Cn=(Tn(),(e,n)=>(...e)=>{N("$where",e,2,2);const{car:n,cdr:r}=W(...e);if("function"!=typeof e[0])throw new Error("[SX] $where: Invalid argument type: args[0] is not function.");if(!Array.isArray(r))throw new Error("[SX] $where: Invalid argument type: args[1] is not array.");return un(r).where(n).select()});Cn();var Fn=[{name:"$range",fn:(e,n)=>(...n)=>{N("$range",n,2,3);const{car:r,cdr:t}=W(...n),o=X(r)||0,s=X(t)||0,a=n.length>2&&X(n[2])||(o<=s?1:-1),i=Math.sign(s-o)+Math.sign(a)!==0?Math.floor(Math.abs(s-o)/Math.abs(a))+1:0;return e.evalCount+=i,L(e,0),Array.from({length:i},(e,n)=>o+n*a)}},{name:"$length",fn:mn},{name:"$trim",fn:yn},{name:"$trim-head",fn:pn},{name:"$trim-tail",fn:gn},{name:"$replace-all",fn:dn},{name:"$split",fn:$n},{name:"$join",fn:hn},{name:"$concat",fn:bn},{name:"$slice",fn:wn},{name:"$top",fn:vn},{name:"$tail",fn:_n},{name:"$__at",fn:Sn},{name:"$reverse",fn:An},{name:"$reverse!",fn:En},{name:"$find",fn:jn},{name:"$filter",fn:In},{name:"$map",fn:xn},{name:"$reduce",fn:On},{name:"$reduce-from-head",fn:On},{name:"$reduce-from-tail",fn:Nn},{name:"$sort",fn:Xn},{name:"$sort!",fn:kn},{name:"$group-every",fn:Pn},{name:"$group-by",fn:Mn},{name:"$order-by",fn:Tn},{name:"$where",fn:Cn}];var qn=[{name:"$[",fn:(e,n)=>e=>{if(!s(e[2],"]"))throw new Error("[SX] $repeat: Invalid syntax: missing ']' keyword.");return[{symbol:"$__at"},e[1],e[3]]}}];var Ln=[];function Rn(e){return e.funcs=(e.funcs||[]).concat(Fn),e.macros=(e.macros||[]).concat(qn),e.symbols=(e.symbols||[]).concat(Ln),e}const Un=(e,n)=>(...n)=>{const r={};for(const t of n){if(!(Array.isArray(t)&&0<t.length))throw new Error("[SX] $jsxProps: Invalid argument(s): args[?] is not array.");{const n=s(t[0]),o=n?n.symbol:String(L(e,t[0]));switch(o){case"style":if(1===t.length)r[o]="";else if(t.length>=2){const n={};for(const r of t.slice(1))if(Array.isArray(r)&&1<r.length)n[String(L(e,r[0]))]=String(L(e,r[1]));else if("string"==typeof r)for(const e of r.split(";")){const r=/^\s*(\S+)\s*:\s*(.*?)\s*$/.exec(e);r&&(n[r[1]]=r[2])}r[o]=n}break;case"class":case"styleClass":if(1===t.length)r[o]=[];else if(t.length>=2){let n=[];for(const r of t.slice(1))Array.isArray(r)?n=n.concat(r.map(n=>L(e,n))):"string"==typeof r&&(n=n.concat(r.split(" ")));const s=[],a=e=>e.forEach(e=>null===e||void 0===e?void 0:Array.isArray(e)?a(e):s.push(String(e)));a(n),r[o]=s}break;case"className":if(1===t.length)r[o]="";else if(t.length>=2){let n="";for(const r of t.slice(1)){let t="";if(Array.isArray(r)){const n=[],o=r=>r.map(n=>L(e,n)).forEach(e=>null===e||void 0===e?void 0:Array.isArray(e)?o(e):n.push(String(e)));o(r),t=n.join(" ")}else"string"==typeof r&&(t=r);0<n.length?n+=" "+t:n=t}r[o]=n}break;case"dangerouslySetInnerHTML":1===t.length?r[o]={__html:""}:t.length>=2?r[o]={__html:L(e,t[1])}:r[o]={__html:L(e,[{symbol:e.config.reservedNames.list}].concat(t.slice(1)))};break;case"setInnerText":1===t.length?r[o]={__text:""}:t.length>=2?r[o]={__text:L(e,t[1])}:r[o]={__text:L(e,[{symbol:e.config.reservedNames.list}].concat(t.slice(1)))};break;default:1===t.length?r[o]=!0:2===t.length?r[o]=L(e,t[1]):r[o]=L(e,[{symbol:e.config.reservedNames.list}].concat(t.slice(1)))}}}return r};function Vn(e,...n){let r=n,t={};if(0<n.length&&Array.isArray(n[0])){s(n[0][0],"@")&&(t=Un(e,"")(...n[0].slice(1)),r=r.slice(1))}return{props:t,children:r}}const Bn=(e,n)=>(...r)=>{const{props:t,children:o}=Vn(e,...r);return e.config.jsx(n,t,...o)},Gn=e=>(n,r)=>(...r)=>{const{props:t,children:o}=Vn(n,...r);return n.config.jsx(e,t,...o)};var Hn=[{name:"$=__if",fn:(e,n)=>(...n)=>{N("$__outputIf",n,2);const{car:r,cdr:t}=W(...n);let o=[];return ce(r)&&(2<n.length?(o.push({symbol:e.config.reservedNames.Template},...n.slice(1)),o=L(e,o)):o=L(e,t)),o}},{name:"$=__for",fn:(e,n)=>(...n)=>{N("$__outputForOf",n,2);const r=G(...n),o=[];if(!Array.isArray(r))throw new Error("[SX] $__outputForOf: Invalid argument(s): args[0] is not array.");for(let s=0;s<r.length;s++){const a=r[s],i=ne(e)(!0,!0,[["$data",t(e,a)],["$index",s],["$array",t(e,r)],["$parent",t(e,F(e).scope)]],...n.slice(1));2<n.length&&Array.isArray(i)?o.push(...i):o.push(i)}return L(e,[{symbol:e.config.reservedNames.Template}].concat(o.map(n=>[{symbol:e.config.reservedNames.quote},n])))}}];var Jn=[{name:"@",fn:(e,n)=>n=>t(e,n)},{name:"$=if",fn:(e,n)=>n=>[{symbol:"$=__if"},n[1],...n.slice(2).map(n=>t(e,n))]},{name:"$=for",fn:(e,n)=>n=>[{symbol:"$=__for"},n[1],...n.slice(2).map(n=>t(e,n))]}];var Yn=[];function zn(e,n){e.funcs=(e.funcs||[]).concat(Hn),e.macros=(e.macros||[]).concat(Jn),e.symbols=(e.symbols||[]).concat(Yn);const r=Object.entries(n.components).map(e=>({name:e[0],fn:Gn(e[1])}));return e.funcs=e.funcs.concat({name:e.reservedNames.Template,fn:Gn(n.jsxFlagment)},...r),e.funcSymbolResolverFallback=Bn,e.jsx=n.jsx,e.JsxFragment=n.jsxFlagment,e}const Dn=(e,n)=>(...n)=>{N("$__letAsync",n,2,2);let r=n[1];return"object"==typeof r&&"function"==typeof r.then||(r=Promise.resolve(r)),r=r.then(r=>{try{return ae(e)(n[0],r),r}catch(e){return Promise.reject(e)}})},Wn=(Dn(null),(e,n)=>(...n)=>{N("$__setAsync",n,2,2);let r=n[1];return"object"==typeof r&&"function"==typeof r.then||(r=Promise.resolve(r)),r=r.then(r=>{try{return ie(e)(n[0],r),r}catch(e){return Promise.reject(e)}})}),Kn=(Wn(null),(e,n)=>(...e)=>{N("$then",e,2,3);let n=e[0];if("object"==typeof n&&"function"==typeof n.then||(n=Promise.resolve(n)),"function"==typeof e[2])n=n.then(e[1],e[2]);else{if("function"!=typeof e[1])throw new Error("[SX] $then: Invalid argument(s): args[1] is not function.");n=n.then(e[1])}return n}),Qn=(Kn(),(e,n)=>(...e)=>{const n=e.slice(0);for(let e=0;e<n.length;e++)"object"==typeof n[e]&&"function"==typeof n[e].then||(n[e]=Promise.resolve(n[e]));return Promise.all(n)}),Zn=(Qn(),(e,n)=>(...e)=>{const n=e.slice(0);for(let e=0;e<n.length;e++)"object"==typeof n[e]&&"function"==typeof n[e].then||(n[e]=Promise.resolve(n[e]));const r=e=>new Promise((n,r)=>e.then(r,n));return(e=>r(Promise.all(e.map(r))))(n)}),er=(Zn(),(e,n)=>(...e)=>{N("$resolvePipe",e,1);let n=e[0];"object"==typeof n&&"function"==typeof n.then||(n=Promise.resolve(n));const r=e.slice(1);for(let e=0;e<r.length;e++)if("function"!=typeof r[e]){const n=r[e];r[e]=(()=>n)}let t=n;for(const e of r)t=t.then(e);return t}),nr=(er(),(e,n)=>(...e)=>{N("$resolveFork",e,1);let n=e[0];"object"==typeof n&&"function"==typeof n.then||(n=Promise.resolve(n));const r=e.slice(1);for(let e=0;e<r.length;e++)if("function"!=typeof r[e]){const n=r[e];r[e]=(()=>n)}const t=new Array(r.length),o=new Array(r.length),s=[];for(let e=0;e<r.length;e++)s.push(new Promise((n,s)=>{t[e]=(t=>{let o=r[e](t);"object"==typeof o&&"function"==typeof o.then||(o=Promise.resolve(o)),o.then(e=>n(e)).catch(e=>s(e))}),o[e]=s}));return n.then(e=>t.forEach(n=>n(e)),e=>o.forEach(n=>n(e))),s});nr();var rr=[{name:"$__let-async",fn:Dn},{name:"$__set-async",fn:Wn},{name:"$then",fn:Kn},{name:"$resolve-all",fn:Qn},{name:"$resolve-any",fn:Zn},{name:"$resolve-pipe",fn:er},{name:"$resolve-fork",fn:nr}];var tr=[{name:"$let-async",fn:(e,n)=>n=>(N("$let-async",n,3,3),[{symbol:"$__let-async"},t(e,n[1]),n[2]])},{name:"$set-async",fn:(e,n)=>n=>(N("$set-async",n,3,3),[{symbol:"$__set-async"},t(e,n[1]),n[2]])}];var or=[];function sr(e){return e.funcs=(e.funcs||[]).concat(rr),e.macros=(e.macros||[]).concat(tr),e.symbols=(e.symbols||[]).concat(or),e}var ar=function(e,n,r,t){return new(r||(r=Promise))(function(o,s){function a(e){try{l(t.next(e))}catch(e){s(e)}}function i(e){try{l(t.throw(e))}catch(e){s(e)}}function l(e){e.done?o(e.value):new r(function(n){n(e.value)}).then(a,i)}l((t=t.apply(e,n||[])).next())})};const ir={eval:"$eval",quote:"$quote",spread:"$spread",car:"$car",cdr:"$cdr",cons:"$cons",atom:"$atom",eq:"$eq",list:"$list",let:"$clisp-let",lambda:"$lambda",self:"$self",defun:"$defun",if:"$if",cond:"$cond",while:"$while",doWhile:"$do-while",until:"$until",doUntil:"$do-until",get:"$get",defvar:"$clisp-defvar",setq:"$clisp-setq",set:"$set",not:"$not",and:"$and",or:"$or",Template:"Template"},lr={raiseOnUnresolvedSymbol:!1,enableEvaluate:!0,enableHereDoc:!0,enableSpread:!0,enableTailCallOptimization:!0,stripComments:!1,wrapExternalValue:!0,returnMultipleRoot:!1,maxEvalCount:0,reservedNames:ir,symbols:[],macros:[],funcs:[]};function cr(e,n,r,t){return{strings:"string"==typeof r?[r]:r,values:t||[],index:0,pos:0,line:0,evalCount:0,scopes:[{isBlockLocal:!1,scope:n}],macroMap:new Map(e.macros.map(e=>[e.name,e])),funcMap:new Map(e.funcs.map(e=>[e.name,e])),symbolMap:new Map(e.symbols.map(e=>[e.name,e])),config:e}}function fr(e,n,r){return e.strings="string"==typeof n?[n]:n,e.values=r||[],e.index=0,e.pos=0,e.line=0,e.evalCount=0,e}function ur(e){let n=e||Object.assign({},lr),r={},t=[];const o=(e,r)=>{if(n.enableEvaluate)for(let n=0;n<r.length;n++)r[n]=L(e,r[n]);return n.returnMultipleRoot?1===r.length?r[0]:r:r[r.length-1]},s=(e,...s)=>{const a=cr(n,Object.assign({},r),e,s);return o(a,t.concat(x(a)))};return s.evaluateAST=(e=>{const s=cr(n,Object.assign({},r),"");return o(s,t.concat(e))}),s.repl=(()=>{const e=cr(n,Object.assign({},r),"");o(e,t.slice(0));return(n,...r)=>(fr(e,n,r),o(e,x(e)))}),s.setGlobals=(e=>(r=Object.assign({},e||{}),s)),s.appendGlobals=(e=>(r=Object.assign({},r,e||{}),s)),s.setStartup=((e,...o)=>{const a=cr(n,Object.assign({},r),e,o);return t=x(a),s}),s.setStartupAST=(e=>(t=e,s)),s.appendStartup=((e,...o)=>{const a=cr(n,Object.assign({},r),e,o);return t=t.concat(x(a)),s}),s.appendStartupAST=(e=>(t=t.concat(e),s)),s.install=(e=>(n=e(n),s)),s}function mr(e){let n=e||Object.assign({},lr),r={},t=[];const o=(e,r)=>ar(this,void 0,void 0,function*(){if(n.enableEvaluate)for(let n=0;n<r.length;n++)r[n]=L(e,r[n]),"object"==typeof r[n]&&"function"==typeof r[n].then&&(r[n]=yield r[n]);return n.returnMultipleRoot?1===r.length?r[0]:r:r[r.length-1]}),s=(e,...s)=>ar(this,void 0,void 0,function*(){const a=cr(n,Object.assign({},r),e,s);return o(a,t.concat(x(a)))});return s.evaluateAST=(e=>{const s=cr(n,Object.assign({},r),"");return o(s,t.concat(e))}),s.repl=(()=>{const e=cr(n,Object.assign({},r),"");o(e,t.slice(0));return(n,...r)=>ar(this,void 0,void 0,function*(){return fr(e,n,r),o(e,x(e))})}),s.setGlobals=(e=>(r=Object.assign({},e||{}),s)),s.appendGlobals=(e=>(r=Object.assign({},r,e||{}),s)),s.setStartup=((e,...o)=>{const a=cr(n,Object.assign({},r),e,o);return t=x(a),s}),s.setStartupAST=(e=>(t=e,s)),s.appendStartup=((e,...o)=>{const a=cr(n,Object.assign({},r),e,o);return t=t.concat(x(a)),s}),s.appendStartupAST=(e=>(t=t.concat(e),s)),s.install=(e=>(n=e(n),s)),s}const yr=(()=>{const e=Object.assign({},lr);return e.enableEvaluate=!1,e.returnMultipleRoot=!0,ur(e)})(),pr=(()=>{let e=Object.assign({},lr);return(e=Rn(e=cn(e=Fe(e)))).stripComments=!0,ur(e)})(),gr=pr,dr=pr,$r=(()=>{let e=Object.assign({},lr);return(e=sr(e=Rn(e=cn(e=Fe(e))))).stripComments=!0,mr(e)})(),hr=$r,br=$r,wr=(()=>{let e=Object.assign({},lr);return(e=Rn(e=cn(e=Fe(e)))).stripComments=!0,e.returnMultipleRoot=!0,ur(e)})(),vr=(()=>{let e=Object.assign({},lr);return(e=sr(e=Rn(e=cn(e=Fe(e))))).stripComments=!0,e.returnMultipleRoot=!0,mr(e)})();function _r(e){let n=Object.assign({},lr);return(n=zn(n=Rn(n=cn(n=Fe(n))),e)).stripComments=!0,ur(n)}function Sr(e){let n=Object.assign({},lr);return(n=zn(n=sr(n=Rn(n=cn(n=Fe(n)))),e)).stripComments=!0,mr(n)}r.d(n,"builtinOperators",function(){return Ar}),r.d(n,"builtinMacros",function(){return Er}),r.d(n,"builtinSymbols",function(){return jr}),r.d(n,"defaultReservedNames",function(){return ir}),r.d(n,"defaultConfig",function(){return lr}),r.d(n,"SExpression",function(){return ur}),r.d(n,"SExpressionAsync",function(){return mr}),r.d(n,"S",function(){return yr}),r.d(n,"L",function(){return pr}),r.d(n,"LS",function(){return gr}),r.d(n,"lisp",function(){return dr}),r.d(n,"L_async",function(){return $r}),r.d(n,"LS_async",function(){return hr}),r.d(n,"lisp_async",function(){return br}),r.d(n,"LM",function(){return wr}),r.d(n,"LM_async",function(){return vr}),r.d(n,"LSX",function(){return _r}),r.d(n,"LSX_async",function(){return Sr}),r.d(n,"installCore",function(){return Fe}),r.d(n,"installArithmetic",function(){return cn}),r.d(n,"installSequence",function(){return Rn}),r.d(n,"installJsx",function(){return zn}),r.d(n,"installConcurrent",function(){return sr});const Ar={core:Me,arithmetic:sn,sequence:Fn,jsx:Hn,concurrent:rr},Er={core:Te,arithmetic:an,sequence:qn,jsx:Jn,concurrent:tr},jr={core:Ce,arithmetic:ln,sequence:Ln,jsx:Yn,concurrent:or}}])});
//# sourceMappingURL=liyad.min.js.map