{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/core.fn.ts","webpack://liyad/./src/s-exp/operators/jsx.fn.ts","webpack://liyad/./src/index.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/operators/core.ts","webpack://liyad/./src/s-exp/operators/core.operator.ts","webpack://liyad/./src/s-exp/operators/core.macro.ts","webpack://liyad/./src/s-exp/operators/core.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic.ts","webpack://liyad/./src/s-exp/operators/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence.ts","webpack://liyad/./src/s-exp/operators/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx.ts","webpack://liyad/./src/s-exp/operators/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent.ts","webpack://liyad/./src/s-exp/operators/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent.symbol.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","x","_typeof","symbol","quote","state","config","reservedNames","isQuoted","Array","isArray","length","q","isSymbol","spread","FatalError","_Error","message","_classCallCheck","this","Error","MaxEvaluationCountError","_FatalError","ScriptTerminationError","_FatalError2","where","setEvaluationCount","evalCount","maxEvalCount","_types","checkParamsLength","args","min","max","toNumber","NaN","Number","resolveMacro","resolveFunctionSymbol","resolveValueSymbolScope","resolveValueSymbol","installScope","scope","isBlockLocal","scopes","push","uninstallScope","pop","getScope","getGlobalScope","optimizeTailCall","formalArgs","fnBody","front","slice","tail","if","self","until","concat","_toConsumableArray","map","idx","let","evaluate","_errors","sym","_sym","eval","symSpr","a","fn","JSON","stringify","apply","undefined","wrapExternalValue","car","cdr","_a","unshift","dotted","macroInfo","macroMap","funcInfo","funcMap","v","funcSymbolResolverFallback","raiseOnUnresolvedSymbol","nullIfNotDefined","localScope","globalScope","symInfo","symbolMap","valueSymbolResolverFallback","_evaluate","$car","_key","arguments","$$first","$cdr","$$car","_key2","$cons","$$cdr","_key3","$$firstAndSecond","_$$firstAndSecond","$first","$$cons","_key4","$second","_key5","$$second","$last","_key6","$rest","$$last","_key7","$firstAndSecond","$$rest","_key8","$atom","_key9","$eq","$$atom","_key10","_$$firstAndSecond2","$notEq","$$eq","_key11","_$$firstAndSecond3","$list","$$notEq","_len12","_key12","$__scope","$$list","_key13","returnMultiple","_$$firstAndSecond4","scopeInstalled","_iteratorNormalCompletion","_step","_iterator","iterator","next","done","kv","kvSym","String","xSym","_iteratorNormalCompletion2","_step2","_iterator2","_x","_iteratorNormalCompletion3","_step3","_iterator3","_x2","$__lambda","$__globalScope","_key14","_iteratorNormalCompletion4","_step4","_iterator4","_iteratorNormalCompletion5","_step5","_iterator5","_x3","_key15","lastIsSpread","fa","enableSpread","enableTailCallOptimization","actualArgs","_key16","index","$raise","$__defun","_key17","_fn","set","st","nm","$__call","_key18","_$$firstAndSecond5","Function","$__try","_key19","e","$pipe","$$raise","$__if","_key20","$$boolean","$__ifNull","_key21","_$$firstAndSecond6","$$ambiguousEq","$__cond","_key22","$__while","_key23","_iteratorNormalCompletion6","_step6","_iterator6","$__doWhile","_key24","_iteratorNormalCompletion7","_step7","_iterator7","$__until","_key25","$$not","_iteratorNormalCompletion8","_step8","_iterator8","$__doUntil","_key26","_iteratorNormalCompletion9","_step9","_iterator9","$__repeat","_key27","_iteratorNormalCompletion10","_step10","_iterator10","$__for","_key28","list","_step11","_iterator11","_iteratorNormalCompletion11","_step12","_iterator12","_iteratorNormalCompletion12","_key29","$boolean","$$pipe","$__get","_key30","inprog","$__let","_key31","$__set","_key32","path","subst","last","_key33","Boolean","$not","_key34","$__and","_key35","prev","curr","$__or","$$__and","_key36","$ambiguousEq","$$__or","_key37","_$$firstAndSecond7","$ambiguousNotEq","$lt","$$ambiguousNotEq","_key38","_$$firstAndSecond8","$le","$$lt","_key39","_$$firstAndSecond9","$gt","$$le","_key40","_$$firstAndSecond10","$ge","$$gt","_key41","_$$firstAndSecond11","$isList","$$ge","_key42","$isString","$$isList","_key43","$isNumber","$$isString","_key44","$isNaN","$$isNumber","_key45","isNaN","$isFinite","$$isNaN","_key46","isFinite","$isInteger","$$isFinite","_key47","isInteger","$toString","$$isInteger","_key48","$toNumber","$$toString","_key49","$objectAssign","$$toNumber","$__toObject","_key50","_step13","_iterator13","_iteratorNormalCompletion13","keyName","_key51","assign","$jsonStringify","$$objectAssign","_key52","$jsonParse","$$jsonStringify","_key53","parse","$consoleLog","$$jsonParse","_console","console","log","$consoleError","$$consoleLog","_console2","error","$$consoleError","_core","$__outputIf","_r","Template","$__outputForOf","z","$jsxProps","styles","split","matched","exec","classes","cs","forEach","fragment","join","__html","getJsxTagsParams","children","props","$jsxStandardTag","_state$config","_getJsxTagsParams","jsx","$jsxComponentTag","component","_state$config2","_getJsxTagsParams2","keys","_sExpression","SExpression","SExpressionAsync","LSX","lsxConf","defaultConfig","_core2","default","_arithmetic2","_sequence2","_jsx2","stripComments","LSX_async","_concurrent2","_parser","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","not","and","or","enableEvaluate","enableHereDoc","returnMultipleRoot","symbols","macros","funcs","initState","globals","strings","values","pos","line","Map","resetState","startup","f","evaluateAST","ast","repl","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","__awaiter","_this","regeneratorRuntime","mark","_callee","then","_context","sent","_len5","_len6","S","L","L_async","LS","lisp","LS_async","lisp_async","LM","LM_async","skipWhitespaces","ch","lookAhead","isEOF","getChar","parseList","parseOneToken","parseSingleLineComment","aheads","lookAheads","parseMultiLineComment","_aheads4","lookCurrentLineHint","isSpace","trim","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","virtualEof","eof","_ch","eofSeq","_ch2","ch1","ch2","fromCodePoint","parseInt","_ch3","chs","parseNumber","parseSymbol","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","parseString","parseHereDoc","attrs","inner","comment","_aheads","isHereDoc","ahs","listStopChar","initialList","_core4","_core6","ops","_interopRequireWildcard","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","_arithmetic4","_arithmetic6","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","$bitOr","$bitXor","$add","$sub","$mul","$sup","$div","$mod","$max","$min","$avg","$floor","$ceil","$round","$abs","$sign","$$bitLShift","$$bitSRShift","$$bitURShift","$$bitNot","reduce","$$bitAnd","$$bitOr","$$bitXor","$$add","$$sub","$$mul","Math","pow","$$sup","$$div","$$mod","$$max","$$min","$$avg","floor","$$floor","ceil","$$ceil","round","$$round","abs","$$abs","sign","$$sign","_sequence4","_sequence6","$range","$length","$trim","$trimHead","$trimTail","$concat","$slice","$top","$tail","$__at","$reverse","$reverseDestructive","$find","$filter","$map","$reduce","$reduceFromTail","$sort","$sortDestructive","start","stop","step","from","$$length","$$trim","trimLeft","$$trimHead","trimRight","$$trimTail","$$concat","$$slice","$$top","$$tail","$$__at","reverse","$$reverse","$$reverseDestructive","find","$$find","filter","$$filter","$$map","$$reduce","reduceRight","$$reduceFromTail","sort","$$sort","$$sortDestructive","_jsx4","_jsx6","components","entries","_jsx7","_config$funcs","jsxFlagment","JsxFragment","_concurrent4","_concurrent6","$__letAsync","$__setAsync","$then","$resolveAll","$resolveAny","$resolvePipe","$resolveFork","promise","Promise","resolve","reject","$$__letAsync","$$__setAsync","$$then","promises","all","$$resolveAll","invert","res","rej","ps","firstOf","$$resolveAny","lambdas","$$resolvePipe","resolvers","rejectors","pa","_i","lp","catch","_loop","$$resolveFork"],"mappings":"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ACb+F,GAAKia,EACVzX,UACOvI,KAAS,QACX+F,GAAKia,EACVtX,QACO1I,KAAU,SACZ+F,GAAKia,EACVtX,QACO1I,KAAS,QACX+F,GAAKia,EACVpX,QACO5I,KAAqB,oBACvB+F,GAAKia,EACVjX,kBACO/I,KAAS,QACX+F,GAAKia,EACV9W,QACOlJ,KAAO,MACT+F,GAAKia,EACV5W,MACOpJ,KAAO,MACT+F,GAAKia,EACV5W,MACOpJ,KAAW,UACb+F,GAAKia,EACVxW,SACOxJ,KAAO,MACT+F,GAAKia,EACVxW,SACOxJ,KAAS,QACX+F,GAAKia,EACVpW,QACO5J,KAAY,WACd+F,GAAKia,EACVhW,WACOhK,KAAa,YACf+F,GAAKia,EACVvU,iBACOzL,KAAa,YACf+F,GAAKia,EACVxU,YACOxL,KAAY,WACd+F,GAAKia,EACVrT,WACO3M,KAAW,UACb+F,GAAKia,EACV/S,UACOjN,KAAU,SACZ+F,GAAKia,EACV3S,SACOrN,KAAU,SACZ+F,GAAKia,EACVtT,SACO1M,KAAS,QACX+F,GAAKia,EACVtS,QACO1N,KAAc,aAChB+F,GAAKia,EACVnS,YACO7N,KAAW,UACb+F,GAAKia,EACV/R,UACOjO,KAAY,WACd+F,GAAKia,EACV7R,WACOnO,KAAe,cACjB+F,GAAKia,EACVxR,aACOxO,KAAY,WACd+F,GAAKia,EACVnR,WACO7O,KAAe,cACjB+F,GAAKia,EACV7Q,aACOnP,KAAa,YACf+F,GAAKia,EACVxQ,YACOxP,KAAU,SACZ+F,GAAKia,EACVnQ,SACO7P,KAAS,QACX+F,GAAKia,EACVxS,QACOxN,KAAU,SACZ+F,GAAKia,EACVvP,SACOzQ,KAAU,SACZ+F,GAAKia,EACVpP,SACO5Q,KAAU,SACZ+F,GAAKia,EACVlP,SACO9Q,KAAY,WACd+F,GAAKia,EACVzP,WACOvQ,KAAQ,OACV+F,GAAKia,EACV3O,OACOrR,KAAU,SACZ+F,GAAKia,EACVzO,SACOvR,KAAS,QACX+F,GAAKia,EACVrO,QACO3R,KAAM,KACR+F,GAAKia,EACVlO,eACO9R,KAAM,KACR+F,GAAKia,EACV9N,kBACOlS,KAAK,IACP+F,GAAKia,EACV7N,MACOnS,KAAM,KACR+F,GAAKia,EACVzN,MACOvS,KAAK,IACP+F,GAAKia,EACVrN,MACO3S,KAAM,KACR+F,GAAKia,EACVjN,MACO/S,KAAY,WACd+F,GAAKia,EACV7M,UACOnT,KAAc,aAChB+F,GAAKia,EACV1M,YACOtT,KAAc,aAChB+F,GAAKia,EACVvM,YACOzT,KAAW,UACb+F,GAAKia,EACVpM,SACO5T,KAAc,aAChB+F,GAAKia,EACVhM,YACOhU,KAAe,cACjB+F,GAAKia,EACV5L,aACOpU,KAAc,aAChB+F,GAAKia,EACVxL,YACOxU,KAAc,aAChB+F,GAAKia,EACVrL,YACO3U,KAAQ,OACV+F,GAAKia,EACVhL,cACOhV,KAAkB,iBACpB+F,GAAKia,EACVlL,gBACO9U,KAAmB,kBACrB+F,GAAKia,EACVxK,iBACOxV,KAAe,cACjB+F,GAAKia,EACVrK,aACO3V,KAAgB,eAClB+F,GAAKia,EACVjK,cACO/V,KAAkB,iBACpB+F,GAAKia,EAIX5J,0BAAqBqE,iGCtLwB,IAAApX,EAAA9D,EAAA,GAKvCkG,EAAAlG,EAAA,2HAAC,IAAYib,EAAAvb,EAAAub,SACXxa,KAAU,SACZ+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAa,YACpBoO,EAAG,GACHA,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAU,SACZ+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAa,aACpB,GAED,GAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAW,UACb+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAc,cAEtB,GAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAc,aAChB+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAa,aACpB,GAED,GAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAW,UACb+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,cAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAM,KACR+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,cAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAU,SACZ+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,aAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAS,QACX+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAK1C,OAFU,EAAAtK,EAAAnC,mBAAQ,QAAMyM,EAAK,KAErBpO,OAAY,WACnBoO,EAAG,IACF,EAAA1M,EAAAzB,OAAMC,EAAMkO,EACd,KAAA5K,OAAAC,EAAK2K,EAAMjL,MAEtB,SAEI9E,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,WAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAO,MACT+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAU,SACjBoO,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAY,WACd+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAe,cACtBoO,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAM,KACR+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OAAe,cACtBoO,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAS,QACX+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,YAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAU,SACZ+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,aAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAa,YACf+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,gBAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAU,SACZ+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,aAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAa,YACf+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,gBAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAW,UACb+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAIjD,KADsB,EAAA1M,EAAAhB,UAAK0N,EAAG,GAAQ,MAElC,MAAM,IAAiEnN,MAAA,uDAEpE,QAAQjB,OAAc,cACpB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAIjD,KADsB,EAAA1M,EAAAhB,UAAK0N,EAAG,GAAQ,MAElC,MAAM,IAA8DnN,MAAA,oDAEjE,QAAQjB,OAAW,WACjB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,WAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAO,OAAMyM,EAAG,EAAK,KAEvBpO,OAAW,WACjB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAEZ,QAEI/P,KAAiB,gBACnB+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAgB,gBAAMyM,EAAG,EAAK,KAEhCpO,OAAY,aACfA,OAAW,WACV,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAGhB,SAEI/P,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAO,OAAMyM,EAAG,EAAK,KAEvBpO,OAAW,WACjB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAEZ,QAEI/P,KAAe,cACjB+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAc,cAAMyM,EAAG,EAAK,KAE9BpO,OAAW,WACjB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAEZ,QAEI/P,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,WAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAO,MACT+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QAAQpO,OACR,UAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAK,IACP+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QACIpO,OACJ,SAAAwD,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,qBAIkB+Y,iFClSf,IAAaD,EAAAtb,EAAAsb,UACXva,KAAO,MAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,YACbA,KAAQ,OAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA6C,QAE3DA,KAAa,YAAI+F,GAAA,SAAuBlE,EAAkB7B,OAE1DA,KAAQ,OAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA6C,KAC3DA,KAAS,QAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA6C,KAC5DA,KAAM,KAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA6C,KAEzDA,KAAS,QAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C,KAC7DA,KAAU,SAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C,KAC9DA,KAAM,KAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C,KAE1DA,KAAoB,mBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAmBsc,qBAC3FlgB,KAAa,YAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAmBsc,qBACpFlgB,KAAa,YAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAmBuc,qBAEpFngB,KAAmB,kBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAASwc,WAChFpgB,KAAoB,mBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAWyc,aACnFrgB,KAAoB,mBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAW0c,aACnFtgB,KAA0B,yBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAkB2c,oBAChGvgB,KAA0B,yBAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAAkB4c,oBAEhGxgB,KAAO,MAAI+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAA8C4D,OAIpED,iBAAuB4W,oGC1B+BzY,GAIlD,OAHMA,EAAM2Y,OAAU3Y,EAAM2Y,WAA0BtV,OAAA2T,EAAAD,SAChD/W,EAAO0Y,QAAU1Y,EAAO0Y,YAAuBrV,OAAAsb,EAAA5H,SAC/C/W,EAAQyY,SAAUzY,EAAQyY,aAAwBpV,OAAAub,EAAA7H,SAE5D/W,GAXuD,QAAAvC,EAAA,SACHA,EAAA,SAKtCA,EAAA,uJCNP,IAIDygB,yJAAAC,CAJC1gB,EAAA,KAIA,IAAWkb,EAAAxb,EAAAwb,QACVza,KAAM,KACR+F,GAAKia,EACVW,aACO3gB,KAAgB,eAClB+F,GAAKia,EACVW,aACO3gB,KAAM,KACR+F,GAAKia,EACVY,cACO5gB,KAAiB,gBACnB+F,GAAKia,EACVY,cACO5gB,KAAO,MACT+F,GAAKia,EACVa,cACO7gB,KAAiB,gBACnB+F,GAAKia,EACVa,cACO7gB,KAAY,WACd+F,GAAKia,EACVc,UACO9gB,KAAY,WACd+F,GAAKia,EACVe,UACO/gB,KAAW,UACb+F,GAAKia,EACVgB,SACOhhB,KAAY,WACd+F,GAAKia,EACViB,UACOjhB,KAAK,IACP+F,GAAKia,EACVkB,OACOlhB,KAAQ,OACV+F,GAAKia,EACVkB,OACOlhB,KAAQ,OACV+F,GAAKia,EACVkB,OACOlhB,KAAK,IACP+F,GAAKia,EACVmB,OACOnhB,KAAQ,OACV+F,GAAKia,EACVmB,OACOnhB,KAAQ,OACV+F,GAAKia,EACVmB,OACOnhB,KAAK,IACP+F,GAAKia,EACVoB,OACOphB,KAAQ,OACV+F,GAAKia,EACVoB,OACOphB,KAAM,KACR+F,GAAKia,EACVqB,OACOrhB,KAAQ,OACV+F,GAAKia,EACVqB,OACOrhB,KAAK,IACP+F,GAAKia,EACVsB,OACOthB,KAAQ,OACV+F,GAAKia,EACVsB,OACOthB,KAAK,IACP+F,GAAKia,EACVuB,OACOvhB,KAAQ,OACV+F,GAAKia,EACVuB,OACOvhB,KAAQ,OACV+F,GAAKia,EACVwB,OACOxhB,KAAQ,OACV+F,GAAKia,EACVyB,OACOzhB,KAAQ,OACV+F,GAAKia,EACV0B,OACO1hB,KAAU,SACZ+F,GAAKia,EACV2B,SACO3hB,KAAS,QACX+F,GAAKia,EACV4B,QACO5hB,KAAU,SACZ+F,GAAKia,EACV6B,SACO7hB,KAAQ,OACV+F,GAAKia,EACV8B,OACO9hB,KAAS,QACX+F,GAAKia,EAIX+B,kBAAqBtH,6dCvG2B,IAAAlT,EAAAhI,EAAA,GACFkG,EAAAlG,EAAA,GAMxCkX,EAAAlX,EAAA,2HAAC,IAAgBohB,EAAA1hB,EAAA0hB,WAAA,SAAwB9e,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAkE,GAAAC,UAAAD,IAGhE,EAAAhC,EAAAnC,mBAAa,aAAMC,EAAG,EAEnC,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA8B,EAAA9B,IAAMC,EAAA6B,EAAA7B,IAId,OAHGD,GAAW,EAAAkB,EAAA7D,UAAM2C,GAGf,IAFFC,GAAW,EAAAiB,EAAA7D,UAAM4C,IAGNA,EAAO,GAAID,GAASC,EAAG,EAEvBA,GAAQ,GAASD,KAAQC,EAAG,IAMtBsa,GAHA3hB,EAAA+iB,YAAarB,EAAY,KAG3C,MAAkB1hB,EAAA2hB,YAAA,SAAwB/e,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuE,GAAAJ,UAAAI,IAGjE,EAAArC,EAAAnC,mBAAc,cAAMC,EAAG,EAEpC,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAkD,EAAAlD,IAAMC,EAAAiD,EAAAjD,IAId,OAHGD,GAAW,EAAAkB,EAAA7D,UAAM2C,GAGf,IAFFC,GAAW,EAAAiB,EAAA7D,UAAM4C,IAGNA,EAAO,GAAID,GAASC,EAAsB,WAAjBD,GAAsB,EAAG,EAElDC,GAAQ,GAAQD,IAAQC,EAAG,KAMrBua,GAHC5hB,EAAAgjB,aAAcrB,EAAY,KAG7C,MAAkB3hB,EAAA4hB,YAAA,SAAwBhf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA0E,GAAAP,UAAAO,IAGjE,EAAAxC,EAAAnC,mBAAc,cAAMC,EAAG,EAEpC,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAsD,EAAAtD,IAAMC,EAAAqD,EAAArD,IAId,OAHGD,GAAW,EAAAkB,EAAA7D,UAAM2C,GAGf,IAFFC,GAAW,EAAAiB,EAAA7D,UAAM4C,IAGNA,EAAO,GAAID,IAAUC,EAAG,EAExBA,GAAQ,GAAQD,IAAQC,EAAG,KAMzBwa,GAHK7hB,EAAAijB,aAAcrB,EAAY,KAG7C,MAAc5hB,EAAA6hB,QAAA,SAAwBjf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+E,GAAAZ,UAAAY,IAG7D,EAAA7C,EAAAnC,mBAAU,UAAMC,EAAG,EAAK,GAEzC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,QAAgB,EAAAgE,EAAA7D,UACpB2C,MAIoB0a,GAHC9hB,EAAAkjB,SAAUrB,EAAY,KAGrC,MAAc7hB,EAAA8hB,QAAA,SAAwBlf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAiF,GAAAd,UAAAc,IAG7D,EAAA/C,EAAAnC,mBAAU,UAAMC,EAAK,GAEtC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAImB2a,GAHE/hB,EAAAojB,SAAUtB,EAAY,KAGrC,MAAa9hB,EAAA+hB,OAAA,SAAwBnf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAoF,GAAAjB,UAAAiB,IAG5D,EAAAlD,EAAAnC,mBAAS,SAAMC,EAAK,GAErC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAIoB4a,GAHAhiB,EAAAqjB,QAAStB,EAAY,KAGnC,MAAc/hB,EAAAgiB,QAAA,SAAwBpf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuF,GAAApB,UAAAoB,IAG7D,EAAArD,EAAAnC,mBAAU,UAAMC,EAAK,GAEtC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAIiB6a,GAHIjiB,EAAAsjB,SAAUtB,EAAY,KAGrC,MAAWhiB,EAAAiiB,KAAA,SAAwBrf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA0F,GAAAvB,UAAAuB,GAK3E,OAFiB,EAAAxD,EAAAnC,mBAAO,OAAMC,EAAK,GAEnCA,EAAkB6e,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,IACtE,MAIiByP,GAHCliB,EAAAujB,MAAOtB,EAAY,KAG/B,MAAWjiB,EAAAkiB,KAAA,SAAwBtf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA4F,GAAAzB,UAAAyB,IAG1D,EAAA1D,EAAAnC,mBAAO,OAAMC,EAAK,GAEnC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAE7B,OAAqB,IADJA,EAAMuB,MAAI,GACZ3C,SAEK,EAAAoF,EAAA7D,UAAM2C,GAGtB9C,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UAAO2C,OAMnF+a,GAHCniB,EAAAwjB,MAAOtB,EAAY,KAG/B,MAAWliB,EAAAmiB,KAAA,SAAwBvf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+F,GAAA5B,UAAA4B,IAG1D,EAAA7D,EAAAnC,mBAAO,OAAMC,EAAK,GAEnC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAIiBgb,GAHCpiB,EAAAyjB,MAAOtB,EAAY,KAG/B,MAAWniB,EAAAoiB,KAAA,SAAwBxf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAmG,GAAAhC,UAAAgC,IAG1D,EAAAjE,EAAAnC,mBAAO,OAAMC,EAAK,GAEnC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAgBiR,KAAAC,KAAQ,EAAArb,EAAA7D,UAAM+N,IAAY,EAAAlK,EAAA7D,UAAMgO,MAAU,EAAAnK,EAAA7D,UAC1F2C,OAIiBib,GAHCriB,EAAA4jB,MAAOxB,EAAY,KAG/B,MAAWpiB,EAAAqiB,KAAA,SAAwBzf,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAwG,GAAArC,UAAAqC,IAG1D,EAAAtE,EAAAnC,mBAAO,OAAMC,EAAK,GAEnC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAIiBkb,GAHCtiB,EAAA6jB,MAAOxB,EAAY,KAG/B,MAAWriB,EAAAsiB,KAAA,SAAwB1f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2G,GAAAxC,UAAAwC,IAG1D,EAAAzE,EAAAnC,mBAAO,OAAMC,EAAK,GAEnC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,OAAAA,EAAiBuB,MAAG,GAAOsd,OAAA,SAAM3Q,EAAUC,GAAf,OAAwB,EAAAnK,EAAA7D,UAAM+N,IAAW,EAAAlK,EAAA7D,UAAMgO,KAAU,EAAAnK,EAAA7D,UACzF2C,OAIiBmb,GAHCviB,EAAA8jB,MAAOxB,EAAY,KAG/B,MAAWtiB,EAAAuiB,KAAA,SAAwB3f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAmI,GAAAhE,UAAAgE,GAG3E,OAAAiX,KAAmBlf,IAAAyC,MAAAyc,KAAAvd,EAAA7B,EAAS8B,IAAA,SAAA5D,GAAK,OAAS,EAAA8F,EAAA7D,UAC9CjC,UAIiBggB,GAHCxiB,EAAA+jB,MAAOxB,EAAY,KAG/B,MAAWviB,EAAAwiB,KAAA,SAAwB5f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2I,GAAAxE,UAAAwE,GAG3E,OAAAyW,KAAmBnf,IAAA0C,MAAAyc,KAAAvd,EAAA7B,EAAS8B,IAAA,SAAA5D,GAAK,OAAS,EAAA8F,EAAA7D,UAC9CjC,UAIiBigB,GAHCziB,EAAAgkB,MAAOxB,EAAY,KAG/B,MAAWxiB,EAAAyiB,KAAA,SAAwB7f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAiJ,GAAA9E,UAAA8E,GAG3E,IAAO1G,EAAAvC,EAAW8B,IAAA,SAAA5D,GAAK,OAAS,EAAA8F,EAAA7D,UAAKjC,KACrC,OAAQqE,EAAO3D,OAAM,EAAA2D,EAASsc,OAAA,SAAM3Q,EAAUC,GAAf,OAAoBD,EAAOC,GAAI,GAAI5L,EAAS3D,OAC/EwB,OAImBge,GAHD1iB,EAAAikB,MAAOxB,EAAY,KAG/B,MAAaziB,EAAA0iB,OAAA,SAAwB9f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAqJ,GAAAlF,UAAAkF,GAK7E,OAFiB,EAAAnH,EAAAnC,mBAAS,SAAMC,EAAG,EAAK,GAE7Bof,KAAMQ,OAAS,EAAA5b,EAAA7D,UAAS+S,EAAA9O,QAAAzB,WAAAC,EACvC5C,QAIkBqe,GAHE3iB,EAAAmkB,QAASzB,EAAY,KAGnC,MAAY1iB,EAAA2iB,MAAA,SAAwB/f,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2J,GAAAxF,UAAAwF,GAK5E,OAFiB,EAAAzH,EAAAnC,mBAAQ,QAAMC,EAAG,EAAK,GAE5Bof,KAAKU,MAAS,EAAA9b,EAAA7D,UAAS+S,EAAA9O,QAAAzB,WAAAC,EACtC5C,QAImBse,GAHA5iB,EAAAqkB,OAAQ1B,EAAY,KAGjC,MAAa3iB,EAAA4iB,OAAA,SAAwBhgB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+J,GAAA5F,UAAA4F,GAK7E,OAFiB,EAAA7H,EAAAnC,mBAAS,SAAMC,EAAG,EAAK,GAE7Bof,KAAMY,OAAS,EAAAhc,EAAA7D,UAAS+S,EAAA9O,QAAAzB,WAAAC,EACvC5C,QAIiBue,GAHG7iB,EAAAukB,QAAS3B,EAAY,KAGnC,MAAW5iB,EAAA6iB,KAAA,SAAwBjgB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAoK,GAAAjG,UAAAiG,GAK3E,OAFiB,EAAAlI,EAAAnC,mBAAO,OAAMC,EAAG,EAAK,GAE3Bof,KAAIc,KAAS,EAAAlc,EAAA7D,UAAS+S,EAAA9O,QAAAzB,WAAAC,EACrC5C,QAIkBwe,GAHA9iB,EAAAykB,MAAO5B,EAAY,KAG/B,MAAY7iB,EAAA8iB,MAAA,SAAwBlgB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuK,GAAApG,UAAAoG,GAK5E,OAFiB,EAAArI,EAAAnC,mBAAQ,QAAMC,EAAG,EAAK,GAE5Bof,KAAKgB,MAAS,EAAApc,EAAA7D,UAAS+S,EAAA9O,QAAAzB,WAAAC,EACtC5C,QACmBtE,EAAA2kB,OAAQ7B,EAAY,KAAe,qFCtP/C,IAAYvH,EAAAvb,EAAAub,oBAGGA,iFCHf,IAAaD,EAAAtb,EAAAsb,qBAGGA,oGCA+BzY,GAIlD,OAHMA,EAAM2Y,OAAU3Y,EAAM2Y,WAA0BtV,OAAA4T,EAAAF,SAChD/W,EAAO0Y,QAAU1Y,EAAO0Y,YAAuBrV,OAAA0e,EAAAhL,SAC/C/W,EAAQyY,SAAUzY,EAAQyY,aAAwBpV,OAAA2e,EAAAjL,SAE5D/W,GAXqD,QAAAvC,EAAA,SACHA,EAAA,SAKpCA,EAAA,uJCNP,IAIDygB,yJAAAC,CAJC1gB,EAAA,KAIA,IAAWkb,EAAAxb,EAAAwb,QACVza,KAAU,SACZ+F,GAAKia,EACV+D,SACO/jB,KAAW,UACb+F,GAAKia,EACVgE,UACOhkB,KAAS,QACX+F,GAAKia,EACViE,QACOjkB,KAAc,aAChB+F,GAAKia,EACVkE,YACOlkB,KAAc,aAChB+F,GAAKia,EACVmE,YACOnkB,KAAW,UACb+F,GAAKia,EACVoE,UACOpkB,KAAU,SACZ+F,GAAKia,EACVqE,SACOrkB,KAAQ,OACV+F,GAAKia,EACVsE,OACOtkB,KAAS,QACX+F,GAAKia,EACVuE,QACOvkB,KAAS,QACX+F,GAAKia,EACVwE,QACOxkB,KAAY,WACd+F,GAAKia,EACVyE,WACOzkB,KAAa,YACf+F,GAAKia,EACV0E,sBACO1kB,KAAS,QACX+F,GAAKia,EACV2E,QACO3kB,KAAW,UACb+F,GAAKia,EACV4E,UACO5kB,KAAQ,OACV+F,GAAKia,EACV6E,OACO7kB,KAAW,UACb+F,GAAKia,EACV8E,UACO9kB,KAAqB,oBACvB+F,GAAKia,EACV8E,UACO9kB,KAAqB,oBACvB+F,GAAKia,EACV+E,kBACO/kB,KAAS,QACX+F,GAAKia,EACVgF,QACOhlB,KAAU,SACZ+F,GAAKia,EAIXiF,6BAAqBxK,6sBClE2BlT,EAAAhI,EAAA,GACFkG,EAAAlG,EAAA,GAMxCkX,EAAAlX,EAAA,GAAaN,EAAA8kB,OAAA,SAAwBliB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAkE,GAAAC,UAAAD,IAI5D,EAAAhC,EAAAnC,mBAAS,SAAMC,EAAG,EAE7B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA8B,EAAA9B,IAAMC,EAAA6B,EAAA7B,IACL4e,GAAW,EAAA3d,EAAA7D,UAAK2C,IAAM,EACvB8e,GAAW,EAAA5d,EAAA7D,UAAK4C,IAAM,EAEtB8e,EAAQ7hB,EAAOpB,OAAM,IAAS,EAAAoF,EAAA7D,UAAKH,EAAI,MAAoB2hB,GAAUC,EAAI,GAAK,GACjFjkB,EAAOyhB,KAAKgB,KAAKwB,EAASD,GAAOvC,KAAKgB,KAAMyB,KAC/C,EAAKzC,KAAOQ,MAAKR,KAAIc,IAAK0B,EAASD,GAAOvC,KAAIc,IAAQ2B,IAAO,EAAG,EAIpE,OAFKvjB,EAAUsB,WAAMjC,GACb,EAAAqG,EAAA/B,UAAM3D,EAAK,GACnBI,MAAiBojB,MAAQljB,OAAIjB,GAAA,SAAIO,EAAOhC,GAAT,OAAeylB,EAAIzlB,EACtD2lB,MAjBO,IAoBapB,EAAA/kB,EAAA+kB,QAAA,SAAwBniB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuE,GAAAJ,UAAAI,IAG7D,EAAArC,EAAAnC,mBAAU,UAAMC,EAAG,EAAK,GAEzC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GACrB,YAAY,IAAA8C,EAAA,YAAA3E,EAAA2E,IACpB,IAAa,SACT,KAAe,WAAQA,GACb,MAGd,IAAa,SACT,OAAUA,EACblE,OACD,MAAM,IACVS,MAAA,2EAIkBqhB,GAHGhlB,EAAAqmB,SAAUtB,EAAY,KAGrC,MAAY/kB,EAAAglB,MAAA,SAAwBpiB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA0E,GAAAP,UAAAO,IAG3D,EAAAxC,EAAAnC,mBAAQ,QAAMC,EAAG,EAAK,GAEvC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,GAA2B,iBAAb8C,EACV,OAAUA,EAAQyX,OAEtB,MAAM,IACVlb,MAAA,gEAIsBshB,GAHHjlB,EAAAsmB,OAAQtB,EAAY,KAGjC,MAAgBhlB,EAAAilB,UAAA,SAAwBriB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+E,GAAAZ,UAAAY,IAG/D,EAAA7C,EAAAnC,mBAAY,YAAMC,EAAG,EAAK,GAE3C,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,GAA2B,iBAAb8C,EACV,OAAUA,EAAYmf,WAE1B,MAAM,IACV5iB,MAAA,oEAIsBuhB,GAHCllB,EAAAwmB,WAAYvB,EAAY,KAGzC,MAAgBjlB,EAAAklB,UAAA,SAAwBtiB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAiF,GAAAd,UAAAc,IAG/D,EAAA/C,EAAAnC,mBAAY,YAAMC,EAAG,EAAK,GAE3C,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,GAA2B,iBAAb8C,EACV,OAAUA,EAAaqf,YAE3B,MAAM,IACV9iB,MAAA,oEAIoBwhB,GAHGnlB,EAAA0mB,WAAYxB,EAAY,KAGzC,MAAcllB,EAAAmlB,QAAA,SAAwBviB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAoF,GAAAjB,UAAAiB,IAG7D,EAAAlD,EAAAnC,mBAAU,UAAMC,EAAK,GAEtC,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GACrB,YAAY,IAAA8C,EAAA,YAAA3E,EAAA2E,IACpB,IAAa,SACT,KAAe,WAAQA,GACb,MAGd,IAAa,SACT,OAAUA,EAAQlB,OAAAe,MAAAG,wHAAAjB,CAAO7B,EAAMuB,MAClC,KACD,MAAM,IACVlC,MAAA,4EAImByhB,GAHEplB,EAAA2mB,SAAUxB,EAAY,KAGrC,MAAanlB,EAAAolB,OAAA,SAAwBxiB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuF,GAAApB,UAAAoB,GAM7E,IAFiB,EAAArD,EAAAnC,mBAAS,SAAMC,EAAG,EAAK,GAEnB,IAAbA,EAAOpB,SACoB,iBAAhBoB,EAAG,IAAsBtB,MAAQC,QAAKqB,EAAI,KACrD,OAAWA,EAAG,GAAMuB,OAAS,EAAAyC,EAAA7D,UAAKH,EAAI,KAAU,EAAAgE,EAAA7D,UAAKH,EAAM,KAGnE,GAAqB,IAAbA,EAAOpB,SACoB,iBAAhBoB,EAAG,IAAsBtB,MAAQC,QAAKqB,EAAI,KACrD,OAAWA,EAAG,GAAMuB,OAAS,EAAAyC,EAAA7D,UAAKH,EAAM,KAGhD,MAAM,IAAUX,MAAA,6CAAgDW,EAAOpB,OAC3E,mCAIiBmiB,GAHGrlB,EAAA4mB,QAASxB,EAAY,KAGnC,MAAWplB,EAAAqlB,KAAA,SAAwBziB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA0F,GAAAvB,UAAAuB,GAK3E,IAFiB,EAAAxD,EAAAnC,mBAAO,OAAMC,EAAG,EAAK,GAEP,iBAAhBA,EAAG,IAAsBtB,MAAQC,QAAKqB,EAAI,IACrD,OAAWA,EAAG,GAAMuB,MAAE,GAAU,EAAAyC,EAAA7D,UAAKH,EAAM,KAE/C,MAAM,IACVX,MAAA,wEAIkB2hB,GAHAtlB,EAAA6mB,MAAOxB,EAAY,KAG/B,MAAYrlB,EAAAslB,MAAA,SAAwB1iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA4F,GAAAzB,UAAAyB,GAK5E,IAFiB,EAAA1D,EAAAnC,mBAAQ,QAAMC,EAAG,EAAK,GAER,iBAAhBA,EAAG,IAAsBtB,MAAQC,QAAKqB,EAAI,IAAE,CACvD,IAAOrC,IAAY,EAAAqG,EAAA7D,UAAKH,EAAK,IAC7B,OAAWA,EAAG,GAAMuB,MAAE5D,GAAK,GAAU0C,OAAMmQ,MAAK7S,GAAKqC,EAAG,GAASpB,OAAIjB,GAEzE,MAAM,IACV0B,MAAA,yEAKkB4hB,GAJCvlB,EAAA8mB,OAAQxB,EAAY,KAAe,MAIpCtlB,EAAAulB,MAAA,SAAwB3iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+F,GAAA5B,UAAA4B,IAG3D,EAAA7D,EAAAnC,mBAAQ,QAAMC,EAAG,EAE5B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAkD,EAAAlD,IACV,OADgBkD,EAAAjD,IAEpBD,MAKqBoe,GAHFxlB,EAAA+mB,OAAQxB,EAAY,KAGjC,MAAevlB,EAAAwlB,SAAA,SAAwB5iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAmG,GAAAhC,UAAAgC,IAG9D,EAAAjE,EAAAnC,mBAAW,WAAMC,EAAG,EAAK,GAE1C,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,GAAStB,MAAQC,QAAKmE,GAClB,OAAUA,EAAMvB,MAAG,GAAWmhB,UAElC,MAAM,IACVrjB,MAAA,kEAIgC8hB,GAHVzlB,EAAAinB,UAAWzB,EAAY,KAGvC,MAA0BxlB,EAAAylB,oBAAA,SAAwB7iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAwG,GAAArC,UAAAqC,IAGzE,EAAAtE,EAAAnC,mBAAY,YAAMC,EAAG,EAAK,GAE3C,IAAS8C,EAAWoQ,EAAA9O,QAAAzB,WAAAC,EAAS5C,GAC7B,GAAStB,MAAQC,QAAKmE,GAClB,OAAUA,EAAW4f,UAEzB,MAAM,IACVrjB,MAAA,mEAIkB+hB,GAHe1lB,EAAAknB,qBAAsBzB,EAAY,KAG7D,MAAYzlB,EAAA0lB,MAAA,SAAwB9iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2G,GAAAxC,UAAAwC,IAG3D,EAAAzE,EAAAnC,mBAAQ,QAAMC,EAAG,EAE5B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAsD,EAAAtD,IAAMC,EAAAqD,EAAArD,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAUA,EAAK+f,KAAM9f,GAEzB,MAAM,IACV1D,MAAA,+DAIoBgiB,GAHD3lB,EAAAonB,OAAQ1B,EAAY,KAGjC,MAAc1lB,EAAA2lB,QAAA,SAAwB/iB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAmI,GAAAhE,UAAAgE,IAG7D,EAAAjG,EAAAnC,mBAAU,UAAMC,EAAG,EAE9B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA+D,EAAA/D,IAAMC,EAAA8D,EAAA9D,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAUA,EAAOigB,OAAMhgB,GAE3B,MAAM,IACV1D,MAAA,iEAIiBiiB,GAHI5lB,EAAAsnB,SAAU3B,EAAY,KAGrC,MAAW3lB,EAAA4lB,KAAA,SAAwBhjB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2I,GAAAxE,UAAAwE,IAG1D,EAAAzG,EAAAnC,mBAAO,OAAMC,EAAG,EAE3B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA8G,EAAA9G,IAAMC,EAAA6G,EAAA7G,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAUA,EAAIhB,IAAMiB,GAExB,MAAM,IACV1D,MAAA,8DAIoBkiB,GAHF7lB,EAAAunB,MAAO3B,EAAY,KAG/B,MAAc5lB,EAAA6lB,QAAA,SAAwBjjB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAiJ,GAAA9E,UAAA8E,IAI7D,EAAA/G,EAAAnC,mBAAU,UAAMC,EAAG,EAE9B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA0H,EAAA1H,IAAMC,EAAAyH,EAAAzH,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAQ9C,EAAOpB,OAAI,EACLkE,EAAO+b,OAAM9b,GAEbD,EAAO+b,OAAI9b,EAAM/C,EAAK,IAGxC,MAAM,IACVX,MAAA,iEAI4BmiB,GAHP9lB,EAAAwnB,SAAU3B,EAAY,KAGrC,MAAsB7lB,EAAA8lB,gBAAA,SAAwBljB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAqJ,GAAAlF,UAAAkF,IAIrE,EAAAnH,EAAAnC,mBAAkB,kBAAMC,EAAG,EAEtC,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAA4L,EAAA5L,IAAMC,EAAA2L,EAAA3L,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAQ9C,EAAOpB,OAAI,EACLkE,EAAYqgB,YAAMpgB,GAElBD,EAAYqgB,YAAIpgB,EAAM/C,EAAK,IAG7C,MAAM,IACVX,MAAA,yEAIkBoiB,GAHW/lB,EAAA0nB,iBAAkB5B,EAAY,KAGrD,MAAY9lB,EAAA+lB,MAAA,SAAwBnjB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA2J,GAAAxF,UAAAwF,IAG3D,EAAAzH,EAAAnC,mBAAQ,QAAMC,EAAG,EAE5B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAiM,EAAAjM,IAAMC,EAAAgM,EAAAhM,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAUA,EAAMvB,MAAG,GAAK8hB,KAAMtgB,GAElC,MAAM,IACV1D,MAAA,+DAI6BqiB,GAHVhmB,EAAA4nB,OAAQ7B,EAAY,KAGjC,MAAuB/lB,EAAAgmB,iBAAA,SAAwBpjB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+J,GAAA5F,UAAA4F,IAGtE,EAAA7H,EAAAnC,mBAAS,SAAMC,EAAG,EAE7B,SAA8BkT,EAAAvO,iBAAAhC,WAAAC,EAAS5C,GAAnC8C,EAAAqM,EAAArM,IAAMC,EAAAoM,EAAApM,IAChB,GAASrE,MAAQC,QAAKmE,GAClB,OAAUA,EAAKugB,KAAMtgB,GAEzB,MAAM,IACV1D,MAAA,gEAC8B3D,EAAA6nB,kBAAmB7B,EAAY,KAAe,qGC3StE,IAAA5hB,EAAA9D,EAAA,GAAaib,EAAAvb,EAAAub,SACXxa,KAAM,KACR+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAIjD,KADsB,EAAA1M,EAAAhB,UAAK0N,EAAG,GAAO,KAEjC,MAAM,IAAgEnN,MAAA,sDAE1E,QAAejB,OAAU,SACjBoO,EAAG,GACHA,EAEZ,kBAIkByK,iFCnBf,IAAaD,EAAAtb,EAAAsb,qBAGGA,oGCI+BzY,EAAoB4W,SAChE5W,EAAM2Y,OAAU3Y,EAAM2Y,WAA0BtV,OAAA6T,EAAAH,SAChD/W,EAAO0Y,QAAU1Y,EAAO0Y,YAAuBrV,OAAA4hB,EAAAlO,SAC/C/W,EAAQyY,SAAUzY,EAAQyY,aAAwBpV,OAAA6hB,EAAAnO,SAExD,IAAgBoO,EAAA9mB,OACE+mB,QAAQxO,EAAYuO,YAC9B5hB,IAAA,SAAA5D,GAAM,OAAMzB,KAAGyB,EAAG,GAAIsE,IAAkB,EAAAohB,EAAAlP,kBAAExW,EAAQ,OAW1D,OATMK,EAAM2Y,OAAS2M,EAAAtlB,EAAM2Y,OAAOtV,OAAAe,MAAAkhB,IACzBpnB,KAAQ8B,EAAcC,cAAS6U,SAAI7Q,IAAkB,EAAAohB,EAAAlP,kBAAQS,EAClE2O,eAAAliB,6HAAAC,CACF6hB,KAEInlB,EAA8CiF,2BAAAogB,EAAAtP,gBAC9C/V,EAAIkW,IAAUU,EAAKV,IACnBlW,EAAYwlB,YAAU5O,EAAa2O,YAG7CvlB,GA5BkD,QAAAvC,EAAA,SACHA,EAAA,SACCA,EAAA,KAOlC4nB,EAAA5nB,EAAA,qJCVP,IAIDygB,yJAAAC,CAJC1gB,EAAA,IAIA,IAAWkb,EAAAxb,EAAAwb,QACVza,KAAU,SACZ+F,GAAKia,EACVtJ,cACO1W,KAAW,UACb+F,GAAKia,EAIXnJ,2BAAqB4D,iGCRf,IAAApX,EAAA9D,EAAA,2HAAC,IAAYib,EAAAvb,EAAAub,SACXxa,KAAK,IACP+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GACjD,OAAY,EAAA1M,EAAAzB,OAAMC,EACtBkO,OAEI/P,KAAQ,OACV+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QACIpO,OAAW,UACdoO,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,WAEIzB,KAAS,QACX+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAG1C,QACIpO,OAAY,WACfoO,EACD,IAAA5K,OAAAC,EAAA2K,EAAWjL,MAAG,GAAIO,IAAA,SAAA5D,GAAK,OAAM,EAAA4B,EAAAzB,OAAMC,EAE9CJ,qBAIkB+Y,iFChCf,IAAaD,EAAAtb,EAAAsb,qBAGGA,oGCA+BzY,GAIlD,OAHMA,EAAM2Y,OAAU3Y,EAAM2Y,WAA0BtV,OAAAgU,EAAAN,SAChD/W,EAAO0Y,QAAU1Y,EAAO0Y,YAAuBrV,OAAAoiB,EAAA1O,SAC/C/W,EAAQyY,SAAUzY,EAAQyY,aAAwBpV,OAAAqiB,EAAA3O,SAE5D/W,GAXuD,QAAAvC,EAAA,SACHA,EAAA,SAKtCA,EAAA,uJCNP,IAIDygB,yJAAAC,CAJC1gB,EAAA,KAIA,IAAWkb,EAAAxb,EAAAwb,QACVza,KAAgB,eAClB+F,GAAKia,EACVyH,cACOznB,KAAgB,eAClB+F,GAAKia,EACV0H,cACO1nB,KAAS,QACX+F,GAAKia,EACV2H,QACO3nB,KAAgB,eAClB+F,GAAKia,EACV4H,cACO5nB,KAAgB,eAClB+F,GAAKia,EACV6H,cACO7nB,KAAiB,gBACnB+F,GAAKia,EACV8H,eACO9nB,KAAiB,gBACnB+F,GAAKia,EAIX+H,yBAAqBtN,2eC5ByBhV,EAAAlG,EAAA,GAEAkX,EAAAlX,EAAA,GAKtBkoB,EAAAxoB,EAAAwoB,YAAA,SAAwB5lB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAkE,GAAAC,UAAAD,IAGjE,EAAAhC,EAAAnC,mBAAc,cAAMC,EAAG,EAAK,GAE7C,IAAWykB,EAAqBzkB,EAAI,GAYpC,MAX+B,iBAAb,IAAAykB,EAAA,YAAAtmB,EAAAsmB,KAAmD,mBAApBA,EAAK9L,OAC3C8L,EAAUC,QAAQC,QAAUF,IAEhCA,IAAe9L,KAAK,SAAApV,GACvB,IAEI,OADM,EAAA2P,EAAA7F,QAAM/O,EAAK,GAAX,CAAgB0B,EAAG,GAAKuD,GACrBA,EACX,MAAQyG,GACN,OAAc0a,QAAOE,OAAI5a,QAUbma,GAJCzoB,EAAAmpB,aAAcX,EAAY,KAAe,MAI1CxoB,EAAAyoB,YAAA,SAAwB7lB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuE,GAAAJ,UAAAI,IAGjE,EAAArC,EAAAnC,mBAAc,cAAMC,EAAG,EAAK,GAE7C,IAAWykB,EAAqBzkB,EAAI,GAYpC,MAX+B,iBAAb,IAAAykB,EAAA,YAAAtmB,EAAAsmB,KAAmD,mBAApBA,EAAK9L,OAC3C8L,EAAUC,QAAQC,QAAUF,IAEhCA,IAAe9L,KAAK,SAAApV,GACvB,IAEI,OADM,EAAA2P,EAAA3F,QAAMjP,EAAK,GAAX,CAAgB0B,EAAG,GAAKuD,GACrBA,EACX,MAAQyG,GACN,OAAc0a,QAAOE,OAAI5a,SASnBoa,GAHO1oB,EAAAopB,aAAcX,EAAY,KAG7C,MAAYzoB,EAAA0oB,MAAA,SAAwB9lB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA0E,GAAAP,UAAAO,IAG3D,EAAAxC,EAAAnC,mBAAQ,QAAMC,EAAG,EAAK,GAEvC,IAAWykB,EAAqBzkB,EAAI,GAIpC,GAH+B,iBAAb,IAAAykB,EAAA,YAAAtmB,EAAAsmB,KAAmD,mBAApBA,EAAK9L,OAC3C8L,EAAUC,QAAQC,QAAUF,IAEN,mBAAlBzkB,EAAG,GACPykB,EAAUA,EAAK9L,KAAK3Y,EAAG,GAAMA,EAAK,QACtC,CACH,GAAiC,mBAAlBA,EAAG,GACd,MAAM,IAAuEX,MAAA,6DAE1EolB,EAAUA,EAAK9L,KAAK3Y,EAAK,IAEpC,OACJykB,KAIwBJ,GAHL3oB,EAAAqpB,OAAQX,EAAY,KAGjC,MAAkB1oB,EAAA2oB,YAAA,SAAwB/lB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAA+E,GAAAZ,UAAAY,GAIlF,IADA,IAAcigB,EAA4BhlB,EAAMuB,MAAI,GAC1CrF,EAAI,EAAGA,EAAW8oB,EAAOpmB,OAAK1C,IACD,WAA/BiC,EAAe6mB,EAAG9oB,KAAgE,mBAA/B8oB,EAAW9oB,GAAKyc,OAC3DqM,EAAG9oB,GAAUwoB,QAAQC,QAASK,EAAK9oB,KAGnD,OAAcwoB,QAAIO,IACtBD,MAIwBV,GAHC5oB,EAAAwpB,aAAcb,EAAY,KAG7C,MAAkB3oB,EAAA4oB,YAAA,SAAwBhmB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAiF,GAAAd,UAAAc,GAIlF,IADA,IAAc+f,EAA4BhlB,EAAMuB,MAAI,GAC1CrF,EAAI,EAAGA,EAAW8oB,EAAOpmB,OAAK1C,IACD,WAA/BiC,EAAe6mB,EAAG9oB,KAAgE,mBAA/B8oB,EAAW9oB,GAAKyc,OAC3DqM,EAAG9oB,GAAUwoB,QAAQC,QAASK,EAAK9oB,KAOnD,IAAYipB,EAAA,SAAwBnnB,GAApB,WAAgC0mB,QAAA,SAAKU,EAASC,GAAb,OAAernB,EAAK2a,KAAI0M,EAAQD,MAGjF,OAFa,SAA+BE,GAA5B,OAAmCH,EAAQT,QAAIO,IAAGK,EAAIxjB,IAAWqjB,KAEnEI,CAClBP,MAIyBT,GAHA7oB,EAAA8pB,aAAclB,EAAY,KAG7C,MAAmB5oB,EAAA6oB,aAAA,SAAwBjmB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAoF,GAAAjB,UAAAiB,IAIlE,EAAAlD,EAAAnC,mBAAe,eAAMC,EAAK,GAE3C,IAAWykB,EAAqBzkB,EAAI,GACL,iBAAb,IAAAykB,EAAA,YAAAtmB,EAAAsmB,KAAmD,mBAApBA,EAAK9L,OAC3C8L,EAAUC,QAAQC,QAAUF,IAGvC,IADA,IAAagB,EAAOzlB,EAAMuB,MAAI,GACpBrF,EAAI,EAAGA,EAAUupB,EAAO7mB,OAAK1C,IACC,mBAAlBupB,EAAGvpB,IAAiB,WAClC,IAAOqH,EAAUkiB,EAAIvpB,GACdupB,EAAGvpB,GAAA,WAAQ,OAAGqH,GAFa,GAK1C,IAAKvF,EAAWymB,yBACX,QAAkBzd,EAAlBC,EAAkBwe,EAAAxoB,OAAAiK,cAAAH,GAAAC,EAAAC,EAAAE,QAAAC,MAAAL,GAAA,GAAE,IAAb5K,EAAA6K,EAAA7J,MACPa,EAAIA,EAAK2a,KAAIxc,iFAElB,OACJ6B,KAIyBwmB,GAHC9oB,EAAAgqB,cAAenB,EAAY,KAG/C,MAAmB7oB,EAAA8oB,aAAA,SAAwBlmB,EAAkB7B,GAAvC,OAAyC,6DAAkBuD,EAAAuF,GAAApB,UAAAoB,IAIlE,EAAArD,EAAAnC,mBAAe,eAAMC,EAAK,GAE3C,IAAWykB,EAAqBzkB,EAAI,GACL,iBAAb,IAAAykB,EAAA,YAAAtmB,EAAAsmB,KAAmD,mBAApBA,EAAK9L,OAC3C8L,EAAUC,QAAQC,QAAUF,IAGvC,IADA,IAAagB,EAAOzlB,EAAMuB,MAAI,GACpBrF,EAAI,EAAGA,EAAUupB,EAAO7mB,OAAK1C,IACC,mBAAlBupB,EAAGvpB,IAAiB,WAClC,IAAOqH,EAAUkiB,EAAIvpB,GACdupB,EAAGvpB,GAAA,WAAQ,OAAGqH,GAFa,GAU1C,IAJA,IAAeoiB,EAAG,IAASjnB,MAAQ+mB,EAAS7mB,QAC7BgnB,EAAG,IAASlnB,MAAQ+mB,EAAS7mB,QAEpCinB,mBAEFA,EAAK/kB,KAAA,IAAY4jB,QAAM,SAAaC,EAAiBC,GAC1Ce,EAAGG,GAAG,SAAWviB,GACtB,IAAMwiB,EAAwBN,EAAGK,GAAIviB,GACX,iBAAb,IAAAwiB,EAAA,YAAA5nB,EAAA4nB,KAA8C,mBAApBA,EAAKpN,OACtCoN,EAAUrB,QAAQC,QAAKoB,IAG3BA,EACGpN,KAAA,SAAAza,GAAK,OAAQymB,EAAIzmB,KAChB8nB,MAAA,SAAAhc,GAAK,OAAO4a,EACtB5a,MACS4b,EAAGE,GAChBlB,MAbMkB,EAAI,EAAGA,EAAUL,EAAO7mB,OAAKknB,IAAEG,EAAAH,GAqBzC,OALOrB,EAAK9L,KAAA,SAAApV,GACJ,OAAAoiB,EAAkB5R,QAAA,SAAA6D,GAAK,OAAEA,EAAIrU,kBAC7B,OAAAqiB,EAAkB7R,QAAA,SAAA6D,GAAK,OAAEA,EAC/B5N,OAGN6b,KAC0BnqB,EAAAwqB,cAAe1B,EAAY,KAAe,qGCrLvB,IAAA1kB,EAAA9D,EAAA,GAKvCkG,EAAAlG,EAAA,GAAaib,EAAAvb,EAAAub,SACXxa,KAAc,aAChB+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAa,aAAMyM,EAAG,EAAK,KAE7BpO,OAAiB,iBACvB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAEZ,QAEI/P,KAAc,aAChB+F,GAAA,SAAuBlE,EAAkB7B,GAAvC,OAAwC,SAAS+P,GAKjD,OAFiB,EAAAtK,EAAAnC,mBAAa,aAAMyM,EAAG,EAAK,KAE7BpO,OAAiB,iBACvB,EAAA0B,EAAAzB,OAAMC,EAAMkO,EAAI,IACjBA,EAEZ,kBAIkByK,iFC9Bf,IAAaD,EAAAtb,EAAAsb,qBAGGA","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    spread: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol }           from './types';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean): any {\r\n    state.scopes.push({isBlockLocal, scope});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            for (let i = r.length - 1; i > 0; i--) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    let a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    a = Array.isArray(a) ? a : [a];\r\n                    r = (r as SxToken[]).slice(0, i).concat(a, r.slice(i + 1));\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol,\r\n         quote,\r\n         FatalError }         from '../types';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }           from '../evaluate';\r\nimport { checkParamsLength }  from '../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n    let scopeInstalled = false;\r\n\r\n    try {\r\n        const scope: any = {};\r\n        if (Array.isArray(car)) {\r\n            for (const x of car) {\r\n                if (Array.isArray(x)) {\r\n                    const kv = $$firstAndSecond(...x);\r\n                    const kvSym = isSymbol(kv.car);\r\n                    scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n                } else {\r\n                    const xSym = isSymbol(x);\r\n                    scope[xSym ? xSym.symbol : String(x)] = null;\r\n                }\r\n            }\r\n        }\r\n        installScope(state, scope, isBlockLocal);\r\n        scopeInstalled = true;\r\n\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        if (scopeInstalled) {\r\n            uninstallScope(state);\r\n        }\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    try {\r\n        installScope(state, getGlobalScope(state).scope, true);\r\n\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    return Function.prototype.apply.call(\r\n        car[sym ? sym.symbol : evaluate(state, cdr) as any],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { evaluate,\r\n         getScope }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    spread: '$spread',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n}\r\n\r\nexport function SExpression(config: SxParserConfig): SExpressionTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n\r\nexport function SExpressionAsync(config: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote,\r\n         spread,\r\n         ScriptTerminationError } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new ScriptTerminationError('parseStringOrComment');\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push(quote(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol }          from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { toNumber,\r\n         evaluate }          from '../evaluate';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from './core.fn';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         isSymbol } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../types';\r\nimport { checkParamsLength } from '../errors';\r\nimport { $__let,\r\n         $__set  }           from './core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote }             from '../types';\r\nimport { checkParamsLength } from '../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n"],"sourceRoot":""}