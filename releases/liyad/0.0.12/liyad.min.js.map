{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/operators/core/core.fn.ts","webpack://liyad/./src/s-exp/operators/core/core.operator.ts","webpack://liyad/./src/s-exp/operators/core/core.macro.ts","webpack://liyad/./src/s-exp/operators/core/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core/index.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic/index.ts","webpack://liyad/./src/lib/data.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence/index.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx/index.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent/index.ts","webpack://liyad/./src/s-exp/s-expression.ts","webpack://liyad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","quote","state","x","symbol","config","reservedNames","spread","isSymbol","FatalError","Error","[object Object]","message","super","MaxEvaluationCountError","ScriptTerminationError","where","isEOF","ch","isSpace","trim","length","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","lookCurrentLineHint","line","index","pos","strings","slice","getChar","virtualEof","eof","values","v","split","eofSeq","ch1","ch2","String","fromCodePoint","Number","parseInt","lookAheads","chs","push","lookAhead","skipWhitespaces","parseNumber","parseSymbol","parseStringOrComment","valuesStartSeq","valuesStopChar","eofSeqs","parseList","parseString","parseHereDoc","attrs","q","inner","parseSingleLineComment","comment","parseMultiLineComment","parseOneToken","aheads","enableSpread","dotted","enableHereDoc","isHereDoc","sym","Template","ahs","a","Array","isArray","wrapExternalValue","listStopChar","initialList","unshift","pop","car","cdr","stripComments","parse","setEvaluationCount","evalCount","maxEvalCount","checkParamsLength","args","min","max","toNumber","NaN","resolveMacro","macroInfo","macroMap","fn","resolveValueSymbolScope","nullIfNotDefined","scopes","localScope","scope","capturedScopes","isBlockLocal","globalScope","getGlobalScope","getScope","resolveValueSymbol","symInfo","symbolMap","valueSymbolResolverFallback","raiseOnUnresolvedSymbol","installScope","uninstallScope","evaluate","eval","sprs","reverse","concat","funcInfo","funcMap","funcSymbolResolverFallback","resolveFunctionSymbol","JSON","stringify","$car","$$first","$cdr","$cons","$$firstAndSecond","$first","$second","$$second","$last","$rest","$firstAndSecond","$atom","$eq","$notEq","$list","$__scope","returnMultiple","kv","kvSym","xSym","$__lambda","formalArgs","lastIsSpread","fa","fnBody","enableTailCallOptimization","front","tail","if","self","until","map","idx","let","optimizeTailCall","assign","getCapturedScopes","actualArgs","$apply","apply","$raise","$pipe","$__let","$__set","path","subst","inprog","last","$boolean","Boolean","$$boolean","$not","$$not","$__and","prev","curr","$__or","$ambiguousEq","$$ambiguousEq","$ambiguousNotEq","$lt","$le","$gt","$ge","$isList","$isString","$isNumber","$isNaN","isNaN","$isFinite","isFinite","$isInteger","isInteger","$toString","$toNumber","$objectAssign","$jsonStringify","$jsonParse","$consoleLog","console","log","$consoleError","error","core_operator","names","collectCapturedVariables","set","st","nm","info","Function","e","list","keyName","core_macro","core_symbol","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","install","funcs","macros","symbols","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","reduce","$bitOr","$bitXor","$add","$sub","$mul","$sup","Math","pow","$div","$mod","$max","$min","$avg","$floor","floor","$ceil","ceil","$round","round","$abs","abs","$sign","sign","arithmetic_operator","arithmetic_macro","arithmetic_symbol","arithmetic_install","Query","data","this","condition","y","desc","sort","start","groupBy","b","array","w","first","intermediate","single","filter","query","$length","$trim","$trimHead","trimLeft","$trimTail","trimRight","$replaceAll","join","$split","$join","$concat","$slice","$top","$tail","$__at","$reverse","$reverseDestructive","$find","find","$filter","$map","$reduce","$reduceFromTail","reduceRight","$sort","$sortDestructive","$groupEvery","groupEvery","select","$groupBy","$orderBy","orderBy","$where","sequence_operator","stop","step","from","sequence_macro","sequence_symbol","sequence_install","$jsxProps","styles","matched","exec","classes","z","cs","forEach","fragment","__html","__text","getJsxTagsParams","children","props","$jsxStandardTag","jsx","$jsxComponentTag","component","jsx_operator","jsx_macro","jsx_symbol","jsx_install","lsxConf","components","entries","jsxFlagment","JsxFragment","$__letAsync","promise","then","Promise","resolve","reject","$__setAsync","$then","$resolveAll","promises","all","$resolveAny","invert","res","rej","ps","firstOf","$resolvePipe","lambdas","$resolveFork","resolvers","rejectors","pa","lp","catch","f","concurrent_operator","concurrent_macro","concurrent_symbol","concurrent_install","defaultReservedNames","cons","atom","eq","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","not","and","or","defaultConfig","enableEvaluate","returnMultipleRoot","initState","globals","Map","resetState","SExpression","conf","startup","evaluateAST","ast","repl","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","installer","SExpressionAsync","__awaiter","S","L","LS","lisp","L_async","LS_async","lisp_async","LM","LM_async","LSX","LSX_async","__webpack_exports__","builtinOperators","builtinMacros","builtinSymbols","core","arithmetic","sequence","concurrent"],"mappings":"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","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;           // { [s: string]: any; };\r\n    capturedScopes?: CapturedScopes;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    spread: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         quote,\r\n         spread,\r\n         ScriptTerminationError } from './types';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if (ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[]): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[]): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null ,\r\n        valuesStopChar: string\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs);\r\n        }\r\n\r\n        getChar(state, eofSeqs);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            throw new ScriptTerminationError('parseStringOrComment');\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')').strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner =  parseStringOrComment(state, ['\"\"\"'], '%%%(', ')');\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')').strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                return quote(state, parseOneToken(state));\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state);\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push(quote(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return true;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         isSymbol,\r\n         CapturedScopes }     from './types';\r\nimport { setEvaluationCount } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol): ((list: SxToken[]) => SxToken) | false {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    if (macroInfo) {\r\n        return macroInfo.fn(state, x.symbol);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (localScope.capturedScopes &&\r\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\r\n            return localScope.capturedScopes[x.symbol];\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\r\n    const capturedScopes: CapturedScopes = {};\r\n    for (const n of names) {\r\n        const scope = resolveValueSymbolScope(state, n, true);\r\n        if (scope === null) {\r\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\r\n        }\r\n        capturedScopes[n.symbol] = scope;\r\n    }\r\n    return capturedScopes;\r\n}\r\n\r\n\r\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\r\n    const a: CapturedScopes[] = [];\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope.capturedScopes) {\r\n            a.unshift(localScope.capturedScopes);\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\r\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (   ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (   ;; fnBody\r\n                //         ($do-until cond\r\n                //             expr1 ... exprN-1\r\n                //             ($let sym1 rArgs1) ... ($let symN rArgsN) )\r\n                //         t-expr\r\n                //     )\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        ...front,\r\n                        ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                            [{symbol: state.config.reservedNames.let}, formalArgs[idx], x])),\r\n                    ],\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym);\r\n\r\n                if (m) {\r\n                    r = m(r);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, r[1]);\r\n                }\r\n            }\r\n\r\n            const sprs = [];\r\n            for (let i = 1; i < r.length; i++) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    sprs.push(i);\r\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    r[i] = Array.isArray(a) ? a : [a];\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n            for (const i of sprs.reverse()) {\r\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         isSymbol,\r\n         quote,\r\n         FatalError,\r\n         CapturedScopes }     from '../../types';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         collectCapturedVariables,\r\n         getCapturedScopes,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }           from '../../evaluate';\r\nimport { checkParamsLength }  from '../../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    const scope: any = {};\r\n    if (Array.isArray(car)) {\r\n        for (const x of car) {\r\n            if (Array.isArray(x)) {\r\n                const kv = $$firstAndSecond(...x);\r\n                const kvSym = isSymbol(kv.car);\r\n                scope[kvSym ? kvSym.symbol : String(kv.car)] = evaluate(state, kv.cdr);\r\n            } else {\r\n                const xSym = isSymbol(x);\r\n                scope[xSym ? xSym.symbol : String(x)] = null;\r\n            }\r\n        }\r\n    }\r\n    installScope(state, scope, isBlockLocal, capturedScopes);\r\n\r\n    try {\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    installScope(state, getGlobalScope(state).scope, true);\r\n    try {\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : exprN\r\n    checkParamsLength('$__capture', args, 1);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let r: SxToken = null;\r\n\r\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\r\n    installScope(state, {}, true, capturedScopes);\r\n    try {\r\n        for (const x of args.slice(1)) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = (...actualArgs: any[]) => {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($refun 'name)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__refun', args, 1, 1);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const info = state.funcMap.get(car.symbol);\r\n    if (!info) {\r\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\r\n    }\r\n    return info.fn(state, car.symbol);\r\n};\r\n\r\n\r\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($apply fn arg1 ... argN)\r\n    //  -> S expr  : fn'\r\n    checkParamsLength('$apply', args, 1);\r\n\r\n    const car: () => any = $$first(...args);\r\n    if (typeof car !== 'function') {\r\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\r\n    }\r\n\r\n    return (\r\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\r\n    );\r\n};\r\nexport const $$apply = $apply(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    return Function.prototype.apply.call(\r\n        car[sym ? sym.symbol : evaluate(state, cdr) as any],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__capture',\r\n    fn: ops.$__capture,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__refun',\r\n    fn: ops.$__refun,\r\n}, {\r\n    name: '$apply',\r\n    fn: ops.$apply,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote,\r\n         isSymbol }          from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$capture',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__capture'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$refun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($refun name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '<-',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (<- name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './core.operator';\r\nimport macros             from './core.macro';\r\nimport symbols            from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\n\r\n\r\n\r\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<< number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitLShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car << cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car >>> (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitLShift = $bitLShift(null as any, null as any);\r\n\r\n\r\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitSRShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\r\n\r\n\r\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>>> number shift)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitURShift', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    car = toNumber(car);\r\n    cdr = toNumber(cdr);\r\n\r\n    if (0 <= cdr) {\r\n        return cdr < 32 ? car >>> cdr : 0;\r\n    } else {\r\n        return cdr > -32 ? car << (-cdr) : 0;\r\n    }\r\n};\r\nexport const $$bitURShift = $bitURShift(null as any, null as any);\r\n\r\n\r\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-not number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitNot', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return ~toNumber(car);\r\n};\r\nexport const $$bitNot = $bitNot(null as any, null as any);\r\n\r\n\r\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-and numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitAnd', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitAnd = $bitAnd(null as any, null as any);\r\n\r\n\r\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-or numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitOr', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitOr = $bitOr(null as any, null as any);\r\n\r\n\r\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($bit-xor numberA numberB)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$bitXor', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\r\n};\r\nexport const $$bitXor = $bitXor(null as any, null as any);\r\n\r\n\r\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (+ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$add', args, 1);\r\n\r\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\r\n};\r\nexport const $$add = $add(null as any, null as any);\r\n\r\n\r\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (- number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sub', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const last = args.slice(1);\r\n    if (last.length === 0) {\r\n        // negate\r\n        return -toNumber(car);\r\n    } else {\r\n        // subtract\r\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\r\n    }\r\n};\r\nexport const $$sub = $sub(null as any, null as any);\r\n\r\n\r\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (* number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mul', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mul = $mul(null as any, null as any);\r\n\r\n\r\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (** number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sup', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\r\n};\r\nexport const $$sup = $sup(null as any, null as any);\r\n\r\n\r\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (/ number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$div', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\r\n};\r\nexport const $$div = $div(null as any, null as any);\r\n\r\n\r\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (% number1 ... numberN)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$mod', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\r\n};\r\nexport const $$mod = $mod(null as any, null as any);\r\n\r\n\r\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($max val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.max(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$max = $max(null as any, null as any);\r\n\r\n\r\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($min val1 ... valN)\r\n    //  -> S expr  : value\r\n    return Math.min(...(args.map(x => toNumber(x))));\r\n};\r\nexport const $$min = $min(null as any, null as any);\r\n\r\n\r\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($avg val1 ... valN)\r\n    //  -> S expr  : value\r\n    const a = args.map(x => toNumber(x));\r\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\r\n};\r\nexport const $$avg = $avg(null as any, null as any);\r\n\r\n\r\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($floor number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$floor', args, 1, 1);\r\n\r\n    return Math.floor(toNumber($$first(...args)));\r\n};\r\nexport const $$floor = $floor(null as any, null as any);\r\n\r\n\r\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($ceil number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$ceil', args, 1, 1);\r\n\r\n    return Math.ceil(toNumber($$first(...args)));\r\n};\r\nexport const $$ceil = $ceil(null as any, null as any);\r\n\r\n\r\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($round number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$round', args, 1, 1);\r\n\r\n    return Math.round(toNumber($$first(...args)));\r\n};\r\nexport const $$round = $round(null as any, null as any);\r\n\r\n\r\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($abs number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$abs', args, 1, 1);\r\n\r\n    return Math.abs(toNumber($$first(...args)));\r\n};\r\nexport const $$abs = $abs(null as any, null as any);\r\n\r\n\r\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sign number)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$sign', args, 1, 1);\r\n\r\n    return Math.sign(toNumber($$first(...args)));\r\n};\r\nexport const $$sign = $sign(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './arithmetic.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '<<',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '$bit-l-shift',\r\n    fn: ops.$bitLShift,\r\n}, {\r\n    name: '>>',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '$bit-sr-shift',\r\n    fn: ops.$bitSRShift,\r\n}, {\r\n    name: '>>>',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-ur-shift',\r\n    fn: ops.$bitURShift,\r\n}, {\r\n    name: '$bit-not',\r\n    fn: ops.$bitNot,\r\n}, {\r\n    name: '$bit-and',\r\n    fn: ops.$bitAnd,\r\n}, {\r\n    name: '$bit-or',\r\n    fn: ops.$bitOr,\r\n}, {\r\n    name: '$bit-xor',\r\n    fn: ops.$bitXor,\r\n}, {\r\n    name: '+',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$add',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '$sum',\r\n    fn: ops.$add,\r\n}, {\r\n    name: '-',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$sub',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '$neg',\r\n    fn: ops.$sub,\r\n}, {\r\n    name: '*',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '$mul',\r\n    fn: ops.$mul,\r\n}, {\r\n    name: '**',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '$sup',\r\n    fn: ops.$sup,\r\n}, {\r\n    name: '/',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '$div',\r\n    fn: ops.$div,\r\n}, {\r\n    name: '%',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$mod',\r\n    fn: ops.$mod,\r\n}, {\r\n    name: '$max',\r\n    fn: ops.$max,\r\n}, {\r\n    name: '$min',\r\n    fn: ops.$min,\r\n}, {\r\n    name: '$avg',\r\n    fn: ops.$avg,\r\n}, {\r\n    name: '$floor',\r\n    fn: ops.$floor,\r\n}, {\r\n    name: '$ceil',\r\n    fn: ops.$ceil,\r\n}, {\r\n    name: '$round',\r\n    fn: ops.$round,\r\n}, {\r\n    name: '$abs',\r\n    fn: ops.$abs,\r\n}, {\r\n    name: '$sign',\r\n    fn: ops.$sign,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './arithmetic.operator';\r\nimport macros             from './arithmetic.macro';\r\nimport symbols            from './arithmetic.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2017, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport class Query<T> {\r\n    public constructor(public data: T[]) {\r\n    }\r\n\r\n    public orderBy(condition: Array<string | string[/* colName: string, ('asc' | 'desc') */]> | ((a: T, b: T) => number)): Query<T> {\r\n        let fn: (a: T, b: T) => number;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (typeof c === 'string') {\r\n                        if (x[c] > y[c]) return 1;\r\n                        if (x[c] < y[c]) return -1;\r\n                    } else {\r\n                        const desc = c[1] === 'desc' ? -1 : 1;\r\n                        if (x[c[0]] > y[c[0]]) return 1 * desc;\r\n                        if (x[c[0]] < y[c[0]]) return -1 * desc;\r\n                    }\r\n                }\r\n                return 0;\r\n            };\r\n        } else {\r\n            fn = condition;\r\n        }\r\n        return new Query(this.data.slice(0).sort(fn));\r\n    }\r\n\r\n    public groupBy(condition: string[/* colName: string */] | ((a: T, b: T, index: number, array: T[]) => boolean)): Query<T[]> {\r\n        let fn: (a: T, b: T, index: number, array: T[]) => boolean;\r\n        if (Array.isArray(condition)) {\r\n            fn = (x: T, y: T) => {\r\n                for (const c of condition) {\r\n                    if (x[c] !== y[c]) return false;\r\n                }\r\n                return true;\r\n            };\r\n        } else{\r\n            fn = condition;\r\n        }\r\n        const r: T[][] = [];\r\n        let start = 0;\r\n        let i = 1;\r\n        for (; i < this.data.length; i++) {\r\n            if (! fn(this.data[start], this.data[i], i, this.data)) {\r\n                r.push(this.data.slice(start, i));\r\n                start = i;\r\n            }\r\n        }\r\n        r.push(this.data.slice(start, i));\r\n        return new Query(r);\r\n    }\r\n\r\n    public groupEvery(n: number | {single: number, first?: number, intermediate: number, last?: number}): Query<T[]> {\r\n        if (typeof n === 'number') {\r\n            return this.groupBy((a, b, index, array) => {\r\n                if ((index % n) === 0) return false;\r\n                return true;\r\n            });\r\n        } else {\r\n            const w = Object.assign({first: n.intermediate, last: n.intermediate}, n);\r\n            const r = this.groupBy((a, b, index, array) => {\r\n                if (w.single >= array.length) {\r\n                    if ((index % w.single) === 0) return false;\r\n                    return true;\r\n                } else if (index <= w.first) {\r\n                    if ((index % w.first) === 0) return false;\r\n                    return true;\r\n                } else {\r\n                    if (((index - w.first) % w.intermediate) === 0) return false;\r\n                    return true;\r\n                }\r\n            });\r\n            if (r.data.length === 1) {\r\n                if (w.single < r.data[0].length) {\r\n                    r.data.push([]);\r\n                }\r\n            } else {\r\n                if (w.first < r.data[0].length) {\r\n                    // case of w.first === 0\r\n                    r.data.unshift([]);\r\n                }\r\n            }\r\n            if (r.data.length > 1) {\r\n                if (r.data[r.data.length - 1].length > w.last) {\r\n                    r.data.push([]);\r\n                }\r\n            }\r\n            return r;\r\n        }\r\n    }\r\n\r\n    public where(fn: (value: T, index: number, array: T[]) => boolean): Query<T> {\r\n        return new Query(this.data.filter(fn));\r\n    }\r\n\r\n    public select(): T[];\r\n    public select<R>(fn: (value: T, index: number, array: T[]) => R): R[];\r\n    public select<R>(fn?: (value: T, index: number, array: T[]) => R): Array<R | T> {\r\n        return fn ? this.data.map(fn) : this.data as any;\r\n    }\r\n}\r\n\r\n\r\n\r\nexport function query<T>(data: T[]): Query<T> {\r\n    return new Query<T>(data);\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { toNumber,\r\n         evaluate }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond }  from '../core/core.fn';\r\nimport { query }             from '../../../lib/data';\r\n\r\n\r\n\r\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($range start end)\r\n    // S expression: ($range start end step)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$range', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const start = toNumber(car) || 0;\r\n    const stop = toNumber(cdr) || 0;\r\n\r\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\r\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\r\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\r\n\r\n    state.evalCount += n;\r\n    evaluate(state, 0);\r\n    return Array.from({length: n}, (x, i) => start + i * step);\r\n};\r\n\r\n\r\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($length listOrString)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$length', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('length' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.length;\r\n    }\r\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\r\n};\r\nexport const $$length = $length(null as any, null as any);\r\n\r\n\r\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trim', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trim();\r\n    }\r\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trim = $trim(null as any, null as any);\r\n\r\n\r\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-head string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimHead', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimLeft();\r\n    }\r\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimHead = $trimHead(null as any, null as any);\r\n\r\n\r\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($trim-tail string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$trimTail', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (typeof car === 'string') {\r\n        return car.trimRight();\r\n    }\r\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\r\n};\r\nexport const $$trimTail = $trimTail(null as any, null as any);\r\n\r\n\r\nexport const $replaceAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($replace-all src-string match-string replacement-string)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$replaceAll', args, 3, 3);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {\r\n        return args[0].split(args[1]).join(args[2]);\r\n    }\r\n    throw new Error(`[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.`);\r\n};\r\nexport const $$replaceAll = $replaceAll(null as any, null as any);\r\n\r\n\r\nexport const $split = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($split src-string match-string)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$split', args, 2, 2);\r\n\r\n    if (typeof args[0] === 'string' && typeof args[1] === 'string') {\r\n        return args[0].split(args[1]);\r\n    }\r\n    throw new Error(`[SX] $split: Invalid argument type: args[0] or [1] is not string.`);\r\n};\r\nexport const $$split = $split(null as any, null as any);\r\n\r\n\r\nexport const $join = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($join '(str1 ... strN) separator)\r\n    //  -> S expr  : (string ... string)\r\n    checkParamsLength('$join', args, 1, 2);\r\n\r\n    if (typeof Array.isArray(args[0])) {\r\n        if (args.length > 1) {\r\n            if (typeof args[1] === 'string') {\r\n                return args[0].join(args[1]);\r\n            }\r\n            throw new Error(`[SX] $join: Invalid argument type: args[1] is not string.`);\r\n        } else {\r\n            return args[0].join();\r\n        }\r\n    }\r\n    throw new Error(`[SX] $join: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$join = $join(null as any, null as any);\r\n\r\n\r\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($concat listOrString1 ... listOrStringN)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$concat', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    switch (typeof car) {\r\n    case 'object':\r\n        if (! ('concat' in car)) {\r\n            break;\r\n        }\r\n        // FALL_THRU\r\n    case 'string':\r\n        return car.concat(...args.slice(1));\r\n    }\r\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\r\n};\r\nexport const $$concat = $concat(null as any, null as any);\r\n\r\n\r\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($slice start end listOrString)\r\n    // S expression: ($slice start listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$slice', args, 2, 3);\r\n\r\n    if (args.length === 3) {\r\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\r\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\r\n        }\r\n    }\r\n    if (args.length === 2) {\r\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n            return args[1].slice(toNumber(args[0]));\r\n        }\r\n    }\r\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\r\n};\r\nexport const $$slice = $slice(null as any, null as any);\r\n\r\n\r\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($top n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$top', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        return args[1].slice(0, toNumber(args[0]));\r\n    }\r\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$top = $top(null as any, null as any);\r\n\r\n\r\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($tail n listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$tail', args, 2, 2);\r\n\r\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\r\n        const n = -toNumber(args[0]);\r\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\r\n    }\r\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\r\n};\r\nexport const $$tail = $tail(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__at index listOrString)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__at', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return cdr[car];\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__at = $__at(null as any, null as any);\r\n\r\n\r\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverse = $reverse(null as any, null as any);\r\n\r\n\r\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reverse! listOrString)\r\n    //  -> S expr  : listOrString\r\n    checkParamsLength('$reverse!', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.reverse();\r\n    }\r\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\r\n\r\n\r\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($find list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$find', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.find(cdr);\r\n    }\r\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$find = $find(null as any, null as any);\r\n\r\n\r\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$filter', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.filter(cdr);\r\n    }\r\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$filter = $filter(null as any, null as any);\r\n\r\n\r\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($map list (lambda (v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$map', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.map(cdr);\r\n    }\r\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$map = $map(null as any, null as any);\r\n\r\n\r\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduce', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduce(cdr);\r\n        } else {\r\n            return car.reduce(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduce = $reduce(null as any, null as any);\r\n\r\n\r\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\r\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$reduceFromTail', args, 2, 3);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        if (args.length < 3) {\r\n            return car.reduceRight(cdr);\r\n        } else {\r\n            return car.reduceRight(cdr, args[2]);\r\n        }\r\n    }\r\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\r\n\r\n\r\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.slice(0).sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sort = $sort(null as any, null as any);\r\n\r\n\r\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\r\n    //  -> S expr  : list\r\n    checkParamsLength('$sort!', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car)) {\r\n        return car.sort(cdr);\r\n    }\r\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\r\n};\r\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\r\n\r\n\r\nexport const $groupEvery = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-every optionsOrNumber (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-every', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-every: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupEvery(car).select();\r\n};\r\nexport const $$groupEvery = $groupEvery(null as any, null as any);\r\n\r\n\r\nexport const $groupBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($group-by conditions (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$group-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $group-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).groupBy(car).select();\r\n};\r\nexport const $$groupBy = $groupBy(null as any, null as any);\r\n\r\n\r\nexport const $orderBy = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($order-by conditions (x1 ... xN))\r\n    //  -> S expr  : (x1 ... xN)\r\n    checkParamsLength('$order-by', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $order-by: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).orderBy(car).select();\r\n};\r\nexport const $$orderBy = $orderBy(null as any, null as any);\r\n\r\n\r\nexport const $where = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($where (-> (v index array) ... boolean) (x1 ... xN))\r\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\r\n    checkParamsLength('$where', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    if (typeof args[0] !== 'function') {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[0] is not function.`);\r\n    }\r\n    if (! Array.isArray(cdr)) {\r\n        throw new Error(`[SX] $where: Invalid argument type: args[1] is not array.`);\r\n    }\r\n\r\n    return query(cdr as any[]).where(car).select();\r\n};\r\nexport const $$where = $where(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './sequence.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$range',\r\n    fn: ops.$range,\r\n}, {\r\n    name: '$length',\r\n    fn: ops.$length,\r\n}, {\r\n    name: '$trim',\r\n    fn: ops.$trim,\r\n}, {\r\n    name: '$trim-head',\r\n    fn: ops.$trimHead,\r\n}, {\r\n    name: '$trim-tail',\r\n    fn: ops.$trimTail,\r\n}, {\r\n    name: '$replace-all',\r\n    fn: ops.$replaceAll,\r\n}, {\r\n    name: '$split',\r\n    fn: ops.$split,\r\n}, {\r\n    name: '$join',\r\n    fn: ops.$join,\r\n}, {\r\n    name: '$concat',\r\n    fn: ops.$concat,\r\n}, {\r\n    name: '$slice',\r\n    fn: ops.$slice,\r\n}, {\r\n    name: '$top',\r\n    fn: ops.$top,\r\n}, {\r\n    name: '$tail',\r\n    fn: ops.$tail,\r\n}, {\r\n    name: '$__at',\r\n    fn: ops.$__at,\r\n}, {\r\n    name: '$reverse',\r\n    fn: ops.$reverse,\r\n}, {\r\n    name: '$reverse!',\r\n    fn: ops.$reverseDestructive,\r\n}, {\r\n    name: '$find',\r\n    fn: ops.$find,\r\n}, {\r\n    name: '$filter',\r\n    fn: ops.$filter,\r\n}, {\r\n    name: '$map',\r\n    fn: ops.$map,\r\n}, {\r\n    name: '$reduce',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-head',\r\n    fn: ops.$reduce,\r\n}, {\r\n    name: '$reduce-from-tail',\r\n    fn: ops.$reduceFromTail,\r\n}, {\r\n    name: '$sort',\r\n    fn: ops.$sort,\r\n}, {\r\n    name: '$sort!',\r\n    fn: ops.$sortDestructive,\r\n}, {\r\n    name: '$group-every',\r\n    fn: ops.$groupEvery,\r\n}, {\r\n    name: '$group-by',\r\n    fn: ops.$groupBy,\r\n}, {\r\n    name: '$order-by',\r\n    fn: ops.$orderBy,\r\n}, {\r\n    name: '$where',\r\n    fn: ops.$where,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         isSymbol } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$[',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($[ index ] listOrObject)\r\n        //  -> S expr  : ($__at listOrObject)\r\n        const symOf = isSymbol(list[2], ']');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\r\n        }\r\n        return [{symbol: '$__at'},\r\n            list[1],\r\n            list[3],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './sequence.operator';\r\nimport macros             from './sequence.macro';\r\nimport symbols            from './sequence.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken,\r\n         quote,\r\n         isSymbol }          from '../../types';\r\nimport { evaluate,\r\n         getScope }          from '../../evaluate';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $$first,\r\n         $$firstAndSecond,\r\n         $__scope,\r\n         $$boolean }         from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputIf cond 'expr)\r\n    //  -> (if cond is true ) S expr  : expr\r\n    //  -> (if cond is false) S expr  : ()\r\n    checkParamsLength('$__outputIf', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        if (2 < args.length) {\r\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\r\n            r = evaluate(state, r);\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__outputForOf list 'expr)\r\n    //  -> S expr  : (Template expr ... expr)\r\n    checkParamsLength('$__outputForOf', args, 2);\r\n\r\n    const car = $$first(...args);\r\n    const r: SxToken[] = [];\r\n    if (Array.isArray(car)) {\r\n        for (let i = 0; i < car.length; i++) {\r\n            const x = car[i];\r\n            const v = $__scope(state, name)(true, true, [\r\n                ['$data', quote(state, x)],\r\n                ['$index', i],\r\n                ['$array', quote(state, car)],\r\n                ['$parent', quote(state, getScope(state).scope)],\r\n            ], ...args.slice(1));\r\n\r\n            if (2 < args.length && Array.isArray(v)) {\r\n                r.push(...v);\r\n            } else {\r\n                r.push(v);\r\n            }\r\n        }\r\n    } else {\r\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    // All of r items are already evaluated.\r\n    return evaluate(state,\r\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\r\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\r\n};\r\n\r\n\r\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (@ (name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n            switch (keyName) {\r\n            case 'style':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (style) ...)\r\n                        //  -> JSON    : {..., style: \"\", ...}\r\n                        r[keyName] = \"\";\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\r\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\r\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\r\n                        const styles: object = {};\r\n                        for (const s of x.slice(1)) {\r\n                            if (Array.isArray(s) && 1 < s.length) {\r\n                                styles[String(evaluate(state, s[0]))] = String(evaluate(state, s[1]));\r\n                            } else if (typeof s === 'string') {\r\n                                for (const v of s.split(';')) {\r\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\r\n                                    if (matched) {\r\n                                        styles[matched[1]] = matched[2];\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        r[keyName] = styles;\r\n                    }\r\n                }\r\n                break;\r\n            case 'class': case 'styleClass':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: [], ...}\r\n                        r[keyName] = [];\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\r\n                        let classes: any[] = [];\r\n                        for (const c of x.slice(1)) {\r\n                            if (Array.isArray(c)) {\r\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\r\n                            } else if (typeof c === 'string') {\r\n                                classes = classes.concat(c.split(' '));\r\n                            }\r\n                        }\r\n                        const cs: string[] = [];\r\n                        const fn: (a: any[]) => void = (a) => a\r\n                            .forEach(c => (c === null || c === void 0) ?\r\n                                void 0 :\r\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\r\n                        fn(classes);\r\n                        r[keyName] = cs;\r\n                    }\r\n                }\r\n                break;\r\n            case 'className':\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (class) ...)\r\n                        //  -> JSON    : {..., class: \"\", ...}\r\n                        r[keyName] = '';\r\n                    } else if (x.length >= 2) {\r\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\r\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\r\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\r\n                        let classes: string = '';\r\n                        for (const c of x.slice(1)) {\r\n                            let fragment = '';\r\n                            if (Array.isArray(c)) {\r\n                                const cs: string[] = [];\r\n                                const fn: (a: any[]) => void = (a) => a\r\n                                    .map(z => evaluate(state, z))\r\n                                    .forEach(z => (z === null || z === void 0) ?\r\n                                        void 0 :\r\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\r\n                                fn(c);\r\n                                fragment = cs.join(' ');\r\n                            } else if (typeof c === 'string') {\r\n                                fragment = c;\r\n                            }\r\n                            if (0 < classes.length) classes += ' ' + fragment;\r\n                            else classes = fragment;\r\n                        }\r\n                        r[keyName] = classes;\r\n                    }\r\n                }\r\n                break;\r\n            case 'dangerouslySetInnerHTML':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__html: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__html: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__html:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            case 'setInnerText':\r\n                {\r\n                    if (x.length === 1) {\r\n                        r[keyName] = {__text: ''};\r\n                    } else if (x.length >= 2) {\r\n                        r[keyName] = {__text: evaluate(state, x[1])};\r\n                    } else {\r\n                        r[keyName] = {__text:\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)))\r\n                        };\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                {\r\n                    if (x.length === 1) {\r\n                        // S expression: (@ ... (keyName) ...)\r\n                        //  -> JSON    : {..., keyName: true, ...}\r\n                        r[keyName] = true;\r\n                    } else if (x.length === 2) {\r\n                        // S expression: (@ ... (keyName value) ...)\r\n                        //  -> JSON    : {..., keyName: value, ...}\r\n                        r[keyName] = evaluate(state, x[1]);\r\n                    } else {\r\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\r\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                        r[keyName] =\r\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                            .concat(x.slice(1)));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\r\n    let children = args;\r\n    let props: any = {};\r\n    if (0 < args.length && Array.isArray(args[0])) {\r\n        const sym = isSymbol(args[0][0], '@');\r\n\r\n        if (sym) {\r\n            props = $jsxProps(state, '')(...args[0].slice(1));\r\n            children = children.slice(1);\r\n        }\r\n    }\r\n    return {props, children};\r\n}\r\n\r\n\r\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(name, props, ...children);\r\n};\r\n\r\n\r\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\r\n    const {props, children} = getJsxTagsParams(state, ...args);\r\n    return (state.config.jsx as any)(component, props, ...children);\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './jsx.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$=__if',\r\n    fn: ops.$__outputIf,\r\n}, {\r\n    name: '$=__for',\r\n    fn: ops.$__outputForOf,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote } from '../../types';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '@',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        return quote(state, list);\r\n    },\r\n}, {\r\n    name: '$=if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=if cond expr)\r\n        //  -> S expr  : ($=__if cond 'expr)\r\n        return [\r\n            {symbol: '$=__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$=for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($=for list expr)\r\n        //  -> S expr  : ($=__for list 'expr)\r\n        return [\r\n            {symbol: '$=__for'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig,\r\n         LsxConfig }        from '../../types';\r\nimport operators            from './jsx.operator';\r\nimport macros               from './jsx.macro';\r\nimport symbols              from './jsx.symbol';\r\n\r\nimport { $jsxStandardTag,\r\n         $jsxComponentTag } from './jsx.fn';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n\r\n    const components =\r\n        Object.entries(lsxConf.components)\r\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\r\n\r\n    config.funcs = config.funcs.concat(\r\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\r\n        ...components\r\n    );\r\n\r\n    config.funcSymbolResolverFallback = $jsxStandardTag;\r\n    config.jsx = lsxConf.jsx;\r\n    config.JsxFragment = lsxConf.jsxFlagment;\r\n\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState }     from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\nimport { $__let,\r\n         $__set  }           from '../core/core.fn';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__letAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__let(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__letAsync = $__letAsync(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$__setAsync', args, 2, 2);\r\n\r\n    let promise: Promise<any> = args[1];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    promise = promise.then(v => {\r\n        try {\r\n            $__set(state, '')(args[0], v);\r\n            return v;\r\n        } catch (e) {\r\n            return Promise.reject(e);\r\n        }\r\n    });\r\n    return promise;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__setAsync = $__setAsync(null as any, null as any);\r\n\r\n\r\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\r\n    //  -> S expr  : promise\r\n    checkParamsLength('$then', args, 2, 3);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    if (typeof args[2] === 'function') {\r\n        promise = promise.then(args[1], args[2]);\r\n    } else {\r\n        if (typeof args[1] !== 'function') {\r\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\r\n        }\r\n        promise = promise.then(args[1]);\r\n    }\r\n    return promise;\r\n};\r\nexport const $$then = $then(null as any, null as any);\r\n\r\n\r\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-all promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n    return Promise.all(promises);\r\n};\r\nexport const $$resolveAll = $resolveAll(null as any, null as any);\r\n\r\n\r\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-any promise1 ... promiseN)\r\n    //  -> S expr  : promise\r\n    const promises: Array<Promise<any>> = args.slice(0);\r\n    for (let i = 0; i < promises.length; i++) {\r\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\r\n            promises[i] = Promise.resolve(promises[i]);\r\n        }\r\n    }\r\n\r\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\r\n    // firstOf: This will return the value of the first fulfilled promise,\r\n    //          or if all reject, an array of rejection reasons.\r\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\r\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\r\n\r\n    return firstOf(promises);\r\n};\r\nexport const $$resolveAny = $resolveAny(null as any, null as any);\r\n\r\n\r\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\r\n    //  -> S expr  : promise\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolvePipe', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n    let p = promise;\r\n    for (const l of lambdas) {\r\n        p = p.then(l);\r\n    }\r\n    return p;\r\n};\r\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\r\n\r\n\r\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\r\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\r\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\r\n    checkParamsLength('$resolveFork', args, 1);\r\n\r\n    let promise: Promise<any> = args[0];\r\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\r\n        promise = Promise.resolve(promise);\r\n    }\r\n    const lambdas = args.slice(1);\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        if (typeof lambdas[i] !== 'function') {\r\n            const v = lambdas[i];\r\n            lambdas[i] = () => v;\r\n        }\r\n    }\r\n\r\n    const resolvers = new Array(lambdas.length);\r\n    const rejectors = new Array(lambdas.length);\r\n\r\n    const pa: Array<Promise<any>> = [];\r\n    for (let i = 0; i < lambdas.length; i++) {\r\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\r\n            resolvers[i] = (v: any) => {\r\n                let lp: Promise<any> = lambdas[i](v);\r\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\r\n                    lp = Promise.resolve(lp);\r\n                }\r\n\r\n                lp\r\n                .then(x => resolve(x))\r\n                .catch(e => reject(e));\r\n            };\r\n            rejectors[i] = reject;\r\n        }));\r\n    }\r\n\r\n    promise.then(\r\n        v => resolvers.forEach(f => f(v)),\r\n        e => rejectors.forEach(f => f(e))\r\n    );\r\n\r\n    return pa;\r\n};\r\nexport const $$resolveFork = $resolveFork(null as any, null as any);\r\n\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './concurrent.fn';\r\n\r\n\r\n\r\nexport const funcs: SxFuncInfo[] = [{\r\n    name: '$__let-async',\r\n    fn: ops.$__letAsync,\r\n}, {\r\n    name: '$__set-async',\r\n    fn: ops.$__setAsync,\r\n}, {\r\n    name: '$then',\r\n    fn: ops.$then,\r\n}, {\r\n    name: '$resolve-all',\r\n    fn: ops.$resolveAll,\r\n}, {\r\n    name: '$resolve-any',\r\n    fn: ops.$resolveAny,\r\n}, {\r\n    name: '$resolve-pipe',\r\n    fn: ops.$resolvePipe,\r\n}, {\r\n    name: '$resolve-fork',\r\n    fn: ops.$resolveFork,\r\n}];\r\n\r\n\r\nexport default funcs;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState,\r\n         quote }             from '../../types';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$let-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let-async nameStrOrSymbol promise)\r\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\r\n        checkParamsLength('$let-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__let-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set-async',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\r\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\r\n        checkParamsLength('$set-async', list, 3, 3);\r\n\r\n        return [{symbol: '$__set-async'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport default macros;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig } from '../../types';\r\nimport operators          from './concurrent.operator';\r\nimport macros             from './concurrent.macro';\r\nimport symbols            from './concurrent.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || []).concat(operators);\r\n    config.macros = (config.macros || []).concat(macros);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxReservedNames,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         LsxConfig }        from './types';\r\nimport { parse }            from './parser';\r\nimport { evaluate }         from './evaluate';\r\nimport installCore          from './operators/core';\r\nimport installArithmetic    from './operators/arithmetic';\r\nimport installSequence      from './operators/sequence';\r\nimport installJsx           from './operators/jsx';\r\nimport installConcurrent    from './operators/concurrent';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    spread: '$spread',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableTailCallOptimization: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\r\n}\r\n\r\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\ninterface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n\r\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    f.repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\n\r\nexport const S = (() => {\r\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config.enableEvaluate = false;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\nexport const L = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\nexport const LS = L;\r\nexport const lisp = L;\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const L_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LS_async = L_async;\r\n// tslint:disable-next-line:variable-name\r\nexport const lisp_async = L_async;\r\n\r\n\r\n\r\nexport const LM = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpression(config);\r\n})();\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const LM_async = (() => {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n\r\n    config.stripComments = true;\r\n    config.returnMultipleRoot = true;\r\n\r\n    return SExpressionAsync(config);\r\n})();\r\n\r\n\r\n\r\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpression(config) as any;\r\n}\r\n\r\n\r\n\r\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\r\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\r\n\r\n    config = installCore(config);\r\n    config = installArithmetic(config);\r\n    config = installSequence(config);\r\n    config = installConcurrent(config);\r\n    config = installJsx(config, lsxConf);\r\n\r\n    config.stripComments = true;\r\n\r\n    return SExpressionAsync(config) as any;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport * from './s-exp/s-expression';\r\n\r\n\r\nexport { default as installCore }         from './s-exp/operators/core';\r\nexport { default as installArithmetic }   from './s-exp/operators/arithmetic';\r\nexport { default as installSequence }     from './s-exp/operators/sequence';\r\nexport { default as installJsx }          from './s-exp/operators/jsx';\r\nexport { default as installConcurrent }   from './s-exp/operators/concurrent';\r\n\r\n\r\nimport { default as coreOperators }       from './s-exp/operators/core/core.operator';\r\nimport { default as coreMacros }          from './s-exp/operators/core/core.macro';\r\nimport { default as coreSymbols }         from './s-exp/operators/core/core.symbol';\r\n\r\nimport { default as arithmeticOperators } from './s-exp/operators/arithmetic/arithmetic.operator';\r\nimport { default as arithmeticMacros }    from './s-exp/operators/arithmetic/arithmetic.macro';\r\nimport { default as arithmeticSymbols }   from './s-exp/operators/arithmetic/arithmetic.symbol';\r\n\r\nimport { default as sequenceOperators }   from './s-exp/operators/sequence/sequence.operator';\r\nimport { default as sequenceMacros }      from './s-exp/operators/sequence/sequence.macro';\r\nimport { default as sequenceSymbols }     from './s-exp/operators/sequence/sequence.symbol';\r\n\r\nimport { default as jsxOperators }        from './s-exp/operators/jsx/jsx.operator';\r\nimport { default as jsxMacros }           from './s-exp/operators/jsx/jsx.macro';\r\nimport { default as jsxSymbols }          from './s-exp/operators/jsx/jsx.symbol';\r\n\r\nimport { default as concurrentOperators } from './s-exp/operators/concurrent/concurrent.operator';\r\nimport { default as concurrentMacros }    from './s-exp/operators/concurrent/concurrent.macro';\r\nimport { default as concurrentSymbols }   from './s-exp/operators/concurrent/concurrent.symbol';\r\n\r\n\r\nexport const builtinOperators = {\r\n    core: coreOperators,\r\n    arithmetic: arithmeticOperators,\r\n    sequence: sequenceOperators,\r\n    jsx: jsxOperators,\r\n    concurrent: concurrentOperators,\r\n};\r\n\r\nexport const builtinMacros = {\r\n    core: coreMacros,\r\n    arithmetic: arithmeticMacros,\r\n    sequence: sequenceMacros,\r\n    jsx: jsxMacros,\r\n    concurrent: concurrentMacros,\r\n};\r\n\r\nexport const builtinSymbols = {\r\n    core: coreSymbols,\r\n    arithmetic: arithmeticSymbols,\r\n    sequence: sequenceSymbols,\r\n    jsx: jsxSymbols,\r\n    concurrent: concurrentSymbols,\r\n};\r\n"],"sourceRoot":""}