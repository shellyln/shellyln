{"version":3,"sources":["webpack://liyad/webpack/universalModuleDefinition","webpack://liyad/webpack/bootstrap","webpack://liyad/./src/s-exp/errors.ts","webpack://liyad/./src/s-exp/evaluate.ts","webpack://liyad/./src/s-exp/ast.ts","webpack://liyad/./src/s-exp/compile.ops/helpers.ts","webpack://liyad/./src/s-exp/types.ts","webpack://liyad/./src/s-exp/global-this.ts","webpack://liyad/./src/s-exp/compile.ts","webpack://liyad/./src/s-exp/compile.ops/index.ts","webpack://liyad/./src/s-exp/defaults.ts","webpack://liyad/./src/s-exp/parser.ts","webpack://liyad/./src/s-exp/interpreters/index.ts","webpack://liyad/./src/s-exp/interpreters/presets/s-exp.ts","webpack://liyad/./src/s-exp/operators/core/core.fn.ts","webpack://liyad/./src/s-exp/operators/core/core.operator.ts","webpack://liyad/./src/s-exp/operators/core/core.macro.ts","webpack://liyad/./src/s-exp/operators/core/core.symbol.ts","webpack://liyad/./src/s-exp/operators/core/index.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.fn.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.operator.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.macro.ts","webpack://liyad/./src/s-exp/operators/arithmetic/arithmetic.symbol.ts","webpack://liyad/./src/s-exp/operators/arithmetic/index.ts","webpack://liyad/./src/lib/data.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.fn.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.operator.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.macro.ts","webpack://liyad/./src/s-exp/operators/sequence/sequence.symbol.ts","webpack://liyad/./src/s-exp/operators/sequence/index.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.fn.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.operator.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.macro.ts","webpack://liyad/./src/s-exp/operators/concurrent/concurrent.symbol.ts","webpack://liyad/./src/s-exp/operators/concurrent/index.ts","webpack://liyad/./src/s-exp/interpreters/presets/lisp.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.fn.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.operator.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.macro.ts","webpack://liyad/./src/s-exp/operators/jsx/jsx.symbol.ts","webpack://liyad/./src/s-exp/operators/jsx/index.ts","webpack://liyad/./src/s-exp/interpreters/presets/lsx.ts","webpack://liyad/./src/s-exp/browser.ts","webpack://liyad/./src/index.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","setEvaluationCount","state","evalCount","config","maxEvalCount","checkParamsLength","args","min","max","length","Error","checkUnsafeVarNames","varName","checkUnsafeVarNamesEx","target","con","__proto__","toNumber","x","NaN","Number","resolveSplice","enableSplice","Array","isArray","reservedNames","splice","slice","concat","resolveMacro","macroInfo","macroMap","symbol","lastErr","r1","formalArgs","fn","actualArgs","matchResult","matchMacroArgs","Boolean","lastIsSpread","error","next","resolveValueSymbolScope","nullIfNotDefined","scopes","localScope","scope","capturedScopes","isBlockLocal","globalScope","getGlobalScope","getScope","resolveValueSymbol","symInfo","symbolMap","valueSymbolResolverFallback","raiseOnUnresolvedSymbol","collectCapturedVariables","names","getCapturedScopes","a","unshift","assign","installScope","push","uninstallScope","pop","macroName","nm","startsWith","endsWith","tpos","lastIndexOf","tname","optimizeTailCall","fnBody","front","tail","if","self","varBaseName","tempVarsSyms","map","idx","until","let","set","evaluate","sym","quote","backquote","resolveUnquote","unquote","eval","sprs","spread","reverse","funcInfo","funcMap","v","funcSymbolResolverFallback","resolveFunctionSymbol","JSON","stringify","wrapExternalValue","car","cdr","dotted","isQuoted","q","isSymbol","isBackquoted","wrapByUnquote","isUnquoted","applyMacros","tok","stripQuote","stripQuoteOrPass","getScope_stateApplied","resolveValueSymbol_dynamic","checkUnsafeVarNames_dynamic","FatalError","message","super","MaxEvaluationCountError","ScriptTerminationError","where","dummyTargetObject","g","globalObj","objConstructor","f","funConstructor","Function","e","window","global","globalThis","constructor","toString","compileCore","_$_vars","compileValue","b","compFnBody","String","ctx","varNames","has","varsCount","compileToken","body","ops","join","arr","Map","varNamesCount","varDefs","makeScope","scoped","varNamesCopy","entries","enableTailCallOptimization","thiz","compFormalArgs","compFnBodyRoot","evalCompiledLambda","_$_state","code","compileLambda","registerOperators","raise","quoted","vName","symName","checkNameCalled","checkNamePos","str","not","w1","w0","hasSpread","defaultReservedNames","cons","atom","eq","list","lambda","defun","cond","while","doWhile","doUntil","defvar","setq","and","or","gensym","catch","Template","defaultConfig","enableEvaluate","enableHereDoc","enableSpread","enableShorthands","enableVerbatimStringLiteral","enableRegExpMatchOperators","enableCompilationOperators","stripComments","returnMultipleRoot","symbols","macros","funcs","isEOF","ch","isSpace","trim","isNumberFirstChar","test","isNumberAfterSignChar","isSymbolFirstChar","lookCurrentLineHint","line","index","pos","strings","getChar","virtualEof","disableEscape","eof","values","split","eofSeq","ch1","ch2","fromCodePoint","parseInt","lookAheads","chs","lookAhead","skipWhitespaces","parseNumber","parseSymbol","match","ws","parseStringOrComment","valuesStartSeq","valuesStopChar","allowPhysicalEof","eofSeqs","parseList","parseString","parseHereDoc","attrs","inner","parseSingleLineComment","comment","parseMultiLineComment","parseOneToken","ahead","isSpliceUnquote","ret","aheads","isHereDoc","ahs","listStopChar","initialList","parse","initState","globals","resetState","SExpression","conf","startup","exec","evaluateAST","ast","repl","fRepl","sync","setGlobals","appendGlobals","setStartup","setStartupAST","appendStartup","appendStartupAST","install","installer","SExpressionAsync","then","stat","execSync","S","$car","$$first","$cdr","$cons","$$firstAndSecond","$first","$second","$$second","$last","$rest","$firstAndSecond","$atom","$eq","$notEq","$list","$__scope","returnMultiple","kv","kvSym","kvName","xSym","xName","$__lambda","fa","$comp$__lambda","compile","$apply","apply","$raise","$pipe","$__let","$__set","path","subst","inprog","last","$boolean","$$boolean","$not","$$not","$__and","prev","curr","$__or","$ambiguousEq","$$ambiguousEq","$ambiguousNotEq","$lt","$le","$gt","$ge","$typeof","tyName","$symbol","$isSymbol","$isNull","$isNil","$isUndefined","$isList","$isString","$isNumber","$isNaN","isNaN","$isFinite","isFinite","$isInteger","isInteger","$toString","$toNumber","assignBlacklist","$objectAssign","includes","$jsonStringify","$jsonParse","$now","Date","now","$datetimeFromIso","dt","getTime","$datetime","year","padStart","$datetimeLc","$datetimeToIsoString","toISOString","$datetimeToComponents","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","getUTCDay","$datetimeToComponentsLc","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTimezoneOffset","getDay","$match","RegExp","$consoleLog","console","log","$consoleError","$consoleTrace","trace","$consoleTime","time","$consoleTimeEnd","timeEnd","$consoleTimeLog","timeLog","operators","st","info","fArgs","aArgs","tempVarSym","keyName","compilationOperators","compilationMacros","POSITIVE_INFINITY","NEGATIVE_INFINITY","EPSILON","MAX_VALUE","MIN_VALUE","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","$bitLShift","$bitSRShift","$bitURShift","$bitNot","$bitAnd","reduce","$bitOr","$bitXor","$add","$sub","$mul","$sup","$div","$mod","$max","Math","$min","$avg","$floor","floor","$ceil","ceil","$round","round","$abs","abs","$sign","sign","Query","data","condition","y","desc","sort","start","groupBy","array","w","first","intermediate","single","filter","query","$length","$trim","$trimHead","trimLeft","$trimTail","trimRight","$replaceAll","$split","$join","$concat","$slice","$top","$tail","$push","$pop","$__at","$reverse","$reverseDestructive","$find","find","$filter","$map","$reduce","$reduceFromTail","reduceRight","$sort","$sortDestructive","$groupEvery","groupEvery","select","$groupBy","$orderBy","orderBy","$where","stop","step","from","$__letAsync","promise","Promise","resolve","reject","$__setAsync","$then","$resolveAll","promises","all","$resolveAny","invert","res","rej","ps","$resolvePipe","lambdas","$resolveFork","resolvers","rejectors","pa","lp","forEach","L","LS","lisp","L_async","LS_async","lisp_async","LM","LM_async","getJsxTagsParams","children","props","styles","styleName","matched","classes","z","cs","fragment","__html","__text","$jsxProps","$jsxStandardTag","jsx","$jsxComponentTag","component","lsxConf","components","jsxFlagment","JsxFragment","LSX","LSX_async","runScriptTags","contentType","codes","document","querySelectorAll","innerHTML","builtinOperators","core","arithmetic","sequence","concurrent","builtinMacros","builtinSymbols"],"mappings":"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","file":"liyad.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"liyad\"] = factory();\n\telse\n\t\troot[\"liyad\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 8);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         MaxEvaluationCountError } from './types';\nimport { globalObj,\n         objConstructor,\n         funConstructor }          from './global-this';\n\n\n\nexport function setEvaluationCount(state: SxParserState) {\n    state.evalCount++;\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\n        throw new MaxEvaluationCountError();\n    }\n}\n\n\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\n    if (args.length < min) {\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\n    }\n    if (max && max < args.length) {\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\n    }\n    return args;\n}\n\n\nexport function checkUnsafeVarNames(name: string, varName: string) {\n    if (varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (objConstructor.hasOwnProperty(varName)) {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'call' || varName === 'arguments' || varName === 'caller') {\n        // NOTE: arguments, caller are not accessible in strict mode\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    return varName;\n}\n\n\nexport function checkUnsafeVarNamesEx(name: string, target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (objConstructor.hasOwnProperty(varName)) {\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            if (con.hasOwnProperty(varName)) {\n                throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n            }\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        if (!target.hasOwnProperty(varName)) {\n            // function's prototypes' members\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\n        }\n    }\n    return varName;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxExternalValue,\n         SxSymbol,\n         SxDottedPair,\n         SxDottedFragment,\n         SxToken,\n         SxScope,\n         CapturedScopes,\n         SxMacroInfo }           from './types';\nimport { isSymbol }              from './ast';\nimport { setEvaluationCount,\n         checkUnsafeVarNamesEx } from './errors';\n\n\n\nexport function toNumber(x: any) {\n    switch (typeof x) {\n    case 'object': case 'symbol': case 'function':\n        return NaN;\n    default:\n        return Number(x);\n    }\n}\n\n\nexport function resolveUnquote(state: SxParserState, r: SxToken[]) {\n    for (let i = 0; i < r.length; i++) {\n        const symUnquote = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.unquote);\n        if (symUnquote) {\n            r = r.slice(0, i).concat([evaluate(state, (r[i] as SxToken[])[1])], r.slice(i + 1));\n        }\n        if (Array.isArray(r[i])) {\n            r = r.slice(0);\n            r[i] = resolveUnquote(state, r[i] as SxToken[]);\n        }\n    }\n    return resolveSplice(state, r);\n}\n\n\nexport function resolveSplice(state: SxParserState, r: SxToken[]) {\n    if (state.config.enableSplice) {\n        for (let i = r.length - 1; i >= 0; i--) {\n            const symSplice = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.splice);\n            if (symSplice) {\n                r = r.slice(0, i).concat((r[i] as SxToken[])[1], r.slice(i + 1));\n            }\n        }\n    }\n    return r;\n}\n\n\nexport function resolveMacro(state: SxParserState, x: SxSymbol, r: SxToken[]) {\n    const macroInfo = state.macroMap.get(x.symbol);\n    let lastErr = null;\n    if (macroInfo) {\n        let m: SxMacroInfo | undefined = macroInfo;\n        const r1 = r.slice(1);\n        while (m) {\n            if (m.formalArgs) {\n                const matchResult = matchMacroArgs(state, x.symbol, m.formalArgs, Boolean(m.lastIsSpread), r1);\n                if (! matchResult.error) {\n                    return {\n                        fn: m.fn(state, x.symbol, matchResult.formalArgs as SxSymbol[]),\n                        actualArgs: r.slice(0, 1).concat(matchResult.actualArgs as SxToken[]),\n                    };\n                }\n                lastErr = matchResult.error;\n                m = m.next;\n            } else {\n                return {\n                    fn: m.fn(state, x.symbol),\n                    actualArgs: r,\n                };\n            }\n        }\n        if (lastErr) {\n            throw new Error(lastErr);\n        }\n    }\n    return false;\n}\n\n\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\n    if (typeof x === 'function') {\n        return x;\n    }\n    const funcInfo = state.funcMap.get(x.symbol);\n    if (funcInfo) {\n        return funcInfo.fn(state, x.symbol);\n    } else {\n        const v = resolveValueSymbol(state, x);\n        if (typeof v === 'function') {\n            return v;\n        }\n        if (state.config.funcSymbolResolverFallback) {\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\n        }\n        if (state.config.raiseOnUnresolvedSymbol) {\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\n        }\n        return x.symbol;\n    }\n}\n\n\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\n    for (let i = state.scopes.length - 1; i > 0; i--) {\n        const localScope: SxScope = state.scopes[i];\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\n            return localScope.scope;\n        }\n        if (localScope.capturedScopes &&\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\n            return localScope.capturedScopes[x.symbol];\n        }\n        if (! localScope.isBlockLocal) {\n            break;\n        }\n    }\n    const globalScope = getGlobalScope(state);\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\n        return globalScope.scope;\n    }\n    return nullIfNotDefined ? null : getScope(state).scope;\n}\n\n\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\n    const scope = resolveValueSymbolScope(state, x, true);\n    if (scope) {\n        return scope[x.symbol];\n    }\n    const symInfo = state.symbolMap.get(x.symbol);\n    if (symInfo) {\n        return symInfo.fn(state, x.symbol);\n    } else {\n        if (state.config.valueSymbolResolverFallback) {\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\n        }\n        if (state.config.raiseOnUnresolvedSymbol) {\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\n        }\n        return x.symbol;\n    }\n}\n\n\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\n    const capturedScopes: CapturedScopes = {};\n    for (const n of names) {\n        const scope = resolveValueSymbolScope(state, n, true);\n        if (scope === null) {\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\n        }\n        checkUnsafeVarNamesEx('collectCapturedVariables', capturedScopes, n.symbol);\n        capturedScopes[n.symbol] = scope;\n    }\n    return capturedScopes;\n}\n\n\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\n    const a: CapturedScopes[] = [];\n    for (let i = state.scopes.length - 1; i > 0; i--) {\n        const localScope: SxScope = state.scopes[i];\n        if (localScope.capturedScopes) {\n            a.unshift(localScope.capturedScopes);\n        }\n        if (! localScope.isBlockLocal) {\n            break;\n        }\n    }\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\n}\n\n\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\n}\n\n\nexport function uninstallScope(state: SxParserState): any {\n    if (state.scopes.length < 2) {\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\n    }\n    return state.scopes.pop();\n}\n\n\nexport function getScope(state: SxParserState) {\n    return state.scopes[state.scopes.length - 1];\n}\n\n\nexport function getGlobalScope(state: SxParserState) {\n    return state.scopes[0];\n}\n\n\nexport function matchMacroArgs(\n        state: SxParserState, macroName: string,\n        formalArgs: SxSymbol[], lastIsSpread: boolean, actualArgs: SxToken[]) {\n\n    formalArgs = formalArgs.slice(0);\n    actualArgs = actualArgs.slice(0);\n    if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\n        return ({ error: `[SX] macro call (${macroName}): Actual args too short: actual ${\n            actualArgs.length} / formal ${formalArgs.length}.` });\n    }\n    for (let i = formalArgs.length - (lastIsSpread ? 2 : 1); i >= 0; i--) {\n        let nm = formalArgs[i].symbol;\n        if (nm.startsWith('!')) {\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1);\n            nm = formalArgs[i].symbol;\n\n            if (! isSymbol(actualArgs[i])) {\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\n            }\n        } else if (nm.startsWith('<') && nm.endsWith('>')) {\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1, -1);\n            nm = formalArgs[i].symbol;\n\n            if (isSymbol(actualArgs[i], nm)) {\n                formalArgs = formalArgs.slice(0, i).concat(formalArgs.slice(i + 1));\n                actualArgs = actualArgs.slice(0, i).concat(actualArgs.slice(i + 1));\n            } else {\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not expected symbol.` });\n            }\n        } else {\n            const tpos = nm.lastIndexOf(':');\n            if (0 < tpos) {\n                const tname = nm.slice(tpos + 1);\n                switch (tname) {\n                case 'number':\n                    if (typeof actualArgs[i] !== 'number') {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not number.` });\n                    }\n                    break;\n                case 'string':\n                    if (typeof actualArgs[i] !== 'string') {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not string.` });\n                    }\n                    break;\n                case 'function':\n                    if (! (Array.isArray(actualArgs[i]) && isSymbol((actualArgs[i] as any)[0]))) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not function.` });\n                    }\n                    break;\n                case 'list':\n                    if (! Array.isArray(actualArgs[i])) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not list.` });\n                    }\n                    break;\n                case 'symbol':\n                    if (! isSymbol(actualArgs[i])) {\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\n                    }\n                    break;\n                case 'any':\n                    break;\n                default:\n                    return ({ error: `[SX] macro call (${macroName}): Formal arg(${i}: ${nm}) is unknown type ${tname}.` });\n                }\n                formalArgs[i].symbol = formalArgs[i].symbol.slice(0, tpos);\n            }\n        }\n    }\n    return ({ formalArgs, actualArgs });\n}\n\n\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //    formalArgs: 'sym1 ... 'symN\n    //        fnBody: 'expr1 ... 'exprN\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\n        const front = fnBody.slice(0, fnBody.length - 1);\n        const tail = fnBody[fnBody.length - 1];\n        if (tail && (typeof tail[0] === 'object') && tail[0].symbol === state.config.reservedNames.if) {\n            // S expression: ($if cond t-expr f-expr)\n            if (Array.isArray(tail[3]) && (typeof tail[3][0] === 'object') && tail[3][0].symbol === state.config.reservedNames.self) {\n                // S expression (recursive):\n                //     (                                 ;; fnBody\n                //         expr1 ... exprN-1             ;; front\n                //         ($if cond                     ;; tail[0] [1]\n                //             t-expr                    ;;     [2]\n                //             ($self                    ;;     [3]\n                //                 rArgs1 ... rArgsN) )  ;; tail[4] ... [N+4]\n                //     )\n                //\n                //  -> S exp (tail call optimization):\n                //     (                                                                  ;; fnBody\n                //         ($until cond                                                   ;; tail[1]\n                //             ($clisp-let (tempsym1 ... tempsymN)                        ;;\n                //                 expr1 ... exprN-1                                      ;; front\n                //                 ($set tempsym1   rArgs1) ... ($set tempsymN   rArgsN)  ;; tail[4] ... [N+4]\n                //                 ($set     sym1 tempsym1) ... ($set     symN tempsymN)  ;;\n                //             )                                                          ;;\n                //         )                                                              ;;\n                //         expr1 ... exprN-1                                              ;; front\n                //         t-expr                                                         ;; tail[2]\n                //     )\n\n                const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\n                const tempVarsSyms = formalArgs.map((a, idx) => ({symbol: `${varBaseName}_$i${idx}_${a.symbol}`}));\n\n                return [\n                    [{symbol: state.config.reservedNames.until}, tail[1],\n                        [{symbol: state.config.reservedNames.let}, [...tempVarsSyms],\n                            ...front,\n                            ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\n                                [{symbol: state.config.reservedNames.set}, tempVarsSyms[idx], x])),\n                            ...(tempVarsSyms.map((x, idx) =>\n                                [{symbol: state.config.reservedNames.set}, formalArgs[idx], x])),\n                        ],\n                    ],\n                    ...front,\n                    tail[2],\n                ];\n            }\n        }\n    }\n    return fnBody;\n}\n\n\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\n    setEvaluationCount(state);\n\n    if (x === null || x === void 0) {\n        return x;\n    }\n    let r: SxToken = x;\n\n    for (;;) {\n        if (Array.isArray(r)) {\n            if (r.length === 0) {\n                return r;\n            }\n            r = resolveSplice(state, r);\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                const m = resolveMacro(state, sym, r);\n                if (m) {\n                    r = m.fn(m.actualArgs as SxToken[]);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        setEvaluationCount(state);\n    }\n\n    if (Array.isArray(r)) {\n        r = r.slice(0);\n        if (0 < r.length) {\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                if (sym.symbol === state.config.reservedNames.quote) {\n                    return r.slice(1, 2)[0];\n                }\n                if (sym.symbol === state.config.reservedNames.backquote) {\n                    r = r.slice(1, 2)[0];\n                    if (Array.isArray(r)) {\n                        r = resolveUnquote(state, r);\n                    }\n                    return r;\n                }\n                if (sym.symbol === state.config.reservedNames.eval) {\n                    return evaluate(state, evaluate(state, r.slice(1, 2)[0]));\n                }\n            }\n\n            const sprs = [];\n            for (let i = 1; i < r.length; i++) {\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\n                if (symSpr) {\n                    sprs.push(i);\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\n                    r[i] = Array.isArray(a) ? a : [a];\n                } else {\n                    r[i] = evaluate(state, r[i]);\n                }\n            }\n            for (const i of sprs.reverse()) {\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\n            }\n\n            let fn: any;\n            if (typeof r[0] === 'function') {\n                fn = r[0];\n            } else if (sym) {\n                fn = resolveFunctionSymbol(state, sym);\n            } else {\n                fn = evaluate(state, r[0]);\n            }\n\n            if (typeof fn === 'function') {\n                r = (fn as any)(...(r.slice(1)));\n            } else {\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\n            }\n        }\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\n        r = (r as SxExternalValue).value;\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\n        r = resolveValueSymbol(state, r as SxSymbol);\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\n        const car = evaluate(state, (r as SxDottedPair).car);\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\n        if (Array.isArray(cdr)) {\n            const a = (cdr as any[]).slice(0);\n            a.unshift(car);\n            r = a;\n        } else {\n            r = { car, cdr };\n        }\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\n        r = [\n            evaluate(state, (r as SxDottedFragment).dotted),\n        ];\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\n        r = [];\n    }\n\n    return r;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol }     from './types';\n\n\n\nexport function quote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.quote}, x];\n}\n\n\nexport function isQuoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.quote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function backquote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.backquote}, x];\n}\n\n\nexport function isBackquoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.backquote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function wrapByUnquote(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.unquote}, x];\n}\n\n\nexport function isUnquoted(state: SxParserState, x: any) {\n    if (Array.isArray(x) && 0 < x.length) {\n        const q = isSymbol(x);\n        if (q && q.symbol === state.config.reservedNames.unquote) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function spread(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.spread}, x];\n}\n\n\nexport function splice(state: SxParserState, x: any) {\n    return [{symbol: state.config.reservedNames.splice}, x];\n}\n\n\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\n        if (name !== void 0) {\n            return x.symbol === name ? x : null;\n        } else {\n            return x;\n        }\n    }\n    return null;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxToken }             from '../types';\nimport { isSymbol }            from '../ast';\nimport { resolveSplice,\n         resolveMacro,\n         resolveValueSymbol,\n         getScope }            from '../evaluate';\nimport { setEvaluationCount,\n         checkUnsafeVarNamesEx,\n         checkUnsafeVarNames } from '../errors';\n\n\n\nexport function applyMacros(state: SxParserState, tok: SxToken) {\n    let r: SxToken = tok;\n    for (;;) {\n        if (Array.isArray(r)) {\n            if (r.length === 0) {\n                break;\n            }\n            r = resolveSplice(state, r);\n            const sym = isSymbol(r[0]);\n            if (sym) {\n                const m = resolveMacro(state, sym, r);\n                if (m) {\n                    r = m.fn(m.actualArgs as SxToken[]);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n        setEvaluationCount(state);\n    }\n    return r;\n}\n\n\nexport function stripQuote(state: SxParserState, tok: SxToken) {\n    if (! (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote))) {\n        throw new Error(`[SX] stripQuote: token is not quoted.`);\n    }\n    return (tok as any)[1];\n}\n\n\nexport function stripQuoteOrPass(state: SxParserState, tok: SxToken) {\n    if (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote)) {\n        return (tok as any)[1];\n    } else {\n        return tok;\n    }\n}\n\n\nexport function getScope_stateApplied(state: SxParserState) {\n    return (function() { return getScope(state); });\n}\n\n\nexport function resolveValueSymbol_dynamic(state: SxParserState, varName: string) {\n    checkUnsafeVarNames('(compiler)resolveValueSymbol_dynamic', varName);\n    return (function(){ return resolveValueSymbol(state, {symbol: varName}); });\n}\n\nexport function checkUnsafeVarNames_dynamic(name: string) {\n    return (function(varName: string){ return checkUnsafeVarNames(name, varName); });\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport type SxMacro = (state: SxParserState, name: string, formalArgs?: SxSymbol[]) => (list: SxToken[]) => SxToken;\n\nexport interface SxMacroInfo {\n    name: string;\n    fn: SxMacro;\n\n    formalArgs?: SxSymbol[];\n    lastIsSpread?: boolean;\n    next?: SxMacroInfo;\n}\n\n\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\n\nexport interface SxFuncInfo {\n    name: string;\n    fn: SxFunc;\n\n    // TODO: overloading\n    // formalArgs?: SxSymbol[];\n    // lastIsSpread?: boolean;\n    // next?: SxFuncInfo;\n}\n\n\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\n\nexport interface SxSymbolInfo {\n    name: string;\n    fn: SxSymbolResolver;\n}\n\n\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\n\nexport interface SxScope {\n    isBlockLocal: boolean;\n    scope: any;           // { [s: string]: any; };\n    capturedScopes?: CapturedScopes;\n}\n\n\nexport interface SxReservedNames {\n    eval: string;\n    quote: string;\n    backquote: string;\n    unquote: string;\n    spread: string;\n    splice: string;\n\n    car: string;\n    cdr: string;\n    cons: string;\n    atom: string;\n    eq: string;\n    list: string;\n\n    let: string;\n    lambda: string;\n    self: string;\n    defun: string;\n    thiz: string;\n\n    if: string;\n    cond: string;\n\n    while: string;\n    doWhile: string;\n    until: string;\n    doUntil: string;\n\n    get: string;\n    defvar: string;\n    setq: string;\n    set: string;\n    call: string;\n\n    not: string;\n    and: string;\n    or: string;\n\n    isSymbol: string;\n    gensym: string;\n    raise: string;\n    catch: string;\n\n    Template: string;\n}\n\nexport interface SxParserConfig {\n    raiseOnUnresolvedSymbol: boolean;\n    enableEvaluate: boolean;\n    enableHereDoc: boolean;\n    enableSpread: boolean;\n    enableSplice: boolean;\n    enableShorthands: boolean;\n    enableVerbatimStringLiteral: boolean;\n    enableTailCallOptimization: boolean;\n    enableRegExpMatchOperators: boolean; // IMPORTANT: Turn off to prevent ReDoS when executing untrusted code\n    enableCompilationOperators: boolean; // IMPORTANT: Turn off to prevent DoS when executing untrusted code\n    stripComments: boolean;\n    wrapExternalValue: boolean;\n    reservedNames: SxReservedNames;\n    returnMultipleRoot: boolean;\n    maxEvalCount: number;                // IMPORTANT: Set positive value to prevent DoS when executing untrusted code\n\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\n    JsxFragment?: any;\n\n    funcs: SxFuncInfo[];\n    macros: SxMacroInfo[];\n    symbols: SxSymbolInfo[];\n\n    funcSymbolResolverFallback?: SxFunc;\n    valueSymbolResolverFallback?: SxSymbolResolver;\n}\n\nexport interface SxParserState {\n    strings: TemplateStringsArray | string[];\n    values: any[];\n\n    index: number;\n    pos: number;\n    line: number;\n\n    evalCount: number;\n\n    scopes: SxScope[];\n\n    macroMap: Map<string, SxMacroInfo>;\n    funcMap: Map<string, SxFuncInfo>;\n    symbolMap: Map<string, SxSymbolInfo>;\n\n    config: SxParserConfig;\n}\n\nexport interface SxEof {\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\n    eofSeq?: string;\n}\n\nexport interface SxExternalValue {\n    value: any;\n}\n\nexport interface SxSymbol {\n    'symbol': string;\n\n    // TODO: debug info\n    // _fileName?: string;\n    // _line?: number;\n    // _col?: number;\n}\n\nexport interface SxComment {\n    comment: string;\n}\n\nexport interface SxDottedPair {\n    car: SxToken; // left\n    cdr: SxToken; // right\n}\n\nexport interface SxDottedFragment {\n    dotted: SxToken; // right\n}\n\n\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\nexport type SxChar = string | SxEof | SxExternalValue;\nexport type SxAtom = SxSymbol | string | number | boolean | null;\nexport type SxList = SxDottedPair | SxAtom[];\n\n\n\nexport type CompilerOperator = (r: SxToken[], args: SxToken[]) => string;\n\n\nexport interface CompilerContext {\n    _$_vars: any[];\n    varsCount: number;\n    varNames: Map<string, string>;\n    varNamesCount: number;\n    varDefs: string;\n    ops: Map<string, CompilerOperator>;\n    makeScope: (scoped: () => void) => void;\n    compileToken: (body: any[], i: number) => string;\n}\n\n\nexport interface LsxConfig {\n    jsx: (comp: any, props: any, ...children: any[]) => any;\n    jsxFlagment: any;\n    components: object;\n}\n\n\nexport class FatalError extends Error {\n    public constructor(message?: string | undefined) {\n        super(message);\n    }\n}\n\n\nexport class MaxEvaluationCountError extends FatalError {\n    public constructor() {\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\n    }\n}\n\n\nexport class ScriptTerminationError extends FatalError {\n    public constructor(where: string) {\n        super(`[SX] ${where}: Unexpected termination of script.`);\n    }\n}\n\n\nexport interface SExpressionRepl<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => R;\n}\n\n\nexport interface SExpressionTemplateFn<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\n    evaluateAST: (ast: SxToken[]) => R;\n    repl: () => SExpressionRepl<R>;\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\n}\n\n\nexport interface SExpressionAsyncRepl<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\n}\n\n\nexport interface SExpressionAsyncTemplateFn<R = SxToken> {\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\n    repl: () => SExpressionAsyncRepl<R>;\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable: no-shadowed-variable\n// tslint:disable: function-constructor\n\n\nexport const dummyTargetObject = {};\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const { g: globalObj, o: objConstructor, f: funConstructor } = (() => {\n    let globalObj = null;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-implied-eval\n        globalObj = Function('return this')();\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! globalObj) {\n        // Fall back (for CSP, etc...)\n        if (typeof window === 'object' && window) {\n            globalObj = window;\n        } else if (typeof global === 'object' && global) {\n            globalObj = global;\n        } else if (typeof globalThis === 'object' && globalThis) {\n            globalObj = globalThis;\n        } else {\n            globalObj = dummyTargetObject;\n        }\n    }\n\n    // NOTE: ({}).constructor === Object\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let objConstructor: ObjectConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = (({}).constructor ?? Object) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! objConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = dummyTargetObject as any;\n    }\n\n    // NOTE: ({}).toString.constructor === Function\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let funConstructor: FunctionConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = (({}).toString.constructor ?? Function) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! funConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = dummyTargetObject as any;\n    }\n\n    return ({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        g: globalObj, o: objConstructor, f: funConstructor\n    });\n})();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         SxFuncInfo,\n         CompilerOperator,\n         CompilerContext  }           from './types';\nimport { isSymbol }                   from './ast';\nimport { getCapturedScopes,\n         optimizeTailCall }           from './evaluate';\nimport { checkUnsafeVarNamesEx }      from './errors';\nimport { applyMacros,\n         stripQuoteOrPass,\n         resolveValueSymbol_dynamic } from './compile.ops/helpers';\nimport { registerOperators }          from './compile.ops';\n\n\n\n// tslint:disable-next-line:variable-name\nfunction compileCore(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[], _$_vars: any[]) {\n\n    function makeScope(scoped: () => void) {\n        const varNamesCopy = new Map<string, string>();\n        for (const x of ctx.varNames.entries()) {\n            varNamesCopy.set(x[0], x[1]);\n        }\n        scoped();\n        ctx.varNames = varNamesCopy;\n    }\n\n\n    function compileValue(b: any) {\n        let compFnBody = '';\n        if (b === null) {\n            compFnBody += '(null)';\n        } else if (b === void 0) {\n            compFnBody += '(void 0)';\n        } else switch (typeof b) {\n        case 'boolean': case 'number':\n            compFnBody += `(${String(b)})`;\n            break;\n        case 'object':\n            if (isSymbol(b)) {\n                const sym = b as SxSymbol;\n                checkUnsafeVarNamesEx('(compiler)compileValue', ctx.varNames, sym.symbol);\n                if (ctx.varNames.has(sym.symbol)) {\n                    compFnBody += `(${ctx.varNames.get(sym.symbol)})`;\n                } else {\n                    _$_vars[ctx.varsCount] = sym.symbol;\n                    compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n                }\n                break;\n            } else {}\n            // FALL_THRU\n        default:\n            _$_vars[ctx.varsCount] = b;\n            compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n            break;\n        }\n        return compFnBody;\n    }\n\n\n    function compileToken(body: any[], i: number) {\n        let compFnBody = '';\n        const b = body[i];\n        if (Array.isArray(b)) {\n            if (0 < b.length) {\n                const r: SxToken = applyMacros(state, b);\n                if (Array.isArray(r)) {\n                    if (0 < r.length) {\n                        if (isSymbol(r[0])) {\n                            const sym = r[0] as SxSymbol;\n                            const args = r.slice(1);\n                            checkUnsafeVarNamesEx('(compiler)compileToken', ops, sym.symbol);\n                            if (ops.has(sym.symbol)) {\n                                compFnBody += (ops.get(sym.symbol) as CompilerOperator)(r, args);\n                            } else {\n                                if (sym.symbol === state.config.reservedNames.spread) {\n                                    compFnBody += `...(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\n                                } else if (state.funcMap.has(sym.symbol)) {\n                                    _$_vars[ctx.varsCount] = (state.funcMap.get(sym.symbol) as SxFuncInfo).fn(state, '');\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                } else if (ctx.varNames.has(sym.symbol)) {\n                                    compFnBody += `(${String(ctx.varNames.get(sym.symbol))})(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\n                                } else {\n                                    _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, sym.symbol);\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])()(${\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                }\n                            }\n                        } else {\n                            switch (typeof r[0]) {\n                            case 'function':\n                                _$_vars[ctx.varsCount] = r[0];\n                                compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\n                                    r.slice(1).map((x, idx, arr) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n                                break;\n                            default:\n                                throw new Error(`[SX] compileToken: First item of list is not a function: ${JSON.stringify(r[0])}.`);\n                            }\n                        }\n                    } else {\n                        compFnBody += '([])';\n                    }\n                } else {\n                    compFnBody += compileValue(b);\n                }\n            } else {\n                compFnBody += '([])';\n            }\n        } else {\n            compFnBody += compileValue(b);\n        }\n        return compFnBody;\n    }\n\n\n    const ctx: CompilerContext = {\n        _$_vars,\n        varsCount: 1,\n        varNames: new Map<string, string>(),\n        varNamesCount: 0,\n        varDefs: 'var x0;',\n        ops: new Map<string, CompilerOperator>(),\n        makeScope,\n        compileToken,\n    };\n\n    registerOperators(state, ctx);\n    const ops = ctx.ops;\n\n    if (state.config.enableTailCallOptimization) {\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\n    }\n\n    // set 'this' object\n    ctx.varNames.set(state.config.reservedNames.thiz, `(this===(Function('return this')())?null:(this===void 0?null:this))`);\n\n    const capturedScopes = getCapturedScopes(state);\n    if (capturedScopes) {\n        for (const x in capturedScopes) {\n            if (Object.prototype.hasOwnProperty.call(capturedScopes, x)) {\n                _$_vars[ctx.varsCount++] = x;\n                _$_vars[ctx.varsCount] = capturedScopes[x];\n                ctx.varNames.set(x, `(_$_vars[${String(ctx.varsCount)}][_$_vars[${String(ctx.varsCount - 1)}]])`);\n                ctx.varsCount++;\n            }\n        }\n    }\n\n    const compFormalArgs = `${formalArgs.map((x, i) => {\n        ctx.varNames.set(formalArgs[i].symbol, 'a' + i);\n        return `${(lastIsSpread && i === formalArgs.length - 1) ? '...' : ''}a${i}`;\n    }).join(',')}`;\n\n    const compFnBodyRoot = `return(${fnBody.map((x, i) => compileToken(fnBody, i)).join(',')})`;\n    return `(function(${compFormalArgs}){\"strict\";${ctx.varDefs}${compFnBodyRoot}})`;\n}\n\n\n// tslint:disable-next-line:variable-name\nfunction evalCompiledLambda(_$_state: SxParserState, _$_vars: any[], code: string) {\n    // tslint:disable-next-line:no-eval\n    _$_vars[0] = eval(code);\n    return _$_vars[0];\n}\n\n\nexport function compileLambda(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[]) {\n    // tslint:disable-next-line:variable-name\n    const _$_vars: any[] = [];\n    return evalCompiledLambda(state, _$_vars, compileCore(state, formalArgs, lastIsSpread, fnBody, _$_vars));\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         CompilerContext }             from '../types';\nimport { isSymbol }                    from '../ast';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx,\n         checkUnsafeVarNames }         from '../errors';\nimport { stripQuote,\n         stripQuoteOrPass,\n         getScope_stateApplied,\n         resolveValueSymbol_dynamic,\n         checkUnsafeVarNames_dynamic } from './helpers';\n\n\n\nexport function registerOperators(state: SxParserState, ctx: CompilerContext) {\n    const {\n        _$_vars,\n        ops,\n        makeScope,\n        compileToken,\n    } = ctx;\n\n\n    ops.set(state.config.reservedNames.quote, function(r: SxToken[], args: SxToken[]) {\n        let compFnBody = '';\n        _$_vars[ctx.varsCount] = r[1];\n        compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.self, function(r: SxToken[], args: SxToken[]) {\n        let compFnBody = '';\n        compFnBody += `((_$_vars[0])(${\n            args.map(x => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__if', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__if condition 't-expr 'f-expr)\n        //  -> (if condition is true ) S expr  : t-expr\n        //  -> (if condition is false) S expr  : f-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__if', args, 2, 3);\n        compFnBody += `(${compileToken(r, 1)}?(${\n            compileToken([stripQuote(state, r[2])], 0)}):(${\n            compileToken([stripQuote(state, r[3])], 0)}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__if-null', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__if-null condition 'null-expr)\n        //  -> (if condition is not null ) S expr  : condition\n        //  -> (if condition is null)      S expr  : null-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__if-null', args, 2, 2);\n        compFnBody += `((()=>{let _$_rv=${compileToken(r, 1)};return _$_rv?_$_rv:(${\n            compileToken([stripQuote(state, r[2])], 0)}});})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__cond', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n        //  -> (if (eval condI) is true ) S expr  : exprI\n        //  -> (if no matched)            S expr  : null\n        let compFnBody = '';\n        {\n            checkParamsLength('compileToken:$__cond', args, 1);\n            compFnBody += `(`;\n            for (let p = 0; p < args.length; p += 2) {\n                compFnBody += `${compileToken([stripQuote(state, args[p])], 0)}?(${\n                    compileToken([stripQuote(state, args[p + 1])], 0)}):(`;\n            }\n            compFnBody += `null`;\n            for (let p = 0; p < args.length; p += 2) {\n                compFnBody += `)`;\n            }\n            compFnBody += `)`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('$__while', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__while 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__while', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;while(${\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n            }}return _$_rv})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__do-while', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__do-until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(${\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__until', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__until 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;while(!${\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n            }}return _$_rv})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__do-until', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\n        //  -> (else)                                          S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__do-until', args, 1);\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(!${\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__repeat', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\n        //  -> (if n > 0) S expr  : exprN\n        //  -> (else)     S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__repeat', args, 2);\n        if (! isSymbol(args[0])) {\n            throw new Error(`[SX] compileToken: $__repeat : args[0] is not symbol.`);\n        }\n        makeScope(() => {\n            const name = 'v' + ctx.varNamesCount++;\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\n            compFnBody += `(((_$_n)=>{let _$_rv=null;for(let ${name}=0;${name}<_$_n;${name}++){_$_rv=${\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n                }}return _$_rv})(${compileToken(args, 1)}))`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__for', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__for 'x list 'expr1 ... 'exprN)\n        //  -> (if list.length > 0) S expr  : exprN\n        //  -> (else)               S expr  : null\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__for', args, 2);\n        if (! isSymbol(args[0])) {\n            throw new Error(`[SX] compileToken: $__for : args[0] is not symbol.`);\n        }\n        makeScope(() => {\n            const name = 'v' + ctx.varNamesCount++;\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\n            compFnBody += `(((_$_l)=>{let _$_rv=null;for(const ${name} of _$_l){_$_rv=${\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\n                }}return _$_rv})(${compileToken(args, 1)}))`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__scope', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\n        //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n        //  -> (else)               S expr  : exprN\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__scope', args, 2);\n        // r[1]: isBlockLocal\n        // r[2]: returnMultiple\n        if (! Array.isArray(r[3])) {\n            throw new Error(`[SX] compileToken: $__scope : args[2] is not array.`);\n        }\n        makeScope(() => {\n            for (const x of stripQuote(state, r[3]) as any[]) {\n                let name = '';\n                if (Array.isArray(x)) {\n                    if (x.length < 1) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is too short.`);\n                    }\n                    if (! isSymbol(x[0])) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?][0] is not symbol.`);\n                    }\n                    name = x[0].symbol;\n                    compFnBody += `(${'v' + ctx.varNamesCount}=${compileToken(x, 1)})`;\n                } else {\n                    if (! isSymbol(x)) {\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is not symbol.`);\n                    }\n                    name = x.symbol;\n                }\n                ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\n                ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\n            }\n            const s = `${r.slice(4).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}`;\n            compFnBody += r[2] ? `[${s}]` : `(${s})`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set('$__try', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__try 'expr 'catch-expr)\n        //  ->                               S expr  : expr\n        //  -> (if error is raised in expr)  S expr  : catch-expr\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__try', args, 1, 2);\n        compFnBody += `((()=>{try{${\n            compileToken([stripQuote(state, r[1])], 0)}}catch(e${\n            ctx.varNamesCount}){let e${ctx.varNamesCount + 1}=(_$_vars[${String(ctx.varsCount)}])();`;\n        _$_vars[ctx.varsCount++] = getScope_stateApplied(state);\n        makeScope(() => {\n            ctx.varNames.set('$error', 'e' + ctx.varNamesCount++);\n            ctx.varNames.set('$parent', 'e' + ctx.varNamesCount++);\n            compFnBody += `${\n                compileToken([stripQuote(state, r[2])], 0)}}})())`;\n        });\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.raise, function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($raise 'expr)\n        //  -> S expr  : -\n        let compFnBody = '';\n        compFnBody += `((()=>{throw ${\n            compileToken([stripQuoteOrPass(state, r[1])], 0)}})())`;\n        return compFnBody;\n    });\n\n\n    ops.set('$boolean', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($boolean any)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:$boolean', args, 1, 1);\n        compFnBody += `((x0=${compileToken(args, 0)\n            }),(Array.isArray(x0)&&x0.length===0?false:boolean(x0)))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__get', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__get', args, 1);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__get : operand is not symbol: ${JSON.stringify(r[1])}.`);\n        }\n        let vName = '';\n        if (ctx.varNames.has(name)) {\n            vName = ctx.varNames.get(name) as string;\n        } else {\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\n        }\n        const regToVars = (symName: string) => {\n            _$_vars[ctx.varsCount] = symName;\n            return `_$_vars[${String(ctx.varsCount++)}]`;\n        };\n        compFnBody += `((${vName})${r.slice(2).map((x, idx, arr) => `[${\n            isSymbol(arr[idx]) ?\n                regToVars((arr as any)[idx].symbol) :\n                compileToken(arr, idx)}]`).join('')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__let', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__let 'nameStrOrSymbol expr)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__let', args, 2, 2);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__let : operand is not rvalue: ${JSON.stringify(r[1])}.`);\n        }\n        if (! ctx.varNames.has(name)) {\n            ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\n            ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\n        }\n        compFnBody += `(${ctx.varNames.get(name)}=${compileToken(r, 2)})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__set', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__set 'nameOrListOfNameOrIndex expr)\n        //  -> S expr  : any\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__set', args, 2);\n        const quoted = stripQuote(state, r[1]);\n        const name = isSymbol(quoted) ?\n            quoted.symbol :\n            (typeof quoted === 'string' ?\n                quoted :\n                (Array.isArray(quoted) ?\n                    (isSymbol(quoted[0]) ?\n                        quoted[0].symbol :\n                        (typeof quoted[0] === 'string' ? quoted[0] : null)\n                    ) :\n                    null\n                )\n            );\n        if (typeof name !== 'string') {\n            throw new Error(`[SX] compileToken: $__set : operand is not rvalue: ${JSON.stringify(r[1])}.`);\n        }\n        let vName = '';\n        if (ctx.varNames.has(name)) {\n            vName = ctx.varNames.get(name) as string;\n        } else {\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\n        }\n        const regToVars = (symName: string) => {\n            _$_vars[ctx.varsCount] = checkUnsafeVarNames('compileToken:$__set', symName);\n            return `_$_vars[${String(ctx.varsCount++)}]`;\n        };\n        let checkNameCalled = false;\n        let checkNamePos = '';\n        const checkName = (str: string) => {\n            if (! checkNameCalled) {\n                _$_vars[ctx.varsCount] = checkUnsafeVarNames_dynamic('compileToken:$__set');\n                checkNamePos = String(ctx.varsCount++);\n                checkNameCalled = true;\n            }\n            return `(_$_vars[${checkNamePos}](${str}))`;\n        };\n        compFnBody += `((${vName})${(Array.isArray(quoted) ? quoted.slice(1) : []).map((x, idx, arr) => `[${\n            isSymbol(arr[idx]) ?\n                regToVars((arr as any)[idx].symbol) :\n                checkName(compileToken(arr, idx))}]`).join('')}=${compileToken(r, 2)})`;\n        return compFnBody;\n    });\n\n\n    ops.set(state.config.reservedNames.not, function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($not any)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:$not', args, 1, 1);\n        compFnBody += `(!${compileToken(args, 0)})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__and', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__and 'expr1 ... 'exprN)\n        //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\n        //  -> (else)                                                     S expr  : expr-i (false left most)\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__and', args, 1);\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('&&')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$__or', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($__or 'expr1 ... 'exprN)\n        //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\n        //  -> (else)                                                  S expr  : expr-i (false right most)\n        let compFnBody = '';\n        checkParamsLength('compileToken:$__or', args, 1);\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('||')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('===', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($eq arg1 arg2)\n        //  -> (if arg1 === arg2)  S expr  : true\n        //  -> (else)              S expr  : false\n        let compFnBody = '';\n        checkParamsLength('compileToken:===', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('===')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('!==', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($not-eq arg1 arg2)\n        //  -> (if arg1 !== arg2)  S expr  : true\n        //  -> (else)              S expr  : false\n        let compFnBody = '';\n        checkParamsLength('compileToken:!==', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!==')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('==', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (== a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:==', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('==')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('!=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (!= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:!=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('<', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (< a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('<=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (<= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (> a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>=', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>= a b)\n        //  -> S expr  : boolean\n        let compFnBody = '';\n        checkParamsLength('compileToken:<=', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>=')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$concat', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($concat listOrString1 ... listOrStringN)\n        //  -> S expr  : listOrString\n        let compFnBody = '';\n        checkParamsLength('compileToken:$concat', args, 1);\n        let w1 = '';\n        if (Array.isArray(args[0]) && isSymbol((args[0] as any)[0], state.config.reservedNames.spread)) {\n            const w0 = compileToken(args[0] as any, 1);\n            w1 = `(${w0}[0]).concat((${w0}.length>1?${w0}[1]:(typeof ${w0}[0]==='string'?'':[])),`;\n        } else {\n            w1 = `${compileToken(args as any, 0)}.concat(`;\n        }\n        compFnBody += `(${w1}${\n            args.slice(1).map((x, idx, arr) => compileToken(arr, idx)).join(',')}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('+', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (+ number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:+', args, 1);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n            };return _$_rv.reduce((x,y)=>x+y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('+')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('-', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (- number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:-', args, 1);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return (_$_rv.length>1?(_$_rv.reduce((x,y)=>x-y)):(_$_rv.length>0?-_$_rv[0]:NaN));})())`;\n        } else {\n            compFnBody += `(${r.length > 2 ?\n                args.map((x, idx, arr) => compileToken(arr, idx)).join('-') :\n                `-(${String(compileToken(r, 1))})`})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('*', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (* number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:*', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x*y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('*')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('**', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (** number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:**', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x**y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('**')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('/', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (/ number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:/', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x/y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('/')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('%', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (% number1 ... numberN)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:%', args, 2);\n\n        let hasSpread = false;\n        args.map((x, idx, arr) => {\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\n                hasSpread = true;\n            }\n        });\n        if (hasSpread) {\n            compFnBody += `((()=>{let _$_rv=[];${\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\n                };return _$_rv.reduce((x,y)=>x%y);})())`;\n        } else {\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('%')})`;\n        }\n        return compFnBody;\n    });\n\n\n    ops.set('<<', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (<< number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:<<', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<<')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>> number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:>>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('>>>', function(r: SxToken[], args: SxToken[]) {\n        // S expression: (>>> number shift)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:>>>', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>>')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-not', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-not number)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-not', args, 1, 1);\n        compFnBody += `(~(${compileToken(r, 1)}))`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-and', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-and numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-and', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('&')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-or', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-or numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-or', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('|')})`;\n        return compFnBody;\n    });\n\n\n    ops.set('$bit-xor', function(r: SxToken[], args: SxToken[]) {\n        // S expression: ($bit-xor numberA numberB)\n        //  -> S expr  : number\n        let compFnBody = '';\n        checkParamsLength('compileToken:$bit-xor', args, 2, 2);\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('^')})`;\n        return compFnBody;\n    });\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxReservedNames,\n         SxParserConfig } from './types';\n\n\n\nexport const defaultReservedNames: SxReservedNames = {\n    eval: '$eval',\n    quote: '$quote',\n    backquote: '$backquote',\n    unquote: '$unquote',\n    spread: '$spread',\n    splice: '$splice',\n\n    car: '$car',\n    cdr: '$cdr',\n    cons: '$cons',\n    atom: '$atom',\n    eq: '$eq',\n    list: '$list',\n\n    let: '$clisp-let',\n    lambda: '$lambda',\n    self: '$self',\n    defun: '$defun',\n    thiz: '$this',\n\n    if: '$if',\n    cond: '$cond',\n\n    while: '$while',\n    doWhile: '$do-while',\n    until: '$until',\n    doUntil: '$do-until',\n\n    get: '$get',\n    defvar: '$clisp-defvar',\n    setq: '$clisp-setq',\n    set: '$set',\n    call: '$call',\n\n    not: '$not',\n    and: '$and',\n    or: '$or',\n\n    isSymbol: '$is-symbol',\n    gensym: '$gensym',\n    raise: '$raise',\n    catch: '$catch',\n\n    Template: 'Template',\n};\n\nexport const defaultConfig: SxParserConfig = {\n    raiseOnUnresolvedSymbol: false,\n    enableEvaluate: true,\n    enableHereDoc: true,\n    enableSpread: true,\n    enableSplice: true,\n    enableShorthands: true,\n    enableVerbatimStringLiteral: true,\n    enableTailCallOptimization: true,\n    enableRegExpMatchOperators: true,\n    enableCompilationOperators: true,\n    stripComments: false,\n    wrapExternalValue: true,\n    returnMultipleRoot: false,\n    maxEvalCount: 0,\n\n    reservedNames: defaultReservedNames,\n    symbols: [],\n    macros: [],\n    funcs: [],\n};\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxEof,\n         SxExternalValue,\n         SxSymbol,\n         SxDottedFragment,\n         SxComment,\n         SxToken,\n         SxChar,\n         ScriptTerminationError } from './types';\nimport { quote,\n         backquote,\n         wrapByUnquote,\n         spread,\n         splice }                 from './ast';\n\n\n\nfunction isEOF(ch: SxChar): boolean {\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\n}\n\n\nfunction isSpace(ch: SxChar): boolean {\n    return typeof ch === 'string' && ch.trim().length === 0;\n}\n\n\nfunction isNumberFirstChar(ch: SxChar): boolean {\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\n}\n\n\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\n}\n\n\nfunction isSymbolFirstChar(ch: SxChar): boolean {\n    return typeof ch === 'string' &&\n        !isSpace(ch) &&\n        !isNumberFirstChar(ch);\n}\n\n\n\nfunction lookCurrentLineHint(state: SxParserState): string {\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\n        state.strings.length > state.index ?\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\n}\n\n\nfunction getChar(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\n    if (state.strings.length <= state.index) {\n        return {eof: true};\n    }\n    if (state.strings[state.index].length <= state.pos) {\n        if ((! state.values) || (state.values.length <= state.index)) {\n            state.pos = 0;\n            state.index++;\n            return getChar(state);\n        } else {\n            const ch = {value: state.values[state.index]};\n            state.pos = 0;\n            state.index++;\n            return ch;\n        }\n    }\n    if (virtualEof) {\n        for (const v of virtualEof) {\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\n            if (ch === v) {\n                state.pos += v.length;\n                state.line += ch.split('\\n').length - 1;\n                return { eof: false , eofSeq: v };\n            }\n        }\n    }\n    {\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\n        state.pos++;\n\n        if (ch === '\\n') {\n            state.line++;\n        }\n\n        if ((! disableEscape) && ch === '\\\\') {\n            if (state.strings[state.index].length <= state.pos) {\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\n            state.pos++;\n\n            switch (ch) {\n            case 'b':\n                ch = '\\b';\n                break;\n            case 't':\n                ch = '\\t';\n                break;\n            case 'n':\n                ch = '\\n';\n                break;\n            case 'v':\n                ch = '\\v';\n                break;\n            case 'f':\n                ch = '\\f';\n                break;\n            case 'r':\n                ch = '\\r';\n                break;\n            case 'U': case 'u':\n                {\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\n                        let ch1 = '';\n                        for (let i = 0; i < 6; i++) {\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\n                            if (ch2 === '}') {\n                                if (i === 0) {\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                                }\n                                state.pos += i;\n                                break;\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                            }\n                            ch1 += ch2;\n                        }\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        state.pos++;\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\n                    } else {\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        state.pos += 4;\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\n                    }\n                }\n                break;\n            }\n        }\n        return ch;\n    }\n}\n\n\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[], disableEscape?: boolean): SxChar[] {\n    const index = state.index;\n    const pos = state.pos;\n    const line = state.line;\n    const chs: SxChar[] = [];\n\n    try {\n        for (let i = 0; i < n; i++) {\n            chs.push(getChar(state, virtualEof, disableEscape));\n        }\n    } finally {\n        state.index = index;\n        state.pos = pos;\n        state.line = line;\n    }\n\n    return chs;\n}\n\n\nfunction lookAhead(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\n    const index = state.index;\n    const pos = state.pos;\n    const line = state.line;\n    let ch: SxChar;\n\n    try {\n        ch = getChar(state, virtualEof, disableEscape);\n    } finally {\n        state.index = index;\n        state.pos = pos;\n        state.line = line;\n    }\n\n    return ch;\n}\n\n\nfunction skipWhitespaces(state: SxParserState): void {\n    let ch = lookAhead(state);\n    while (!isEOF(ch) && isSpace(ch)) {\n        getChar(state);\n        ch = lookAhead(state);\n    }\n}\n\n\n\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\n    let s = '';\n    let ch = lookAhead(state, virtualEof);\n\n    while (! isEOF(ch)) {\n        if (typeof ch === 'string') {\n            if (/^0[XxOoBb][0-9]*$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else {\n                break;\n            }\n        } else {\n            break;\n        }\n\n        ch = lookAhead(state, virtualEof);\n    }\n\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|(0[XxOoBb][0-9]+)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n    }\n    return Number(s);\n}\n\n\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\n    let s = '';\n    let ch = lookAhead(state, virtualEof);\n\n    while (! isEOF(ch)) {\n        if (typeof ch === 'string') {\n            if (isSpace(ch)) {\n                break;\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\n                break;\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\n                getChar(state, virtualEof);\n                s += ch;\n            } else {\n                break;\n            }\n        } else {\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                getChar(state, virtualEof);\n                const v = (ch as SxExternalValue).value;\n                s += String(ch);\n            } else {\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n        }\n\n        ch = lookAhead(state, virtualEof);\n    }\n\n    if (state.config.enableShorthands) {\n        let m: RegExpMatchArray | null = null;\n        // tslint:disable-next-line:no-conditional-assignment\n        if (m = s.match(/^:((?:\\:[^=:]+?)+?)=$/)) {\n            // ::foo:bar:baz= -> ($splice ($set (foo bar baz)))\n            const ws = m[1].slice(1).split(':');\n            const z =\n                [{symbol: state.config.reservedNames.splice},\n                    [{symbol: state.config.reservedNames.set},\n                        ws\n                    ]\n                ];\n            return z as any;\n        }\n        // tslint:disable-next-line:no-conditional-assignment\n        else if (m = s.match(/^:((?:\\:[^@:]+?)+?)@([^@:]+?)$/)) {\n            // ::foo:bar@baz -> ($splice ($call ($get foo bar) baz))\n            const ws = m[1].slice(1).split(':');\n            const z =\n                [{symbol: state.config.reservedNames.splice},\n                    [{symbol: state.config.reservedNames.call},\n                        [{symbol: state.config.reservedNames.get}, ...ws],\n                        {symbol: m[2]},\n                    ]\n                ];\n            return z as any;\n        }\n        // tslint:disable-next-line:no-conditional-assignment\n        else if (m = s.match(/^:((?:\\:[^:]+?)+?)$/)) {\n            // ::foo:bar:baz -> ($get foo bar baz)\n            const ws = m[1].slice(1).split(':');\n            const z = [{symbol: state.config.reservedNames.get}, ...ws];\n            return z as any;\n        }\n    }\n\n    return {symbol: s};\n}\n\n\nfunction parseStringOrComment(\n        state: SxParserState, eof: string[],\n        valuesStartSeq: string | null,\n        valuesStopChar: string,\n        disableEscape: boolean,\n        allowPhysicalEof: boolean,\n    ): { strings: string[], values: any[] } {\n\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\n    const strings: string[] = [];\n    const values: any[] = [];\n\n    for (;;) {\n        let s = '';\n        let ch = lookAhead(state, eofSeqs, disableEscape);\n\n        while (! isEOF(ch)) {\n            if (typeof ch === 'string') {\n                getChar(state, eofSeqs, disableEscape);\n                s += ch;\n            } else {\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                    getChar(state, eofSeqs, disableEscape);\n                    const v = (ch as SxExternalValue).value;\n                    s += String(ch);\n                } else {\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                }\n            }\n\n            ch = lookAhead(state, eofSeqs, disableEscape);\n        }\n\n        getChar(state, eofSeqs, disableEscape);\n\n        if ((ch as SxEof).eof === true) {\n            if (! allowPhysicalEof) {\n                throw new ScriptTerminationError('parseStringOrComment');\n            }\n        }\n\n        strings.push(s);\n\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\n            values.push(parseList(state, valuesStopChar, []));\n        } else {\n            break;\n        }\n    }\n\n    return { strings, values };\n}\n\n\nfunction parseString(state: SxParserState, disableEscape: boolean): string {\n    return parseStringOrComment(state, ['\"'], null, ')', disableEscape, false).strings[0];\n}\n\n\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\n    const q: SxToken[] = [symbol];\n\n    if (attrs) {\n        q.push(attrs);\n    }\n\n    const inner = parseStringOrComment(state, ['\"\"\"'], '%%%(', ')', false, false);\n    for (let i = 0; i < inner.strings.length; i++) {\n        q.push(inner.strings[i]);\n        if (i < inner.values.length) {\n            q.push(inner.values[i]);\n        }\n    }\n\n    return q;\n}\n\n\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\n    return {\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')', false, true).strings[0]\n    };\n}\n\n\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\n    return {\n        comment: parseStringOrComment(state, ['|#'], null, ')', false, false).strings[0]\n    };\n}\n\n\nfunction parseOneToken(state: SxParserState): SxToken {\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case ')':\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n\n        case '(':\n            getChar(state);\n            return parseList(state, ')', []);\n\n        case \"'\": case \"`\": case ',':\n            {\n                getChar(state);\n                const ahead = lookAhead(state);\n                let isSpliceUnquote = false;\n                if (ch === ',' && ahead === '@') {\n                    getChar(state);\n                    isSpliceUnquote = true;\n                }\n                skipWhitespaces(state);\n                const ret = (ch === \"'\" ?\n                        quote :\n                        (ch === \"`\" ? backquote : wrapByUnquote))\n                    (state, parseOneToken(state)\n                );\n                return (isSpliceUnquote ? splice(state, ret) : ret);\n            }\n\n        case \".\":\n            {\n                getChar(state);\n                const aheads = lookAheads(state, 2);\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\n                    getChar(state);\n                    getChar(state);\n                    skipWhitespaces(state);\n                    return spread(state, parseOneToken(state));\n                } else {\n                    skipWhitespaces(state);\n                    return {dotted: parseOneToken(state)};\n                }\n            }\n\n        case ';':\n            getChar(state);\n            return parseSingleLineComment(state);\n\n        case '#':\n            {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '|') {\n                    getChar(state);\n                    getChar(state);\n                    return parseMultiLineComment(state);\n                } else {\n                    return parseSymbol(state);\n                }\n            }\n\n        case '\"':\n            {\n                getChar(state);\n                const aheads = lookAheads(state, 4);\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\n                    let isHereDoc = true;\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\n                        // here doc\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\n                        if (aheads[2] === '+' || aheads[2] === '-') {\n                            if (! isNumberAfterSignChar(aheads[3])) {\n                                isHereDoc = false;\n                            }\n                        }\n                        // here doc\n                    } else if (isSymbolFirstChar(aheads[2])) {\n                        isHereDoc = false;\n                    } else {\n                        // here doc\n                    }\n                    getChar(state);\n                    getChar(state);\n\n                    let sym: SxSymbol | number | null = null;\n                    let attrs: SxToken[] | null = null;\n                    if (isHereDoc) {\n                        sym = {symbol: state.config.reservedNames.Template};\n                    } else {\n                        sym = parseSymbol(state, ['@']);\n                        if (sym === null) {\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        if (typeof sym === 'number') {\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                        }\n                        const ahs = lookAheads(state, 2);\n                        if (ahs[0] === '@') {\n                            if (ahs[1] !== '{') {\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                            }\n                            getChar(state);\n                            getChar(state);\n                            const a = parseList(state, '}', [{symbol: '@'}]);\n                            if (Array.isArray(a)) {\n                                attrs = a;\n                            }\n                        }\n                    }\n\n                    return parseHereDoc(state, sym, attrs);\n                } else {\n                    return parseString(state, false);\n                }\n            }\n\n        case '@':\n            if (state.config.enableVerbatimStringLiteral) {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '\"') {\n                    getChar(state);\n                    getChar(state);\n                    return parseString(state, true);\n                }\n            }\n            // FALL_THRU\n\n        default:\n            if (typeof ch !== 'string') {\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\n                    getChar(state);\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\n                } else {\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                }\n            } else if (isSpace(ch)) {\n                break;\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\n                if (ch === '+' || ch === '-') {\n                    const aheads = lookAheads(state, 2);\n                    if (! isNumberAfterSignChar(aheads[1])) {\n                        return parseSymbol(state);\n                    }\n                }\n                return parseNumber(state);\n            } else if (isSymbolFirstChar(ch)) {\n                return parseSymbol(state);\n            } else {\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n            }\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    throw new ScriptTerminationError('parseOneToken');\n}\n\n\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\n    const r: SxToken[] = initialList.slice(0);\n    let dotted = false;\n\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case listStopChar:\n            getChar(state);\n            if (dotted) {\n                return r[0];\n            } else {\n                return r;\n            }\n\n        default:\n            {\n                const t = parseOneToken(state);\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\n                    if (r.length !== 1) {\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                    }\n                    dotted = true;\n                    if (Array.isArray(t)) {\n                        t.unshift(r.pop() as SxToken);\n                        r.push(t);\n                    } else {\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\n                    }\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\n                    if (! state.config.stripComments) {\n                        r.push(t);\n                    }\n                } else {\n                    if (dotted) {\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n                    }\n                    r.push(t);\n                }\n            }\n            break;\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    throw new ScriptTerminationError('parseList');\n}\n\n\n\nexport function parse(state: SxParserState) {\n    const r: SxToken[] = [];\n\n    skipWhitespaces(state);\n    let ch = lookAhead(state);\n\n    while (! isEOF(ch)) {\n        switch (ch) {\n        case '(':\n            getChar(state);\n            r.push(parseList(state, ')', []));\n            break;\n\n        case \"'\": case \"`\":\n            {\n                getChar(state);\n                skipWhitespaces(state);\n                for (;;) {\n                    const t = parseOneToken(state);\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\n                        if (! state.config.stripComments) {\n                            r.push(t);\n                        }\n                    } else {\n                        r.push((ch === \"'\" ? quote : backquote)(state, t));\n                        break;\n                    }\n                }\n                break;\n            }\n\n        case ';':\n            getChar(state);\n            if (state.config.stripComments) {\n                parseSingleLineComment(state);\n            } else {\n                r.push(parseSingleLineComment(state));\n            }\n            break;\n\n        case '#':\n            {\n                const aheads = lookAheads(state, 2);\n                if (aheads[1] === '|') {\n                    getChar(state);\n                    getChar(state);\n                    if (state.config.stripComments) {\n                        parseMultiLineComment(state);\n                    } else {\n                        r.push(parseMultiLineComment(state));\n                    }\n                } else {\n                    getChar(state);\n                    if (state.config.stripComments) {\n                        parseSingleLineComment(state);\n                    } else {\n                        r.push(parseSingleLineComment(state));\n                    }\n                }\n            }\n            break;\n\n        case '\"':\n            {\n                const aheads = lookAheads(state, 3);\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\n                    r.push(parseOneToken(state));\n                    break;\n                }\n            }\n            // FALL_THRU\n\n        default:\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\n        }\n\n        skipWhitespaces(state);\n        ch = lookAhead(state);\n    }\n\n    return r;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxFuncInfo,\n         SxSymbolInfo,\n         SxParserConfig,\n         SxParserState,\n         SxToken,\n         SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from '../types';\nimport { parse }                      from '../parser';\nimport { evaluate }                   from '../evaluate';\nimport { defaultConfig }              from '../defaults';\n\n\n\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\n    return {\n        strings: typeof strings === 'string' ? [strings] : strings,\n        values: values || [],\n\n        index: 0,\n        pos: 0,\n        line: 0,\n\n        evalCount: 0,\n\n        scopes: [{isBlockLocal: false, scope: globals}],\n\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\n\n        config,\n    };\n}\n\n\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\n    state.strings = typeof strings === 'string' ? [strings] : strings;\n    state.values = values || [];\n    state.index = 0;\n    state.pos = 0;\n    state.line = 0;\n    state.evalCount = 0;\n    return state;\n}\n\n\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\n    let config = conf || Object.assign({}, defaultConfig);\n    let globalScope: any = {};\n    let startup: SxToken[] = [];\n\n    const exec = (state: SxParserState, s: SxToken[]) => {\n        if (config.enableEvaluate) {\n            for (let i = 0; i < s.length; i++) {\n                s[i] = evaluate(state, s[i]);\n            }\n        }\n\n        if (config.returnMultipleRoot) {\n            return s.length === 1 ? s[0] : s;\n        } else {\n            return s[s.length - 1];\n        }\n    };\n\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        return exec(state, startup.concat(parse(state)));\n    }) as any;\n\n    f.evaluateAST = (ast: SxToken[]) => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        return exec(state, startup.concat(ast));\n    };\n    (f as any).repl = () => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        exec(state, startup.slice(0));\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return exec(state, parse(state));\n        }) as any;\n        (fRepl as any).sync = fRepl;\n        return fRepl;\n    };\n    f.setGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globals || {});\n        return f;\n    };\n    f.appendGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globalScope, globals || {});\n        return f;\n    };\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = parse(state);\n        return f;\n    };\n    f.setStartupAST = (ast: SxToken[]) => {\n        startup = ast;\n        return f;\n    };\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = startup.concat(parse(state));\n        return f;\n    };\n    f.appendStartupAST = (ast: SxToken[]) => {\n        startup = startup.concat(ast);\n        return f;\n    };\n    f.install = (installer) => {\n        config = installer(config);\n        return f;\n    };\n\n    return f;\n}\n\n\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\n    let config = conf || Object.assign({}, defaultConfig);\n    let globalScope: any = {};\n    let startup: SxToken[] = [];\n\n    const exec = async (state: SxParserState, s: SxToken[]) => {\n        if (config.enableEvaluate) {\n            for (let i = 0; i < s.length; i++) {\n                s[i] = evaluate(state, s[i]);\n\n                if (typeof s[i] === 'object' && s[i] !== null && typeof (s[i] as any).then === 'function') {\n                    s[i] = await s[i];\n                }\n            }\n        }\n\n        if (config.returnMultipleRoot) {\n            return s.length === 1 ? s[0] : s;\n        } else {\n            return s[s.length - 1];\n        }\n    };\n\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        return exec(state, startup.concat(parse(state)));\n    }) as any;\n\n    f.evaluateAST = (ast: SxToken[]) => {\n        const state = initState(config, Object.assign({}, globalScope), '');\n        return exec(state, startup.concat(ast));\n    };\n    (f as any).repl = () => {\n        const execSync = (stat: SxParserState, s: SxToken[]) => {\n            if (config.enableEvaluate) {\n                for (let i = 0; i < s.length; i++) {\n                    s[i] = evaluate(stat, s[i]);\n                }\n            }\n\n            if (config.returnMultipleRoot) {\n                return s.length === 1 ? s[0] : s;\n            } else {\n                return s[s.length - 1];\n            }\n        };\n        const state = initState(config, Object.assign({}, globalScope), '');\n        exec(state, startup.slice(0));\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return exec(state, parse(state));\n        }) as any;\n        const fReplSync: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\n            resetState(state, strings, values);\n            return execSync(state, parse(state));\n        }) as any;\n        (fRepl as any).sync = fReplSync;\n        return fRepl;\n    };\n    f.setGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globals || {});\n        return f;\n    };\n    f.appendGlobals = (globals: object) => {\n        globalScope = Object.assign({}, globalScope, globals || {});\n        return f;\n    };\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = parse(state);\n        return f;\n    };\n    f.setStartupAST = (ast: SxToken[]) => {\n        startup = ast;\n        return f;\n    };\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\n        startup = startup.concat(parse(state));\n        return f;\n    };\n    f.appendStartupAST = (ast: SxToken[]) => {\n        startup = startup.concat(ast);\n        return f;\n    };\n    f.install = (installer) => {\n        config = installer(config);\n        return f;\n    };\n\n    return f;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport { SExpression }    from '../../interpreters';\nimport { defaultConfig }  from '../../defaults';\n\n\n\nexport const S = (() => {\n    const config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config.enableEvaluate = false;\n    config.returnMultipleRoot = true;\n\n    return SExpression(config);\n})();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbol,\n         SxToken,\n         FatalError,\n         CapturedScopes,\n         SxMacroInfo }           from '../../types';\nimport { globalObj }             from '../../global-this';\nimport { isSymbol,\n         quote }                 from '../../ast';\nimport { evaluate,\n         resolveValueSymbolScope,\n         collectCapturedVariables,\n         getCapturedScopes,\n         getScope,\n         getGlobalScope,\n         installScope,\n         uninstallScope,\n         optimizeTailCall,\n         toNumber }              from '../../evaluate';\nimport { compileLambda }         from '../../compile';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx } from '../../errors';\n\n\n\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($car '(first second ... last))\n    //  -> S expr  : first\n    checkParamsLength('$car', args, 1, 1);\n\n    const car = $$first(...args);\n    if (! Array.isArray(car)) {\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\n    }\n    if (car.length === 0) {\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\n    }\n    return car[0];\n};\nexport const $$car = $car(null as any, null as any);\n\n\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($cdr '(first second ... last))\n    //  -> S expr  : (second ... last)\n    checkParamsLength('$cdr', args, 1, 1);\n\n    const car = $$first(...args);\n    if (! Array.isArray(car)) {\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is not array.`);\n    }\n    if (car.length === 0) {\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is nil.`);\n    }\n    return car.slice(1);\n};\nexport const $$cdr = $cdr(null as any, null as any);\n\n\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\n    //  -> S expr  : (arg1 arg2-item1 ...)\n    // S expression: ($cons arg1 nilOrNull ... argN)\n    //  -> S expr  : (arg1)\n    // S expression: ($cons arg1 arg2 ... argN)\n    //  -> S expr  : arg1.arg2\n    checkParamsLength('$cons', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    if (car === null) {\n        car = [];\n    }\n    if (cdr === null) {\n        cdr = [];\n    }\n\n    if (Array.isArray(cdr)) {\n        cdr = cdr.slice(0);\n        cdr.unshift(car);\n        return cdr;\n    } else {\n        return {car, cdr};\n    }\n};\nexport const $$cons = $cons(null as any, null as any);\n\n\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($first first second ... last)\n    //  -> S expr  : first\n    // S expression: ($first)\n    //  -> S expr  : null\n    const car: any = args.slice(0, 1);\n    return (car.length === 1) ? car[0] : null;\n};\nexport const $$first = $first(null as any, null as any);\n\n\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($second first second ... last)\n    //  -> S expr  : second\n    // S expression: ($second first)\n    //  -> S expr  : null\n    const cdr: any = args.slice(1, 2);\n    return (cdr.length === 1) ? cdr[0] : null;\n};\nexport const $$second = $second(null as any, null as any);\n\n\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($last first second ... last)\n    //  -> S expr  : last\n    // S expression: ($last)\n    //  -> S expr  : null\n    const car: any = args.slice(args.length - 1, args.length);\n    return (car.length === 1) ? car[0] : null;\n};\nexport const $$last = $last(null as any, null as any);\n\n\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($rest first second ... last)\n    //  -> S expr  : (second ... last)\n    // S expression: ($rest first)\n    //  -> S expr  : null\n    const cdr: any = args.slice(1);\n    return (0 < cdr.length) ? cdr : null;\n};\nexport const $$rest = $rest(null as any, null as any);\n\n\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($first-and-second first second ... last)\n    //  -> S expr  : first.second\n    let car: any = args.slice(0, 1);\n    car = (car.length === 1) ? car[0] : null;\n\n    let cdr: any = args.slice(1, 2);\n    cdr = (cdr.length === 1) ? cdr[0] : null;\n\n    return {car, cdr};\n};\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\n\n\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($atom arg1 ...)\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\n    //  -> (if arg1 is nil or anything else) S expr  : true\n    checkParamsLength('$atom', args, 1, 1);\n\n    const car = $$first(...args);\n\n    if (car === null || car === void 0) {\n        return true;\n    }\n    if (Array.isArray(car)) {\n        if (car.length === 0) return  true;\n        else                  return false;\n    }\n\n    switch (typeof car) {\n    case 'number': case 'string': case 'function': case 'boolean':\n        return true;\n    case 'object':\n        return isSymbol(car) ? true : false;\n    }\n    return false;\n};\nexport const $$atom = $atom(null as any, null as any);\n\n\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($eq arg1 arg2)\n    //  -> (if arg1 === arg2)  S expr  : true\n    //  -> (else)              S expr  : false\n    checkParamsLength('$eq', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return car === cdr;\n};\nexport const $$eq = $eq(null as any, null as any);\n\n\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($not-eq arg1 arg2)\n    //  -> (if arg1 !== arg2)  S expr  : true\n    //  -> (else)              S expr  : false\n    checkParamsLength('$notEq', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return car !== cdr;\n};\nexport const $$notEq = $notEq(null as any, null as any);\n\n\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\n    // S expression: ($list arg1 ... argN)\n    //  -> S expr  : (arg1 ... argN)\n    args.slice(0);\nexport const $$list = $list(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n    //  -> (else)               S expr  : exprN\n    checkParamsLength('$__scope', args, 3);\n\n    const isBlockLocal = $$first(...args);\n    const returnMultiple = $$second(...args);\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\n    let r: SxToken = null;\n\n    const scope: any = {};\n    if (Array.isArray(car)) {\n        for (const x of car) {\n            if (Array.isArray(x)) {\n                const kv = $$firstAndSecond(...x);\n                const kvSym = isSymbol(kv.car);\n                const kvName = kvSym ? kvSym.symbol : String(kv.car);\n                checkUnsafeVarNamesEx('$__scope', scope, kvName);\n                scope[kvName] = evaluate(state, kv.cdr);\n            } else {\n                const xSym = isSymbol(x);\n                const xName = xSym ? xSym.symbol : String(x);\n                checkUnsafeVarNamesEx('$__scope', scope, xName);\n                scope[xName] = null;\n            }\n        }\n    }\n    installScope(state, scope, isBlockLocal, capturedScopes);\n\n    try {\n        if (4 < args.length) {\n            if (returnMultiple) {\n                r = [];\n                for (const x of args.slice(3)) {\n                    r.push(evaluate(state, x));\n                }\n            } else {\n                for (const x of args.slice(3)) {\n                    r = evaluate(state, x);\n                }\n            }\n        } else {\n            r = evaluate(state, cdr);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\n    //  -> (else)               S expr  : exprN\n    checkParamsLength('$__globalScope', args, 1);\n\n    const returnMultiple = $$first(...args);\n    const cdr = $$second(...args);\n    let r: SxToken = null;\n\n    installScope(state, getGlobalScope(state).scope, true);\n    try {\n        if (2 < args.length) {\n            if (returnMultiple) {\n                r = [];\n                for (const x of args.slice(1)) {\n                    r.push(evaluate(state, x));\n                }\n            } else {\n                for (const x of args.slice(1)) {\n                    r = evaluate(state, x);\n                }\n            }\n        } else {\n            r = evaluate(state, cdr);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : exprN\n    checkParamsLength('$__capture', args, 1);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let r: SxToken = null;\n\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\n    installScope(state, {}, true, capturedScopes);\n    try {\n        for (const x of args.slice(1)) {\n            r = evaluate(state, x);\n        }\n    } finally {\n        uninstallScope(state);\n    }\n\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : fn\n    checkParamsLength('$__lambda', args, 2);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    let fnBody = args.slice(1);\n    if (state.config.enableTailCallOptimization) {\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\n    }\n\n    const capturedScopes = getCapturedScopes(state);\n\n    const fn = function(this: any, ...actualArgs: any[]) {\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\n            throw new Error(`[SX] func call: Actual args too short: actual ${\n                actualArgs.length} / formal ${formalArgs.length}.`);\n        }\n        // TODO: add type checking\n        return $__scope(state, name, capturedScopes)(false, false, [\n            [state.config.reservedNames.self, fn],\n            [state.config.reservedNames.thiz, this === globalObj || this === void 0 ? null : quote(state, this)],\n            ...(formalArgs.map((x: SxSymbol, index) => [\n                x.symbol,\n                quote(state,\n                    (lastIsSpread && index === formalArgs.length - 1) ?\n                        actualArgs.slice(index) : actualArgs[index]\n                )\n            ])),\n        ], ...fnBody);\n    };\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $comp$__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\n    //  -> S expr  : fn\n    checkParamsLength('$$__lambda', args, 2);\n\n    const formalArgs: SxSymbol[] = args[0];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $$__lambda: Invalid argument(s): args[0] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    const fnBody = args.slice(1);\n    return compileLambda(state, formalArgs, lastIsSpread, fnBody);\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$__defun', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const fn = $__lambda(state, name)(...args.slice(1));\n\n    checkUnsafeVarNamesEx('$__defun', state.funcMap, car.symbol);\n    // TODO: overloading\n    state.funcMap.set(car.symbol, {\n        name: car.symbol,\n        fn: (st, nm) => fn,\n        // formalArgs: ,\n        // lastIsSpread: ,\n        // next: ,\n    });\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $comp$__defun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$$__defun', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const fn = $comp$__lambda(state, name)(...args.slice(1));\n\n    checkUnsafeVarNamesEx('$$__defun', state.funcMap, car.symbol);\n    // TODO: overloading\n    state.funcMap.set(car.symbol, {\n        name: car.symbol,\n        fn: (st, nm) => fn,\n        // formalArgs: ,\n        // lastIsSpread: ,\n        // next: ,\n    });\n    return fn;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($refun 'name)\n    //  -> S expr  : fn\n    checkParamsLength('$__refun', args, 1, 1);\n\n    const car: SxSymbol = $$first(...args);\n\n    checkUnsafeVarNamesEx('$__refun', state.funcMap, car.symbol);\n    const info = state.funcMap.get(car.symbol);\n    if (!info) {\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\n    }\n    return info.fn(state, car.symbol);\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__defmacro = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\n    //  -> S expr  : fn\n    checkParamsLength('$__defmacro', args, 3);\n\n    const car: SxSymbol = $$first(...args);\n    const formalArgs: SxSymbol[] = args[1];\n    if (! Array.isArray(formalArgs)) {\n        throw new Error(`[SX] $__defmacro: Invalid argument(s): args[1] is not array.`);\n    }\n\n    let lastIsSpread = false;\n    for (let i = 0; i < formalArgs.length; i++) {\n        const fa = formalArgs[i];\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\n            if (! isSymbol(fa[1])) {\n                throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n            }\n            formalArgs[i] = fa[1];\n            lastIsSpread = true;\n        } else if (! isSymbol(fa)) {\n            throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\n        }\n    }\n\n    const fnBody = args.slice(2);\n    const capturedScopes = getCapturedScopes(state);\n\n    const fn = (fArgs: SxSymbol[]) => (...aArgs: any[]) => {\n        return $__scope(state, name, capturedScopes)(false, false, [\n            [state.config.reservedNames.self, fn],\n            ...(fArgs.map((x: SxSymbol, index) => [\n                x.symbol,\n                quote(state,\n                    (lastIsSpread && index === fArgs.length - 1) ?\n                        aArgs.slice(index) : aArgs[index]\n                )\n            ])),\n        ], ...fnBody);\n    };\n\n    const m: SxMacroInfo = {\n        name: car.symbol,\n        fn: (st: SxParserState, nm: string, fArgs: SxSymbol[]) => (list: SxToken[]) => fn(fArgs)(...(list.slice(1))),\n        formalArgs,\n        lastIsSpread,\n    };\n\n    checkUnsafeVarNamesEx('$__defmacro', state.macroMap, car.symbol);\n\n    if (state.macroMap.has(car.symbol)) {\n        let curr = state.macroMap.get(car.symbol);\n        (curr as SxMacroInfo).next = m;\n        if (curr && curr.formalArgs) {\n            if (curr.formalArgs.length < formalArgs.length) {\n                state.macroMap.set(car.symbol, m);\n                m.next = curr;\n            } else {\n                let prev = curr;\n                curr = curr.next;\n                while (curr) {\n                    if (curr.formalArgs) {\n                        if (curr.formalArgs.length < formalArgs.length) {\n                            prev.next = m;\n                            m.next = curr;\n                            break;\n                        }\n                    }\n                    prev = curr;\n                    curr = curr.next;\n                }\n            }\n        }\n    } else {\n        state.macroMap.set(car.symbol, m);\n    }\n    return fn;\n};\n\n\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($apply fn arg1 ... argN)\n    //  -> S expr  : fn'\n    checkParamsLength('$apply', args, 1);\n\n    const car: () => any = $$first(...args);\n    if (typeof car !== 'function') {\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\n    }\n\n    return (\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\n    );\n};\nexport const $$apply = $apply(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\n    //  -> S expr  : fn\n    checkParamsLength('$__call', args, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    const sym = isSymbol(cdr);\n    const xName = sym ? sym.symbol : evaluate(state, cdr) as any;\n\n    checkUnsafeVarNamesEx('$__call', car, xName);\n\n    return Function.prototype.apply.call(\n        car[xName],\n        car,\n        args.slice(2)\n    );\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__try 'expr 'catch-expr)\n    //  ->                               S expr  : expr\n    //  -> (if error is raised in expr)  S expr  : catch-expr\n    checkParamsLength('$__try', args, 1, 2);\n\n    let r: SxToken = [];\n    try {\n        r = evaluate(state, args[0]);\n    } catch (e) {\n        if (e instanceof FatalError) {\n            throw e;\n        }\n        if (1 < args.length) {\n            r = $__scope(state, name)(true, false, [\n                ['$error', quote(state, e)],\n                ['$parent', quote(state, getScope(state))],\n            ], args[1]);\n        } else {\n            r = null;\n        }\n    }\n    return r;\n};\n\n\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($raise 'expr)\n    //  -> S expr  : -\n    const car = $$first(...args);\n    throw car;\n};\nexport const $$raise = $raise(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__if condition 't-expr 'f-expr)\n    //  -> (if condition is true ) S expr  : t-expr\n    //  -> (if condition is false) S expr  : f-expr\n    checkParamsLength('$__if', args, 2, 3);\n\n    const car = $$first(...args);\n    let r: SxToken = [];\n    if ($$boolean(car)) {\n        r = evaluate(state, args[1]);\n    } else {\n        if (2 < args.length) {\n            r = evaluate(state, args[2]);\n        } else {\n            r = null;\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__if-null condition 'null-expr)\n    //  -> (if condition is not null ) S expr  : condition\n    //  -> (if condition is null)      S expr  : null-expr\n    checkParamsLength('$__ifNull', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    let r: SxToken = [];\n    if (! $$ambiguousEq(car, null)) {\n        r = car;\n    } else {\n        r = evaluate(state, cdr);\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n    //  -> (if (eval condI) is true ) S expr  : exprI\n    //  -> (if no matched)            S expr  : null\n    checkParamsLength('$__cond', args, 1);\n\n    for (let i = 0; i < args.length - 1; i += 2) {\n        const c = args[i];\n        const x = args[i + 1];\n        if ($$boolean(evaluate(state, c))) {\n            return evaluate(state, x);\n        }\n    }\n    return null;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__while', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    while ($$boolean(evaluate(state, car))) {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__doWhile', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n\n    do {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    } while ($$boolean(evaluate(state, car)));\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__until', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    while ($$not(evaluate(state, car))) {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\n    //  -> (else)                                          S expr  : null\n    checkParamsLength('$__doUntil', args, 1);\n\n    const car = $$first(...args);\n    const cdr = args.slice(1);\n    let r: SxToken = null;\n    do {\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    } while ($$not(evaluate(state, car)));\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\n    //  -> (if n > 0) S expr  : exprN\n    //  -> (else)     S expr  : null\n    checkParamsLength('$__repeat', args, 2);\n\n    const sym = isSymbol($$first(...args));\n    if (! sym) {\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\n    }\n\n    checkUnsafeVarNamesEx('$__repeat', {}, sym.symbol); // NOTE: pass dummy target object.\n    const scope = resolveValueSymbolScope(state, sym, false);\n\n    const n = toNumber($$second(...args));\n    const cdr = args.slice(2);\n    let r: SxToken = null;\n    for (let i = 0; i < n; i++) {\n        scope[sym.symbol] = i;\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\n    //  -> (if list.length > 0) S expr  : exprN\n    //  -> (else)               S expr  : null\n    checkParamsLength('$__for', args, 2);\n\n    const sym = isSymbol($$first(...args));\n    if (! sym) {\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\n    }\n\n    checkUnsafeVarNamesEx('$__for', {}, sym.symbol); // NOTE: pass dummy target object.\n    const scope = resolveValueSymbolScope(state, sym, false);\n\n    const list = $$second(...args);\n    if (! Array.isArray(list)) {\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\n    }\n\n    const cdr = args.slice(2);\n    let r: SxToken = null;\n    for (const q of list) {\n        scope[sym.symbol] = q;\n        for (const x of cdr) {\n            r = evaluate(state, x);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__get v fn1 ... fnN)\n    //  -> S expr  : any\n    checkParamsLength('$pipe', args, 1);\n\n    let v = args[0];\n    for (let i = 1; i < args.length; i++) {\n        v = args[i](v);\n    }\n    return v;\n};\nexport const $$pipe = $pipe(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n    //  -> S expr  : any\n    checkParamsLength('$__get', args, 1);\n\n    let v: any = null;\n    let sym = isSymbol(args[0]);\n\n    if (!sym) {\n        switch (typeof args[0]) {\n        case 'string': case 'number':\n            sym = {symbol: String(args[0])};\n            break;\n        default:\n            v = evaluate(state, args[0]);\n            break;\n        }\n    }\n\n    if (sym) {\n        const scope = resolveValueSymbolScope(state, sym, true);\n        if (! scope) {\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\n        }\n        v = scope[sym.symbol];\n    }\n\n    for (let i = 1; i < args.length; i++) {\n        let q: any = args[i];\n        let inprog = true;\n        while (inprog) {\n            switch (typeof q) {\n            case 'function':\n                v = q(v);\n                inprog = false;\n                break;\n            case 'object':\n                if (Array.isArray(q)) {\n                    q = evaluate(state, q);\n                } else {\n                    sym = isSymbol(q);\n                    if (sym) {\n                        q = sym.symbol;\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\n                        q = evaluate(state, q);\n                    } else {\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\n                    }\n                }\n                break;\n            case 'number':\n                if (q < 0) {\n                    q = v.length + q;\n                }\n                // FALL_THRU\n            case 'string':\n                checkUnsafeVarNamesEx('$__get', v, q);\n                v = v[q];\n                inprog = false;\n                break;\n            default:\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\n            }\n        }\n    }\n    return v;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__let 'nameStrOrSymbol expr)\n    //  -> S expr  : any\n    checkParamsLength('$__let', args, 2, 2);\n\n    let sym = isSymbol($$first(...args));\n\n    if (! sym) {\n        if (typeof args[0] === 'string') {\n            sym = {symbol: args[0]};\n        } else {\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\n        }\n    }\n\n    checkUnsafeVarNamesEx('$__let', {}, sym.symbol); // NOTE: pass dummy target object.\n\n    const scope = resolveValueSymbolScope(state, sym, false);\n    scope[sym.symbol] = args[1];\n\n    return args[1];\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\n    //  -> S expr  : any\n    checkParamsLength('$__set', args, 2, 2);\n\n    let path: any = [];\n\n    if (Array.isArray(args[0])) {\n        path = args[0];\n    } else {\n        path.push(args[0]);\n    }\n\n    let sym = isSymbol(path[0]);\n\n    if (! sym) {\n        if (typeof path[0] === 'string') {\n            checkUnsafeVarNamesEx('$__set', {}, path[0]); // NOTE: pass dummy target object.\n            sym = {symbol: path[0]};\n        } else {\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n        }\n    }\n\n    let scope = resolveValueSymbolScope(state, sym, true);\n    if (scope === null) {\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\n    }\n\n    let subst = false;\n\n    for (let i = 0; i < path.length; i++) {\n        let q: any = path[i];\n        let inprog = true;\n        const last = i === path.length - 1;\n        while (inprog) {\n            switch (typeof q) {\n            case 'function':\n                scope = q(scope);\n                inprog = false;\n                break;\n            case 'object':\n                if (Array.isArray(q)) {\n                    q = evaluate(state, q);\n                } else {\n                    sym = isSymbol(q);\n                    if (sym) {\n                        q = sym.symbol;\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\n                        q = evaluate(state, q);\n                    } else {\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n                    }\n                }\n                break;\n            case 'number':\n                if (q < 0) {\n                    q = scope.length + q;\n                }\n                // FALL_THRU\n            case 'string':\n                checkUnsafeVarNamesEx('$__set', scope, q);\n                if (last) {\n                    scope[q] = args[1];\n                    subst = true;\n                } else {\n                    scope = scope[q];\n                }\n                inprog = false;\n                break;\n            default:\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\n            }\n        }\n    }\n\n    if (! subst) {\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\n    }\n\n    return args[1];\n};\n\n\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($boolean any)\n    //  -> S expr  : boolean\n    checkParamsLength('$boolean', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car) && car.length === 0) return false;\n    else return Boolean(car);\n};\nexport const $$boolean = $boolean(null as any, null as any);\n\n\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($not any)\n    //  -> S expr  : boolean\n    checkParamsLength('$not', args, 1, 1);\n\n    return ! $$boolean(...args);\n};\nexport const $$not = $not(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__and 'expr1 ... 'exprN)\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\n    //  -> (else)                                                     S expr  : expr-i (false left most)\n    checkParamsLength('$__and', args, 1);\n\n    let prev = null;\n    for (let i = 0; i < args.length; i++) {\n        const curr = evaluate(state, args[i]);\n        if (! $$boolean(curr)) {\n            return curr;\n        }\n        prev = curr;\n    }\n    return prev;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__and = $__and(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__or 'expr1 ... 'exprN)\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\n    //  -> (else)                                                  S expr  : expr-i (false right most)\n    checkParamsLength('$__or', args, 1);\n\n    let prev = null;\n    for (let i = 0; i < args.length; i++) {\n        const curr = evaluate(state, args[i]);\n        if ($$boolean(curr)) {\n            return curr;\n        }\n        prev = curr;\n    }\n    return prev;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__or = $__or(null as any, null as any);\n\n\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (== a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$ambiguousEq', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car) && car.length === 0) car = null;\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\n    if (car === void 0) car = null;\n    if (cdr === void 0) cdr = null;\n    // tslint:disable-next-line:triple-equals\n    return car == cdr;\n};\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\n\n\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (!= a b)\n    //  -> S expr  : boolean\n    return ! $$ambiguousEq(...args);\n};\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\n\n\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (< a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$lt', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) < toNumber(cdr);\n};\nexport const $$lt = $lt(null as any, null as any);\n\n\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (<= a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$le', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) <= toNumber(cdr);\n};\nexport const $$le = $le(null as any, null as any);\n\n\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (> a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$gt', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) > toNumber(cdr);\n};\nexport const $$gt = $gt(null as any, null as any);\n\n\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>= a b)\n    //  -> S expr  : boolean\n    checkParamsLength('$ge', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return toNumber(car) >= toNumber(cdr);\n};\nexport const $$ge = $ge(null as any, null as any);\n\n\nexport const $typeof = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($typeof x)\n    //  -> S expr  : 'null' | 'bigint' | 'boolean' | 'function' | 'number' | 'string' | 'undefined' |\n    //               'js-symbol' | 'list' | 'object'\n    checkParamsLength('$typeof', args, 1, 1);\n\n    const car = $$first(...args);\n    if (car === null) {\n        return 'null';\n    }\n    const tyName = typeof car;\n    switch (tyName) {\n    case 'object':\n        if (Array.isArray(car)) {\n            return 'list';\n        } else {\n            return 'object';\n        }\n    case 'symbol':\n        return 'js-symbol';\n    default:\n        return tyName;\n    }\n};\nexport const $$typeof = $typeof(null as any, null as any);\n\n\nexport const $symbol = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($symbol)\n    // S expression: ($symbol name)\n    //  -> S expr  : symbol\n    checkParamsLength('$symbol', args, 1, 1);\n\n    if (typeof args[0] === 'string') {\n        return {symbol: args[0]};\n    } else {\n        throw new Error(`[SX] $symbol: Invalid argument(s): item(s) of args[0] is not string.`);\n    }\n};\nexport const $$symbol = $symbol(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__gensym = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__gensym)\n    // S expression: ($__gensym name)\n    //  -> S expr  : symbol\n    checkParamsLength('$__gensym', args, 0, 1);\n\n    const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\n    const tempVarSym = ({symbol: `${varBaseName}_$gensym`});\n    if (args.length === 1) {\n        const a = isSymbol(args[0]);\n        if (a) {\n            $__let(state, '')(a, tempVarSym);\n        } else if (typeof args[0] === 'string') {\n            $__let(state, '')({symbol: args[0]}, tempVarSym);\n        } else {\n            throw new Error(`[SX] $__gensym: Invalid argument(s): item(s) of args[0] is not symbol.`);\n        }\n    }\n    return tempVarSym;\n};\n\n\nexport const $isSymbol = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-symbol x)\n    // S expression: ($is-symbol x name)\n    //  -> S expr  : boolean\n    checkParamsLength('$isSymbol', args, 1, 2);\n\n    if (args.length === 1) {\n        return (isSymbol(args[0]) ? true : false);\n    } else {\n        if (typeof args[1] === 'string') {\n            return (isSymbol(args[0], args[1]) ? true : false);\n        } else {\n            throw new Error(`[SX] $isSymbol: Invalid argument(s): item(s) of args[1] is not string.`);\n        }\n    }\n};\nexport const $$isSymbol = $isSymbol(null as any, null as any);\n\n\nexport const $isNull = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-null x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNull', args, 1, 1);\n\n    return $$first(...args) === null;\n};\nexport const $$isNull = $isNull(null as any, null as any);\n\n\nexport const $isNil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-nil x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNil', args, 1, 1);\n\n    const car = $$first(...args);\n    return Array.isArray(car) && car.length === 0;\n};\nexport const $$isNil = $isNil(null as any, null as any);\n\n\nexport const $isUndefined = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-undefined x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isUndefined', args, 1, 1);\n\n    return $$first(...args) === void 0;\n};\nexport const $$isUndefined = $isUndefined(null as any, null as any);\n\n\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-list x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isList', args, 1, 1);\n\n    return Array.isArray($$first(...args));\n};\nexport const $$isList = $isList(null as any, null as any);\n\n\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-string x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isString', args, 1, 1);\n\n    return typeof $$first(...args) === 'string';\n};\nexport const $$isString = $isString(null as any, null as any);\n\n\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-number x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNumber', args, 1, 1);\n\n    return typeof $$first(...args) === 'number';\n};\nexport const $$isNumber = $isNumber(null as any, null as any);\n\n\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-NaN x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isNaN', args, 1, 1);\n\n    return Number.isNaN($$first(...args));\n};\nexport const $$isNaN = $isNaN(null as any, null as any);\n\n\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-finate x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isFinite', args, 1, 1);\n\n    return Number.isFinite($$first(...args));\n};\nexport const $$isFinite = $isFinite(null as any, null as any);\n\n\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($is-integer x)\n    //  -> S expr  : boolean\n    checkParamsLength('$isInteger', args, 1, 1);\n\n    return Number.isInteger($$first(...args));\n};\nexport const $$isInteger = $isInteger(null as any, null as any);\n\n\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($to-string x)\n    //  -> S expr  : string\n    checkParamsLength('$toString', args, 1, 1);\n\n    return String($$first(...args));\n};\nexport const $$toString = $toString(null as any, null as any);\n\n\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($to-number x)\n    //  -> S expr  : number\n    checkParamsLength('$toNumber', args, 1, 1);\n\n    return toNumber($$first(...args));\n};\nexport const $$toNumber = $toNumber(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__# '(name value...)...)\n    //  -> JSON    : {name: value, ...}\n    const r: any = {};\n    for (const x of args) {\n        if (Array.isArray(x) && 0 < x.length) {\n            const sym = isSymbol(x[0]);\n            const keyName =\n                sym ? sym.symbol :\n                String(evaluate(state, x[0]));\n\n            checkUnsafeVarNamesEx('$__#', r, keyName);\n            if (x.length === 1) {\n                // S expression: (# ... (keyName) ...)\n                //  -> JSON    : {..., keyName: true, ...}\n                r[keyName] = true;\n            } else if (x.length === 2) {\n                // S expression: (# ... (keyName value) ...)\n                //  -> JSON    : {..., keyName: value, ...}\n                r[keyName] = evaluate(state, x[1]);\n            } else {\n                // S expression: (# ... (keyName value1 value2 ...) ...)\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\n                r[keyName] =\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                    .concat(x.slice(1)));\n            }\n        } else {\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\n        }\n    }\n    return r;\n};\n\n\nconst assignBlacklist = [\n    globalObj,\n    (Object as any).__proto__,\n    ({} as any).__proto__,\n    (Function as any).__proto__,\n];\n\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($object-assign x)\n    //  -> S expr  : string\n    checkParamsLength('$objectAssign', args, 1);\n\n    if (assignBlacklist.includes(args[0])) {\n        throw new Error(`[SX] $objectAssign: Invalid argument: args[0] is blacklisted object.`);\n    }\n    return Object.assign(args[0], ...(args.slice(1)));\n};\nexport const $$objectAssign = $objectAssign(null as any, null as any);\n\n\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($json-stringify x)\n    //  -> S expr  : string\n    checkParamsLength('$jsonStringify', args, 1, 1);\n\n    return JSON.stringify($$first(...args));\n};\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\n\n\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($json-parse x)\n    //  -> S expr  : object\n    checkParamsLength('$jsonParse', args, 1, 1);\n\n    const s = $$first(...args);\n    if (typeof s !== 'string') {\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\n    }\n    return JSON.parse(s);\n};\nexport const $$jsonParse = $jsonParse(null as any, null as any);\n\n\nexport const $now = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($now)\n    //  -> S expr  : number\n    return Date.now();\n};\nexport const $$now = $now(null as any, null as any);\n\n\nexport const $datetimeFromIso = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-from-iso str)\n    //  -> S expr  : number\n    checkParamsLength('$datetimeFromIso', args, 1, 1);\n\n    const s = $$first(...args);\n    if (typeof s !== 'string') {\n        throw new Error(`[SX] $datetimeFromIso: Invalid argument(s): args[0] is not string.`);\n    }\n    if (! /^(?:(?:-[0-9]{6,})|[0-9]{4,})-(?:[0-1][0-9])-(?:[0-3][0-9])(?:T(?:[0-2][0-9])(?:[:](?:[0-6][0-9])(?:[:](?:[0-6][0-9])(?:.[0-9]{1,})?)?)?(?:Z|[-+][0-9]{2}(?:[:]?[0-6][0-9])?)?)?$/.test(s)) {\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime (pattern unmatched): ${s}.`);\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetimeFromIso = $datetimeFromIso(null as any, null as any);\n\n\nexport const $datetime = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime year month1-12 day)\n    // S expression: ($datetime year month1-12 day hours)\n    // S expression: ($datetime year month1-12 day hours minutes)\n    // S expression: ($datetime year month1-12 day hours minutes seconds)\n    // S expression: ($datetime year month1-12 day hours minutes seconds milliseconds)\n    //  -> S expr  : number\n    checkParamsLength('$datetime', args, 3, 7);\n\n    let s = '';\n    const year = Number(args[0]);\n    if (year >= 0) {\n        s += String(year).padStart(4, '0');\n    } else {\n        s += '-' + String(-year).padStart(6, '0');\n    }\n    // month1\n    s += '-' + String(Number(args[1])).padStart(2, '0');\n    // day\n    s += '-' + String(Number(args[2])).padStart(2, '0');\n    // hours\n    if (args.length >= 4) {\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\n        // minutes\n        if (args.length >= 5) {\n            s += ':' + String(Number(args[4])).padStart(2, '0');\n        } else {\n            s += ':00';\n        }\n        // seconds\n        if (args.length >= 6) {\n            s += ':' + String(Number(args[5])).padStart(2, '0');\n        }\n        // milliseconds\n        if (args.length >= 7) {\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\n        }\n        s += 'Z';\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetime: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetime = $datetime(null as any, null as any);\n\n\nexport const $datetimeLc = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-lc year month1-12 day)\n    // S expression: ($datetime-lc year month1-12 day hours)\n    // S expression: ($datetime-lc year month1-12 day hours minutes)\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds)\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds milliseconds)\n    //  -> S expr  : number\n    checkParamsLength('$datetimeLc', args, 3, 7);\n\n    let s = '';\n    const year = Number(args[0]);\n    if (year >= 0) {\n        s += String(year).padStart(4, '0');\n    } else {\n        s += '-' + String(-year).padStart(6, '0');\n    }\n    // month1\n    s += '-' + String(Number(args[1])).padStart(2, '0');\n    // day\n    s += '-' + String(Number(args[2])).padStart(2, '0');\n    // hours\n    if (args.length >= 4) {\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\n        // minutes\n        if (args.length >= 5) {\n            s += ':' + String(Number(args[4])).padStart(2, '0');\n        } else {\n            s += ':00';\n        }\n        // seconds\n        if (args.length >= 6) {\n            s += ':' + String(Number(args[5])).padStart(2, '0');\n        }\n        // milliseconds\n        if (args.length >= 7) {\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\n        }\n    } else {\n        s += 'T00:00:00.000';\n    }\n    const dt = new Date(s).getTime();\n    if (Number.isNaN(dt)) {\n        throw new Error(`[SX] $datetimeLc: Invalid datetime: ${s}.`);\n    }\n    return dt;\n};\nexport const $$datetimeLc = $datetimeLc(null as any, null as any);\n\n\nexport const $datetimeToIsoString = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-iso-string number)\n    //  -> S expr  : string\n    checkParamsLength('$datetimeToIsoString', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToIsoString: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToIsoString: Invalid datetime: ${n}.`);\n    }\n    return dt.toISOString();\n};\nexport const $$datetimeToIsoString = $datetimeToIsoString(null as any, null as any);\n\n\nexport const $datetimeToComponents = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-components number)\n    //  -> S expr  : list\n    checkParamsLength('$datetimeToComponents', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToComponents: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToComponents: Invalid datetime: ${n}.`);\n    }\n    return ([\n        dt.getUTCFullYear(),\n        dt.getUTCMonth() + 1,\n        dt.getUTCDate(),\n        dt.getUTCHours(),\n        dt.getUTCMinutes(),\n        dt.getUTCSeconds(),\n        dt.getUTCMilliseconds(),\n        0, // TZ\n        dt.getUTCDay(),\n    ]);\n};\nexport const $$datetimeToComponents = $datetimeToComponents(null as any, null as any);\n\n\nexport const $datetimeToComponentsLc = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($datetime-to-components-lc number)\n    //  -> S expr  : list\n    checkParamsLength('$datetimeToComponentsLc', args, 1, 1);\n\n    const n = $$first(...args);\n    if (typeof n !== 'number') {\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid argument(s): args[0] is not number.`);\n    }\n    const dt = new Date(n);\n    if (Number.isNaN(dt.getTime())) {\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid datetime: ${n}.`);\n    }\n    return ([\n        dt.getFullYear(),\n        dt.getMonth() + 1,\n        dt.getDate(),\n        dt.getHours(),\n        dt.getMinutes(),\n        dt.getSeconds(),\n        dt.getMilliseconds(),\n        -dt.getTimezoneOffset(), // time difference between local time and UTC time, in minutes.\n                                 // If your time zone is UTC+2:00, +120 will be returned.\n        dt.getDay(),\n    ]);\n};\nexport const $$datetimeToComponentsLc = $datetimeToComponentsLc(null as any, null as any);\n\n\nexport const $match = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($match pattern-str string)\n    // S expression: ($match pattern-str options-str string)\n    //  -> S expr  : array\n    checkParamsLength('$match', args, 2, 3);\n\n    if (! state.config.enableRegExpMatchOperators) {\n        throw new Error(`[SX] $match: Operator is disabled by configuration.`);\n    }\n\n    if (args.length === 2) {\n        const m = new RegExp(args[0]);\n        return m.exec(args[1]);\n    } else {\n        const m = new RegExp(args[0], args[1]);\n        return m.exec(args[2]);\n    }\n};\nexport const $$match = $match(null as any, null as any);\n\n\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-log expr1 ... exprN)\n    //  -> S expr  : null\n    console.log(...args);\n    return null;\n};\nexport const $$consoleLog = $consoleLog(null as any, null as any);\n\n\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-error expr1 ... exprN)\n    //  -> S expr  : null\n    console.error(...args);\n    return null;\n};\nexport const $$consoleError = $consoleError(null as any, null as any);\n\n\nexport const $consoleTrace = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-trace expr1 ... exprN)\n    //  -> S expr  : null\n    console.trace(...args);\n    return null;\n};\nexport const $$consoleTrace = $consoleTrace(null as any, null as any);\n\n\nexport const $consoleTime = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time)\n    // S expression: ($console-time label)\n    //  -> S expr  : null\n    console.time(...args);\n    return null;\n};\nexport const $$consoleTime = $consoleTime(null as any, null as any);\n\n\nexport const $consoleTimeEnd = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time-end)\n    // S expression: ($console-time-end label)\n    //  -> S expr  : null\n    console.timeEnd(...args);\n    return null;\n};\nexport const $$consoleTimeEnd = $consoleTimeEnd(null as any, null as any);\n\n\nexport const $consoleTimeLog = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($console-time-log label)\n    // S expression: ($console-time-log label value ... value)\n    //  -> S expr  : null\n    (console as any).timeLog(...args);\n    return null;\n};\nexport const $$consoleTimeLog = $consoleTimeLog(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './core.fn';\n\n\n\nexport const operators: SxFuncInfo[] = [{\n    name: '$car',\n    fn: ops.$car,\n}, {\n    name: '$cdr',\n    fn: ops.$cdr,\n}, {\n    name: '$cons',\n    fn: ops.$cons,\n}, {\n    name: '$first',\n    fn: ops.$first,\n}, {\n    name: '$second',\n    fn: ops.$second,\n}, {\n    name: '$last',\n    fn: ops.$last,\n}, {\n    name: '$progn', // alias of $last\n    fn: ops.$last,\n}, {\n    name: '$rest',\n    fn: ops.$rest,\n}, {\n    name: '$first-and-second',\n    fn: ops.$firstAndSecond,\n}, {\n    name: '$atom',\n    fn: ops.$atom,\n}, {\n    name: '$eq',\n    fn: ops.$eq,\n}, {\n    name: '===',\n    fn: ops.$eq,\n}, {\n    name: '$not-eq',\n    fn: ops.$notEq,\n}, {\n    name: '!==',\n    fn: ops.$notEq,\n}, {\n    name: '$list',\n    fn: ops.$list,\n}, {\n    name: '$__scope',\n    fn: ops.$__scope,\n}, {\n    name: '$__global',\n    fn: ops.$__globalScope,\n}, {\n    name: '$__capture',\n    fn: ops.$__capture,\n}, {\n    name: '$__lambda',\n    fn: ops.$__lambda,\n}, {\n    name: '$__defun',\n    fn: ops.$__defun,\n}, {\n    name: '$__refun',\n    fn: ops.$__refun,\n}, {\n    name: '$__defmacro',\n    fn: ops.$__defmacro,\n}, {\n    name: '$apply',\n    fn: ops.$apply,\n}, {\n    name: '$__call',\n    fn: ops.$__call,\n}, {\n    name: '$__try',\n    fn: ops.$__try,\n}, {\n    name: '$raise',\n    fn: ops.$raise,\n}, {\n    name: '$__if',\n    fn: ops.$__if,\n}, {\n    name: '$__if-null',\n    fn: ops.$__ifNull,\n}, {\n    name: '$__cond',\n    fn: ops.$__cond,\n}, {\n    name: '$__while',\n    fn: ops.$__while,\n}, {\n    name: '$__do-while',\n    fn: ops.$__doWhile,\n}, {\n    name: '$__until',\n    fn: ops.$__until,\n}, {\n    name: '$__do-until',\n    fn: ops.$__doUntil,\n}, {\n    name: '$__repeat',\n    fn: ops.$__repeat,\n}, {\n    name: '$__for',\n    fn: ops.$__for,\n}, {\n    name: '$pipe',\n    fn: ops.$pipe,\n}, {\n    name: '$__get',\n    fn: ops.$__get,\n}, {\n    name: '$__let',\n    fn: ops.$__let,\n}, {\n    name: '$__set',\n    fn: ops.$__set,\n}, {\n    name: '$boolean',\n    fn: ops.$boolean,\n}, {\n    name: '$not',\n    fn: ops.$not,\n}, {\n    name: '$__and',\n    fn: ops.$__and,\n}, {\n    name: '$__or',\n    fn: ops.$__or,\n}, {\n    name: '==',\n    fn: ops.$ambiguousEq,\n}, {\n    name: '!=',\n    fn: ops.$ambiguousNotEq,\n}, {\n    name: '<',\n    fn: ops.$lt,\n}, {\n    name: '<=',\n    fn: ops.$le,\n}, {\n    name: '>',\n    fn: ops.$gt,\n}, {\n    name: '>=',\n    fn: ops.$ge,\n}, {\n    name: '$typeof',\n    fn: ops.$typeof,\n}, {\n    name: '$symbol',\n    fn: ops.$symbol,\n}, {\n    name: '$__gensym',\n    fn: ops.$__gensym,\n}, {\n    name: '$is-symbol',\n    fn: ops.$isSymbol,\n}, {\n    name: '$is-null',\n    fn: ops.$isNull,\n}, {\n    name: '$is-nil',\n    fn: ops.$isNil,\n}, {\n    name: '$is-undefined',\n    fn: ops.$isUndefined,\n}, {\n    name: '$is-list',\n    fn: ops.$isList,\n}, {\n    name: '$is-string',\n    fn: ops.$isString,\n}, {\n    name: '$is-number',\n    fn: ops.$isNumber,\n}, {\n    name: '$is-NaN',\n    fn: ops.$isNaN,\n}, {\n    name: '$is-finite',\n    fn: ops.$isFinite,\n}, {\n    name: '$is-integer',\n    fn: ops.$isInteger,\n}, {\n    name: '$to-string',\n    fn: ops.$toString,\n}, {\n    name: '$to-number',\n    fn: ops.$toNumber,\n}, {\n    name: '$__#',\n    fn: ops.$__toObject,\n}, {\n    name: '$object-assign',\n    fn: ops.$objectAssign,\n}, {\n    name: '$json-stringify',\n    fn: ops.$jsonStringify,\n}, {\n    name: '$now',\n    fn: ops.$now,\n}, {\n    name: '$datetime-from-iso',\n    fn: ops.$datetimeFromIso,\n}, {\n    name: '$datetime',\n    fn: ops.$datetime,\n}, {\n    name: '$datetime-lc',\n    fn: ops.$datetimeLc,\n}, {\n    name: '$datetime-to-iso-string',\n    fn: ops.$datetimeToIsoString,\n}, {\n    name: '$datetime-to-components',\n    fn: ops.$datetimeToComponents,\n}, {\n    name: '$datetime-to-components-lc',\n    fn: ops.$datetimeToComponentsLc,\n}, {\n    name: '$json-parse',\n    fn: ops.$jsonParse,\n}, {\n    name: '$match',\n    fn: ops.$match,\n}, {\n    name: '$console-log',\n    fn: ops.$consoleLog,\n}, {\n    name: '$console-error',\n    fn: ops.$consoleError,\n}, {\n    name: '$console-trace',\n    fn: ops.$consoleTrace,\n}, {\n    name: '$console-time',\n    fn: ops.$consoleTime,\n}, {\n    name: '$console-time-end',\n    fn: ops.$consoleTimeEnd,\n}, {\n    name: '$console-time-log',\n    fn: ops.$consoleTimeLog,\n}];\n\n\nexport const compilationOperators: SxFuncInfo[] = [{\n    name: '$$__lambda',\n    fn: ops.$comp$__lambda,\n}, {\n    name: '$$__defun',\n    fn: ops.$comp$__defun,\n}];\n\n\n// for backword compatibility\nexport default ([] as SxFuncInfo[]).concat(operators, compilationOperators);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { isSymbol,\n         quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$scope',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            list[1],\n            list[2],\n            ...(list.slice(3).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$local',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($local ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            true,\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$global',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($__global expr1 ... exprN)\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\n        return [{symbol: '$__global'},\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$clisp-let', // alias of $local\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\n        return [{symbol: '$__scope'},\n            true,\n            false,\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$capture',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__capture'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$closure',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\n        const symUse = isSymbol(list[2], 'use');\n        if (! symUse) {\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\n        }\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\n            quote(state, list[1]),\n            ...(list.slice(4).map(x => quote(state, x))),\n        ])];\n    },\n}, {\n    name: '|->',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        return [{symbol: '$closure'},\n            ...list.slice(1),\n        ];\n    },\n}, {\n    name: '$lambda',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '->',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$defun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__defun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$refun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($refun name)\n        //  -> S expr  : ($__refun 'name)\n        return [{symbol: '$__refun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '<-',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (<- name)\n        //  -> S expr  : ($__refun 'name)\n        return [{symbol: '$__refun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$defmacro',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($defmacro name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$__defmacro'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$call',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($call thisArg symbol arg1 ... argN)\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\n        checkParamsLength('$call', list, 3);\n\n        return [{symbol: '$__call'},\n            list[1],\n            quote(state, list[2]),\n            ...(list.slice(3)),\n        ];\n    },\n}, {\n    name: '$try',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($try expr catch-expr)\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\n        return [{symbol: '$__try'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$if',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($if cond t-expr f-expr)\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\n        return [{symbol: '$__if'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$if-null',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($if-null cond null-expr)\n        //  -> S expr  : ($__if-null cont 'null-expr)\n        return [{symbol: '$__if-null'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '??',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (?? cond null-expr)\n        //  -> S expr  : ($__if-null cont 'null-expr)\n        return [{symbol: '$__if-null'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$cond',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($cond cond1 expr1 ... condN exprN)\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\n        return [{symbol: '$__cond'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$while',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($while condition expr1 exprN)\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\n        return [{symbol: '$__while'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$do-while',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($do-while condition expr1 exprN)\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\n        return [{symbol: '$__do-while'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$until',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($until condition expr1 exprN)\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\n        return [{symbol: '$__until'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$do-until',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($do-until condition expr1 exprN)\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\n        return [{symbol: '$__do-until'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$repeat',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($repeat i of n-times expr1 exprN)\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\n        const symOf = isSymbol(list[2], 'of');\n        if (! symOf) {\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\n        }\n        return [{symbol: '$__repeat'},\n            quote(state, list[1]),\n            list[3],\n            ...(list.slice(4).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$for',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($for x of list expr1 exprN)\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\n        const symOf = isSymbol(list[2], 'of');\n        if (! symOf) {\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\n        }\n        return [{symbol: '$__for'},\n            quote(state, list[1]),\n            list[3],\n            ...(list.slice(4).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$get',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\n        return [{symbol: '$__get'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$let',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let nameStrOrSymbol expr)\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\n        checkParamsLength('$let', list, 3, 3);\n\n        return [{symbol: '$__let'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$clisp-defvar',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let nameStrOrSymbol expr)\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\n        checkParamsLength('$clisp-defvar', list, 3, 3);\n\n        return [{symbol: '$global'},\n            [{symbol: '$__let'},\n                quote(state, list[1]),\n                list[2]\n            ],\n        ];\n    },\n}, {\n    name: '$set',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($set nameOrListOfNameOrIndex expr)\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\n        checkParamsLength('$set', list, 3, 3);\n\n        return [{symbol: '$__set'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$clisp-setq', // alias of $set\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($clisp-setq symbol expr)\n        //  -> S expr  : ($__set 'symbol expr)\n        checkParamsLength('$clisp-setq', list, 3, 3);\n\n        return [{symbol: '$__set'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$and',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($and expr1 ... exprN)\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\n        return [{symbol: '$__and'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$or',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($or expr1 ... exprN)\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\n        return [{symbol: '$__or'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$gensym',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($gensym)\n        // S expression: ($gensym name)\n        //  -> S expr  : ($__gensym 'name)\n        return [\n            {symbol: '$__gensym'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '#',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (# (name value...)...)\n        //  -> S expr  : ($__# '(name value...)...)\n        return [\n            {symbol: '$__#'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\nexport const compilationMacros: SxMacroInfo[] = [{\n    name: '$$closure',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($$__lambda '(sym1 ... symN) 'expr ... 'expr) )\n        const symUse = isSymbol(list[2], 'use');\n        if (! symUse) {\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\n        }\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$$__lambda'},\n            quote(state, list[1]),\n            ...(list.slice(4).map(x => quote(state, x))),\n        ])];\n    },\n}, {\n    name: '|=>',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\n        return [{symbol: '$$closure'},\n            ...list.slice(1),\n        ];\n    },\n}, {\n    name: '$$lambda',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '=>',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__lambda'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$$defun',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($$defun name (sym1 ... symN) expr ... expr)\n        //  -> S expr  : ($$__defun 'name '(sym1 ... symN) 'expr ... 'expr)\n        return [{symbol: '$$__defun'},\n            ...(list.slice(1).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\n// for backword compatibility\nexport default ([] as SxMacroInfo[]).concat(macros, compilationMacros);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\n\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\n\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\n\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\n\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\n\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\n\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\n];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig }       from '../../types';\nimport { operators,\n         compilationOperators } from './core.operator';\nimport { macros,\n         compilationMacros }    from './core.macro';\nimport symbols                  from './core.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || [])\n        .concat(operators)\n        .concat(config.enableCompilationOperators ? compilationOperators : []);\n    config.macros = (config.macros || [])\n        .concat(macros)\n        .concat(config.enableCompilationOperators ? compilationMacros : []);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { toNumber }          from '../../evaluate';\nimport { checkParamsLength } from '../../errors';\nimport { $$first,\n         $$firstAndSecond }  from '../core/core.fn';\n\n\n\nexport const $bitLShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (<< number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitLShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car << cdr : 0;\n    } else {\n        return cdr > -32 ? car >>> (-cdr) : 0;\n    }\n};\nexport const $$bitLShift = $bitLShift(null as any, null as any);\n\n\nexport const $bitSRShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>> number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitSRShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car >> cdr : (car & 0x080000000) ? -1 : 0;\n    } else {\n        return cdr > -32 ? car << (-cdr) : 0;\n    }\n};\nexport const $$bitSRShift = $bitSRShift(null as any, null as any);\n\n\nexport const $bitURShift = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (>>> number shift)\n    //  -> S expr  : number\n    checkParamsLength('$bitURShift', args, 2, 2);\n\n    let {car, cdr} = $$firstAndSecond(...args);\n    car = toNumber(car);\n    cdr = toNumber(cdr);\n\n    if (0 <= cdr) {\n        return cdr < 32 ? car >>> cdr : 0;\n    } else {\n        return cdr > -32 ? car << (-cdr) : 0;\n    }\n};\nexport const $$bitURShift = $bitURShift(null as any, null as any);\n\n\nexport const $bitNot = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-not number)\n    //  -> S expr  : number\n    checkParamsLength('$bitNot', args, 1, 1);\n\n    const car = $$first(...args);\n    return ~toNumber(car);\n};\nexport const $$bitNot = $bitNot(null as any, null as any);\n\n\nexport const $bitAnd = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-and numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitAnd', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) & toNumber(curr), toNumber(car));\n};\nexport const $$bitAnd = $bitAnd(null as any, null as any);\n\n\nexport const $bitOr = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-or numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitOr', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) | toNumber(curr), toNumber(car));\n};\nexport const $$bitOr = $bitOr(null as any, null as any);\n\n\nexport const $bitXor = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($bit-xor numberA numberB)\n    //  -> S expr  : number\n    checkParamsLength('$bitXor', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ^ toNumber(curr), toNumber(car));\n};\nexport const $$bitXor = $bitXor(null as any, null as any);\n\n\nexport const $add = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (+ number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$add', args, 1);\n\n    return args.reduce((prev, curr) => toNumber(prev) + toNumber(curr), 0);\n};\nexport const $$add = $add(null as any, null as any);\n\n\nexport const $sub = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (- number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$sub', args, 1);\n\n    const car = $$first(...args);\n    const last = args.slice(1);\n    if (last.length === 0) {\n        // negate\n        return -toNumber(car);\n    } else {\n        // subtract\n        return args.slice(1).reduce((prev, curr) => toNumber(prev) - toNumber(curr), toNumber(car));\n    }\n};\nexport const $$sub = $sub(null as any, null as any);\n\n\nexport const $mul = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (* number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$mul', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) * toNumber(curr), toNumber(car));\n};\nexport const $$mul = $mul(null as any, null as any);\n\n\nexport const $sup = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (** number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$sup', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) ** toNumber(curr), toNumber(car));\n};\nexport const $$sup = $sup(null as any, null as any);\n\n\nexport const $div = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (/ number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$div', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) / toNumber(curr), toNumber(car));\n};\nexport const $$div = $div(null as any, null as any);\n\n\nexport const $mod = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (% number1 ... numberN)\n    //  -> S expr  : number\n    checkParamsLength('$mod', args, 2);\n\n    const car = $$first(...args);\n    return args.slice(1).reduce((prev, curr) => toNumber(prev) % toNumber(curr), toNumber(car));\n};\nexport const $$mod = $mod(null as any, null as any);\n\n\nexport const $max = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($max val1 ... valN)\n    //  -> S expr  : value\n    return Math.max(...(args.map(x => toNumber(x))));\n};\nexport const $$max = $max(null as any, null as any);\n\n\nexport const $min = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($min val1 ... valN)\n    //  -> S expr  : value\n    return Math.min(...(args.map(x => toNumber(x))));\n};\nexport const $$min = $min(null as any, null as any);\n\n\nexport const $avg = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($avg val1 ... valN)\n    //  -> S expr  : value\n    const a = args.map(x => toNumber(x));\n    return a.length > 0 ? a.reduce((prev, curr) => prev + curr, 0) / a.length : NaN;\n};\nexport const $$avg = $avg(null as any, null as any);\n\n\nexport const $floor = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($floor number)\n    //  -> S expr  : number\n    checkParamsLength('$floor', args, 1, 1);\n\n    return Math.floor(toNumber($$first(...args)));\n};\nexport const $$floor = $floor(null as any, null as any);\n\n\nexport const $ceil = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($ceil number)\n    //  -> S expr  : number\n    checkParamsLength('$ceil', args, 1, 1);\n\n    return Math.ceil(toNumber($$first(...args)));\n};\nexport const $$ceil = $ceil(null as any, null as any);\n\n\nexport const $round = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($round number)\n    //  -> S expr  : number\n    checkParamsLength('$round', args, 1, 1);\n\n    return Math.round(toNumber($$first(...args)));\n};\nexport const $$round = $round(null as any, null as any);\n\n\nexport const $abs = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($abs number)\n    //  -> S expr  : number\n    checkParamsLength('$abs', args, 1, 1);\n\n    return Math.abs(toNumber($$first(...args)));\n};\nexport const $$abs = $abs(null as any, null as any);\n\n\nexport const $sign = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sign number)\n    //  -> S expr  : number\n    checkParamsLength('$sign', args, 1, 1);\n\n    return Math.sign(toNumber($$first(...args)));\n};\nexport const $$sign = $sign(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './arithmetic.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '<<',\n    fn: ops.$bitLShift,\n}, {\n    name: '$bit-l-shift',\n    fn: ops.$bitLShift,\n}, {\n    name: '>>',\n    fn: ops.$bitSRShift,\n}, {\n    name: '$bit-sr-shift',\n    fn: ops.$bitSRShift,\n}, {\n    name: '>>>',\n    fn: ops.$bitURShift,\n}, {\n    name: '$bit-ur-shift',\n    fn: ops.$bitURShift,\n}, {\n    name: '$bit-not',\n    fn: ops.$bitNot,\n}, {\n    name: '$bit-and',\n    fn: ops.$bitAnd,\n}, {\n    name: '$bit-or',\n    fn: ops.$bitOr,\n}, {\n    name: '$bit-xor',\n    fn: ops.$bitXor,\n}, {\n    name: '+',\n    fn: ops.$add,\n}, {\n    name: '$add',\n    fn: ops.$add,\n}, {\n    name: '$sum',\n    fn: ops.$add,\n}, {\n    name: '-',\n    fn: ops.$sub,\n}, {\n    name: '$sub',\n    fn: ops.$sub,\n}, {\n    name: '$neg',\n    fn: ops.$sub,\n}, {\n    name: '*',\n    fn: ops.$mul,\n}, {\n    name: '$mul',\n    fn: ops.$mul,\n}, {\n    name: '**',\n    fn: ops.$sup,\n}, {\n    name: '$sup',\n    fn: ops.$sup,\n}, {\n    name: '/',\n    fn: ops.$div,\n}, {\n    name: '$div',\n    fn: ops.$div,\n}, {\n    name: '%',\n    fn: ops.$mod,\n}, {\n    name: '$mod',\n    fn: ops.$mod,\n}, {\n    name: '$max',\n    fn: ops.$max,\n}, {\n    name: '$min',\n    fn: ops.$min,\n}, {\n    name: '$avg',\n    fn: ops.$avg,\n}, {\n    name: '$floor',\n    fn: ops.$floor,\n}, {\n    name: '$ceil',\n    fn: ops.$ceil,\n}, {\n    name: '$round',\n    fn: ops.$round,\n}, {\n    name: '$abs',\n    fn: ops.$abs,\n}, {\n    name: '$sign',\n    fn: ops.$sign,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { isSymbol,\n         quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$incl',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($incl name)\n        //  -> S expr  : ($set name ($add name 1))\n        checkParamsLength('$incl', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], 1],\n        ];\n    },\n}, {\n    name: '++',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (++ name)\n        //  -> S expr  : ($set name ($add name 1))\n        checkParamsLength('++', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], 1],\n        ];\n    },\n}, {\n    name: '$decl',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($decl name)\n        //  -> S expr  : ($set name ($add name -1))\n        checkParamsLength('$decl', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -1],\n        ];\n    },\n}, {\n    name: '--',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (-- name)\n        //  -> S expr  : ($set name ($add name -1))\n        checkParamsLength('--', list, 2, 2);\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -1],\n        ];\n    },\n}, {\n    name: '$incln',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($incln name v)\n        //  -> S expr  : ($set name ($add name v))\n        checkParamsLength('$incln', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] $incln: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], list[2]],\n        ];\n    },\n}, {\n    name: '+=',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (++ name v)\n        //  -> S expr  : ($set name ($add name v))\n        checkParamsLength('+=', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] +=: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], list[2]],\n        ];\n    },\n}, {\n    name: '$decln',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($decln name v)\n        //  -> S expr  : ($set name ($add name -v))\n        checkParamsLength('$decln', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] $decln: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\n        ];\n    },\n}, {\n    name: '-=',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: (-- name)\n        //  -> S expr  : ($set name ($add name -v))\n        checkParamsLength('-=', list, 3, 3);\n        if (typeof list[2] !== 'number') {\n            throw new Error(`[SX] -=: Invalid parameter: arg(1) is not number.`);\n        }\n\n        return [{symbol: '$set'},\n            list[1],\n            [{symbol: '$add'}, list[1], -(list[2] as number)],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './arithmetic.operator';\nimport macros             from './arithmetic.macro';\nimport symbols            from './arithmetic.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2017, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport class Query<T> {\n    public constructor(public data: T[]) {\n    }\n\n    public orderBy(condition: Array<string | string[/* colName: string, ('asc' | 'desc') */]> | ((a: T, b: T) => number)): Query<T> {\n        let fn: (a: T, b: T) => number;\n        if (Array.isArray(condition)) {\n            fn = (x: T, y: T) => {\n                for (const c of condition) {\n                    if (typeof c === 'string') {\n                        if (x[c] > y[c]) return 1;\n                        if (x[c] < y[c]) return -1;\n                    } else {\n                        const desc = c[1] === 'desc' ? -1 : 1;\n                        if (x[c[0]] > y[c[0]]) return 1 * desc;\n                        if (x[c[0]] < y[c[0]]) return -1 * desc;\n                    }\n                }\n                return 0;\n            };\n        } else {\n            fn = condition;\n        }\n        return new Query(this.data.slice(0).sort(fn));\n    }\n\n    public groupBy(condition: string[/* colName: string */] | ((a: T, b: T, index: number, array: T[]) => boolean)): Query<T[]> {\n        let fn: (a: T, b: T, index: number, array: T[]) => boolean;\n        if (Array.isArray(condition)) {\n            fn = (x: T, y: T) => {\n                for (const c of condition) {\n                    if (x[c] !== y[c]) return false;\n                }\n                return true;\n            };\n        } else{\n            fn = condition;\n        }\n        const r: T[][] = [];\n        let start = 0;\n        let i = 1;\n        for (; i < this.data.length; i++) {\n            if (! fn(this.data[start], this.data[i], i, this.data)) {\n                r.push(this.data.slice(start, i));\n                start = i;\n            }\n        }\n        r.push(this.data.slice(start, i));\n        return new Query(r);\n    }\n\n    public groupEvery(n: number | {single: number, first?: number, intermediate: number, last?: number}): Query<T[]> {\n        if (typeof n === 'number') {\n            return this.groupBy((a, b, index, array) => {\n                if ((index % n) === 0) return false;\n                return true;\n            });\n        } else {\n            const w = Object.assign({first: n.intermediate, last: n.intermediate}, n);\n            const r = this.groupBy((a, b, index, array) => {\n                if (w.single >= array.length) {\n                    if ((index % w.single) === 0) return false;\n                    return true;\n                } else if (index <= w.first) {\n                    if ((index % w.first) === 0) return false;\n                    return true;\n                } else {\n                    if (((index - w.first) % w.intermediate) === 0) return false;\n                    return true;\n                }\n            });\n            if (r.data.length === 1) {\n                if (w.single < r.data[0].length) {\n                    r.data.push([]);\n                }\n            } else {\n                if (w.first < r.data[0].length) {\n                    // case of w.first === 0\n                    r.data.unshift([]);\n                }\n            }\n            if (r.data.length > 1) {\n                if (r.data[r.data.length - 1].length > w.last) {\n                    r.data.push([]);\n                }\n            }\n            return r;\n        }\n    }\n\n    public where(fn: (value: T, index: number, array: T[]) => boolean): Query<T> {\n        return new Query(this.data.filter(fn));\n    }\n\n    public select(): T[];\n    public select<R>(fn: (value: T, index: number, array: T[]) => R): R[];\n    public select<R>(fn?: (value: T, index: number, array: T[]) => R): Array<R | T> {\n        return fn ? this.data.map(fn) : this.data as any;\n    }\n}\n\n\n\nexport function query<T>(data: T[]): Query<T> {\n    return new Query<T>(data);\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { toNumber,\n         evaluate }          from '../../evaluate';\nimport { checkParamsLength } from '../../errors';\nimport { $$first,\n         $$firstAndSecond }  from '../core/core.fn';\nimport { query }             from '../../../lib/data';\n\n\n\nexport const $range = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($range start end)\n    // S expression: ($range start end step)\n    //  -> S expr  : list\n    checkParamsLength('$range', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    const start = toNumber(car) || 0;\n    const stop = toNumber(cdr) || 0;\n\n    const step = (args.length > 2 ? toNumber(args[2]) || 0 : 0) || (start <= stop ? 1 : -1);\n    const n = Math.sign(stop - start) + Math.sign(step) !== 0 ?\n        (Math.floor((Math.abs(stop - start) / Math.abs(step))) + 1) : 0;\n\n    state.evalCount += n;\n    evaluate(state, 0);\n    return Array.from({length: n}, (x, i) => start + i * step);\n};\n\n\nexport const $length = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($length listOrString)\n    //  -> S expr  : number\n    checkParamsLength('$length', args, 1, 1);\n\n    const car = $$first(...args);\n    switch (typeof car) {\n    case 'object':\n        if (! ('length' in car)) {\n            break;\n        }\n        // FALL_THRU\n    case 'string':\n        return car.length;\n    }\n    throw new Error(`[SX] $length: Invalid argument type: object has no property 'length'.`);\n};\nexport const $$length = $length(null as any, null as any);\n\n\nexport const $trim = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim string)\n    //  -> S expr  : string\n    checkParamsLength('$trim', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trim();\n    }\n    throw new Error(`[SX] $trim: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trim = $trim(null as any, null as any);\n\n\nexport const $trimHead = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim-head string)\n    //  -> S expr  : string\n    checkParamsLength('$trimHead', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trimLeft();\n    }\n    throw new Error(`[SX] $trimHead: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trimHead = $trimHead(null as any, null as any);\n\n\nexport const $trimTail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($trim-tail string)\n    //  -> S expr  : string\n    checkParamsLength('$trimTail', args, 1, 1);\n\n    const car = $$first(...args);\n    if (typeof car === 'string') {\n        return car.trimRight();\n    }\n    throw new Error(`[SX] $trimTail: Invalid argument type: args[0] is not string.`);\n};\nexport const $$trimTail = $trimTail(null as any, null as any);\n\n\nexport const $replaceAll = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($replace-all src-string match-string replacement-string)\n    //  -> S expr  : string\n    checkParamsLength('$replaceAll', args, 3, 3);\n\n    if (typeof args[0] === 'string' && typeof args[1] === 'string' && typeof args[2] === 'string') {\n        return args[0].split(args[1]).join(args[2]);\n    }\n    throw new Error(`[SX] $replaceAll: Invalid argument type: args[0] or [1] or [2] is not string.`);\n};\nexport const $$replaceAll = $replaceAll(null as any, null as any);\n\n\nexport const $split = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($split src-string match-string)\n    //  -> S expr  : (string ... string)\n    checkParamsLength('$split', args, 2, 2);\n\n    if (typeof args[0] === 'string' && typeof args[1] === 'string') {\n        return args[0].split(args[1]);\n    }\n    throw new Error(`[SX] $split: Invalid argument type: args[0] or [1] is not string.`);\n};\nexport const $$split = $split(null as any, null as any);\n\n\nexport const $join = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($join '(str1 ... strN) separator)\n    //  -> S expr  : (string ... string)\n    checkParamsLength('$join', args, 1, 2);\n\n    if (typeof Array.isArray(args[0])) {\n        if (args.length > 1) {\n            if (typeof args[1] === 'string') {\n                return args[0].join(args[1]);\n            }\n            throw new Error(`[SX] $join: Invalid argument type: args[1] is not string.`);\n        } else {\n            return args[0].join();\n        }\n    }\n    throw new Error(`[SX] $join: Invalid argument type: args[0] is not array.`);\n};\nexport const $$join = $join(null as any, null as any);\n\n\nexport const $concat = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($concat listOrString1 ... listOrStringN)\n    //  -> S expr  : listOrString\n    checkParamsLength('$concat', args, 1);\n\n    const car = $$first(...args);\n    switch (typeof car) {\n    case 'object':\n        if (! ('concat' in car)) {\n            break;\n        }\n        // FALL_THRU\n    case 'string':\n        return car.concat(...args.slice(1));\n    }\n    throw new Error(`[SX] $concat: Invalid argument type: object has no property 'concat'.`);\n};\nexport const $$concat = $concat(null as any, null as any);\n\n\nexport const $slice = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($slice start end listOrString)\n    // S expression: ($slice start listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$slice', args, 2, 3);\n\n    if (args.length === 3) {\n        if (typeof args[2] === 'string' || Array.isArray(args[2])) {\n            return args[2].slice(toNumber(args[0]), toNumber(args[1]));\n        }\n    }\n    if (args.length === 2) {\n        if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n            return args[1].slice(toNumber(args[0]));\n        }\n    }\n    throw new Error(`[SX] $slice: Invalid argument type: args[${args.length - 1}] is not string or array.`);\n};\nexport const $$slice = $slice(null as any, null as any);\n\n\nexport const $top = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($top n listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$top', args, 2, 2);\n\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n        return args[1].slice(0, toNumber(args[0]));\n    }\n    throw new Error(`[SX] $top: Invalid argument type: args[1] is not string or array.`);\n};\nexport const $$top = $top(null as any, null as any);\n\n\nexport const $tail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($tail n listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$tail', args, 2, 2);\n\n    if (typeof args[1] === 'string' || Array.isArray(args[1])) {\n        const n = -toNumber(args[0]);\n        return args[1].slice(n >= 0 || Number.isNaN(n) ? args[1].length : n);\n    }\n    throw new Error(`[SX] $tail: Invalid argument type: args[1] is not string or array.`);\n};\nexport const $$tail = $tail(null as any, null as any);\n\n\nexport const $push = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($push list value)\n    //  -> S expr  : list\n    checkParamsLength('$push', args, 2, 2);\n\n    if (typeof Array.isArray(args[0])) {\n        args[0].push(args[1]);\n        return args[0];\n    }\n    throw new Error(`[SX] $push: Invalid argument type: args[1] is not array.`);\n};\nexport const $$push = $push(null as any, null as any);\n\n\nexport const $pop = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($pop list)\n    //  -> S expr  : value\n    checkParamsLength('$pop', args, 1, 1);\n\n    if (typeof Array.isArray(args[0])) {\n        const v = args[0].pop();\n        return v;\n    }\n    throw new Error(`[SX] $pop: Invalid argument type: args[1] is not array.`);\n};\nexport const $$pop = $pop(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__at = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__at index listOrString)\n    //  -> S expr  : any\n    checkParamsLength('$__at', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    return cdr[car];\n};\n// tslint:disable-next-line:variable-name\nexport const $$__at = $__at(null as any, null as any);\n\n\nexport const $reverse = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reverse listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$reverse', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car)) {\n        return car.slice(0).reverse();\n    }\n    throw new Error(`[SX] $reverse: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reverse = $reverse(null as any, null as any);\n\n\nexport const $reverseDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reverse! listOrString)\n    //  -> S expr  : listOrString\n    checkParamsLength('$reverse!', args, 1, 1);\n\n    const car = $$first(...args);\n    if (Array.isArray(car)) {\n        return car.reverse();\n    }\n    throw new Error(`[SX] $reverse!: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reverseDestructive = $reverseDestructive(null as any, null as any);\n\n\nexport const $find = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($find list (lambda (v index array) (... boolean)))\n    //  -> S expr  : list\n    checkParamsLength('$find', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.find(cdr);\n    }\n    throw new Error(`[SX] $find: Invalid argument type: args[0] is not array.`);\n};\nexport const $$find = $find(null as any, null as any);\n\n\nexport const $filter = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($filter list (lambda (v index array) (... boolean)))\n    //  -> S expr  : list\n    checkParamsLength('$filter', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.filter(cdr);\n    }\n    throw new Error(`[SX] $filter: Invalid argument type: args[0] is not array.`);\n};\nexport const $$filter = $filter(null as any, null as any);\n\n\nexport const $map = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($map list (lambda (v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$map', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.map(cdr);\n    }\n    throw new Error(`[SX] $map: Invalid argument type: args[0] is not array.`);\n};\nexport const $$map = $map(null as any, null as any);\n\n\nexport const $reduce = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reduce list (lambda (acc v index array) (... any)) initial-value)\n    // S expression: ($reduce list (lambda (acc v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$reduce', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        if (args.length < 3) {\n            return car.reduce(cdr);\n        } else {\n            return car.reduce(cdr, args[2]);\n        }\n    }\n    throw new Error(`[SX] $reduce: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reduce = $reduce(null as any, null as any);\n\n\nexport const $reduceFromTail = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)) initial-value)\n    // S expression: ($reduce-from-tail list (lambda (acc v index array) (... any)))\n    //  -> S expr  : list\n    checkParamsLength('$reduceFromTail', args, 2, 3);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        if (args.length < 3) {\n            return car.reduceRight(cdr);\n        } else {\n            return car.reduceRight(cdr, args[2]);\n        }\n    }\n    throw new Error(`[SX] $reduceFromTail: Invalid argument type: args[0] is not array.`);\n};\nexport const $$reduceFromTail = $reduceFromTail(null as any, null as any);\n\n\nexport const $sort = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sort list (lambda (a b) (... number_a-b)))\n    //  -> S expr  : list\n    checkParamsLength('$sort', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.slice(0).sort(cdr);\n    }\n    throw new Error(`[SX] $sort: Invalid argument type: args[0] is not array.`);\n};\nexport const $$sort = $sort(null as any, null as any);\n\n\nexport const $sortDestructive = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($sort! list (lambda (a b) (... number_a-b)))\n    //  -> S expr  : list\n    checkParamsLength('$sort!', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (Array.isArray(car)) {\n        return car.sort(cdr);\n    }\n    throw new Error(`[SX] $sort!: Invalid argument type: args[0] is not array.`);\n};\nexport const $$sortDestructive = $sortDestructive(null as any, null as any);\n\n\nexport const $groupEvery = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($group-every optionsOrNumber (x1 ... xN))\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\n    checkParamsLength('$group-every', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $group-every: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).groupEvery(car).select();\n};\nexport const $$groupEvery = $groupEvery(null as any, null as any);\n\n\nexport const $groupBy = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($group-by conditions (x1 ... xN))\n    //  -> S expr  : ((x1 ... ) ... ( ... xN))\n    checkParamsLength('$group-by', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $group-by: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).groupBy(car).select();\n};\nexport const $$groupBy = $groupBy(null as any, null as any);\n\n\nexport const $orderBy = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($order-by conditions (x1 ... xN))\n    //  -> S expr  : (x1 ... xN)\n    checkParamsLength('$order-by', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $order-by: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).orderBy(car).select();\n};\nexport const $$orderBy = $orderBy(null as any, null as any);\n\n\nexport const $where = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($where (-> (v index array) ... boolean) (x1 ... xN))\n    //  -> S expr  : (x'1 ... x'M)\n    checkParamsLength('$where', args, 2, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    if (typeof args[0] !== 'function') {\n        throw new Error(`[SX] $where: Invalid argument type: args[0] is not function.`);\n    }\n    if (! Array.isArray(cdr)) {\n        throw new Error(`[SX] $where: Invalid argument type: args[1] is not array.`);\n    }\n\n    return query(cdr as any[]).where(car).select();\n};\nexport const $$where = $where(null as any, null as any);\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './sequence.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$range',\n    fn: ops.$range,\n}, {\n    name: '$length',\n    fn: ops.$length,\n}, {\n    name: '$trim',\n    fn: ops.$trim,\n}, {\n    name: '$trim-head',\n    fn: ops.$trimHead,\n}, {\n    name: '$trim-tail',\n    fn: ops.$trimTail,\n}, {\n    name: '$replace-all',\n    fn: ops.$replaceAll,\n}, {\n    name: '$split',\n    fn: ops.$split,\n}, {\n    name: '$join',\n    fn: ops.$join,\n}, {\n    name: '$concat',\n    fn: ops.$concat,\n}, {\n    name: '$slice',\n    fn: ops.$slice,\n}, {\n    name: '$top',\n    fn: ops.$top,\n}, {\n    name: '$tail',\n    fn: ops.$tail,\n}, {\n    name: '$push',\n    fn: ops.$push,\n}, {\n    name: '$pop',\n    fn: ops.$pop,\n}, {\n    name: '$__at',\n    fn: ops.$__at,\n}, {\n    name: '$reverse',\n    fn: ops.$reverse,\n}, {\n    name: '$reverse!',\n    fn: ops.$reverseDestructive,\n}, {\n    name: '$find',\n    fn: ops.$find,\n}, {\n    name: '$filter',\n    fn: ops.$filter,\n}, {\n    name: '$map',\n    fn: ops.$map,\n}, {\n    name: '$reduce',\n    fn: ops.$reduce,\n}, {\n    name: '$reduce-from-head',\n    fn: ops.$reduce,\n}, {\n    name: '$reduce-from-tail',\n    fn: ops.$reduceFromTail,\n}, {\n    name: '$sort',\n    fn: ops.$sort,\n}, {\n    name: '$sort!',\n    fn: ops.$sortDestructive,\n}, {\n    name: '$group-every',\n    fn: ops.$groupEvery,\n}, {\n    name: '$group-by',\n    fn: ops.$groupBy,\n}, {\n    name: '$order-by',\n    fn: ops.$orderBy,\n}, {\n    name: '$where',\n    fn: ops.$where,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState } from '../../types';\nimport { isSymbol }      from '../../ast';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$[',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($[ index ] listOrObject)\n        //  -> S expr  : ($__at listOrObject)\n        const symOf = isSymbol(list[2], ']');\n        if (! symOf) {\n            throw new Error(`[SX] $repeat: Invalid syntax: missing ']' keyword.`);\n        }\n        return [{symbol: '$__at'},\n            list[1],\n            list[3],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './sequence.operator';\nimport macros             from './sequence.macro';\nimport symbols            from './sequence.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState }     from '../../types';\nimport { checkParamsLength } from '../../errors';\nimport { $__let,\n         $__set  }           from '../core/core.fn';\n\n\n\n// tslint:disable-next-line:variable-name\nexport const $__letAsync = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__let-async 'nameStrOrSymbol promise)\n    //  -> S expr  : promise\n    checkParamsLength('$__letAsync', args, 2, 2);\n\n    let promise: Promise<any> = args[1];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    promise = promise.then(v => {\n        try {\n            $__let(state, '')(args[0], v);\n            return v;\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    });\n    return promise;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__letAsync = $__letAsync(null as any, null as any);\n\n\n// tslint:disable-next-line:variable-name\nexport const $__setAsync = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__set-async 'nameOrListOfNameOrIndex promise)\n    //  -> S expr  : promise\n    checkParamsLength('$__setAsync', args, 2, 2);\n\n    let promise: Promise<any> = args[1];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    promise = promise.then(v => {\n        try {\n            $__set(state, '')(args[0], v);\n            return v;\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    });\n    return promise;\n};\n// tslint:disable-next-line:variable-name\nexport const $$__setAsync = $__setAsync(null as any, null as any);\n\n\nexport const $then = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($then promise (lambda (val) ...) (lambda (err) ...))\n    //  -> S expr  : promise\n    checkParamsLength('$then', args, 2, 3);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    if (typeof args[2] === 'function') {\n        promise = promise.then(args[1], args[2]);\n    } else {\n        if (typeof args[1] !== 'function') {\n            throw new Error(`[SX] $then: Invalid argument(s): args[1] is not function.`);\n        }\n        promise = promise.then(args[1]);\n    }\n    return promise;\n};\nexport const $$then = $then(null as any, null as any);\n\n\nexport const $resolveAll = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-all promise1 ... promiseN)\n    //  -> S expr  : promise\n    const promises: Array<Promise<any>> = args.slice(0);\n    for (let i = 0; i < promises.length; i++) {\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\n            promises[i] = Promise.resolve(promises[i]);\n        }\n    }\n    return Promise.all(promises);\n};\nexport const $$resolveAll = $resolveAll(null as any, null as any);\n\n\nexport const $resolveAny = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-any promise1 ... promiseN)\n    //  -> S expr  : promise\n    const promises: Array<Promise<any>> = args.slice(0);\n    for (let i = 0; i < promises.length; i++) {\n        if (typeof promises[i] !== 'object' || typeof (promises[i] as any).then !== 'function') {\n            promises[i] = Promise.resolve(promises[i]);\n        }\n    }\n\n    // https://stackoverflow.com/questions/39940152/get-first-fulfilled-promise\n    // firstOf: This will return the value of the first fulfilled promise,\n    //          or if all reject, an array of rejection reasons.\n    const invert  = (p: Promise<any>) => new Promise((res, rej) => p.then(rej, res));\n    const firstOf = (ps: Array<Promise<any>>) => invert(Promise.all(ps.map(invert)));\n\n    return firstOf(promises);\n};\nexport const $$resolveAny = $resolveAny(null as any, null as any);\n\n\nexport const $resolvePipe = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-pipe promise<val1> (lambda (val1) ... promiseOrVal2) (lambda (val2) ... promiseOrVal3) ... (lambda (valN-1) ... promiseOrValN))\n    //  -> S expr  : promise\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\n    checkParamsLength('$resolvePipe', args, 1);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    const lambdas = args.slice(1);\n    for (let i = 0; i < lambdas.length; i++) {\n        if (typeof lambdas[i] !== 'function') {\n            const v = lambdas[i];\n            lambdas[i] = () => v;\n        }\n    }\n    let p = promise;\n    for (const l of lambdas) {\n        p = p.then(l);\n    }\n    return p;\n};\nexport const $$resolvePipe = $resolvePipe(null as any, null as any);\n\n\nexport const $resolveFork = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($resolve-fork promise<val1> (lambda (val1) ... promiseOrVal2a) ... (lambda (val1) ... promiseOrVal2z))\n    //  -> S expr  : (promise<val2a> ... promise<val2z>)\n    // remarks: If the formal argument lambda is a non-lambda value, the value is then piped as is.\n    checkParamsLength('$resolveFork', args, 1);\n\n    let promise: Promise<any> = args[0];\n    if (typeof promise !== 'object' || typeof promise.then !== 'function') {\n        promise = Promise.resolve(promise);\n    }\n    const lambdas = args.slice(1);\n    for (let i = 0; i < lambdas.length; i++) {\n        if (typeof lambdas[i] !== 'function') {\n            const v = lambdas[i];\n            lambdas[i] = () => v;\n        }\n    }\n\n    const resolvers = new Array(lambdas.length);\n    const rejectors = new Array(lambdas.length);\n\n    const pa: Array<Promise<any>> = [];\n    for (let i = 0; i < lambdas.length; i++) {\n        pa.push(new Promise<any>((resolve: any, reject: any) => {\n            resolvers[i] = (v: any) => {\n                let lp: Promise<any> = lambdas[i](v);\n                if (typeof lp !== 'object' || typeof lp.then !== 'function') {\n                    lp = Promise.resolve(lp);\n                }\n\n                lp\n                .then(x => resolve(x))\n                .catch(e => reject(e));\n            };\n            rejectors[i] = reject;\n        }));\n    }\n\n    promise.then(\n        v => resolvers.forEach(f => f(v)),\n        e => rejectors.forEach(f => f(e))\n    );\n\n    return pa;\n};\nexport const $$resolveFork = $resolveFork(null as any, null as any);\n\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './concurrent.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$__let-async',\n    fn: ops.$__letAsync,\n}, {\n    name: '$__set-async',\n    fn: ops.$__setAsync,\n}, {\n    name: '$then',\n    fn: ops.$then,\n}, {\n    name: '$resolve-all',\n    fn: ops.$resolveAll,\n}, {\n    name: '$resolve-any',\n    fn: ops.$resolveAny,\n}, {\n    name: '$resolve-pipe',\n    fn: ops.$resolvePipe,\n}, {\n    name: '$resolve-fork',\n    fn: ops.$resolveFork,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState }     from '../../types';\nimport { quote }             from '../../ast';\nimport { checkParamsLength } from '../../errors';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '$let-async',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($let-async nameStrOrSymbol promise)\n        //  -> S expr  : ($__let-async 'nameStrOrSymbol promise)\n        checkParamsLength('$let-async', list, 3, 3);\n\n        return [{symbol: '$__let-async'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}, {\n    name: '$set-async',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($set-async nameOrListOfNameOrIndex promise)\n        //  -> S expr  : ($__set-async 'nameOrListOfNameOrIndex promise)\n        checkParamsLength('$set-async', list, 3, 3);\n\n        return [{symbol: '$__set-async'},\n            quote(state, list[1]),\n            list[2],\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig } from '../../types';\nimport operators          from './concurrent.operator';\nimport macros             from './concurrent.macro';\nimport symbols            from './concurrent.symbol';\n\n\n\nexport default function install(config: SxParserConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig }   from '../../types';\nimport installCore          from '../../operators/core';\nimport installArithmetic    from '../../operators/arithmetic';\nimport installSequence      from '../../operators/sequence';\nimport installConcurrent    from '../../operators/concurrent';\nimport { SExpression,\n         SExpressionAsync } from '../../interpreters';\nimport { defaultConfig }    from '../../defaults';\n\n\n\nexport const L = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n\n    return SExpression(config);\n})();\n\nexport const LS = L;\nexport const lisp = L;\n\n\n\n// tslint:disable-next-line:variable-name\nexport const L_async = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n\n    return SExpressionAsync(config);\n})();\n\n// tslint:disable-next-line:variable-name\nexport const LS_async = L_async;\n// tslint:disable-next-line:variable-name\nexport const lisp_async = L_async;\n\n\n\nexport const LM = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n    config.returnMultipleRoot = true;\n\n    return SExpression(config);\n})();\n\n\n\n// tslint:disable-next-line:variable-name\nexport const LM_async = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n\n    config.stripComments = true;\n    config.returnMultipleRoot = true;\n\n    return SExpressionAsync(config);\n})();\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserState,\n         SxToken }               from '../../types';\nimport { isSymbol,\n         quote }                 from '../../ast';\nimport { evaluate,\n         getScope }              from '../../evaluate';\nimport { checkParamsLength,\n         checkUnsafeVarNamesEx } from '../../errors';\nimport { $$first,\n         $$firstAndSecond,\n         $__scope,\n         $$boolean }             from '../core/core.fn';\n\n\n\n// tslint:disable-next-line:variable-name\nexport const $__outputIf = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__outputIf cond 'expr)\n    //  -> (if cond is true ) S expr  : expr\n    //  -> (if cond is false) S expr  : ()\n    checkParamsLength('$__outputIf', args, 2);\n\n    const {car, cdr} = $$firstAndSecond(...args);\n    let r: SxToken = [];\n    if ($$boolean(car)) {\n        if (2 < args.length) {\n            r.push({symbol: state.config.reservedNames.Template}, ...args.slice(1));\n            r = evaluate(state, r);\n        } else {\n            r = evaluate(state, cdr);\n        }\n    }\n    return r;\n};\n\n\n// tslint:disable-next-line:variable-name\nexport const $__outputForOf = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: ($__outputForOf list 'expr)\n    //  -> S expr  : (Template expr ... expr)\n    checkParamsLength('$__outputForOf', args, 2);\n\n    const car = $$first(...args);\n    const r: SxToken[] = [];\n    if (Array.isArray(car)) {\n        for (let i = 0; i < car.length; i++) {\n            const x = car[i];\n            const v = $__scope(state, name)(true, true, [\n                ['$data', quote(state, x)],\n                ['$index', i],\n                ['$array', quote(state, car)],\n                ['$parent', quote(state, getScope(state).scope)],\n            ], ...args.slice(1));\n\n            if (2 < args.length && Array.isArray(v)) {\n                r.push(...v);\n            } else {\n                r.push(v);\n            }\n        }\n    } else {\n        throw new Error(`[SX] $__outputForOf: Invalid argument(s): args[0] is not array.`);\n    }\n    // All of r items are already evaluated.\n    return evaluate(state,\n        ([{symbol: state.config.reservedNames.Template}] as SxToken[])\n        .concat(r.map(z => [{symbol: state.config.reservedNames.quote}, z])));\n};\n\n\nexport const $jsxProps = (state: SxParserState, name: string) => (...args: any[]) => {\n    // S expression: (@ (name value...)...)\n    //  -> JSON    : {name: value, ...}\n    const r: any = {};\n    for (const x of args) {\n        if (Array.isArray(x) && 0 < x.length) {\n            const sym = isSymbol(x[0]);\n            const keyName =\n                sym ? sym.symbol :\n                String(evaluate(state, x[0]));\n            switch (keyName) {\n            case 'style':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (style) ...)\n                        //  -> JSON    : {..., style: \"\", ...}\n                        r[keyName] = \"\";\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (style \"styleName1: styleValue1; ...\" ...) ...)\n                        // S expression: (@ ... (style (styleName1 styleValue1) ...) ...)\n                        //  -> JSON    : {..., style: {styleName1: styleValue1}, ...}\n                        const styles: object = {};\n                        for (const s of x.slice(1)) {\n                            if (Array.isArray(s) && 1 < s.length) {\n                                const styleName = String(evaluate(state, s[0]));\n                                checkUnsafeVarNamesEx('$jsxProps', styles, styleName);\n                                styles[styleName] = String(evaluate(state, s[1]));\n                            } else if (typeof s === 'string') {\n                                for (const v of s.split(';')) {\n                                    const matched = /^\\s*(\\S+)\\s*:\\s*(.*?)\\s*$/.exec(v);\n                                    if (matched) {\n                                        checkUnsafeVarNamesEx('$jsxProps', styles, matched[1]);\n                                        styles[matched[1]] = matched[2];\n                                    }\n                                }\n                            }\n                        }\n                        r[keyName] = styles;\n                    }\n                }\n                break;\n            case 'class': case 'styleClass':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (class) ...)\n                        //  -> JSON    : {..., class: [], ...}\n                        r[keyName] = [];\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\n                        //  -> JSON    : {..., class: [className1 className2 ...], ...}\n                        let classes: any[] = [];\n                        for (const c of x.slice(1)) {\n                            if (Array.isArray(c)) {\n                                classes = classes.concat(c.map(z => evaluate(state, z)));\n                            } else if (typeof c === 'string') {\n                                classes = classes.concat(c.split(' '));\n                            }\n                        }\n                        const cs: string[] = [];\n                        const fn: (a: any[]) => void = (a) => a\n                            .forEach(c => (c === null || c === void 0) ?\n                                void 0 :\n                                (Array.isArray(c) ? fn(c) : cs.push(String(c))));\n                        fn(classes);\n                        r[keyName] = cs;\n                    }\n                }\n                break;\n            case 'className':\n                {\n                    if (x.length === 1) {\n                        // S expression: (@ ... (class) ...)\n                        //  -> JSON    : {..., class: \"\", ...}\n                        r[keyName] = '';\n                    } else if (x.length >= 2) {\n                        // S expression: (@ ... (class \"className1 className2 ...\") ...)\n                        // S expression: (@ ... (class (className1 className2 ...)) ...)\n                        //  -> JSON    : {..., class: \"className1 className2 ...\", ...}\n                        let classes: string = '';\n                        for (const c of x.slice(1)) {\n                            let fragment = '';\n                            if (Array.isArray(c)) {\n                                const cs: string[] = [];\n                                const fn: (a: any[]) => void = (a) => a\n                                    .map(z => evaluate(state, z))\n                                    .forEach(z => (z === null || z === void 0) ?\n                                        void 0 :\n                                        (Array.isArray(z) ? fn(z) : cs.push(String(z))));\n                                fn(c);\n                                fragment = cs.join(' ');\n                            } else if (typeof c === 'string') {\n                                fragment = c;\n                            }\n                            if (0 < classes.length) classes += ' ' + fragment;\n                            else classes = fragment;\n                        }\n                        r[keyName] = classes;\n                    }\n                }\n                break;\n            case 'dangerouslySetInnerHTML':\n                {\n                    if (x.length === 1) {\n                        r[keyName] = {__html: ''};\n                    } else if (x.length >= 2) {\n                        r[keyName] = {__html: evaluate(state, x[1])};\n                    } else {\n                        r[keyName] = {__html:\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)))\n                        };\n                    }\n                }\n                break;\n            case 'setInnerText':\n                {\n                    if (x.length === 1) {\n                        r[keyName] = {__text: ''};\n                    } else if (x.length >= 2) {\n                        r[keyName] = {__text: evaluate(state, x[1])};\n                    } else {\n                        r[keyName] = {__text:\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)))\n                        };\n                    }\n                }\n                break;\n            default:\n                {\n                    checkUnsafeVarNamesEx('$jsxProps', r, keyName);\n                    if (x.length === 1) {\n                        // S expression: (@ ... (keyName) ...)\n                        //  -> JSON    : {..., keyName: true, ...}\n                        r[keyName] = true;\n                    } else if (x.length === 2) {\n                        // S expression: (@ ... (keyName value) ...)\n                        //  -> JSON    : {..., keyName: value, ...}\n                        r[keyName] = evaluate(state, x[1]);\n                    } else {\n                        // S expression: (@ ... (keyName value1 value2 ...) ...)\n                        //  -> JSON    : {..., keyName: [value1, value2, ], ...}\n                        r[keyName] =\n                            evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\n                            .concat(x.slice(1)));\n                    }\n                }\n                break;\n            }\n        } else {\n            throw new Error(`[SX] $jsxProps: Invalid argument(s): args[?] is not array.`);\n        }\n    }\n    return r;\n};\n\n\nfunction getJsxTagsParams(state: SxParserState, ...args: any[]) {\n    let children = args;\n    let props: any = {};\n    if (0 < args.length && Array.isArray(args[0])) {\n        const sym = isSymbol(args[0][0], '@');\n\n        if (sym) {\n            props = $jsxProps(state, '')(...args[0].slice(1));\n            children = children.slice(1);\n        }\n    }\n    return {props, children};\n}\n\n\nexport const $jsxStandardTag = (state: SxParserState, name: string) => (...args: any[]) => {\n    const {props, children} = getJsxTagsParams(state, ...args);\n    return (state.config.jsx as any)(name, props, ...children);\n};\n\n\nexport const $jsxComponentTag = (component: any) => (state: SxParserState, name: string) => (...args: any[]) => {\n    const {props, children} = getJsxTagsParams(state, ...args);\n    return (state.config.jsx as any)(component, props, ...children);\n};\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxFuncInfo } from '../../types';\nimport * as ops       from './jsx.fn';\n\n\n\nexport const funcs: SxFuncInfo[] = [{\n    name: '$=__if',\n    fn: ops.$__outputIf,\n}, {\n    name: '$=__for',\n    fn: ops.$__outputForOf,\n}];\n\n\nexport default funcs;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxMacroInfo,\n         SxParserState } from '../../types';\nimport { quote }         from '../../ast';\n\n\n\nexport const macros: SxMacroInfo[] = [{\n    name: '@',\n    fn: (state: SxParserState, name: string) => (list) => {\n        return quote(state, list);\n    },\n}, {\n    name: '$=if',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($=if cond expr)\n        //  -> S expr  : ($=__if cond 'expr)\n        return [\n            {symbol: '$=__if'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}, {\n    name: '$=for',\n    fn: (state: SxParserState, name: string) => (list) => {\n        // S expression: ($=for list expr)\n        //  -> S expr  : ($=__for list 'expr)\n        return [\n            {symbol: '$=__for'},\n            list[1],\n            ...(list.slice(2).map(x => quote(state, x))),\n        ];\n    },\n}];\n\n\nexport default macros;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxSymbolInfo } from '../../types';\n\n\n\nexport const symbols: SxSymbolInfo[] = [];\n\n\nexport default symbols;\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig,\n         LsxConfig }        from '../../types';\nimport operators            from './jsx.operator';\nimport macros               from './jsx.macro';\nimport symbols              from './jsx.symbol';\n\nimport { $jsxStandardTag,\n         $jsxComponentTag } from './jsx.fn';\n\n\n\nexport default function install(config: SxParserConfig, lsxConf: LsxConfig): SxParserConfig {\n    config.funcs = (config.funcs || []).concat(operators);\n    config.macros = (config.macros || []).concat(macros);\n    config.symbols = (config.symbols || []).concat(symbols);\n\n    const components =\n        Object.entries(lsxConf.components)\n        .map(x => ({name: x[0], fn: $jsxComponentTag(x[1])}));\n\n    config.funcs = config.funcs.concat(\n        {name: config.reservedNames.Template, fn: $jsxComponentTag(lsxConf.jsxFlagment)},\n        ...components\n    );\n\n    config.funcSymbolResolverFallback = $jsxStandardTag;\n    config.jsx = lsxConf.jsx;\n    config.JsxFragment = lsxConf.jsxFlagment;\n\n    return config;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SxParserConfig,\n         SxToken,\n         LsxConfig,\n         SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from '../../types';\nimport installCore          from '../../operators/core';\nimport installArithmetic    from '../../operators/arithmetic';\nimport installSequence      from '../../operators/sequence';\nimport installJsx           from '../../operators/jsx';\nimport installConcurrent    from '../../operators/concurrent';\nimport { SExpression,\n         SExpressionAsync } from '../../interpreters';\nimport { defaultConfig }    from '../../defaults';\n\n\n\nexport function LSX<R = SxToken>(lsxConf: LsxConfig): SExpressionTemplateFn<R> {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n    config = installJsx(config, lsxConf);\n\n    config.stripComments = true;\n\n    return SExpression(config) as any;\n}\n\n\n\nexport function LSX_async<R = SxToken>(lsxConf: LsxConfig): SExpressionAsyncTemplateFn<R> {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n\n    config = installCore(config);\n    config = installArithmetic(config);\n    config = installSequence(config);\n    config = installConcurrent(config);\n    config = installJsx(config, lsxConf);\n\n    config.stripComments = true;\n\n    return SExpressionAsync(config) as any;\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { SExpressionTemplateFn,\n         SExpressionAsyncTemplateFn } from './types';\n\n\n\nexport function runScriptTags(lisp: SExpressionTemplateFn | SExpressionAsyncTemplateFn, globals?: object, contentType = 'text/lisp') {\n    const codes = document.querySelectorAll(`script[type=\"${contentType}\"]`);\n    const cs = [];\n    for (let i = 0; i < codes.length; i++) {\n        cs.push(codes[i].innerHTML);\n    }\n    lisp = lisp.appendGlobals(globals || {});\n    return lisp(cs.join('\\n'));\n}\n","// Copyright (c) 2018, Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport * from './s-exp/types';\nexport * from './s-exp/ast';\nexport * from './s-exp/s-expression';\nexport * from './s-exp/browser';\n\n\nexport { default as installCore }         from './s-exp/operators/core';\nexport { default as installArithmetic }   from './s-exp/operators/arithmetic';\nexport { default as installSequence }     from './s-exp/operators/sequence';\nexport { default as installJsx }          from './s-exp/operators/jsx';\nexport { default as installConcurrent }   from './s-exp/operators/concurrent';\n\n\nimport { default as coreOperators }       from './s-exp/operators/core/core.operator';\nimport { default as coreMacros }          from './s-exp/operators/core/core.macro';\nimport { default as coreSymbols }         from './s-exp/operators/core/core.symbol';\n\nimport { default as arithmeticOperators } from './s-exp/operators/arithmetic/arithmetic.operator';\nimport { default as arithmeticMacros }    from './s-exp/operators/arithmetic/arithmetic.macro';\nimport { default as arithmeticSymbols }   from './s-exp/operators/arithmetic/arithmetic.symbol';\n\nimport { default as sequenceOperators }   from './s-exp/operators/sequence/sequence.operator';\nimport { default as sequenceMacros }      from './s-exp/operators/sequence/sequence.macro';\nimport { default as sequenceSymbols }     from './s-exp/operators/sequence/sequence.symbol';\n\nimport { default as jsxOperators }        from './s-exp/operators/jsx/jsx.operator';\nimport { default as jsxMacros }           from './s-exp/operators/jsx/jsx.macro';\nimport { default as jsxSymbols }          from './s-exp/operators/jsx/jsx.symbol';\n\nimport { default as concurrentOperators } from './s-exp/operators/concurrent/concurrent.operator';\nimport { default as concurrentMacros }    from './s-exp/operators/concurrent/concurrent.macro';\nimport { default as concurrentSymbols }   from './s-exp/operators/concurrent/concurrent.symbol';\n\n\nexport const builtinOperators = {\n    core: coreOperators,\n    arithmetic: arithmeticOperators,\n    sequence: sequenceOperators,\n    jsx: jsxOperators,\n    concurrent: concurrentOperators,\n};\n\nexport const builtinMacros = {\n    core: coreMacros,\n    arithmetic: arithmeticMacros,\n    sequence: sequenceMacros,\n    jsx: jsxMacros,\n    concurrent: concurrentMacros,\n};\n\nexport const builtinSymbols = {\n    core: coreSymbols,\n    arithmetic: arithmeticSymbols,\n    sequence: sequenceSymbols,\n    jsx: jsxSymbols,\n    concurrent: concurrentSymbols,\n};\n"],"sourceRoot":""}