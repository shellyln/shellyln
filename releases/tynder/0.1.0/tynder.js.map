{"version":3,"sources":["webpack://tynder/webpack/universalModuleDefinition","webpack://tynder/webpack/bootstrap","webpack://tynder/./node_modules/fruitsconfits/src/lib/object-parser.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/parser.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/string-parser.ts","webpack://tynder/./node_modules/fruitsconfits/src/lib/types.ts","webpack://tynder/./node_modules/liyad/src/s-exp/ast.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ops/helpers.ts","webpack://tynder/./node_modules/liyad/src/s-exp/compile.ops/index.ts","webpack://tynder/./node_modules/liyad/src/s-exp/consts.ts","webpack://tynder/./node_modules/liyad/src/s-exp/defaults.ts","webpack://tynder/./node_modules/liyad/src/s-exp/errors.ts","webpack://tynder/./node_modules/liyad/src/s-exp/evaluate.ts","webpack://tynder/./node_modules/liyad/src/s-exp/interpreters/index.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.fn.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.macro.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.operator.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/core.symbol.ts","webpack://tynder/./node_modules/liyad/src/s-exp/operators/core/index.ts","webpack://tynder/./node_modules/liyad/src/s-exp/parser.ts","webpack://tynder/./node_modules/liyad/src/s-exp/types.ts","webpack://tynder/./src/codegen.ts","webpack://tynder/./src/compiler.ts","webpack://tynder/./src/index.ts","webpack://tynder/./src/lib/codegen-graphql.ts","webpack://tynder/./src/lib/codegen-json-schema.ts","webpack://tynder/./src/lib/codegen-proto3.ts","webpack://tynder/./src/lib/codegen-ts.ts","webpack://tynder/./src/lib/errors.ts","webpack://tynder/./src/lib/escape.ts","webpack://tynder/./src/lib/reporter.ts","webpack://tynder/./src/lib/resolver.ts","webpack://tynder/./src/lib/util.ts","webpack://tynder/./src/operators.ts","webpack://tynder/./src/picker.ts","webpack://tynder/./src/serializer.ts","webpack://tynder/./src/types.ts","webpack://tynder/./src/types/tynder-schema-types.ts","webpack://tynder/./src/validator.ts"],"names":[],"mappings":"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","file":"tynder.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tynder\"] = factory();\n\telse\n\t\troot[\"tynder\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserFnWithCtx } from './types';\r\nimport { makeMessage,\r\n         zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules } from './parser';\r\n\r\n\r\n\r\nexport function objSequence<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: T) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let matched = true;\r\n\r\n            if (len >= needle.length) {\r\n                for (let i = 0; i < needle.length; i++) {\r\n                    if (! comparator(input.src[input.start + i], needle[i])) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                matched = false;\r\n            }\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"objSequence(${needle})\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClass<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            let index = -1;\r\n\r\n            const succeeded = len > 0 ? needles.some((needle, idx) => {\r\n                if (comparator(input.src[input.start], needle)) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            }) : false;\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"objClass(${needles.join(',')})\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassNot<T extends ArrayLike<T[number]>, C, R>(\r\n    helper: (token: T[number]) => R,\r\n    comparator: (a: T[number], b: T[number]) => boolean,\r\n    ): (...needles: Array<T[number]>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n\r\n            if (len > 0) {\r\n                for (const needle of needles) {\r\n                    let matched = true;\r\n\r\n                    if (! comparator(input.src[input.start], needle)) {\r\n                        matched = false;\r\n                        break;\r\n                    }\r\n\r\n                    if (matched) {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: input.src,\r\n                            pos: input.start,\r\n                            message: makeMessage(input, `operator \"objClassNot(${needles.join(',')})\"`),\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function objClassByNeedleFn<T extends ArrayLike<T[number]>, C, R>(\r\n        helper: (token: T[number]) => R,\r\n        comparator: (a: T[number], b: T[number]) => boolean,\r\n        ): (needle: (src: T[number]) => boolean) => ParserFnWithCtx<T, C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    // NOTE: <T> version `needles` type is `T`.\r\n    return (needle => {\r\n        return (input => {\r\n            const len = Math.max(0, input.end - input.start);\r\n            const matched = len > 0 ? needle(input.src[input.start]) : false;\r\n\r\n            return (matched ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + 1,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(input.src[input.start])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"objClassByNeedleFn\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function getObjectParsers<T extends ArrayLike<T[number]>, C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: T[number]) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n            comparator: (a: T[number], b: T[number]) => boolean,\r\n        }) {\r\n\r\n    const clsFn = objClassByNeedleFn<T, C, R>(params.rawToToken, params.comparator);\r\n\r\n    const isAny = clsFn(src => true);\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq: objSequence<T, C, R>(params.rawToToken, params.comparator),\r\n        cls: objClass<T, C, R>(params.rawToToken, params.comparator),\r\n        notCls: objClassNot<T, C, R>(params.rawToToken, params.comparator),\r\n        clsFn,\r\n        classes: {\r\n            any: isAny,\r\n        },\r\n        cat: transform<T, C, R>(params.concatTokens),\r\n        once: quantify<T, C, R>(1, 1),\r\n        repeat: quantify<T, C, R>(),\r\n        qty: (min?: number, max?: number) => quantify<T, C, R>(min, max), // TODO:\r\n        zeroWidth: (helper?: () => R) => zeroWidth<T, C, R>(helper),      // TODO:\r\n        err: (message: string) => zeroWidthError<T, C, R>(message),       // TODO:\r\n        beginning: (helper?: () => R) => beginning<T, C, R>(helper),      // TODO:\r\n        end: (helper?: () => R) => end<T, C, R>(helper),                  // TODO:\r\n        first: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => first<T, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => or<T, C, R>(...parsers),       // TODO:\r\n        combine: transform<T, C, R>(),\r\n        erase: transform<T, C, R>(tokens => []),\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<T, C, R>(fn),                            // TODO:\r\n        ahead: (...parsers: Array<ParserFnWithCtx<T, C, R>>) => lookAhead<T, C, R>(...parsers), // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<T, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<T, C, R>) => applyProductionRules<T, C, R>(args), // TODO:\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { ParserInputWithCtx,\r\n         ParseError,\r\n         parserInput,\r\n         ParserFnFailedResult,\r\n         ParserFnWithCtx } from './types';\r\n\r\n\r\n\r\nexport function makeErrorMessage<T extends ArrayLike<T[number]>, C>(\r\n        input: ParserInputWithCtx<T, C>, message?: string) {\r\n\r\n    let src = '';\r\n    if (typeof input.src === 'string') {\r\n        src = input.src.slice(Math.max(input.start - 5, 0), input.start + 55);\r\n\r\n        let ar = src.split(/\\r\\n|\\n|\\r/);\r\n        ar = ar.slice(0, 1)\r\n            .concat('          ^~~~~~~~')\r\n            .concat(...ar.slice(1));\r\n        src = ar.join('\\n') + '\\n\\n';\r\n    } else {\r\n        src = '     (object)\\n          ^~~~~~~~';\r\n        try {\r\n            src = '     ' +\r\n                JSON.stringify((input.src as any).slice(Math.max(input.start - 10, 0), input.start)) + '\\n          ' +\r\n                JSON.stringify((input.src as any).slice(input.start, input.start + 1)) + '\\n          ' +\r\n                JSON.stringify((input.src as any).slice(input.start + 1, input.start + 10));\r\n\r\n            let ar = src.split(/\\r\\n|\\n|\\r/);\r\n            ar = ar.slice(0, 2)\r\n                .concat('          ^~~~~~~~')\r\n                .concat(...ar.slice(2));\r\n            src = ar.join('\\n') + '\\n\\n';\r\n        } catch (e) {}\r\n    }\r\n\r\n    return (`parse error occured at position:${\r\n        input.start} ${\r\n        message ? ` ${message}` : ''}\\n     ${src}`);\r\n}\r\n\r\n\r\nexport function makeMessage<T extends ArrayLike<T[number]>, C>(\r\n        input: ParserInputWithCtx<T, C>, message?: string) {\r\n\r\n    return (`parse faild at position:${input.start} ${message ? ` ${message}` : ''}`);\r\n}\r\n\r\n\r\nexport function zeroWidth<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return ({\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function zeroWidthError<T extends ArrayLike<T[number]>, C, R>(\r\n        message: string\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        throw new ParseError(makeErrorMessage(input, message));\r\n        // return ({\r\n        //     succeeded: false,\r\n        //     error: true,\r\n        //     src: input.src,\r\n        //     pos: input.start,\r\n        //     message: makeErrorMessage(input, message),\r\n        // });\r\n    });\r\n}\r\n\r\n\r\nexport function beginning<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === 0 ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: makeMessage(input, 'operator \"beginning\"'),\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function end<T extends ArrayLike<T[number]>, C, R>(\r\n        helper?: () => R\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        return (input.start === input.end ? {\r\n            succeeded: true,\r\n            next: {\r\n                src: input.src,\r\n                start: input.start,\r\n                end: input.end,\r\n                context: input.context,\r\n            },\r\n            tokens: helper ? [helper()] : [],\r\n        } : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: makeMessage(input, 'operator \"end\"'),\r\n        });\r\n    });\r\n}\r\n\r\n// TODO: match by callback function parser\r\n// TODO: `nesting` parser\r\n\r\n\r\nexport function quantify<T extends ArrayLike<T[number]>, C, R>(\r\n        min?: number, max?: number\r\n        ): (parser: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    min = min || 0;\r\n    return (parser => {\r\n        return (input => {\r\n            let next = input;\r\n            const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n            for (;;) {\r\n                const x = parser(next);\r\n                if (x.succeeded) {\r\n                    next = x.next;\r\n                    matched.push({next: x.next, tokens: x.tokens});\r\n                    if (max && max === matched.length) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (x.error) {\r\n                        return x;\r\n                    }\r\n                    if (matched.length >= (min as number)) {\r\n                        break;\r\n                    } else {\r\n                        return ({\r\n                            succeeded: false,\r\n                            error: false,\r\n                            src: next.src,\r\n                            pos: next.start,\r\n                            message: makeMessage(next, 'operator \"quantify\"'),\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            if (matched.length > 0) {\r\n                const r: R[] = [];\r\n                for (const x of matched) {\r\n                    r.push(...x.tokens);\r\n                }\r\n                return ({\r\n                    succeeded: true,\r\n                    next: (matched[matched.length - 1]).next,\r\n                    tokens: r,\r\n                });\r\n            } else {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: {\r\n                        src: input.src,\r\n                        start: input.start,\r\n                        end: input.end,\r\n                        context: input.context,\r\n                    },\r\n                    tokens: [],\r\n                });\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function first<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let matched: {next: ParserInputWithCtx<T, C>, tokens: R[]} | null = null;\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched = {next: x.next, tokens: x.tokens};\r\n                break;\r\n            }\r\n            if (last) {\r\n                if (x.error) {\r\n                    if (!last.error || last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else if (last.pos < x.pos) {\r\n                    last = x;\r\n                }\r\n            } else {\r\n                last = x;\r\n            }\r\n        }\r\n\r\n        return (matched ? {\r\n            succeeded: true, next: matched.next, tokens: matched.tokens\r\n        } : last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: makeMessage(input, 'operator \"first\"'),\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function or<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        const matched: Array<{next: ParserInputWithCtx<T, C>, tokens: R[]}> = [];\r\n\r\n        let last: ParserFnFailedResult<T, C, R> | null = null;\r\n        for (const parser of parsers) {\r\n            const x = parser(input);\r\n            if (x.succeeded) {\r\n                matched.push({next: x.next, tokens: x.tokens});\r\n            } else {\r\n                if (last) {\r\n                    if (x.error) {\r\n                        if (!last.error || last.pos < x.pos) {\r\n                            last = x;\r\n                        }\r\n                    } else if (last.pos < x.pos) {\r\n                        last = x;\r\n                    }\r\n                } else {\r\n                    last = x;\r\n                }\r\n            }\r\n        }\r\n        if (matched.length > 0) {\r\n            const z = matched.reduce((a, b) => a.next.start >= b.next.start ? a : b);\r\n            return ({succeeded: true, next: z.next, tokens: z.tokens});\r\n        }\r\n\r\n        return (last ? last : {\r\n            succeeded: false,\r\n            error: false,\r\n            src: input.src,\r\n            pos: input.start,\r\n            message: makeMessage(input, 'operator \"or\"'),\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function transform<T extends ArrayLike<T[number]>, C, R>(\r\n        trans?: ((tokens: R[], input: ParserInputWithCtx<T, C>) => R[]), ctxTrans?: ((context: C) => C)\r\n        ): (...parsers: Array<ParserFnWithCtx<T, C, R>>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            let next = input;\r\n            const tokens: R[] = [];\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n                tokens.push(...x.tokens);\r\n            }\r\n\r\n            // TODO: report errors while transforming\r\n            const t2 = trans ? trans(tokens, input) : tokens;\r\n            return ({\r\n                succeeded: true,\r\n                next: ctxTrans ? {\r\n                    src: next.src,\r\n                    start: next.start,\r\n                    end: next.end,\r\n                    context: ctxTrans(next.context),\r\n                } : next,\r\n                tokens: t2,\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function combine<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return transform<T, C, R>()(...parsers);\r\n}\r\n\r\n\r\nexport function lookAhead<T extends ArrayLike<T[number]>, C, R>(\r\n        ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n        ): ParserFnWithCtx<T, C, R> {\r\n\r\n    return (input => {\r\n        let next = input;\r\n\r\n        for (const parser of parsers) {\r\n            const x = parser(next);\r\n            if (! x.succeeded) {\r\n                return x;\r\n            }\r\n            next = x.next;\r\n        }\r\n\r\n        return ({\r\n            succeeded: true,\r\n            next: input,\r\n            tokens: [],\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function lookBehind<T extends ArrayLike<T[number]>, C, R>(\r\n        n: number, helper?: () => R): (\r\n            ...parsers: Array<ParserFnWithCtx<T, C, R>>\r\n            ) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return ((...parsers) => {\r\n        return (input => {\r\n            if (input.start - n < 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: makeMessage(input, 'lookBehind: src is too short'),\r\n                });\r\n            }\r\n            let next = {\r\n                src: input.src,\r\n                start: input.start - n,\r\n                end: input.end,\r\n                context: input.context,\r\n            };\r\n\r\n            for (const parser of parsers) {\r\n                const x = parser(next);\r\n                if (! x.succeeded) {\r\n                    return x;\r\n                }\r\n                next = x.next;\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: input,\r\n                tokens: helper ? [helper()] : [],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ApplyProductionRulesArg<T extends ArrayLike<T[number]>, C, R> = {\r\n    rules: Array<ParserFnWithCtx<R[], C, R> |\r\n           {parser: ParserFnWithCtx<R[], C, R>, rtol: boolean}>,\r\n    maxApply?: number,\r\n    check: ParserFnWithCtx<R[], C, R>,\r\n};\r\n\r\nexport function applyProductionRules<T extends ArrayLike<T[number]>, C, R>(\r\n        args: ApplyProductionRulesArg<T, C, R>\r\n        ): (lexer: ParserFnWithCtx<T, C, R>) => ParserFnWithCtx<T, C, R> {\r\n\r\n    return (lexer => {\r\n        return (lexerInput => {\r\n            const lexResult = lexer(lexerInput);\r\n            if (! lexResult.succeeded) {\r\n                return lexResult;\r\n            }\r\n\r\n            const input = parserInput<R[], C>(lexResult.tokens, lexerInput.context);\r\n            let next = input;\r\n            let completed = false;\r\n\r\n            if (args.check(next).succeeded) {\r\n                return ({\r\n                    succeeded: true,\r\n                    next: lexResult.next,\r\n                    tokens: lexResult.tokens,\r\n                });\r\n            }\r\n\r\n            completed: for (let i = 0;\r\n                    args.maxApply !== void 0 ? i < args.maxApply : true; i++) {\r\n                let matched = false;\r\n\r\n                rules: for (const rule of args.rules) {\r\n                    const {parser, rtol} =\r\n                        typeof rule === 'function' ?\r\n                            {parser: rule, rtol: false} : rule;\r\n                    const len = next.src.length;\r\n\r\n                    for (let s = 0; s <= len; s++) {\r\n                        const x = parser({\r\n                            src: next.src,\r\n                            start: rtol ? len - s : s,\r\n                            end: next.src.length,\r\n                            context: next.context,\r\n                        });\r\n                        if (x.succeeded) {\r\n                            matched = true;\r\n                            const nextSrc = next.src.slice(0, rtol ? len - s : s);\r\n                            nextSrc.push(...x.tokens);\r\n                            nextSrc.push(...next.src.slice(x.next.start));\r\n                            next = {\r\n                                src: nextSrc,\r\n                                start: 0,\r\n                                end: nextSrc.length,\r\n                                context: x.next.context,\r\n                            };\r\n                            if (args.check(next).succeeded) {\r\n                                completed = true;\r\n                                break completed;\r\n                            }\r\n                            break rules;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (! matched) {\r\n                    break;\r\n                }\r\n            }\r\n            if (! completed) {\r\n                if (! args.check(next).succeeded) {\r\n                    throw new ParseError(makeErrorMessage(input));\r\n                }\r\n            }\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: lexResult.next,\r\n                tokens: next.src,\r\n            });\r\n        });\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { StringParserFnWithCtx } from './types';\r\nimport { makeMessage,\r\n         zeroWidth,\r\n         zeroWidthError,\r\n         beginning,\r\n         end,\r\n         quantify,\r\n         first,\r\n         or,\r\n         transform,\r\n         lookAhead,\r\n         lookBehind,\r\n         ApplyProductionRulesArg,\r\n         applyProductionRules } from './parser';\r\n\r\n\r\n\r\nexport function charSequence<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: string) => StringParserFnWithCtx<C, R> {\r\n\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            return (src.startsWith(needle) ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needle.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(needle)],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"charSequence(${needle})\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClass<C, R>(\r\n        helper: (token: string) => R\r\n        ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            let index = -1;\r\n\r\n            const succeeded = needles.some((needle, idx) => {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    index = idx;\r\n                    return true;\r\n                }\r\n            });\r\n\r\n            return (succeeded ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + needles[index].length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(needles[index])],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"charClass(${needles.join(',')})\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassNot<C, R>(\r\n    helper: (token: string) => R\r\n    ): (...needles: string[]) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return ((...needles) => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n\r\n            for (const needle of needles) {\r\n                const matched = src.startsWith(needle);\r\n                if (matched) {\r\n                    return ({\r\n                        succeeded: false,\r\n                        error: false,\r\n                        src: input.src,\r\n                        pos: input.start,\r\n                        message: makeMessage(input, `operator \"charClassNot(${needles.join(',')})\"`),\r\n                    });\r\n                }\r\n            }\r\n            const p = input.src.codePointAt(input.start);\r\n            if (p === void 0) {\r\n                return ({\r\n                    succeeded: false,\r\n                    error: false,\r\n                    src: input.src,\r\n                    pos: input.start,\r\n                    message: makeMessage(input, `operator \"charClassNot(${needles.join(',')})\"`),\r\n                });\r\n            }\r\n            const c = String.fromCodePoint(p);\r\n\r\n            return ({\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + c.length,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(c)],\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function charClassByNeedleFn<C, R>(\r\n        helper: (token: string) => R\r\n        ): (needle: (src: string) => number) => StringParserFnWithCtx<C, R> {\r\n\r\n    // NOTE: needles[i] should be one character. surrogate pair and/or ligature are accepted.\r\n    return (needle => {\r\n        return (input => {\r\n            const src = input.src.slice(input.start, input.end);\r\n            const len = needle(src);\r\n\r\n            return (len >= 0 ? {\r\n                succeeded: true,\r\n                next: {\r\n                    src: input.src,\r\n                    start: input.start + len,\r\n                    end: input.end,\r\n                    context: input.context,\r\n                },\r\n                tokens: [helper(src.substring(0, len))],\r\n            } : {\r\n                succeeded: false,\r\n                error: false,\r\n                src: input.src,\r\n                pos: input.start,\r\n                message: makeMessage(input, `operator \"charClassByNeedleFn\"`),\r\n            });\r\n        });\r\n    });\r\n}\r\n\r\n\r\nexport function getStringParsers<C, R>(\r\n        params: {\r\n            rawToToken: (rawToken: string) => R,\r\n            concatTokens: (tokens: R[]) => R[],\r\n        }) {\r\n\r\n    const seq = charSequence<C, R>(params.rawToToken);\r\n    const cls = charClass<C, R>(params.rawToToken);\r\n    const notCls = charClassNot<C, R>(params.rawToToken);\r\n    const clsFn = charClassByNeedleFn<C, R>(params.rawToToken);\r\n    const cat = transform<string, C, R>(params.concatTokens);\r\n    const once = quantify<string, C, R>(1, 1);\r\n    const repeat = quantify<string, C, R>();\r\n    // TODO: reduce unneccessary call for adding types.\r\n    const qty = (min?: number, max?: number) => quantify<string, C, R>(min, max);\r\n    const combine = transform<string, C, R>();\r\n    const erase = transform<string, C, R>(tokens => []);\r\n\r\n    const isAlpha = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z')) ? c.length : -1);\r\n    });\r\n\r\n    const isUpper = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('A' <= c && c <= 'Z') ? c.length : -1);\r\n    });\r\n\r\n    const isLower = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('a' <= c && c <= 'z') ? c.length : -1);\r\n    });\r\n\r\n    const isNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isNonZeroNumber = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('1' <= c && c <= '9') ? c.length : -1);\r\n    });\r\n\r\n    const isBinNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '1') ? c.length : -1);\r\n    });\r\n\r\n    const isOctNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ('0' <= c && c <= '7') ? c.length : -1);\r\n    });\r\n\r\n    const isHexNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'F') ||\r\n            ('a' <= c && c <= 'f') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isAlNum = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            ('A' <= c && c <= 'Z') ||\r\n            ('a' <= c && c <= 'z') ||\r\n            ('0' <= c && c <= '9')) ? c.length : -1);\r\n    });\r\n\r\n    const isSpace = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '​\\u2028\\u2029\\u202f\\u205f​\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isSpaceWithinSingleLine = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((' \\f\\t\\v​\\u00a0\\u1680​\\u180e' +\r\n            '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n            '​\\u2028\\u2029\\u202f\\u205f​\\u3000\\ufeff').includes(c) ? c.length : -1);\r\n    });\r\n\r\n    const isControl = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return ((\r\n            (0x0000 <= p && p <= 0x001f) ||\r\n            (0x007f <= p && p <= 0x009f)) ? c.length : -1);\r\n    });\r\n\r\n    const isWord = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return (\r\n            ((' \\f\\n\\r\\t\\v​\\u00a0\\u1680​\\u180e' +\r\n              '\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a' +\r\n              '​\\u2028\\u2029\\u202f\\u205f​\\u3000\\ufeff').includes(c)) ||\r\n            ((0x0000 <= p && p <= 0x001f) ||\r\n             (0x007f <= p && p <= 0x009f)) ?\r\n            -1 : c.length);\r\n    });\r\n\r\n    const isNewline = cls('\\r\\n', '\\n', '\\r');\r\n\r\n    const isAny = clsFn(src => {\r\n        const p = src.codePointAt(0);\r\n        if (p === void 0) {\r\n            return -1;\r\n        }\r\n        const c = String.fromCodePoint(p);\r\n        return c.length;\r\n    });\r\n\r\n\r\n    const binSep =\r\n        first(isBinNum, cls('_'));\r\n    const octSep =\r\n        first(isOctNum, cls('_'));\r\n    const hexSep =\r\n        first(isHexNum, cls('_'));\r\n\r\n    const binaryIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isBinNum), repeat(binSep)), );\r\n    const octalIntegerNumber = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isOctNum), repeat(octSep)), );\r\n    const hexIntegerValue = (...prefixes: Array<StringParserFnWithCtx<C, R>>) =>\r\n        combine(erase(first(...prefixes)),\r\n            cat(once(isHexNum), repeat(hexSep)), );\r\n    const decimalIntegerNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), )));\r\n    const bigDecimalIntegerNumber =\r\n        combine(cat(decimalIntegerNumber,\r\n            erase(seq('n')), ));\r\n    const floatingPointNumber =\r\n        combine(cat(qty(0, 1)(cls('+', '-')),\r\n            first(combine(once(isNonZeroNumber), repeat(first(isNumber, cls('_')))),\r\n                seq('0'), ),\r\n            qty(0, 1)(combine(seq('.'),\r\n                qty(1)(first(isNumber, cls('_'))), )),\r\n            qty(0, 1)(combine(cls('E', 'e'), qty(0, 1)(cls('+', '-')),\r\n                first(combine(once(isNonZeroNumber), repeat(isNumber)), seq('0')), ))));\r\n\r\n    // TODO: reduce unneccessary call for adding types.\r\n    return ({\r\n        seq,\r\n        cls,\r\n        notCls,\r\n        clsFn,\r\n        classes: {\r\n            alpha: isAlpha,\r\n            upper: isUpper,\r\n            lower: isLower,\r\n            num: isNumber,\r\n            nonzero: isNonZeroNumber,\r\n            bin: isBinNum,\r\n            oct: isOctNum,\r\n            hex: isHexNum,\r\n            alnum: isAlNum,\r\n            space: isSpace,\r\n            spaceWithinSingleLine: isSpaceWithinSingleLine,\r\n            ctrl: isControl,\r\n            newline: isNewline,\r\n            word: isWord,\r\n            any: isAny,\r\n        },\r\n        numbers: {\r\n            bin: binaryIntegerNumber,\r\n            oct: octalIntegerNumber,\r\n            hex: hexIntegerValue,\r\n            int: decimalIntegerNumber,\r\n            bigint: bigDecimalIntegerNumber,\r\n            float: floatingPointNumber,\r\n        },\r\n        cat,\r\n        once,\r\n        repeat,\r\n        qty,\r\n        zeroWidth: (helper?: () => R) => zeroWidth<string, C, R>(helper), // TODO:\r\n        err: (message: string) => zeroWidthError<string, C, R>(message),  // TODO:\r\n        beginning: (helper?: () => R) => beginning<string, C, R>(helper), // TODO:\r\n        end: (helper?: () => R) => end<string, C, R>(helper),             // TODO:\r\n        first: (...parsers: Array<StringParserFnWithCtx<C, R>>) => first<string, C, R>(...parsers), // TODO:\r\n        or: (...parsers: Array<StringParserFnWithCtx<C, R>>) => or<string, C, R>(...parsers),       // TODO:\r\n        combine,\r\n        erase,\r\n        trans: (fn: (tokens: R[]) => R[]) => transform<string, C, R>(fn),                                 // TODO:\r\n        ahead: (...parsers: Array<StringParserFnWithCtx<C, R>>) => lookAhead<string, C, R>(...parsers),   // TODO:\r\n        behind: (n: number, helper?: () => R) => lookBehind<string, C, R>(n, helper),\r\n        rules: (args: ApplyProductionRulesArg<string, C, R>) => applyProductionRules<string, C, R>(args), // TODO:\r\n    });\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nexport interface ParserInputWithCtx<T extends ArrayLike<T[number]>, C> {\r\n    src: T;\r\n    start: number;\r\n    end: number;\r\n    context: C;\r\n}\r\nexport type ParserInput<T extends ArrayLike<T[number]>> = ParserInputWithCtx<T, undefined>;\r\nexport type StringParserInputWithCtx<C> = ParserInputWithCtx<string, C>;\r\nexport type StringParserInput = StringParserInputWithCtx<undefined>;\r\n\r\nexport class ParseError extends Error {}\r\n\r\n\r\nexport function parserInput<T extends ArrayLike<T[number]>>(src: T): ParserInputWithCtx<T, undefined>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context: C): ParserInputWithCtx<T, C>;\r\nexport function parserInput<T extends ArrayLike<T[number]>, C>(src: T, context?: C): ParserInputWithCtx<T, C> {\r\n    return ({\r\n        src,\r\n        start: 0,\r\n        end: src.length,\r\n        context: context as any,\r\n    });\r\n}\r\n\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnSucceededResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: true, next: ParserInputWithCtx<T, C>, tokens: R[]};\r\n\r\n// tslint:disable-next-line: interface-over-type-literal\r\nexport type ParserFnFailedResult<T extends ArrayLike<T[number]>, C, R> =\r\n    {succeeded: false, error: boolean, src: T, pos: number, message: string};\r\n\r\nexport type ParserFnWithCtx<T extends ArrayLike<T[number]>, C, R> =\r\n    (input: ParserInputWithCtx<T, C>) =>\r\n        ParserFnSucceededResult<T, C, R> |\r\n        ParserFnFailedResult<T, C, R>;\r\n\r\nexport type ParserFn<T extends ArrayLike<T[number]>, R> = ParserFnWithCtx<T, undefined, R>;\r\nexport type StringParserFnWithCtx<C, R> = ParserFnWithCtx<string, C, R>;\r\nexport type StringParserFn<R> = StringParserFnWithCtx<undefined, R>;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol }     from './types';\r\n\r\n\r\n\r\nexport function quote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.quote}, x];\r\n}\r\n\r\n\r\nexport function isQuoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.quote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function backquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.backquote}, x];\r\n}\r\n\r\n\r\nexport function isBackquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.backquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function wrapByUnquote(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.unquote}, x];\r\n}\r\n\r\n\r\nexport function isUnquoted(state: SxParserState, x: any) {\r\n    if (Array.isArray(x) && 0 < x.length) {\r\n        const q = isSymbol(x);\r\n        if (q && q.symbol === state.config.reservedNames.unquote) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function spread(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.spread}, x];\r\n}\r\n\r\n\r\nexport function splice(state: SxParserState, x: any) {\r\n    return [{symbol: state.config.reservedNames.splice}, x];\r\n}\r\n\r\n\r\nexport function isSymbol(x: any, name?: string): SxSymbol | null {\r\n    if (x && typeof x === 'object' && Object.prototype.hasOwnProperty.call(x, 'symbol')) {\r\n        if (name !== void 0) {\r\n            return x.symbol === name ? x : null;\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         SxFuncInfo,\r\n         CompilerOperator,\r\n         CompilerContext  }           from './types';\r\nimport { isSymbol }                   from './ast';\r\nimport { getCapturedScopes,\r\n         optimizeTailCall }           from './evaluate';\r\nimport { checkUnsafeVarNamesEx }      from './errors';\r\nimport { applyMacros,\r\n         stripQuoteOrPass,\r\n         resolveValueSymbol_dynamic } from './compile.ops/helpers';\r\nimport { registerOperators }          from './compile.ops';\r\n\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction compileCore(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[], _$_vars: any[]) {\r\n\r\n    function makeScope(scoped: () => void) {\r\n        const varNamesCopy = new Map<string, string>();\r\n        for (const x of ctx.varNames.entries()) {\r\n            varNamesCopy.set(x[0], x[1]);\r\n        }\r\n        scoped();\r\n        ctx.varNames = varNamesCopy;\r\n    }\r\n\r\n\r\n    function compileValue(b: any) {\r\n        let compFnBody = '';\r\n        if (b === null) {\r\n            compFnBody += '(null)';\r\n        } else if (b === void 0) {\r\n            compFnBody += '(void 0)';\r\n        } else switch (typeof b) {\r\n        case 'boolean': case 'number':\r\n            compFnBody += `(${String(b)})`;\r\n            break;\r\n        case 'object':\r\n            if (isSymbol(b)) {\r\n                const sym = b as SxSymbol;\r\n                checkUnsafeVarNamesEx('(compiler)compileValue', ctx.varNames, sym.symbol);\r\n                if (ctx.varNames.has(sym.symbol)) {\r\n                    compFnBody += `(${ctx.varNames.get(sym.symbol)})`;\r\n                } else {\r\n                    _$_vars[ctx.varsCount] = sym.symbol;\r\n                    compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n                }\r\n                break;\r\n            } else {}\r\n            // FALL_THRU\r\n        default:\r\n            _$_vars[ctx.varsCount] = b;\r\n            compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n            break;\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    function compileToken(body: any[], i: number) {\r\n        let compFnBody = '';\r\n        const b = body[i];\r\n        if (Array.isArray(b)) {\r\n            if (0 < b.length) {\r\n                const r: SxToken = applyMacros(state, b);\r\n                if (Array.isArray(r)) {\r\n                    if (0 < r.length) {\r\n                        if (isSymbol(r[0])) {\r\n                            const sym = r[0] as SxSymbol;\r\n                            const args = r.slice(1);\r\n                            checkUnsafeVarNamesEx('(compiler)compileToken', ops, sym.symbol);\r\n                            if (ops.has(sym.symbol)) {\r\n                                compFnBody += (ops.get(sym.symbol) as CompilerOperator)(r, args);\r\n                            } else {\r\n                                if (sym.symbol === state.config.reservedNames.spread) {\r\n                                    compFnBody += `...(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else if (state.funcMap.has(sym.symbol)) {\r\n                                    _$_vars[ctx.varsCount] = (state.funcMap.get(sym.symbol) as SxFuncInfo).fn(state, '');\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                } else if (ctx.varNames.has(sym.symbol)) {\r\n                                    compFnBody += `(${String(ctx.varNames.get(sym.symbol))})(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')})`;\r\n                                } else {\r\n                                    _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, sym.symbol);\r\n                                    compFnBody += `((_$_vars[${String(ctx.varsCount++)}])()(${\r\n                                        args.map((x) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                }\r\n                            }\r\n                        } else {\r\n                            switch (typeof r[0]) {\r\n                            case 'function':\r\n                                _$_vars[ctx.varsCount] = r[0];\r\n                                compFnBody += `((_$_vars[${String(ctx.varsCount++)}])(${\r\n                                    r.slice(1).map((x, idx, arr) => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n                                break;\r\n                            default:\r\n                                throw new Error(`[SX] compileToken: First item of list is not a function: ${JSON.stringify(r[0])}.`);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        compFnBody += '([])';\r\n                    }\r\n                } else {\r\n                    compFnBody += compileValue(b);\r\n                }\r\n            } else {\r\n                compFnBody += '([])';\r\n            }\r\n        } else {\r\n            compFnBody += compileValue(b);\r\n        }\r\n        return compFnBody;\r\n    }\r\n\r\n\r\n    const ctx: CompilerContext = {\r\n        _$_vars,\r\n        varsCount: 1,\r\n        varNames: new Map<string, string>(),\r\n        varNamesCount: 0,\r\n        varDefs: 'var x0;',\r\n        ops: new Map<string, CompilerOperator>(),\r\n        makeScope,\r\n        compileToken,\r\n    };\r\n\r\n    registerOperators(state, ctx);\r\n    const ops = ctx.ops;\r\n\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    // set 'this' object\r\n    ctx.varNames.set(state.config.reservedNames.thiz, `(this===(Function('return this')())?null:(this===void 0?null:this))`);\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n    if (capturedScopes) {\r\n        for (const x in capturedScopes) {\r\n            if (Object.prototype.hasOwnProperty.call(capturedScopes, x)) {\r\n                _$_vars[ctx.varsCount++] = x;\r\n                _$_vars[ctx.varsCount] = capturedScopes[x];\r\n                ctx.varNames.set(x, `(_$_vars[${String(ctx.varsCount)}][_$_vars[${String(ctx.varsCount - 1)}]])`);\r\n                ctx.varsCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    const compFormalArgs = `${formalArgs.map((x, i) => {\r\n        ctx.varNames.set(formalArgs[i].symbol, 'a' + i);\r\n        return `${(lastIsSpread && i === formalArgs.length - 1) ? '...' : ''}a${i}`;\r\n    }).join(',')}`;\r\n\r\n    const compFnBodyRoot = `return(${fnBody.map((x, i) => compileToken(fnBody, i)).join(',')})`;\r\n    return `(function(${compFormalArgs}){\"strict\";${ctx.varDefs}${compFnBodyRoot}})`;\r\n}\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nfunction evalCompiledLambda(_$_state: SxParserState, _$_vars: any[], code: string) {\r\n    // tslint:disable-next-line:no-eval\r\n    _$_vars[0] = eval(code);\r\n    return _$_vars[0];\r\n}\r\n\r\n\r\nexport function compileLambda(state: SxParserState, formalArgs: SxSymbol[], lastIsSpread: boolean, fnBody: any[]) {\r\n    // tslint:disable-next-line:variable-name\r\n    const _$_vars: any[] = [];\r\n    return evalCompiledLambda(state, _$_vars, compileCore(state, formalArgs, lastIsSpread, fnBody, _$_vars));\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxToken }             from '../types';\r\nimport { isSymbol }            from '../ast';\r\nimport { resolveSplice,\r\n         resolveMacro,\r\n         resolveValueSymbol,\r\n         getScope }            from '../evaluate';\r\nimport { setEvaluationCount,\r\n         checkUnsafeVarNamesEx,\r\n         checkUnsafeVarNames } from '../errors';\r\n\r\n\r\n\r\nexport function applyMacros(state: SxParserState, tok: SxToken) {\r\n    let r: SxToken = tok;\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                break;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function stripQuote(state: SxParserState, tok: SxToken) {\r\n    if (! (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote))) {\r\n        throw new Error(`[SX] stripQuote: token is not quoted.`);\r\n    }\r\n    return (tok as any)[1];\r\n}\r\n\r\n\r\nexport function stripQuoteOrPass(state: SxParserState, tok: SxToken) {\r\n    if (Array.isArray(tok) && isSymbol((tok as any)[0], state.config.reservedNames.quote)) {\r\n        return (tok as any)[1];\r\n    } else {\r\n        return tok;\r\n    }\r\n}\r\n\r\n\r\nexport function getScope_stateApplied(state: SxParserState) {\r\n    return (function() { return getScope(state); });\r\n}\r\n\r\n\r\nexport function resolveValueSymbol_dynamic(state: SxParserState, varName: string) {\r\n    checkUnsafeVarNames('(compiler)resolveValueSymbol_dynamic', varName);\r\n    return (function(){ return resolveValueSymbol(state, {symbol: varName}); });\r\n}\r\n\r\nexport function checkUnsafeVarNames_dynamic(name: string) {\r\n    return (function(varName: string){ return checkUnsafeVarNames(name, varName); });\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         CompilerContext }             from '../types';\r\nimport { isSymbol }                    from '../ast';\r\nimport { checkParamsLength,\r\n         checkUnsafeVarNamesEx,\r\n         checkUnsafeVarNames }         from '../errors';\r\nimport { stripQuote,\r\n         stripQuoteOrPass,\r\n         getScope_stateApplied,\r\n         resolveValueSymbol_dynamic,\r\n         checkUnsafeVarNames_dynamic } from './helpers';\r\n\r\n\r\n\r\nexport function registerOperators(state: SxParserState, ctx: CompilerContext) {\r\n    const {\r\n        _$_vars,\r\n        ops,\r\n        makeScope,\r\n        compileToken,\r\n    } = ctx;\r\n\r\n\r\n    ops.set(state.config.reservedNames.quote, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        _$_vars[ctx.varsCount] = r[1];\r\n        compFnBody += `(_$_vars[${String(ctx.varsCount++)}])`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.self, function(r: SxToken[], args: SxToken[]) {\r\n        let compFnBody = '';\r\n        compFnBody += `((_$_vars[0])(${\r\n            args.map(x => compileToken([stripQuoteOrPass(state, x)], 0)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if condition 't-expr 'f-expr)\r\n        //  -> (if condition is true ) S expr  : t-expr\r\n        //  -> (if condition is false) S expr  : f-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if', args, 2, 3);\r\n        compFnBody += `(${compileToken(r, 1)}?(${\r\n            compileToken([stripQuote(state, r[2])], 0)}):(${\r\n            compileToken([stripQuote(state, r[3])], 0)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__if-null', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__if-null condition 'null-expr)\r\n        //  -> (if condition is not null ) S expr  : condition\r\n        //  -> (if condition is null)      S expr  : null-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__if-null', args, 2, 2);\r\n        compFnBody += `((()=>{let _$_rv=${compileToken(r, 1)};return _$_rv?_$_rv:(${\r\n            compileToken([stripQuote(state, r[2])], 0)}});})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__cond', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        //  -> (if (eval condI) is true ) S expr  : exprI\r\n        //  -> (if no matched)            S expr  : null\r\n        let compFnBody = '';\r\n        {\r\n            checkParamsLength('compileToken:$__cond', args, 1);\r\n            compFnBody += `(`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `${compileToken([stripQuote(state, args[p])], 0)}?(${\r\n                    compileToken([stripQuote(state, args[p + 1])], 0)}):(`;\r\n            }\r\n            compFnBody += `null`;\r\n            for (let p = 0; p < args.length; p += 2) {\r\n                compFnBody += `)`;\r\n            }\r\n            compFnBody += `)`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__while', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-while', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)}){_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n            }}return _$_rv})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__do-until', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n        //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n        //  -> (else)                                          S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__do-until', args, 1);\r\n        compFnBody += `((()=>{let _$_rv=null;do{_$_rv=${\r\n            r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}}}while(!${\r\n            compileToken([stripQuote(state, r[1])], 0)})return _$_rv)())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__repeat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n        //  -> (if n > 0) S expr  : exprN\r\n        //  -> (else)     S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__repeat', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__repeat : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_n)=>{let _$_rv=null;for(let ${name}=0;${name}<_$_n;${name}++){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__for', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n        //  -> (if list.length > 0) S expr  : exprN\r\n        //  -> (else)               S expr  : null\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__for', args, 2);\r\n        if (! isSymbol(args[0])) {\r\n            throw new Error(`[SX] compileToken: $__for : args[0] is not symbol.`);\r\n        }\r\n        makeScope(() => {\r\n            const name = 'v' + ctx.varNamesCount++;\r\n            ctx.varNames.set((args[0] as SxSymbol).symbol, name);\r\n            compFnBody += `(((_$_l)=>{let _$_rv=null;for(const ${name} of _$_l){_$_rv=${\r\n                r.slice(2).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')\r\n                }}return _$_rv})(${compileToken(args, 1)}))`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__scope', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n        //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n        //  -> (else)               S expr  : exprN\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__scope', args, 2);\r\n        // r[1]: isBlockLocal\r\n        // r[2]: returnMultiple\r\n        if (! Array.isArray(r[3])) {\r\n            throw new Error(`[SX] compileToken: $__scope : args[2] is not array.`);\r\n        }\r\n        makeScope(() => {\r\n            for (const x of stripQuote(state, r[3]) as any[]) {\r\n                let name = '';\r\n                if (Array.isArray(x)) {\r\n                    if (x.length < 1) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is too short.`);\r\n                    }\r\n                    if (! isSymbol(x[0])) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?][0] is not symbol.`);\r\n                    }\r\n                    name = x[0].symbol;\r\n                    compFnBody += `(${'v' + ctx.varNamesCount}=${compileToken(x, 1)})`;\r\n                } else {\r\n                    if (! isSymbol(x)) {\r\n                        throw new Error(`[SX] compileToken: $__scope : args[0][?] is not symbol.`);\r\n                    }\r\n                    name = x.symbol;\r\n                }\r\n                ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n                ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\r\n            }\r\n            const s = `${r.slice(4).map((x) => compileToken([stripQuote(state, x)], 0)).join(',')}`;\r\n            compFnBody += r[2] ? `[${s}]` : `(${s})`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__try', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__try 'expr 'catch-expr)\r\n        //  ->                               S expr  : expr\r\n        //  -> (if error is raised in expr)  S expr  : catch-expr\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__try', args, 1, 2);\r\n        compFnBody += `((()=>{try{${\r\n            compileToken([stripQuote(state, r[1])], 0)}}catch(e${\r\n            ctx.varNamesCount}){let e${ctx.varNamesCount + 1}=(_$_vars[${String(ctx.varsCount)}])();`;\r\n        _$_vars[ctx.varsCount++] = getScope_stateApplied(state);\r\n        makeScope(() => {\r\n            ctx.varNames.set('$error', 'e' + ctx.varNamesCount++);\r\n            ctx.varNames.set('$parent', 'e' + ctx.varNamesCount++);\r\n            compFnBody += `${\r\n                compileToken([stripQuote(state, r[2])], 0)}}})())`;\r\n        });\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.raise, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($raise 'expr)\r\n        //  -> S expr  : -\r\n        let compFnBody = '';\r\n        compFnBody += `((()=>{throw ${\r\n            compileToken([stripQuoteOrPass(state, r[1])], 0)}})())`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$boolean', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($boolean any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$boolean', args, 1, 1);\r\n        compFnBody += `((x0=${compileToken(args, 0)\r\n            }),(Array.isArray(x0)&&x0.length===0?false:boolean(x0)))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__get', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__get', args, 1);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__get : operand is not symbol: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = symName;\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        compFnBody += `((${vName})${r.slice(2).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                compileToken(arr, idx)}]`).join('')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__let', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__let 'nameStrOrSymbol expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__let', args, 2, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ? quoted.symbol : (typeof quoted === 'string' ? quoted : null);\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__let : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        if (! ctx.varNames.has(name)) {\r\n            ctx.varDefs += `var v${ctx.varNamesCount}=void 0;`;\r\n            ctx.varNames.set(name, 'v' + ctx.varNamesCount++);\r\n        }\r\n        compFnBody += `(${ctx.varNames.get(name)}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__set', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : any\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__set', args, 2);\r\n        const quoted = stripQuote(state, r[1]);\r\n        const name = isSymbol(quoted) ?\r\n            quoted.symbol :\r\n            (typeof quoted === 'string' ?\r\n                quoted :\r\n                (Array.isArray(quoted) ?\r\n                    (isSymbol(quoted[0]) ?\r\n                        quoted[0].symbol :\r\n                        (typeof quoted[0] === 'string' ? quoted[0] : null)\r\n                    ) :\r\n                    null\r\n                )\r\n            );\r\n        if (typeof name !== 'string') {\r\n            throw new Error(`[SX] compileToken: $__set : operand is not rvalue: ${JSON.stringify(r[1])}.`);\r\n        }\r\n        let vName = '';\r\n        if (ctx.varNames.has(name)) {\r\n            vName = ctx.varNames.get(name) as string;\r\n        } else {\r\n            _$_vars[ctx.varsCount] = resolveValueSymbol_dynamic(state, name);\r\n            vName = `_$_vars[${String(ctx.varsCount++)}]`;\r\n        }\r\n        const regToVars = (symName: string) => {\r\n            _$_vars[ctx.varsCount] = checkUnsafeVarNames('compileToken:$__set', symName);\r\n            return `_$_vars[${String(ctx.varsCount++)}]`;\r\n        };\r\n        let checkNameCalled = false;\r\n        let checkNamePos = '';\r\n        const checkName = (str: string) => {\r\n            if (! checkNameCalled) {\r\n                _$_vars[ctx.varsCount] = checkUnsafeVarNames_dynamic('compileToken:$__set');\r\n                checkNamePos = String(ctx.varsCount++);\r\n                checkNameCalled = true;\r\n            }\r\n            return `(_$_vars[${checkNamePos}](${str}))`;\r\n        };\r\n        compFnBody += `((${vName})${(Array.isArray(quoted) ? quoted.slice(1) : []).map((x, idx, arr) => `[${\r\n            isSymbol(arr[idx]) ?\r\n                regToVars((arr as any)[idx].symbol) :\r\n                checkName(compileToken(arr, idx))}]`).join('')}=${compileToken(r, 2)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set(state.config.reservedNames.not, function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not any)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$not', args, 1, 1);\r\n        compFnBody += `(!${compileToken(args, 0)})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__and 'expr1 ... 'exprN)\r\n        //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n        //  -> (else)                                                     S expr  : expr-i (false left most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__and', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('&&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$__or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($__or 'expr1 ... 'exprN)\r\n        //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n        //  -> (else)                                                  S expr  : expr-i (false right most)\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$__or', args, 1);\r\n        compFnBody += `(${args.map((x) => compileToken([stripQuote(state, x)], 0)).join('||')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('===', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($eq arg1 arg2)\r\n        //  -> (if arg1 === arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:===', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('===')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($not-eq arg1 arg2)\r\n        //  -> (if arg1 !== arg2)  S expr  : true\r\n        //  -> (else)              S expr  : false\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('==', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (== a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:==', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('==')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('!=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (!= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:!=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('!=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (< a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (> a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>=', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>= a b)\r\n        //  -> S expr  : boolean\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<=', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>=')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$concat', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($concat listOrString1 ... listOrStringN)\r\n        //  -> S expr  : listOrString\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$concat', args, 1);\r\n        let w1 = '';\r\n        if (Array.isArray(args[0]) && isSymbol((args[0] as any)[0], state.config.reservedNames.spread)) {\r\n            const w0 = compileToken(args[0] as any, 1);\r\n            w1 = `(${w0}[0]).concat((${w0}.length>1?${w0}[1]:(typeof ${w0}[0]==='string'?'':[])),`;\r\n        } else {\r\n            w1 = `${compileToken(args as any, 0)}.concat(`;\r\n        }\r\n        compFnBody += `(${w1}${\r\n            args.slice(1).map((x, idx, arr) => compileToken(arr, idx)).join(',')}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('+', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (+ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:+', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n            };return _$_rv.reduce((x,y)=>x+y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('+')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('-', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (- number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:-', args, 1);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return (_$_rv.length>1?(_$_rv.reduce((x,y)=>x-y)):(_$_rv.length>0?-_$_rv[0]:NaN));})())`;\r\n        } else {\r\n            compFnBody += `(${r.length > 2 ?\r\n                args.map((x, idx, arr) => compileToken(arr, idx)).join('-') :\r\n                `-(${String(compileToken(r, 1))})`})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('*', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (* number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:*', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x*y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('*')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('**', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (** number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:**', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x**y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('**')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('/', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (/ number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:/', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x/y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('/')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('%', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (% number1 ... numberN)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:%', args, 2);\r\n\r\n        let hasSpread = false;\r\n        args.map((x, idx, arr) => {\r\n            if (Array.isArray(x) && isSymbol((x as any)[0], state.config.reservedNames.spread)) {\r\n                hasSpread = true;\r\n            }\r\n        });\r\n        if (hasSpread) {\r\n            compFnBody += `((()=>{let _$_rv=[];${\r\n                args.map((x, idx, arr) => `_$_rv.push(${compileToken(arr, idx)})`).join(';')\r\n                };return _$_rv.reduce((x,y)=>x%y);})())`;\r\n        } else {\r\n            compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('%')})`;\r\n        }\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('<<', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (<< number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:<<', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('<<')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('>>>', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: (>>> number shift)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:>>>', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('>>>')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-not', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-not number)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-not', args, 1, 1);\r\n        compFnBody += `(~(${compileToken(r, 1)}))`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-and', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-and numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-and', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('&')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-or', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-or numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-or', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('|')})`;\r\n        return compFnBody;\r\n    });\r\n\r\n\r\n    ops.set('$bit-xor', function(r: SxToken[], args: SxToken[]) {\r\n        // S expression: ($bit-xor numberA numberB)\r\n        //  -> S expr  : number\r\n        let compFnBody = '';\r\n        checkParamsLength('compileToken:$bit-xor', args, 2, 2);\r\n        compFnBody += `(${args.map((x, idx, arr) => compileToken(arr, idx)).join('^')})`;\r\n        return compFnBody;\r\n    });\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n// tslint:disable-next-line:function-constructor\r\nexport const globalObj = Function('return this')();\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxReservedNames,\r\n         SxParserConfig } from './types';\r\n\r\n\r\n\r\nexport const defaultReservedNames: SxReservedNames = {\r\n    eval: '$eval',\r\n    quote: '$quote',\r\n    backquote: '$backquote',\r\n    unquote: '$unquote',\r\n    spread: '$spread',\r\n    splice: '$splice',\r\n\r\n    car: '$car',\r\n    cdr: '$cdr',\r\n    cons: '$cons',\r\n    atom: '$atom',\r\n    eq: '$eq',\r\n    list: '$list',\r\n\r\n    let: '$clisp-let',\r\n    lambda: '$lambda',\r\n    self: '$self',\r\n    defun: '$defun',\r\n    thiz: '$this',\r\n\r\n    if: '$if',\r\n    cond: '$cond',\r\n\r\n    while: '$while',\r\n    doWhile: '$do-while',\r\n    until: '$until',\r\n    doUntil: '$do-until',\r\n\r\n    get: '$get',\r\n    defvar: '$clisp-defvar',\r\n    setq: '$clisp-setq',\r\n    set: '$set',\r\n    call: '$call',\r\n\r\n    not: '$not',\r\n    and: '$and',\r\n    or: '$or',\r\n\r\n    isSymbol: '$is-symbol',\r\n    gensym: '$gensym',\r\n    raise: '$raise',\r\n    catch: '$catch',\r\n\r\n    Template: 'Template',\r\n};\r\n\r\nexport const defaultConfig: SxParserConfig = {\r\n    raiseOnUnresolvedSymbol: false,\r\n    enableEvaluate: true,\r\n    enableHereDoc: true,\r\n    enableSpread: true,\r\n    enableSplice: true,\r\n    enableShorthands: true,\r\n    enableVerbatimStringLiteral: true,\r\n    enableTailCallOptimization: true,\r\n    enableRegExpMatchOperators: true,\r\n    enableCompilationOperators: true,\r\n    stripComments: false,\r\n    wrapExternalValue: true,\r\n    returnMultipleRoot: false,\r\n    maxEvalCount: 0,\r\n\r\n    reservedNames: defaultReservedNames,\r\n    symbols: [],\r\n    macros: [],\r\n    funcs: [],\r\n};\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         MaxEvaluationCountError } from './types';\r\nimport { globalObj }               from './consts';\r\n\r\n\r\n\r\nexport function setEvaluationCount(state: SxParserState) {\r\n    state.evalCount++;\r\n    if (state.config.maxEvalCount && state.config.maxEvalCount < state.evalCount) {\r\n        throw new MaxEvaluationCountError();\r\n    }\r\n}\r\n\r\n\r\nexport function checkParamsLength(name: string, args: ArrayLike<any>, min: number, max?: number) {\r\n    if (args.length < min) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${min} / args: ${args.length}.`);\r\n    }\r\n    if (max && max < args.length) {\r\n        throw new Error(`[SX] ${name}: Invalid argument length: expected: ${max} / args: ${args.length}.`);\r\n    }\r\n    return args;\r\n}\r\n\r\n\r\nconst objConstructor = ({}).constructor; // NOTE: objConstructor            === Object\r\nconst funConstructor = Function;         // NOTE: ({}).toString.constructor === Function\r\n\r\nexport function checkUnsafeVarNames(name: string, varName: string) {\r\n    if (varName === '__proto__' ||\r\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\r\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'prototype' || varName === 'constructor') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (objConstructor.hasOwnProperty(varName)) {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'call' || varName === 'arguments' || varName === 'caller') {\r\n        // NOTE: arguments, caller are not accessible in strict mode\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    return varName;\r\n}\r\n\r\n\r\nexport function checkUnsafeVarNamesEx(name: string, target: any, varName: string) {\r\n    if (target === globalObj ||\r\n        varName === '__proto__' ||\r\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\r\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\r\n        throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n    }\r\n    if (varName === 'prototype' || varName === 'constructor') {\r\n        if (target === null || target === void 0 || typeof target === 'function') {\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    if (target === null || target === void 0 || target === objConstructor) {\r\n        if (objConstructor.hasOwnProperty(varName)) {\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    if (target === null || target === void 0 || target === funConstructor) {\r\n        // checking 'call', 'arguments', 'caller', ...\r\n        let con: any = funConstructor;\r\n        while (con) {\r\n            if (con.hasOwnProperty(varName)) {\r\n                throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n            }\r\n            con = con.__proto__;\r\n        }\r\n    }\r\n    if (typeof target === 'function') {\r\n        if (!target.hasOwnProperty(varName)) {\r\n            // function's prototypes' members\r\n            throw new Error(`[SX] ${name}: Invalid var name ${varName}.`);\r\n        }\r\n    }\r\n    return varName;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedPair,\r\n         SxDottedFragment,\r\n         SxToken,\r\n         SxScope,\r\n         CapturedScopes,\r\n         SxMacroInfo }           from './types';\r\nimport { isSymbol }              from './ast';\r\nimport { setEvaluationCount,\r\n         checkUnsafeVarNamesEx } from './errors';\r\n\r\n\r\n\r\nexport function toNumber(x: any) {\r\n    switch (typeof x) {\r\n    case 'object': case 'symbol': case 'function':\r\n        return NaN;\r\n    default:\r\n        return Number(x);\r\n    }\r\n}\r\n\r\n\r\nexport function resolveUnquote(state: SxParserState, r: SxToken[]) {\r\n    for (let i = 0; i < r.length; i++) {\r\n        const symUnquote = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.unquote);\r\n        if (symUnquote) {\r\n            r = r.slice(0, i).concat([evaluate(state, (r[i] as SxToken[])[1])], r.slice(i + 1));\r\n        }\r\n        if (Array.isArray(r[i])) {\r\n            r = r.slice(0);\r\n            r[i] = resolveUnquote(state, r[i] as SxToken[]);\r\n        }\r\n    }\r\n    return resolveSplice(state, r);\r\n}\r\n\r\n\r\nexport function resolveSplice(state: SxParserState, r: SxToken[]) {\r\n    if (state.config.enableSplice) {\r\n        for (let i = r.length - 1; i >= 0; i--) {\r\n            const symSplice = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.splice);\r\n            if (symSplice) {\r\n                r = r.slice(0, i).concat((r[i] as SxToken[])[1], r.slice(i + 1));\r\n            }\r\n        }\r\n    }\r\n    return r;\r\n}\r\n\r\n\r\nexport function resolveMacro(state: SxParserState, x: SxSymbol, r: SxToken[]) {\r\n    const macroInfo = state.macroMap.get(x.symbol);\r\n    let lastErr = null;\r\n    if (macroInfo) {\r\n        let m: SxMacroInfo | undefined = macroInfo;\r\n        const r1 = r.slice(1);\r\n        while (m) {\r\n            if (m.formalArgs) {\r\n                const matchResult = matchMacroArgs(state, x.symbol, m.formalArgs, Boolean(m.lastIsSpread), r1);\r\n                if (! matchResult.error) {\r\n                    return {\r\n                        fn: m.fn(state, x.symbol, matchResult.formalArgs as SxSymbol[]),\r\n                        actualArgs: r.slice(0, 1).concat(matchResult.actualArgs as SxToken[]),\r\n                    };\r\n                }\r\n                lastErr = matchResult.error;\r\n                m = m.next;\r\n            } else {\r\n                return {\r\n                    fn: m.fn(state, x.symbol),\r\n                    actualArgs: r,\r\n                };\r\n            }\r\n        }\r\n        if (lastErr) {\r\n            throw new Error(lastErr);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n\r\nexport function resolveFunctionSymbol(state: SxParserState, x: SxSymbol) {\r\n    if (typeof x === 'function') {\r\n        return x;\r\n    }\r\n    const funcInfo = state.funcMap.get(x.symbol);\r\n    if (funcInfo) {\r\n        return funcInfo.fn(state, x.symbol);\r\n    } else {\r\n        const v = resolveValueSymbol(state, x);\r\n        if (typeof v === 'function') {\r\n            return v;\r\n        }\r\n        if (state.config.funcSymbolResolverFallback) {\r\n            return state.config.funcSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveFunctionSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function resolveValueSymbolScope(state: SxParserState, x: SxSymbol, nullIfNotDefined: boolean) {\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope && Object.prototype.hasOwnProperty.call(localScope.scope, x.symbol)) {\r\n            return localScope.scope;\r\n        }\r\n        if (localScope.capturedScopes &&\r\n            Object.prototype.hasOwnProperty.call(localScope.capturedScopes, x.symbol)) {\r\n            return localScope.capturedScopes[x.symbol];\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    const globalScope = getGlobalScope(state);\r\n    if (Object.prototype.hasOwnProperty.call(globalScope.scope, x.symbol)) {\r\n        return globalScope.scope;\r\n    }\r\n    return nullIfNotDefined ? null : getScope(state).scope;\r\n}\r\n\r\n\r\nexport function resolveValueSymbol(state: SxParserState, x: SxSymbol) {\r\n    const scope = resolveValueSymbolScope(state, x, true);\r\n    if (scope) {\r\n        return scope[x.symbol];\r\n    }\r\n    const symInfo = state.symbolMap.get(x.symbol);\r\n    if (symInfo) {\r\n        return symInfo.fn(state, x.symbol);\r\n    } else {\r\n        if (state.config.valueSymbolResolverFallback) {\r\n            return state.config.valueSymbolResolverFallback(state, x.symbol);\r\n        }\r\n        if (state.config.raiseOnUnresolvedSymbol) {\r\n            throw new Error(`[SX] resolveValueSymbol: Unresolved symbol: ${x.symbol}.`);\r\n        }\r\n        return x.symbol;\r\n    }\r\n}\r\n\r\n\r\nexport function collectCapturedVariables(state: SxParserState, names: SxSymbol[]): CapturedScopes {\r\n    const capturedScopes: CapturedScopes = {};\r\n    for (const n of names) {\r\n        const scope = resolveValueSymbolScope(state, n, true);\r\n        if (scope === null) {\r\n            throw new Error(`[SX] collectCapturedVariables: Unresolved symbols ${n}`);\r\n        }\r\n        checkUnsafeVarNamesEx('collectCapturedVariables', capturedScopes, n.symbol);\r\n        capturedScopes[n.symbol] = scope;\r\n    }\r\n    return capturedScopes;\r\n}\r\n\r\n\r\nexport function getCapturedScopes(state: SxParserState): CapturedScopes | undefined {\r\n    const a: CapturedScopes[] = [];\r\n    for (let i = state.scopes.length - 1; i > 0; i--) {\r\n        const localScope: SxScope = state.scopes[i];\r\n        if (localScope.capturedScopes) {\r\n            a.unshift(localScope.capturedScopes);\r\n        }\r\n        if (! localScope.isBlockLocal) {\r\n            break;\r\n        }\r\n    }\r\n    return a.length > 0 ? Object.assign({}, ...a) : void 0;\r\n}\r\n\r\n\r\nexport function installScope(state: SxParserState, scope: any, isBlockLocal: boolean, capturedScopes?: CapturedScopes): any {\r\n    state.scopes.push({isBlockLocal, scope, capturedScopes});\r\n}\r\n\r\n\r\nexport function uninstallScope(state: SxParserState): any {\r\n    if (state.scopes.length < 2) {\r\n        throw new Error(`[SX] uninstallScope: Unable to pop stack.`);\r\n    }\r\n    return state.scopes.pop();\r\n}\r\n\r\n\r\nexport function getScope(state: SxParserState) {\r\n    return state.scopes[state.scopes.length - 1];\r\n}\r\n\r\n\r\nexport function getGlobalScope(state: SxParserState) {\r\n    return state.scopes[0];\r\n}\r\n\r\n\r\nexport function matchMacroArgs(\r\n        state: SxParserState, macroName: string,\r\n        formalArgs: SxSymbol[], lastIsSpread: boolean, actualArgs: SxToken[]) {\r\n\r\n    formalArgs = formalArgs.slice(0);\r\n    actualArgs = actualArgs.slice(0);\r\n    if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n        return ({ error: `[SX] macro call (${macroName}): Actual args too short: actual ${\r\n            actualArgs.length} / formal ${formalArgs.length}.` });\r\n    }\r\n    for (let i = formalArgs.length - (lastIsSpread ? 2 : 1); i >= 0; i--) {\r\n        let nm = formalArgs[i].symbol;\r\n        if (nm.startsWith('!')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (! isSymbol(actualArgs[i])) {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n            }\r\n        } else if (nm.startsWith('<') && nm.endsWith('>')) {\r\n            formalArgs[i].symbol = formalArgs[i].symbol.slice(1, -1);\r\n            nm = formalArgs[i].symbol;\r\n\r\n            if (isSymbol(actualArgs[i], nm)) {\r\n                formalArgs = formalArgs.slice(0, i).concat(formalArgs.slice(i + 1));\r\n                actualArgs = actualArgs.slice(0, i).concat(actualArgs.slice(i + 1));\r\n            } else {\r\n                return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not expected symbol.` });\r\n            }\r\n        } else {\r\n            const tpos = nm.lastIndexOf(':');\r\n            if (0 < tpos) {\r\n                const tname = nm.slice(tpos + 1);\r\n                switch (tname) {\r\n                case 'number':\r\n                    if (typeof actualArgs[i] !== 'number') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not number.` });\r\n                    }\r\n                    break;\r\n                case 'string':\r\n                    if (typeof actualArgs[i] !== 'string') {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not string.` });\r\n                    }\r\n                    break;\r\n                case 'function':\r\n                    if (! (Array.isArray(actualArgs[i]) && isSymbol((actualArgs[i] as any)[0]))) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not function.` });\r\n                    }\r\n                    break;\r\n                case 'list':\r\n                    if (! Array.isArray(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not list.` });\r\n                    }\r\n                    break;\r\n                case 'symbol':\r\n                    if (! isSymbol(actualArgs[i])) {\r\n                        return ({ error: `[SX] macro call (${macroName}): Actual arg(${i}: ${nm}) is not symbol.` });\r\n                    }\r\n                    break;\r\n                case 'any':\r\n                    break;\r\n                default:\r\n                    return ({ error: `[SX] macro call (${macroName}): Formal arg(${i}: ${nm}) is unknown type ${tname}.` });\r\n                }\r\n                formalArgs[i].symbol = formalArgs[i].symbol.slice(0, tpos);\r\n            }\r\n        }\r\n    }\r\n    return ({ formalArgs, actualArgs });\r\n}\r\n\r\n\r\nexport function optimizeTailCall(state: SxParserState, formalArgs: SxSymbol[], fnBody: SxToken[]) {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //    formalArgs: 'sym1 ... 'symN\r\n    //        fnBody: 'expr1 ... 'exprN\r\n    if (Array.isArray(fnBody[fnBody.length - 1])) {\r\n        const front = fnBody.slice(0, fnBody.length - 1);\r\n        const tail = fnBody[fnBody.length - 1];\r\n        if (tail && (typeof tail[0] === 'object') && tail[0].symbol === state.config.reservedNames.if) {\r\n            // S expression: ($if cond t-expr f-expr)\r\n            if (Array.isArray(tail[3]) && (typeof tail[3][0] === 'object') && tail[3][0].symbol === state.config.reservedNames.self) {\r\n                // S expression (recursive):\r\n                //     (                                 ;; fnBody\r\n                //         expr1 ... exprN-1             ;; front\r\n                //         ($if cond                     ;; tail[0] [1]\r\n                //             t-expr                    ;;     [2]\r\n                //             ($self                    ;;     [3]\r\n                //                 rArgs1 ... rArgsN) )  ;; tail[4] ... [N+4]\r\n                //     )\r\n                //\r\n                //  -> S exp (tail call optimization):\r\n                //     (                                                                  ;; fnBody\r\n                //         ($until cond                                                   ;; tail[1]\r\n                //             ($clisp-let (tempsym1 ... tempsymN)                        ;;\r\n                //                 expr1 ... exprN-1                                      ;; front\r\n                //                 ($set tempsym1   rArgs1) ... ($set tempsymN   rArgsN)  ;; tail[4] ... [N+4]\r\n                //                 ($set     sym1 tempsym1) ... ($set     symN tempsymN)  ;;\r\n                //             )                                                          ;;\r\n                //         )                                                              ;;\r\n                //         expr1 ... exprN-1                                              ;; front\r\n                //         t-expr                                                         ;; tail[2]\r\n                //     )\r\n\r\n                const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n                const tempVarsSyms = formalArgs.map((a, idx) => ({symbol: `${varBaseName}_$i${idx}_${a.symbol}`}));\r\n\r\n                return [\r\n                    [{symbol: state.config.reservedNames.until}, tail[1],\r\n                        [{symbol: state.config.reservedNames.let}, [...tempVarsSyms],\r\n                            ...front,\r\n                            ...((tail[3].slice(1) as any[]).map((x: any, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, tempVarsSyms[idx], x])),\r\n                            ...(tempVarsSyms.map((x, idx) =>\r\n                                [{symbol: state.config.reservedNames.set}, formalArgs[idx], x])),\r\n                        ],\r\n                    ],\r\n                    ...front,\r\n                    tail[2],\r\n                ];\r\n            }\r\n        }\r\n    }\r\n    return fnBody;\r\n}\r\n\r\n\r\nexport function evaluate(state: SxParserState, x: SxToken): SxToken {\r\n    setEvaluationCount(state);\r\n\r\n    if (x === null || x === void 0) {\r\n        return x;\r\n    }\r\n    let r: SxToken = x;\r\n\r\n    for (;;) {\r\n        if (Array.isArray(r)) {\r\n            if (r.length === 0) {\r\n                return r;\r\n            }\r\n            r = resolveSplice(state, r);\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                const m = resolveMacro(state, sym, r);\r\n                if (m) {\r\n                    r = m.fn(m.actualArgs as SxToken[]);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n        setEvaluationCount(state);\r\n    }\r\n\r\n    if (Array.isArray(r)) {\r\n        r = r.slice(0);\r\n        if (0 < r.length) {\r\n            const sym = isSymbol(r[0]);\r\n            if (sym) {\r\n                if (sym.symbol === state.config.reservedNames.quote) {\r\n                    return r.slice(1, 2)[0];\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.backquote) {\r\n                    r = r.slice(1, 2)[0];\r\n                    if (Array.isArray(r)) {\r\n                        r = resolveUnquote(state, r);\r\n                    }\r\n                    return r;\r\n                }\r\n                if (sym.symbol === state.config.reservedNames.eval) {\r\n                    return evaluate(state, evaluate(state, r.slice(1, 2)[0]));\r\n                }\r\n            }\r\n\r\n            const sprs = [];\r\n            for (let i = 1; i < r.length; i++) {\r\n                const symSpr = Array.isArray(r[i]) && isSymbol((r[i] as SxToken[])[0], state.config.reservedNames.spread);\r\n                if (symSpr) {\r\n                    sprs.push(i);\r\n                    const a = evaluate(state, (r[i] as SxToken[])[1]);\r\n                    r[i] = Array.isArray(a) ? a : [a];\r\n                } else {\r\n                    r[i] = evaluate(state, r[i]);\r\n                }\r\n            }\r\n            for (const i of sprs.reverse()) {\r\n                r = (r as SxToken[]).slice(0, i).concat(r[i], r.slice(i + 1));\r\n            }\r\n\r\n            let fn: any;\r\n            if (typeof r[0] === 'function') {\r\n                fn = r[0];\r\n            } else if (sym) {\r\n                fn = resolveFunctionSymbol(state, sym);\r\n            } else {\r\n                fn = evaluate(state, r[0]);\r\n            }\r\n\r\n            if (typeof fn === 'function') {\r\n                r = (fn as any)(...(r.slice(1)));\r\n            } else {\r\n                throw new Error(`[SX] evaluate: First item of list is not a function: ${JSON.stringify(r)}.`);\r\n            }\r\n        }\r\n    } else if (state.config.wrapExternalValue && Object.prototype.hasOwnProperty.call(r, 'value')) {\r\n        r = (r as SxExternalValue).value;\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'symbol')) {\r\n        r = resolveValueSymbol(state, r as SxSymbol);\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'car')) {\r\n        const car = evaluate(state, (r as SxDottedPair).car);\r\n        const cdr = evaluate(state, (r as SxDottedPair).cdr);\r\n        if (Array.isArray(cdr)) {\r\n            const a = (cdr as any[]).slice(0);\r\n            a.unshift(car);\r\n            r = a;\r\n        } else {\r\n            r = { car, cdr };\r\n        }\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'dotted')) {\r\n        r = [\r\n            evaluate(state, (r as SxDottedFragment).dotted),\r\n        ];\r\n    } else if (Object.prototype.hasOwnProperty.call(r, 'comment')) {\r\n        r = [];\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxFuncInfo,\r\n         SxSymbolInfo,\r\n         SxParserConfig,\r\n         SxParserState,\r\n         SxToken,\r\n         SExpressionTemplateFn,\r\n         SExpressionAsyncTemplateFn } from '../types';\r\nimport { parse }                      from '../parser';\r\nimport { evaluate }                   from '../evaluate';\r\nimport { defaultConfig }              from '../defaults';\r\n\r\n\r\n\r\nfunction initState(config: SxParserConfig, globals: any, strings: TemplateStringsArray | string, values?: any[]): SxParserState {\r\n    return {\r\n        strings: typeof strings === 'string' ? [strings] : strings,\r\n        values: values || [],\r\n\r\n        index: 0,\r\n        pos: 0,\r\n        line: 0,\r\n\r\n        evalCount: 0,\r\n\r\n        scopes: [{isBlockLocal: false, scope: globals}],\r\n\r\n        macroMap: new Map<string, SxMacroInfo>(config.macros.map(x => [x.name, x] as [string, SxMacroInfo])),\r\n        funcMap: new Map<string, SxFuncInfo>(config.funcs.map(x => [x.name, x] as [string, SxFuncInfo])),\r\n        symbolMap: new Map<string, SxSymbolInfo>(config.symbols.map(x => [x.name, x] as [string, SxSymbolInfo])),\r\n\r\n        config,\r\n    };\r\n}\r\n\r\n\r\nfunction resetState(state: SxParserState, strings: TemplateStringsArray | string, values?: any[]) {\r\n    state.strings = typeof strings === 'string' ? [strings] : strings;\r\n    state.values = values || [];\r\n    state.index = 0;\r\n    state.pos = 0;\r\n    state.line = 0;\r\n    state.evalCount = 0;\r\n    return state;\r\n}\r\n\r\n\r\nexport function SExpression(conf?: SxParserConfig): SExpressionTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fRepl;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n\r\n\r\nexport function SExpressionAsync(conf?: SxParserConfig): SExpressionAsyncTemplateFn {\r\n    let config = conf || Object.assign({}, defaultConfig);\r\n    let globalScope: any = {};\r\n    let startup: SxToken[] = [];\r\n\r\n    const exec = async (state: SxParserState, s: SxToken[]) => {\r\n        if (config.enableEvaluate) {\r\n            for (let i = 0; i < s.length; i++) {\r\n                s[i] = evaluate(state, s[i]);\r\n\r\n                if (typeof s[i] === 'object' && s[i] !== null && typeof (s[i] as any).then === 'function') {\r\n                    s[i] = await s[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (config.returnMultipleRoot) {\r\n            return s.length === 1 ? s[0] : s;\r\n        } else {\r\n            return s[s.length - 1];\r\n        }\r\n    };\r\n\r\n    const f: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        return exec(state, startup.concat(parse(state)));\r\n    }) as any;\r\n\r\n    f.evaluateAST = (ast: SxToken[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        return exec(state, startup.concat(ast));\r\n    };\r\n    (f as any).repl = () => {\r\n        const execSync = (stat: SxParserState, s: SxToken[]) => {\r\n            if (config.enableEvaluate) {\r\n                for (let i = 0; i < s.length; i++) {\r\n                    s[i] = evaluate(stat, s[i]);\r\n                }\r\n            }\r\n\r\n            if (config.returnMultipleRoot) {\r\n                return s.length === 1 ? s[0] : s;\r\n            } else {\r\n                return s[s.length - 1];\r\n            }\r\n        };\r\n        const state = initState(config, Object.assign({}, globalScope), '');\r\n        exec(state, startup.slice(0));\r\n        const fRepl: SExpressionAsyncTemplateFn = (async (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return exec(state, parse(state));\r\n        }) as any;\r\n        const fReplSync: SExpressionTemplateFn = ((strings: TemplateStringsArray | string, ...values: any[]) => {\r\n            resetState(state, strings, values);\r\n            return execSync(state, parse(state));\r\n        }) as any;\r\n        (fRepl as any).sync = fReplSync;\r\n        return fRepl;\r\n    };\r\n    f.setGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globals || {});\r\n        return f;\r\n    };\r\n    f.appendGlobals = (globals: object) => {\r\n        globalScope = Object.assign({}, globalScope, globals || {});\r\n        return f;\r\n    };\r\n    f.setStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = parse(state);\r\n        return f;\r\n    };\r\n    f.setStartupAST = (ast: SxToken[]) => {\r\n        startup = ast;\r\n        return f;\r\n    };\r\n    f.appendStartup = (strings: TemplateStringsArray | string, ...values: any[]) => {\r\n        const state = initState(config, Object.assign({}, globalScope), strings, values);\r\n        startup = startup.concat(parse(state));\r\n        return f;\r\n    };\r\n    f.appendStartupAST = (ast: SxToken[]) => {\r\n        startup = startup.concat(ast);\r\n        return f;\r\n    };\r\n    f.install = (installer) => {\r\n        config = installer(config);\r\n        return f;\r\n    };\r\n\r\n    return f;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbol,\r\n         SxToken,\r\n         FatalError,\r\n         CapturedScopes,\r\n         SxMacroInfo }           from '../../types';\r\nimport { globalObj }             from '../../consts';\r\nimport { isSymbol,\r\n         quote }                 from '../../ast';\r\nimport { evaluate,\r\n         resolveValueSymbolScope,\r\n         collectCapturedVariables,\r\n         getCapturedScopes,\r\n         getScope,\r\n         getGlobalScope,\r\n         installScope,\r\n         uninstallScope,\r\n         optimizeTailCall,\r\n         toNumber }              from '../../evaluate';\r\nimport { compileLambda }         from '../../compile';\r\nimport { checkParamsLength,\r\n         checkUnsafeVarNamesEx } from '../../errors';\r\n\r\n\r\n\r\nexport const $car = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($car '(first second ... last))\r\n    //  -> S expr  : first\r\n    checkParamsLength('$car', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $car: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car[0];\r\n};\r\nexport const $$car = $car(null as any, null as any);\r\n\r\n\r\nexport const $cdr = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cdr '(first second ... last))\r\n    //  -> S expr  : (second ... last)\r\n    checkParamsLength('$cdr', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (! Array.isArray(car)) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n    if (car.length === 0) {\r\n        throw new Error(`[SX] $cdr: Invalid argument(s): args[0] is nil.`);\r\n    }\r\n    return car.slice(1);\r\n};\r\nexport const $$cdr = $cdr(null as any, null as any);\r\n\r\n\r\nexport const $cons = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($cons arg1 '(arg2-item1 ...) ... argN)\r\n    //  -> S expr  : (arg1 arg2-item1 ...)\r\n    // S expression: ($cons arg1 nilOrNull ... argN)\r\n    //  -> S expr  : (arg1)\r\n    // S expression: ($cons arg1 arg2 ... argN)\r\n    //  -> S expr  : arg1.arg2\r\n    checkParamsLength('$cons', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (car === null) {\r\n        car = [];\r\n    }\r\n    if (cdr === null) {\r\n        cdr = [];\r\n    }\r\n\r\n    if (Array.isArray(cdr)) {\r\n        cdr = cdr.slice(0);\r\n        cdr.unshift(car);\r\n        return cdr;\r\n    } else {\r\n        return {car, cdr};\r\n    }\r\n};\r\nexport const $$cons = $cons(null as any, null as any);\r\n\r\n\r\nexport const $first = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first first second ... last)\r\n    //  -> S expr  : first\r\n    // S expression: ($first)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(0, 1);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$first = $first(null as any, null as any);\r\n\r\n\r\nexport const $second = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($second first second ... last)\r\n    //  -> S expr  : second\r\n    // S expression: ($second first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1, 2);\r\n    return (cdr.length === 1) ? cdr[0] : null;\r\n};\r\nexport const $$second = $second(null as any, null as any);\r\n\r\n\r\nexport const $last = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($last first second ... last)\r\n    //  -> S expr  : last\r\n    // S expression: ($last)\r\n    //  -> S expr  : null\r\n    const car: any = args.slice(args.length - 1, args.length);\r\n    return (car.length === 1) ? car[0] : null;\r\n};\r\nexport const $$last = $last(null as any, null as any);\r\n\r\n\r\nexport const $rest = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($rest first second ... last)\r\n    //  -> S expr  : (second ... last)\r\n    // S expression: ($rest first)\r\n    //  -> S expr  : null\r\n    const cdr: any = args.slice(1);\r\n    return (0 < cdr.length) ? cdr : null;\r\n};\r\nexport const $$rest = $rest(null as any, null as any);\r\n\r\n\r\nexport const $firstAndSecond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($first-and-second first second ... last)\r\n    //  -> S expr  : first.second\r\n    let car: any = args.slice(0, 1);\r\n    car = (car.length === 1) ? car[0] : null;\r\n\r\n    let cdr: any = args.slice(1, 2);\r\n    cdr = (cdr.length === 1) ? cdr[0] : null;\r\n\r\n    return {car, cdr};\r\n};\r\nexport const $$firstAndSecond = $firstAndSecond(null as any, null as any);\r\n\r\n\r\nexport const $atom = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($atom arg1 ...)\r\n    //  -> (if arg1 is list or dotted pair)  S expr  : false\r\n    //  -> (if arg1 is nil or anything else) S expr  : true\r\n    checkParamsLength('$atom', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n\r\n    if (car === null || car === void 0) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(car)) {\r\n        if (car.length === 0) return  true;\r\n        else                  return false;\r\n    }\r\n\r\n    switch (typeof car) {\r\n    case 'number': case 'string': case 'function': case 'boolean':\r\n        return true;\r\n    case 'object':\r\n        return isSymbol(car) ? true : false;\r\n    }\r\n    return false;\r\n};\r\nexport const $$atom = $atom(null as any, null as any);\r\n\r\n\r\nexport const $eq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($eq arg1 arg2)\r\n    //  -> (if arg1 === arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$eq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car === cdr;\r\n};\r\nexport const $$eq = $eq(null as any, null as any);\r\n\r\n\r\nexport const $notEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not-eq arg1 arg2)\r\n    //  -> (if arg1 !== arg2)  S expr  : true\r\n    //  -> (else)              S expr  : false\r\n    checkParamsLength('$notEq', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return car !== cdr;\r\n};\r\nexport const $$notEq = $notEq(null as any, null as any);\r\n\r\n\r\nexport const $list = (state: SxParserState, name: string) => (...args: any[]) =>\r\n    // S expression: ($list arg1 ... argN)\r\n    //  -> S expr  : (arg1 ... argN)\r\n    args.slice(0);\r\nexport const $$list = $list(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__scope = (state: SxParserState, name: string, capturedScopes?: CapturedScopes) => (...args: any[]) => {\r\n    // S expression: ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__scope', args, 3);\r\n\r\n    const isBlockLocal = $$first(...args);\r\n    const returnMultiple = $$second(...args);\r\n    const {car, cdr} = $$firstAndSecond(...args.slice(2));\r\n    let r: SxToken = null;\r\n\r\n    const scope: any = {};\r\n    if (Array.isArray(car)) {\r\n        for (const x of car) {\r\n            if (Array.isArray(x)) {\r\n                const kv = $$firstAndSecond(...x);\r\n                const kvSym = isSymbol(kv.car);\r\n                const kvName = kvSym ? kvSym.symbol : String(kv.car);\r\n                checkUnsafeVarNamesEx('$__scope', scope, kvName);\r\n                scope[kvName] = evaluate(state, kv.cdr);\r\n            } else {\r\n                const xSym = isSymbol(x);\r\n                const xName = xSym ? xSym.symbol : String(x);\r\n                checkUnsafeVarNamesEx('$__scope', scope, xName);\r\n                scope[xName] = null;\r\n            }\r\n        }\r\n    }\r\n    installScope(state, scope, isBlockLocal, capturedScopes);\r\n\r\n    try {\r\n        if (4 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(3)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(3)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__globalScope = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__global returnMultiple 'expr1 ... 'exprN)\r\n    //  -> (if returnMultiple)  S expr  : [expr1 ... exprN]\r\n    //  -> (else)               S expr  : exprN\r\n    checkParamsLength('$__globalScope', args, 1);\r\n\r\n    const returnMultiple = $$first(...args);\r\n    const cdr = $$second(...args);\r\n    let r: SxToken = null;\r\n\r\n    installScope(state, getGlobalScope(state).scope, true);\r\n    try {\r\n        if (2 < args.length) {\r\n            if (returnMultiple) {\r\n                r = [];\r\n                for (const x of args.slice(1)) {\r\n                    r.push(evaluate(state, x));\r\n                }\r\n            } else {\r\n                for (const x of args.slice(1)) {\r\n                    r = evaluate(state, x);\r\n                }\r\n            }\r\n        } else {\r\n            r = evaluate(state, cdr);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__capture = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__capture '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : exprN\r\n    checkParamsLength('$__capture', args, 1);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let r: SxToken = null;\r\n\r\n    const capturedScopes = collectCapturedVariables(state, formalArgs);\r\n    installScope(state, {}, true, capturedScopes);\r\n    try {\r\n        for (const x of args.slice(1)) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } finally {\r\n        uninstallScope(state);\r\n    }\r\n\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    let fnBody = args.slice(1);\r\n    if (state.config.enableTailCallOptimization) {\r\n        fnBody = optimizeTailCall(state, formalArgs, fnBody);\r\n    }\r\n\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = function(this: any, ...actualArgs: any[]) {\r\n        if ((actualArgs.length + (lastIsSpread ? 1 : 0)) < formalArgs.length) {\r\n            throw new Error(`[SX] func call: Actual args too short: actual ${\r\n                actualArgs.length} / formal ${formalArgs.length}.`);\r\n        }\r\n        // TODO: add type checking\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            [state.config.reservedNames.thiz, this === globalObj || this === void 0 ? null : quote(state, this)],\r\n            ...(formalArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === formalArgs.length - 1) ?\r\n                        actualArgs.slice(index) : actualArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__lambda = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__lambda '(sym1 ... symN) 'expr1 ... 'exprN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__lambda', args, 2);\r\n\r\n    const formalArgs: SxSymbol[] = args[0];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $$__lambda: Invalid argument(s): args[0] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $$__lambda: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(1);\r\n    return compileLambda(state, formalArgs, lastIsSpread, fnBody);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $__lambda(state, name)(...args.slice(1));\r\n\r\n    checkUnsafeVarNamesEx('$__defun', state.funcMap, car.symbol);\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $comp$__defun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$$__defun', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const fn = $comp$__lambda(state, name)(...args.slice(1));\r\n\r\n    checkUnsafeVarNamesEx('$$__defun', state.funcMap, car.symbol);\r\n    // TODO: overloading\r\n    state.funcMap.set(car.symbol, {\r\n        name: car.symbol,\r\n        fn: (st, nm) => fn,\r\n        // formalArgs: ,\r\n        // lastIsSpread: ,\r\n        // next: ,\r\n    });\r\n    return fn;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__refun = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($refun 'name)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__refun', args, 1, 1);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n\r\n    checkUnsafeVarNamesEx('$__refun', state.funcMap, car.symbol);\r\n    const info = state.funcMap.get(car.symbol);\r\n    if (!info) {\r\n        throw new Error(`[SX] $__refun: function ${car.symbol} is not defined.`);\r\n    }\r\n    return info.fn(state, car.symbol);\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__defmacro = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__defmacro', args, 3);\r\n\r\n    const car: SxSymbol = $$first(...args);\r\n    const formalArgs: SxSymbol[] = args[1];\r\n    if (! Array.isArray(formalArgs)) {\r\n        throw new Error(`[SX] $__defmacro: Invalid argument(s): args[1] is not array.`);\r\n    }\r\n\r\n    let lastIsSpread = false;\r\n    for (let i = 0; i < formalArgs.length; i++) {\r\n        const fa = formalArgs[i];\r\n        if (i === formalArgs.length - 1 && state.config.enableSpread &&\r\n            Array.isArray(fa) && isSymbol(fa[0], state.config.reservedNames.spread)) {\r\n            if (! isSymbol(fa[1])) {\r\n                throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n            }\r\n            formalArgs[i] = fa[1];\r\n            lastIsSpread = true;\r\n        } else if (! isSymbol(fa)) {\r\n            throw new Error(`[SX] $__defmacro: Invalid formal argument(s): item(s) of args[${i}] is not symbol.`);\r\n        }\r\n    }\r\n\r\n    const fnBody = args.slice(2);\r\n    const capturedScopes = getCapturedScopes(state);\r\n\r\n    const fn = (fArgs: SxSymbol[]) => (...aArgs: any[]) => {\r\n        return $__scope(state, name, capturedScopes)(false, false, [\r\n            [state.config.reservedNames.self, fn],\r\n            ...(fArgs.map((x: SxSymbol, index) => [\r\n                x.symbol,\r\n                quote(state,\r\n                    (lastIsSpread && index === fArgs.length - 1) ?\r\n                        aArgs.slice(index) : aArgs[index]\r\n                )\r\n            ])),\r\n        ], ...fnBody);\r\n    };\r\n\r\n    const m: SxMacroInfo = {\r\n        name: car.symbol,\r\n        fn: (st: SxParserState, nm: string, fArgs: SxSymbol[]) => (list: SxToken[]) => fn(fArgs)(...(list.slice(1))),\r\n        formalArgs,\r\n        lastIsSpread,\r\n    };\r\n\r\n    checkUnsafeVarNamesEx('$__defmacro', state.macroMap, car.symbol);\r\n\r\n    if (state.macroMap.has(car.symbol)) {\r\n        let curr = state.macroMap.get(car.symbol);\r\n        (curr as SxMacroInfo).next = m;\r\n        if (curr && curr.formalArgs) {\r\n            if (curr.formalArgs.length < formalArgs.length) {\r\n                state.macroMap.set(car.symbol, m);\r\n                m.next = curr;\r\n            } else {\r\n                let prev = curr;\r\n                curr = curr.next;\r\n                while (curr) {\r\n                    if (curr.formalArgs) {\r\n                        if (curr.formalArgs.length < formalArgs.length) {\r\n                            prev.next = m;\r\n                            m.next = curr;\r\n                            break;\r\n                        }\r\n                    }\r\n                    prev = curr;\r\n                    curr = curr.next;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        state.macroMap.set(car.symbol, m);\r\n    }\r\n    return fn;\r\n};\r\n\r\n\r\nexport const $apply = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($apply fn arg1 ... argN)\r\n    //  -> S expr  : fn'\r\n    checkParamsLength('$apply', args, 1);\r\n\r\n    const car: () => any = $$first(...args);\r\n    if (typeof car !== 'function') {\r\n        throw new Error(`[SX] $apply: Invalid argument(s): args[0] is not function.`);\r\n    }\r\n\r\n    return (\r\n        (...p: any[]) => car.apply(null, args.slice(1).concat(p))\r\n    );\r\n};\r\nexport const $$apply = $apply(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__call = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__call thisArg 'symbol arg1 ... argN)\r\n    //  -> S expr  : fn\r\n    checkParamsLength('$__call', args, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    const sym = isSymbol(cdr);\r\n    const xName = sym ? sym.symbol : evaluate(state, cdr) as any;\r\n\r\n    checkUnsafeVarNamesEx('$__call', car, xName);\r\n\r\n    return Function.prototype.apply.call(\r\n        car[xName],\r\n        car,\r\n        args.slice(2)\r\n    );\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__try = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__try 'expr 'catch-expr)\r\n    //  ->                               S expr  : expr\r\n    //  -> (if error is raised in expr)  S expr  : catch-expr\r\n    checkParamsLength('$__try', args, 1, 2);\r\n\r\n    let r: SxToken = [];\r\n    try {\r\n        r = evaluate(state, args[0]);\r\n    } catch (e) {\r\n        if (e instanceof FatalError) {\r\n            throw e;\r\n        }\r\n        if (1 < args.length) {\r\n            r = $__scope(state, name)(true, false, [\r\n                ['$error', quote(state, e)],\r\n                ['$parent', quote(state, getScope(state))],\r\n            ], args[1]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nexport const $raise = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($raise 'expr)\r\n    //  -> S expr  : -\r\n    const car = $$first(...args);\r\n    throw car;\r\n};\r\nexport const $$raise = $raise(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__if = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if condition 't-expr 'f-expr)\r\n    //  -> (if condition is true ) S expr  : t-expr\r\n    //  -> (if condition is false) S expr  : f-expr\r\n    checkParamsLength('$__if', args, 2, 3);\r\n\r\n    const car = $$first(...args);\r\n    let r: SxToken = [];\r\n    if ($$boolean(car)) {\r\n        r = evaluate(state, args[1]);\r\n    } else {\r\n        if (2 < args.length) {\r\n            r = evaluate(state, args[2]);\r\n        } else {\r\n            r = null;\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__ifNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__if-null condition 'null-expr)\r\n    //  -> (if condition is not null ) S expr  : condition\r\n    //  -> (if condition is null)      S expr  : null-expr\r\n    checkParamsLength('$__ifNull', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    let r: SxToken = [];\r\n    if (! $$ambiguousEq(car, null)) {\r\n        r = car;\r\n    } else {\r\n        r = evaluate(state, cdr);\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__cond = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n    //  -> (if (eval condI) is true ) S expr  : exprI\r\n    //  -> (if no matched)            S expr  : null\r\n    checkParamsLength('$__cond', args, 1);\r\n\r\n    for (let i = 0; i < args.length - 1; i += 2) {\r\n        const c = args[i];\r\n        const x = args[i + 1];\r\n        if ($$boolean(evaluate(state, c))) {\r\n            return evaluate(state, x);\r\n        }\r\n    }\r\n    return null;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__while = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__while', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$boolean(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doWhile = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-while 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doWhile', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$boolean(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__until = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__until', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    while ($$not(evaluate(state, car))) {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__doUntil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__do-until 'condition 'expr1 ... 'exprN)\r\n    //  -> (if condition is true at least 1 or more times) S expr  : exprN\r\n    //  -> (else)                                          S expr  : null\r\n    checkParamsLength('$__doUntil', args, 1);\r\n\r\n    const car = $$first(...args);\r\n    const cdr = args.slice(1);\r\n    let r: SxToken = null;\r\n    do {\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    } while ($$not(evaluate(state, car)));\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__repeat = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__repeat 'i n-times 'expr1 ... 'exprN)\r\n    //  -> (if n > 0) S expr  : exprN\r\n    //  -> (else)     S expr  : null\r\n    checkParamsLength('$__repeat', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__repeat: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__repeat', {}, sym.symbol); // NOTE: pass dummy target object.\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const n = toNumber($$second(...args));\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (let i = 0; i < n; i++) {\r\n        scope[sym.symbol] = i;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__for = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__for 'x list 'expr1 ... 'exprN)\r\n    //  -> (if list.length > 0) S expr  : exprN\r\n    //  -> (else)               S expr  : null\r\n    checkParamsLength('$__for', args, 2);\r\n\r\n    const sym = isSymbol($$first(...args));\r\n    if (! sym) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__for', {}, sym.symbol); // NOTE: pass dummy target object.\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n\r\n    const list = $$second(...args);\r\n    if (! Array.isArray(list)) {\r\n        throw new Error(`[SX] $__for: Invalid argument(s): item(s) of args[1] is not array.`);\r\n    }\r\n\r\n    const cdr = args.slice(2);\r\n    let r: SxToken = null;\r\n    for (const q of list) {\r\n        scope[sym.symbol] = q;\r\n        for (const x of cdr) {\r\n            r = evaluate(state, x);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $pipe = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get v fn1 ... fnN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$pipe', args, 1);\r\n\r\n    let v = args[0];\r\n    for (let i = 1; i < args.length; i++) {\r\n        v = args[i](v);\r\n    }\r\n    return v;\r\n};\r\nexport const $$pipe = $pipe(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__get = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__get', args, 1);\r\n\r\n    let v: any = null;\r\n    let sym = isSymbol(args[0]);\r\n\r\n    if (!sym) {\r\n        switch (typeof args[0]) {\r\n        case 'string': case 'number':\r\n            sym = {symbol: String(args[0])};\r\n            break;\r\n        default:\r\n            v = evaluate(state, args[0]);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (sym) {\r\n        const scope = resolveValueSymbolScope(state, sym, true);\r\n        if (! scope) {\r\n            throw new Error(`[SX] $__get: Invalid argument(s): args[0]: symbol \"${sym.symbol}\" is not defined.`);\r\n        }\r\n        v = scope[sym.symbol];\r\n    }\r\n\r\n    for (let i = 1; i < args.length; i++) {\r\n        let q: any = args[i];\r\n        let inprog = true;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                v = q(v);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = v.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                checkUnsafeVarNamesEx('$__get', v, q);\r\n                v = v[q];\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__get: Invalid argument(s): invalid name path.`);\r\n            }\r\n        }\r\n    }\r\n    return v;\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__let = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__let 'nameStrOrSymbol expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__let', args, 2, 2);\r\n\r\n    let sym = isSymbol($$first(...args));\r\n\r\n    if (! sym) {\r\n        if (typeof args[0] === 'string') {\r\n            sym = {symbol: args[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__let: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    checkUnsafeVarNamesEx('$__let', {}, sym.symbol); // NOTE: pass dummy target object.\r\n\r\n    const scope = resolveValueSymbolScope(state, sym, false);\r\n    scope[sym.symbol] = args[1];\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__set = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__set 'nameOrListOfNameOrIndex expr)\r\n    //  -> S expr  : any\r\n    checkParamsLength('$__set', args, 2, 2);\r\n\r\n    let path: any = [];\r\n\r\n    if (Array.isArray(args[0])) {\r\n        path = args[0];\r\n    } else {\r\n        path.push(args[0]);\r\n    }\r\n\r\n    let sym = isSymbol(path[0]);\r\n\r\n    if (! sym) {\r\n        if (typeof path[0] === 'string') {\r\n            checkUnsafeVarNamesEx('$__set', {}, path[0]); // NOTE: pass dummy target object.\r\n            sym = {symbol: path[0]};\r\n        } else {\r\n            throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n        }\r\n    }\r\n\r\n    let scope = resolveValueSymbolScope(state, sym, true);\r\n    if (scope === null) {\r\n        throw new Error(`[SX] $__set: Unresolved symbol: ${sym.symbol}.`);\r\n    }\r\n\r\n    let subst = false;\r\n\r\n    for (let i = 0; i < path.length; i++) {\r\n        let q: any = path[i];\r\n        let inprog = true;\r\n        const last = i === path.length - 1;\r\n        while (inprog) {\r\n            switch (typeof q) {\r\n            case 'function':\r\n                scope = q(scope);\r\n                inprog = false;\r\n                break;\r\n            case 'object':\r\n                if (Array.isArray(q)) {\r\n                    q = evaluate(state, q);\r\n                } else {\r\n                    sym = isSymbol(q);\r\n                    if (sym) {\r\n                        q = sym.symbol;\r\n                    } else if (Object.prototype.hasOwnProperty.call(q, 'value')) {\r\n                        q = evaluate(state, q);\r\n                    } else {\r\n                        throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n                    }\r\n                }\r\n                break;\r\n            case 'number':\r\n                if (q < 0) {\r\n                    q = scope.length + q;\r\n                }\r\n                // FALL_THRU\r\n            case 'string':\r\n                checkUnsafeVarNamesEx('$__set', scope, q);\r\n                if (last) {\r\n                    scope[q] = args[1];\r\n                    subst = true;\r\n                } else {\r\n                    scope = scope[q];\r\n                }\r\n                inprog = false;\r\n                break;\r\n            default:\r\n                throw new Error(`[SX] $__set: Invalid argument(s): invalid name.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    if (! subst) {\r\n        throw new Error(`[SX] $__set: Invalid argument(s): last path is not lvalue.`);\r\n    }\r\n\r\n    return args[1];\r\n};\r\n\r\n\r\nexport const $boolean = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($boolean any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$boolean', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (Array.isArray(car) && car.length === 0) return false;\r\n    else return Boolean(car);\r\n};\r\nexport const $$boolean = $boolean(null as any, null as any);\r\n\r\n\r\nexport const $not = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($not any)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$not', args, 1, 1);\r\n\r\n    return ! $$boolean(...args);\r\n};\r\nexport const $$not = $not(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__and = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__and 'expr1 ... 'exprN)\r\n    //  -> (if all of ($boolean expr1) ... ($boolean exprN) are true) S expr  : exprN\r\n    //  -> (else)                                                     S expr  : expr-i (false left most)\r\n    checkParamsLength('$__and', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if (! $$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__and = $__and(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__or = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__or 'expr1 ... 'exprN)\r\n    //  -> (if any ($boolean expr1) ... ($boolean exprN) are true) S expr  : expr-i (where i: index of item first ($boolean expr-i) is to be true)\r\n    //  -> (else)                                                  S expr  : expr-i (false right most)\r\n    checkParamsLength('$__or', args, 1);\r\n\r\n    let prev = null;\r\n    for (let i = 0; i < args.length; i++) {\r\n        const curr = evaluate(state, args[i]);\r\n        if ($$boolean(curr)) {\r\n            return curr;\r\n        }\r\n        prev = curr;\r\n    }\r\n    return prev;\r\n};\r\n// tslint:disable-next-line:variable-name\r\nexport const $$__or = $__or(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (== a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ambiguousEq', args, 2, 2);\r\n\r\n    let {car, cdr} = $$firstAndSecond(...args);\r\n    if (Array.isArray(car) && car.length === 0) car = null;\r\n    if (Array.isArray(cdr) && cdr.length === 0) cdr = null;\r\n    if (car === void 0) car = null;\r\n    if (cdr === void 0) cdr = null;\r\n    // tslint:disable-next-line:triple-equals\r\n    return car == cdr;\r\n};\r\nexport const $$ambiguousEq = $ambiguousEq(null as any, null as any);\r\n\r\n\r\nexport const $ambiguousNotEq = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (!= a b)\r\n    //  -> S expr  : boolean\r\n    return ! $$ambiguousEq(...args);\r\n};\r\nexport const $$ambiguousNotEq = $ambiguousNotEq(null as any, null as any);\r\n\r\n\r\nexport const $lt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (< a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$lt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) < toNumber(cdr);\r\n};\r\nexport const $$lt = $lt(null as any, null as any);\r\n\r\n\r\nexport const $le = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (<= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$le', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) <= toNumber(cdr);\r\n};\r\nexport const $$le = $le(null as any, null as any);\r\n\r\n\r\nexport const $gt = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (> a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$gt', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) > toNumber(cdr);\r\n};\r\nexport const $$gt = $gt(null as any, null as any);\r\n\r\n\r\nexport const $ge = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: (>= a b)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$ge', args, 2, 2);\r\n\r\n    const {car, cdr} = $$firstAndSecond(...args);\r\n    return toNumber(car) >= toNumber(cdr);\r\n};\r\nexport const $$ge = $ge(null as any, null as any);\r\n\r\n\r\nexport const $typeof = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($typeof x)\r\n    //  -> S expr  : 'null' | 'bigint' | 'boolean' | 'function' | 'number' | 'string' | 'undefined' |\r\n    //               'js-symbol' | 'list' | 'object'\r\n    checkParamsLength('$typeof', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    if (car === null) {\r\n        return 'null';\r\n    }\r\n    const tyName = typeof car;\r\n    switch (tyName) {\r\n    case 'object':\r\n        if (Array.isArray(car)) {\r\n            return 'list';\r\n        } else {\r\n            return 'object';\r\n        }\r\n    case 'symbol':\r\n        return 'js-symbol';\r\n    default:\r\n        return tyName;\r\n    }\r\n};\r\nexport const $$typeof = $typeof(null as any, null as any);\r\n\r\n\r\nexport const $symbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($symbol)\r\n    // S expression: ($symbol name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$symbol', args, 1, 1);\r\n\r\n    if (typeof args[0] === 'string') {\r\n        return {symbol: args[0]};\r\n    } else {\r\n        throw new Error(`[SX] $symbol: Invalid argument(s): item(s) of args[0] is not string.`);\r\n    }\r\n};\r\nexport const $$symbol = $symbol(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__gensym = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__gensym)\r\n    // S expression: ($__gensym name)\r\n    //  -> S expr  : symbol\r\n    checkParamsLength('$__gensym', args, 0, 1);\r\n\r\n    const varBaseName = `$__tempvar__$$ec${state.evalCount++}$$_`;\r\n    const tempVarSym = ({symbol: `${varBaseName}_$gensym`});\r\n    if (args.length === 1) {\r\n        const a = isSymbol(args[0]);\r\n        if (a) {\r\n            $__let(state, '')(a, tempVarSym);\r\n        } else if (typeof args[0] === 'string') {\r\n            $__let(state, '')({symbol: args[0]}, tempVarSym);\r\n        } else {\r\n            throw new Error(`[SX] $__gensym: Invalid argument(s): item(s) of args[0] is not symbol.`);\r\n        }\r\n    }\r\n    return tempVarSym;\r\n};\r\n\r\n\r\nexport const $isSymbol = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-symbol x)\r\n    // S expression: ($is-symbol x name)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isSymbol', args, 1, 2);\r\n\r\n    if (args.length === 1) {\r\n        return (isSymbol(args[0]) ? true : false);\r\n    } else {\r\n        if (typeof args[1] === 'string') {\r\n            return (isSymbol(args[0], args[1]) ? true : false);\r\n        } else {\r\n            throw new Error(`[SX] $isSymbol: Invalid argument(s): item(s) of args[1] is not string.`);\r\n        }\r\n    }\r\n};\r\nexport const $$isSymbol = $isSymbol(null as any, null as any);\r\n\r\n\r\nexport const $isNull = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-null x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNull', args, 1, 1);\r\n\r\n    return $$first(...args) === null;\r\n};\r\nexport const $$isNull = $isNull(null as any, null as any);\r\n\r\n\r\nexport const $isNil = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-nil x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNil', args, 1, 1);\r\n\r\n    const car = $$first(...args);\r\n    return Array.isArray(car) && car.length === 0;\r\n};\r\nexport const $$isNil = $isNil(null as any, null as any);\r\n\r\n\r\nexport const $isUndefined = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-undefined x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isUndefined', args, 1, 1);\r\n\r\n    return $$first(...args) === void 0;\r\n};\r\nexport const $$isUndefined = $isUndefined(null as any, null as any);\r\n\r\n\r\nexport const $isList = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-list x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isList', args, 1, 1);\r\n\r\n    return Array.isArray($$first(...args));\r\n};\r\nexport const $$isList = $isList(null as any, null as any);\r\n\r\n\r\nexport const $isString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-string x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isString', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'string';\r\n};\r\nexport const $$isString = $isString(null as any, null as any);\r\n\r\n\r\nexport const $isNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-number x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNumber', args, 1, 1);\r\n\r\n    return typeof $$first(...args) === 'number';\r\n};\r\nexport const $$isNumber = $isNumber(null as any, null as any);\r\n\r\n\r\nexport const $isNaN = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-NaN x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isNaN', args, 1, 1);\r\n\r\n    return Number.isNaN($$first(...args));\r\n};\r\nexport const $$isNaN = $isNaN(null as any, null as any);\r\n\r\n\r\nexport const $isFinite = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-finate x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isFinite', args, 1, 1);\r\n\r\n    return Number.isFinite($$first(...args));\r\n};\r\nexport const $$isFinite = $isFinite(null as any, null as any);\r\n\r\n\r\nexport const $isInteger = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($is-integer x)\r\n    //  -> S expr  : boolean\r\n    checkParamsLength('$isInteger', args, 1, 1);\r\n\r\n    return Number.isInteger($$first(...args));\r\n};\r\nexport const $$isInteger = $isInteger(null as any, null as any);\r\n\r\n\r\nexport const $toString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-string x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$toString', args, 1, 1);\r\n\r\n    return String($$first(...args));\r\n};\r\nexport const $$toString = $toString(null as any, null as any);\r\n\r\n\r\nexport const $toNumber = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($to-number x)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$toNumber', args, 1, 1);\r\n\r\n    return toNumber($$first(...args));\r\n};\r\nexport const $$toNumber = $toNumber(null as any, null as any);\r\n\r\n\r\n// tslint:disable-next-line:variable-name\r\nexport const $__toObject = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($__# '(name value...)...)\r\n    //  -> JSON    : {name: value, ...}\r\n    const r: any = {};\r\n    for (const x of args) {\r\n        if (Array.isArray(x) && 0 < x.length) {\r\n            const sym = isSymbol(x[0]);\r\n            const keyName =\r\n                sym ? sym.symbol :\r\n                String(evaluate(state, x[0]));\r\n\r\n            checkUnsafeVarNamesEx('$__#', r, keyName);\r\n            if (x.length === 1) {\r\n                // S expression: (# ... (keyName) ...)\r\n                //  -> JSON    : {..., keyName: true, ...}\r\n                r[keyName] = true;\r\n            } else if (x.length === 2) {\r\n                // S expression: (# ... (keyName value) ...)\r\n                //  -> JSON    : {..., keyName: value, ...}\r\n                r[keyName] = evaluate(state, x[1]);\r\n            } else {\r\n                // S expression: (# ... (keyName value1 value2 ...) ...)\r\n                //  -> JSON    : {..., keyName: [value1, value2, ], ...}\r\n                r[keyName] =\r\n                    evaluate(state, ([{symbol: state.config.reservedNames.list}] as SxToken[])\r\n                    .concat(x.slice(1)));\r\n            }\r\n        } else {\r\n            throw new Error(`[SX] $__toObject: Invalid argument(s): args[?] is not array.`);\r\n        }\r\n    }\r\n    return r;\r\n};\r\n\r\n\r\nconst assignBlacklist = [\r\n    globalObj,\r\n    (Object as any).__proto__,\r\n    ({} as any).__proto__,\r\n    (Function as any).__proto__,\r\n];\r\n\r\nexport const $objectAssign = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($object-assign x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$objectAssign', args, 1);\r\n\r\n    if (assignBlacklist.includes(args[0])) {\r\n        throw new Error(`[SX] $objectAssign: Invalid argument: args[0] is blacklisted object.`);\r\n    }\r\n    return Object.assign(args[0], ...(args.slice(1)));\r\n};\r\nexport const $$objectAssign = $objectAssign(null as any, null as any);\r\n\r\n\r\nexport const $jsonStringify = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-stringify x)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$jsonStringify', args, 1, 1);\r\n\r\n    return JSON.stringify($$first(...args));\r\n};\r\nexport const $$jsonStringify = $jsonStringify(null as any, null as any);\r\n\r\n\r\nexport const $jsonParse = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($json-parse x)\r\n    //  -> S expr  : object\r\n    checkParamsLength('$jsonParse', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $jsonParse: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    return JSON.parse(s);\r\n};\r\nexport const $$jsonParse = $jsonParse(null as any, null as any);\r\n\r\n\r\nexport const $now = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($now)\r\n    //  -> S expr  : number\r\n    return Date.now();\r\n};\r\nexport const $$now = $now(null as any, null as any);\r\n\r\n\r\nexport const $datetimeFromIso = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-from-iso str)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeFromIso', args, 1, 1);\r\n\r\n    const s = $$first(...args);\r\n    if (typeof s !== 'string') {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid argument(s): args[0] is not string.`);\r\n    }\r\n    if (! /^(?:(?:-[0-9]{6,})|[0-9]{4,})-(?:[0-1][0-9])-(?:[0-3][0-9])(?:T(?:[0-2][0-9])(?:[:](?:[0-6][0-9])(?:[:](?:[0-6][0-9])(?:.[0-9]{1,})?)?)?(?:Z|[-+][0-9]{2}(?:[:]?[0-6][0-9])?)?)?$/.test(s)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime (pattern unmatched): ${s}.`);\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeFromIso: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeFromIso = $datetimeFromIso(null as any, null as any);\r\n\r\n\r\nexport const $datetime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime year month1-12 day)\r\n    // S expression: ($datetime year month1-12 day hours)\r\n    // S expression: ($datetime year month1-12 day hours minutes)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetime', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n        s += 'Z';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetime: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetime = $datetime(null as any, null as any);\r\n\r\n\r\nexport const $datetimeLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-lc year month1-12 day)\r\n    // S expression: ($datetime-lc year month1-12 day hours)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds)\r\n    // S expression: ($datetime-lc year month1-12 day hours minutes seconds milliseconds)\r\n    //  -> S expr  : number\r\n    checkParamsLength('$datetimeLc', args, 3, 7);\r\n\r\n    let s = '';\r\n    const year = Number(args[0]);\r\n    if (year >= 0) {\r\n        s += String(year).padStart(4, '0');\r\n    } else {\r\n        s += '-' + String(-year).padStart(6, '0');\r\n    }\r\n    // month1\r\n    s += '-' + String(Number(args[1])).padStart(2, '0');\r\n    // day\r\n    s += '-' + String(Number(args[2])).padStart(2, '0');\r\n    // hours\r\n    if (args.length >= 4) {\r\n        s += 'T' + String(Number(args[3])).padStart(2, '0');\r\n        // minutes\r\n        if (args.length >= 5) {\r\n            s += ':' + String(Number(args[4])).padStart(2, '0');\r\n        } else {\r\n            s += ':00';\r\n        }\r\n        // seconds\r\n        if (args.length >= 6) {\r\n            s += ':' + String(Number(args[5])).padStart(2, '0');\r\n        }\r\n        // milliseconds\r\n        if (args.length >= 7) {\r\n            s += '.' + String(Number(args[6])).padStart(3, '0').slice(0, 3);\r\n        }\r\n    } else {\r\n        s += 'T00:00:00.000';\r\n    }\r\n    const dt = new Date(s).getTime();\r\n    if (Number.isNaN(dt)) {\r\n        throw new Error(`[SX] $datetimeLc: Invalid datetime: ${s}.`);\r\n    }\r\n    return dt;\r\n};\r\nexport const $$datetimeLc = $datetimeLc(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToIsoString = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-iso-string number)\r\n    //  -> S expr  : string\r\n    checkParamsLength('$datetimeToIsoString', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToIsoString: Invalid datetime: ${n}.`);\r\n    }\r\n    return dt.toISOString();\r\n};\r\nexport const $$datetimeToIsoString = $datetimeToIsoString(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponents = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponents', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponents: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getUTCFullYear(),\r\n        dt.getUTCMonth() + 1,\r\n        dt.getUTCDate(),\r\n        dt.getUTCHours(),\r\n        dt.getUTCMinutes(),\r\n        dt.getUTCSeconds(),\r\n        dt.getUTCMilliseconds(),\r\n        0, // TZ\r\n        dt.getUTCDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponents = $datetimeToComponents(null as any, null as any);\r\n\r\n\r\nexport const $datetimeToComponentsLc = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($datetime-to-components-lc number)\r\n    //  -> S expr  : list\r\n    checkParamsLength('$datetimeToComponentsLc', args, 1, 1);\r\n\r\n    const n = $$first(...args);\r\n    if (typeof n !== 'number') {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid argument(s): args[0] is not number.`);\r\n    }\r\n    const dt = new Date(n);\r\n    if (Number.isNaN(dt.getTime())) {\r\n        throw new Error(`[SX] $datetimeToComponentsLc: Invalid datetime: ${n}.`);\r\n    }\r\n    return ([\r\n        dt.getFullYear(),\r\n        dt.getMonth() + 1,\r\n        dt.getDate(),\r\n        dt.getHours(),\r\n        dt.getMinutes(),\r\n        dt.getSeconds(),\r\n        dt.getMilliseconds(),\r\n        -dt.getTimezoneOffset(), // time difference between local time and UTC time, in minutes.\r\n                                 // If your time zone is UTC+2:00, +120 will be returned.\r\n        dt.getDay(),\r\n    ]);\r\n};\r\nexport const $$datetimeToComponentsLc = $datetimeToComponentsLc(null as any, null as any);\r\n\r\n\r\nexport const $match = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($match pattern-str string)\r\n    // S expression: ($match pattern-str options-str string)\r\n    //  -> S expr  : array\r\n    checkParamsLength('$match', args, 2, 3);\r\n\r\n    if (! state.config.enableRegExpMatchOperators) {\r\n        throw new Error(`[SX] $match: Operator is disabled by configuration.`);\r\n    }\r\n\r\n    if (args.length === 2) {\r\n        const m = new RegExp(args[0]);\r\n        return m.exec(args[1]);\r\n    } else {\r\n        const m = new RegExp(args[0], args[1]);\r\n        return m.exec(args[2]);\r\n    }\r\n};\r\nexport const $$match = $match(null as any, null as any);\r\n\r\n\r\nexport const $consoleLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-log expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.log(...args);\r\n    return null;\r\n};\r\nexport const $$consoleLog = $consoleLog(null as any, null as any);\r\n\r\n\r\nexport const $consoleError = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-error expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.error(...args);\r\n    return null;\r\n};\r\nexport const $$consoleError = $consoleError(null as any, null as any);\r\n\r\n\r\nexport const $consoleTrace = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-trace expr1 ... exprN)\r\n    //  -> S expr  : null\r\n    console.trace(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTrace = $consoleTrace(null as any, null as any);\r\n\r\n\r\nexport const $consoleTime = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time)\r\n    // S expression: ($console-time label)\r\n    //  -> S expr  : null\r\n    console.time(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTime = $consoleTime(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeEnd = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-end)\r\n    // S expression: ($console-time-end label)\r\n    //  -> S expr  : null\r\n    console.timeEnd(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeEnd = $consoleTimeEnd(null as any, null as any);\r\n\r\n\r\nexport const $consoleTimeLog = (state: SxParserState, name: string) => (...args: any[]) => {\r\n    // S expression: ($console-time-log label)\r\n    // S expression: ($console-time-log label value ... value)\r\n    //  -> S expr  : null\r\n    (console as any).timeLog(...args);\r\n    return null;\r\n};\r\nexport const $$consoleTimeLog = $consoleTimeLog(null as any, null as any);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxMacroInfo,\r\n         SxParserState }     from '../../types';\r\nimport { isSymbol,\r\n         quote }             from '../../ast';\r\nimport { checkParamsLength } from '../../errors';\r\n\r\n\r\n\r\nexport const macros: SxMacroInfo[] = [{\r\n    name: '$scope',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($scope isBlockLocal returnMultiple ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal returnMultiple '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            list[1],\r\n            list[2],\r\n            ...(list.slice(3).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$local',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($local ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$global',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($__global expr1 ... exprN)\r\n        //  -> S expr  : ($__global returnMultiple=false 'expr ... 'expr)\r\n        return [{symbol: '$__global'},\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-let', // alias of $local\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-let ((name value) | name ...) expr ... expr)\r\n        //  -> S expr  : ($__scope isBlockLocal=true returnMultiple=false '((name value) | name ...) 'expr ... 'expr)\r\n        return [{symbol: '$__scope'},\r\n            true,\r\n            false,\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$capture',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($capture (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__capture '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__capture'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '->',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$refun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($refun name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '<-',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (<- name)\r\n        //  -> S expr  : ($__refun 'name)\r\n        return [{symbol: '$__refun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$defmacro',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($defmacro name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($__defmacro 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$__defmacro'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$call',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($call thisArg symbol arg1 ... argN)\r\n        //  -> S expr  : ($__call thisArg 'symbol arg1 ... argN)\r\n        checkParamsLength('$call', list, 3);\r\n\r\n        return [{symbol: '$__call'},\r\n            list[1],\r\n            quote(state, list[2]),\r\n            ...(list.slice(3)),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$try',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($try expr catch-expr)\r\n        //  -> S expr  : ($__try 't-expr 'catch-expr)\r\n        return [{symbol: '$__try'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if cond t-expr f-expr)\r\n        //  -> S expr  : ($__if cond 't-expr 'f-expr)\r\n        return [{symbol: '$__if'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$if-null',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($if-null cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '??',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (?? cond null-expr)\r\n        //  -> S expr  : ($__if-null cont 'null-expr)\r\n        return [{symbol: '$__if-null'},\r\n            list[1],\r\n            ...(list.slice(2).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$cond',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($cond cond1 expr1 ... condN exprN)\r\n        //  -> S expr  : ($__cond 'cond1 'expr1 ... 'condN 'exprN)\r\n        return [{symbol: '$__cond'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($while condition expr1 exprN)\r\n        //  -> S expr  : ($__while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-while',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-while condition expr1 exprN)\r\n        //  -> S expr  : ($__do-while 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-while'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($until condition expr1 exprN)\r\n        //  -> S expr  : ($__until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$do-until',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($do-until condition expr1 exprN)\r\n        //  -> S expr  : ($__do-until 'condition 'expr1 'exprN)\r\n        return [{symbol: '$__do-until'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$repeat',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($repeat i of n-times expr1 exprN)\r\n        //  -> S expr  : ($__repeat 'i n-times 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $repeat: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__repeat'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$for',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($for x of list expr1 exprN)\r\n        //  -> S expr  : ($__for 'x list 'expr1 'exprN)\r\n        const symOf = isSymbol(list[2], 'of');\r\n        if (! symOf) {\r\n            throw new Error(`[SX] $for: Invalid syntax: missing 'of' keyword.`);\r\n        }\r\n        return [{symbol: '$__for'},\r\n            quote(state, list[1]),\r\n            list[3],\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$get',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($get nameOrIndex1 ... nameOrIndexN)\r\n        //  -> S expr  : ($__get 'nameOrIndex1 ... 'nameOrIndexN)\r\n        return [{symbol: '$__get'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$let',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$let', list, 3, 3);\r\n\r\n        return [{symbol: '$__let'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-defvar',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($let nameStrOrSymbol expr)\r\n        //  -> S expr  : ($__let 'nameStrOrSymbol expr)\r\n        checkParamsLength('$clisp-defvar', list, 3, 3);\r\n\r\n        return [{symbol: '$global'},\r\n            [{symbol: '$__let'},\r\n                quote(state, list[1]),\r\n                list[2]\r\n            ],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$set',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($set nameOrListOfNameOrIndex expr)\r\n        //  -> S expr  : ($__set 'nameOrListOfNameOrIndex expr)\r\n        checkParamsLength('$set', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$clisp-setq', // alias of $set\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($clisp-setq symbol expr)\r\n        //  -> S expr  : ($__set 'symbol expr)\r\n        checkParamsLength('$clisp-setq', list, 3, 3);\r\n\r\n        return [{symbol: '$__set'},\r\n            quote(state, list[1]),\r\n            list[2],\r\n        ];\r\n    },\r\n}, {\r\n    name: '$and',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($and expr1 ... exprN)\r\n        //  -> S expr  : ($__and 'expr1 ... 'exprN)\r\n        return [{symbol: '$__and'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$or',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($or expr1 ... exprN)\r\n        //  -> S expr  : ($__or 'expr1 ... 'exprN)\r\n        return [{symbol: '$__or'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$gensym',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($gensym)\r\n        // S expression: ($gensym name)\r\n        //  -> S expr  : ($__gensym 'name)\r\n        return [\r\n            {symbol: '$__gensym'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '#',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (# (name value...)...)\r\n        //  -> S expr  : ($__# '(name value...)...)\r\n        return [\r\n            {symbol: '$__#'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\nexport const compilationMacros: SxMacroInfo[] = [{\r\n    name: '$$closure',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($__capture '(u-sym1 ... u-symM) ($$__lambda '(sym1 ... symN) 'expr ... 'expr) )\r\n        const symUse = isSymbol(list[2], 'use');\r\n        if (! symUse) {\r\n            throw new Error(`[SX] $closure: Invalid syntax: missing 'use' keyword.`);\r\n        }\r\n        return [{symbol: '$__capture'}, quote(state, list[3]), quote(state, [{symbol: '$$__lambda'},\r\n            quote(state, list[1]),\r\n            ...(list.slice(4).map(x => quote(state, x))),\r\n        ])];\r\n    },\r\n}, {\r\n    name: '|=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: (|-> (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        //  -> S expr  : ($closure (sym1 ... symN) use (u-sym1 ... u-symM) expr ... expr)\r\n        return [{symbol: '$$closure'},\r\n            ...list.slice(1),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$lambda',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '=>',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$lambda (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__lambda '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__lambda'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}, {\r\n    name: '$$defun',\r\n    fn: (state: SxParserState, name: string) => (list) => {\r\n        // S expression: ($$defun name (sym1 ... symN) expr ... expr)\r\n        //  -> S expr  : ($$__defun 'name '(sym1 ... symN) 'expr ... 'expr)\r\n        return [{symbol: '$$__defun'},\r\n            ...(list.slice(1).map(x => quote(state, x))),\r\n        ];\r\n    },\r\n}];\r\n\r\n\r\n// for backword compatibility\r\nexport default ([] as SxMacroInfo[]).concat(macros, compilationMacros);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxFuncInfo } from '../../types';\r\nimport * as ops       from './core.fn';\r\n\r\n\r\n\r\nexport const operators: SxFuncInfo[] = [{\r\n    name: '$car',\r\n    fn: ops.$car,\r\n}, {\r\n    name: '$cdr',\r\n    fn: ops.$cdr,\r\n}, {\r\n    name: '$cons',\r\n    fn: ops.$cons,\r\n}, {\r\n    name: '$first',\r\n    fn: ops.$first,\r\n}, {\r\n    name: '$second',\r\n    fn: ops.$second,\r\n}, {\r\n    name: '$last',\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$progn', // alias of $last\r\n    fn: ops.$last,\r\n}, {\r\n    name: '$rest',\r\n    fn: ops.$rest,\r\n}, {\r\n    name: '$first-and-second',\r\n    fn: ops.$firstAndSecond,\r\n}, {\r\n    name: '$atom',\r\n    fn: ops.$atom,\r\n}, {\r\n    name: '$eq',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '===',\r\n    fn: ops.$eq,\r\n}, {\r\n    name: '$not-eq',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '!==',\r\n    fn: ops.$notEq,\r\n}, {\r\n    name: '$list',\r\n    fn: ops.$list,\r\n}, {\r\n    name: '$__scope',\r\n    fn: ops.$__scope,\r\n}, {\r\n    name: '$__global',\r\n    fn: ops.$__globalScope,\r\n}, {\r\n    name: '$__capture',\r\n    fn: ops.$__capture,\r\n}, {\r\n    name: '$__lambda',\r\n    fn: ops.$__lambda,\r\n}, {\r\n    name: '$__defun',\r\n    fn: ops.$__defun,\r\n}, {\r\n    name: '$__refun',\r\n    fn: ops.$__refun,\r\n}, {\r\n    name: '$__defmacro',\r\n    fn: ops.$__defmacro,\r\n}, {\r\n    name: '$apply',\r\n    fn: ops.$apply,\r\n}, {\r\n    name: '$__call',\r\n    fn: ops.$__call,\r\n}, {\r\n    name: '$__try',\r\n    fn: ops.$__try,\r\n}, {\r\n    name: '$raise',\r\n    fn: ops.$raise,\r\n}, {\r\n    name: '$__if',\r\n    fn: ops.$__if,\r\n}, {\r\n    name: '$__if-null',\r\n    fn: ops.$__ifNull,\r\n}, {\r\n    name: '$__cond',\r\n    fn: ops.$__cond,\r\n}, {\r\n    name: '$__while',\r\n    fn: ops.$__while,\r\n}, {\r\n    name: '$__do-while',\r\n    fn: ops.$__doWhile,\r\n}, {\r\n    name: '$__until',\r\n    fn: ops.$__until,\r\n}, {\r\n    name: '$__do-until',\r\n    fn: ops.$__doUntil,\r\n}, {\r\n    name: '$__repeat',\r\n    fn: ops.$__repeat,\r\n}, {\r\n    name: '$__for',\r\n    fn: ops.$__for,\r\n}, {\r\n    name: '$pipe',\r\n    fn: ops.$pipe,\r\n}, {\r\n    name: '$__get',\r\n    fn: ops.$__get,\r\n}, {\r\n    name: '$__let',\r\n    fn: ops.$__let,\r\n}, {\r\n    name: '$__set',\r\n    fn: ops.$__set,\r\n}, {\r\n    name: '$boolean',\r\n    fn: ops.$boolean,\r\n}, {\r\n    name: '$not',\r\n    fn: ops.$not,\r\n}, {\r\n    name: '$__and',\r\n    fn: ops.$__and,\r\n}, {\r\n    name: '$__or',\r\n    fn: ops.$__or,\r\n}, {\r\n    name: '==',\r\n    fn: ops.$ambiguousEq,\r\n}, {\r\n    name: '!=',\r\n    fn: ops.$ambiguousNotEq,\r\n}, {\r\n    name: '<',\r\n    fn: ops.$lt,\r\n}, {\r\n    name: '<=',\r\n    fn: ops.$le,\r\n}, {\r\n    name: '>',\r\n    fn: ops.$gt,\r\n}, {\r\n    name: '>=',\r\n    fn: ops.$ge,\r\n}, {\r\n    name: '$typeof',\r\n    fn: ops.$typeof,\r\n}, {\r\n    name: '$symbol',\r\n    fn: ops.$symbol,\r\n}, {\r\n    name: '$__gensym',\r\n    fn: ops.$__gensym,\r\n}, {\r\n    name: '$is-symbol',\r\n    fn: ops.$isSymbol,\r\n}, {\r\n    name: '$is-null',\r\n    fn: ops.$isNull,\r\n}, {\r\n    name: '$is-nil',\r\n    fn: ops.$isNil,\r\n}, {\r\n    name: '$is-undefined',\r\n    fn: ops.$isUndefined,\r\n}, {\r\n    name: '$is-list',\r\n    fn: ops.$isList,\r\n}, {\r\n    name: '$is-string',\r\n    fn: ops.$isString,\r\n}, {\r\n    name: '$is-number',\r\n    fn: ops.$isNumber,\r\n}, {\r\n    name: '$is-NaN',\r\n    fn: ops.$isNaN,\r\n}, {\r\n    name: '$is-finite',\r\n    fn: ops.$isFinite,\r\n}, {\r\n    name: '$is-integer',\r\n    fn: ops.$isInteger,\r\n}, {\r\n    name: '$to-string',\r\n    fn: ops.$toString,\r\n}, {\r\n    name: '$to-number',\r\n    fn: ops.$toNumber,\r\n}, {\r\n    name: '$__#',\r\n    fn: ops.$__toObject,\r\n}, {\r\n    name: '$object-assign',\r\n    fn: ops.$objectAssign,\r\n}, {\r\n    name: '$json-stringify',\r\n    fn: ops.$jsonStringify,\r\n}, {\r\n    name: '$now',\r\n    fn: ops.$now,\r\n}, {\r\n    name: '$datetime-from-iso',\r\n    fn: ops.$datetimeFromIso,\r\n}, {\r\n    name: '$datetime',\r\n    fn: ops.$datetime,\r\n}, {\r\n    name: '$datetime-lc',\r\n    fn: ops.$datetimeLc,\r\n}, {\r\n    name: '$datetime-to-iso-string',\r\n    fn: ops.$datetimeToIsoString,\r\n}, {\r\n    name: '$datetime-to-components',\r\n    fn: ops.$datetimeToComponents,\r\n}, {\r\n    name: '$datetime-to-components-lc',\r\n    fn: ops.$datetimeToComponentsLc,\r\n}, {\r\n    name: '$json-parse',\r\n    fn: ops.$jsonParse,\r\n}, {\r\n    name: '$match',\r\n    fn: ops.$match,\r\n}, {\r\n    name: '$console-log',\r\n    fn: ops.$consoleLog,\r\n}, {\r\n    name: '$console-error',\r\n    fn: ops.$consoleError,\r\n}, {\r\n    name: '$console-trace',\r\n    fn: ops.$consoleTrace,\r\n}, {\r\n    name: '$console-time',\r\n    fn: ops.$consoleTime,\r\n}, {\r\n    name: '$console-time-end',\r\n    fn: ops.$consoleTimeEnd,\r\n}, {\r\n    name: '$console-time-log',\r\n    fn: ops.$consoleTimeLog,\r\n}];\r\n\r\n\r\nexport const compilationOperators: SxFuncInfo[] = [{\r\n    name: '$$__lambda',\r\n    fn: ops.$comp$__lambda,\r\n}, {\r\n    name: '$$__defun',\r\n    fn: ops.$comp$__defun,\r\n}];\r\n\r\n\r\n// for backword compatibility\r\nexport default ([] as SxFuncInfo[]).concat(operators, compilationOperators);\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxSymbolInfo } from '../../types';\r\n\r\n\r\n\r\nexport const symbols: SxSymbolInfo[] = [\r\n    {name: 'nil', fn: (state: SxParserState, name: string) => []},\r\n    {name: 'null', fn: (state: SxParserState, name: string) => null},\r\n\r\n    {name: 'undefined', fn: (state: SxParserState, name: string) => void 0},\r\n\r\n    {name: 'true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#true', fn: (state: SxParserState, name: string) => true},\r\n    {name: '#t', fn: (state: SxParserState, name: string) => true},\r\n\r\n    {name: 'false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#false', fn: (state: SxParserState, name: string) => false},\r\n    {name: '#f', fn: (state: SxParserState, name: string) => false},\r\n\r\n    {name: '#Number:Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '+Infinity', fn: (state: SxParserState, name: string) => Number.POSITIVE_INFINITY},\r\n    {name: '-Infinity', fn: (state: SxParserState, name: string) => Number.NEGATIVE_INFINITY},\r\n\r\n    {name: '#Number:Epsilon', fn: (state: SxParserState, name: string) => Number.EPSILON},\r\n    {name: '#Number:MaxValue', fn: (state: SxParserState, name: string) => Number.MAX_VALUE},\r\n    {name: '#Number:MinValue', fn: (state: SxParserState, name: string) => Number.MIN_VALUE},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MAX_SAFE_INTEGER},\r\n    {name: '#Number:MinSafeInteger', fn: (state: SxParserState, name: string) => Number.MIN_SAFE_INTEGER},\r\n\r\n    {name: 'NaN', fn: (state: SxParserState, name: string) => Number.NaN},\r\n];\r\n\r\n\r\nexport default symbols;\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserConfig }       from '../../types';\r\nimport { operators,\r\n         compilationOperators } from './core.operator';\r\nimport { macros,\r\n         compilationMacros }    from './core.macro';\r\nimport symbols                  from './core.symbol';\r\n\r\n\r\n\r\nexport default function install(config: SxParserConfig): SxParserConfig {\r\n    config.funcs = (config.funcs || [])\r\n        .concat(operators)\r\n        .concat(config.enableCompilationOperators ? compilationOperators : []);\r\n    config.macros = (config.macros || [])\r\n        .concat(macros)\r\n        .concat(config.enableCompilationOperators ? compilationMacros : []);\r\n    config.symbols = (config.symbols || []).concat(symbols);\r\n    return config;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\nimport { SxParserState,\r\n         SxEof,\r\n         SxExternalValue,\r\n         SxSymbol,\r\n         SxDottedFragment,\r\n         SxComment,\r\n         SxToken,\r\n         SxChar,\r\n         ScriptTerminationError } from './types';\r\nimport { quote,\r\n         backquote,\r\n         wrapByUnquote,\r\n         spread,\r\n         splice }                 from './ast';\r\n\r\n\r\n\r\nfunction isEOF(ch: SxChar): boolean {\r\n    return typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'eof');\r\n}\r\n\r\n\r\nfunction isSpace(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && ch.trim().length === 0;\r\n}\r\n\r\n\r\nfunction isNumberFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9\\+\\-]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isNumberAfterSignChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' && /^[0-9]$/.test(ch);\r\n}\r\n\r\n\r\nfunction isSymbolFirstChar(ch: SxChar): boolean {\r\n    return typeof ch === 'string' &&\r\n        !isSpace(ch) &&\r\n        !isNumberFirstChar(ch);\r\n}\r\n\r\n\r\n\r\nfunction lookCurrentLineHint(state: SxParserState): string {\r\n    return `line: ${state.line} / strings: ${state.index} / pos: ${state.pos} :${\r\n        state.strings.length > state.index ?\r\n            state.strings[state.index].slice(state.pos, state.pos + 20) : ''}`;\r\n}\r\n\r\n\r\nfunction getChar(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    if (state.strings.length <= state.index) {\r\n        return {eof: true};\r\n    }\r\n    if (state.strings[state.index].length <= state.pos) {\r\n        if ((! state.values) || (state.values.length <= state.index)) {\r\n            state.pos = 0;\r\n            state.index++;\r\n            return getChar(state);\r\n        } else {\r\n            const ch = {value: state.values[state.index]};\r\n            state.pos = 0;\r\n            state.index++;\r\n            return ch;\r\n        }\r\n    }\r\n    if (virtualEof) {\r\n        for (const v of virtualEof) {\r\n            const ch = state.strings[state.index].slice(state.pos, state.pos + v.length);\r\n            if (ch === v) {\r\n                state.pos += v.length;\r\n                state.line += ch.split('\\n').length - 1;\r\n                return { eof: false , eofSeq: v };\r\n            }\r\n        }\r\n    }\r\n    {\r\n        let ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n        state.pos++;\r\n\r\n        if (ch === '\\n') {\r\n            state.line++;\r\n        }\r\n\r\n        if ((! disableEscape) && ch === '\\\\') {\r\n            if (state.strings[state.index].length <= state.pos) {\r\n                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n            ch = state.strings[state.index].slice(state.pos, state.pos + 1);\r\n            state.pos++;\r\n\r\n            switch (ch) {\r\n            case 'b':\r\n                ch = '\\b';\r\n                break;\r\n            case 't':\r\n                ch = '\\t';\r\n                break;\r\n            case 'n':\r\n                ch = '\\n';\r\n                break;\r\n            case 'v':\r\n                ch = '\\v';\r\n                break;\r\n            case 'f':\r\n                ch = '\\f';\r\n                break;\r\n            case 'r':\r\n                ch = '\\r';\r\n                break;\r\n            case 'U': case 'u':\r\n                {\r\n                    if (state.strings[state.index].slice(state.pos, state.pos + 1) === '{') {\r\n                        let ch1 = '';\r\n                        for (let i = 0; i < 6; i++) {\r\n                            const ch2 = state.strings[state.index].slice(state.pos + i, state.pos + 1 + i);\r\n                            if (ch2 === '}') {\r\n                                if (i === 0) {\r\n                                    throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                                }\r\n                                state.pos += i;\r\n                                break;\r\n                            } else if (! /^[0-9A-Fa-f]{1}$/.test(ch1)) {\r\n                                throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            ch1 += ch2;\r\n                        }\r\n                        if (state.strings[state.index].slice(state.pos, state.pos + 1) !== '}') {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos++;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    } else {\r\n                        const ch1 = state.strings[state.index].slice(state.pos, state.pos + 4);\r\n                        if (! /^[0-9A-Fa-f]{4}$/.test(ch1)) {\r\n                            throw new Error(`[SX] getChar: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        state.pos += 4;\r\n                        ch = String.fromCodePoint(Number.parseInt(ch1, 16));\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return ch;\r\n    }\r\n}\r\n\r\n\r\nfunction lookAheads(state: SxParserState, n: number, virtualEof?: string[], disableEscape?: boolean): SxChar[] {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    const chs: SxChar[] = [];\r\n\r\n    try {\r\n        for (let i = 0; i < n; i++) {\r\n            chs.push(getChar(state, virtualEof, disableEscape));\r\n        }\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return chs;\r\n}\r\n\r\n\r\nfunction lookAhead(state: SxParserState, virtualEof?: string[], disableEscape?: boolean): SxChar {\r\n    const index = state.index;\r\n    const pos = state.pos;\r\n    const line = state.line;\r\n    let ch: SxChar;\r\n\r\n    try {\r\n        ch = getChar(state, virtualEof, disableEscape);\r\n    } finally {\r\n        state.index = index;\r\n        state.pos = pos;\r\n        state.line = line;\r\n    }\r\n\r\n    return ch;\r\n}\r\n\r\n\r\nfunction skipWhitespaces(state: SxParserState): void {\r\n    let ch = lookAhead(state);\r\n    while (!isEOF(ch) && isSpace(ch)) {\r\n        getChar(state);\r\n        ch = lookAhead(state);\r\n    }\r\n}\r\n\r\n\r\n\r\nfunction parseNumber(state: SxParserState, virtualEof?: string[]): number {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (/^0[XxOoBb][0-9]*$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else if (/^[0-9\\+\\-\\.EeInfinityNaN]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (! /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)|(0[XxOoBb][0-9]+)|([\\+\\-]Infinity)|(NaN)$/.test(s)) {\r\n        throw new Error(`[SX] parseNumber: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n    }\r\n    return Number(s);\r\n}\r\n\r\n\r\nfunction parseSymbol(state: SxParserState, virtualEof?: string[]): SxSymbol | number | null {\r\n    let s = '';\r\n    let ch = lookAhead(state, virtualEof);\r\n\r\n    while (! isEOF(ch)) {\r\n        if (typeof ch === 'string') {\r\n            if (isSpace(ch)) {\r\n                break;\r\n            } else if (ch === '#' && lookAheads(state, 2, virtualEof)[1] === '|') {\r\n                break;\r\n            } else if (/^[^.;()\"]+$/.test(s + ch)) {\r\n                getChar(state, virtualEof);\r\n                s += ch;\r\n            } else {\r\n                break;\r\n            }\r\n        } else {\r\n            if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                getChar(state, virtualEof);\r\n                const v = (ch as SxExternalValue).value;\r\n                s += String(ch);\r\n            } else {\r\n                throw new Error(`[SX] parseSymbol: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        ch = lookAhead(state, virtualEof);\r\n    }\r\n\r\n    if (state.config.enableShorthands) {\r\n        let m: RegExpMatchArray | null = null;\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        if (m = s.match(/^:((?:\\:[^=:]+?)+?)=$/)) {\r\n            // ::foo:bar:baz= -> ($splice ($set (foo bar baz)))\r\n            const ws = m[1].slice(1).split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.set},\r\n                        ws\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^:((?:\\:[^@:]+?)+?)@([^@:]+?)$/)) {\r\n            // ::foo:bar@baz -> ($splice ($call ($get foo bar) baz))\r\n            const ws = m[1].slice(1).split(':');\r\n            const z =\r\n                [{symbol: state.config.reservedNames.splice},\r\n                    [{symbol: state.config.reservedNames.call},\r\n                        [{symbol: state.config.reservedNames.get}, ...ws],\r\n                        {symbol: m[2]},\r\n                    ]\r\n                ];\r\n            return z as any;\r\n        }\r\n        // tslint:disable-next-line:no-conditional-assignment\r\n        else if (m = s.match(/^:((?:\\:[^:]+?)+?)$/)) {\r\n            // ::foo:bar:baz -> ($get foo bar baz)\r\n            const ws = m[1].slice(1).split(':');\r\n            const z = [{symbol: state.config.reservedNames.get}, ...ws];\r\n            return z as any;\r\n        }\r\n    }\r\n\r\n    return {symbol: s};\r\n}\r\n\r\n\r\nfunction parseStringOrComment(\r\n        state: SxParserState, eof: string[],\r\n        valuesStartSeq: string | null,\r\n        valuesStopChar: string,\r\n        disableEscape: boolean,\r\n        allowPhysicalEof: boolean,\r\n    ): { strings: string[], values: any[] } {\r\n\r\n    const eofSeqs = valuesStartSeq ? [...eof, valuesStartSeq] : eof;\r\n    const strings: string[] = [];\r\n    const values: any[] = [];\r\n\r\n    for (;;) {\r\n        let s = '';\r\n        let ch = lookAhead(state, eofSeqs, disableEscape);\r\n\r\n        while (! isEOF(ch)) {\r\n            if (typeof ch === 'string') {\r\n                getChar(state, eofSeqs, disableEscape);\r\n                s += ch;\r\n            } else {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state, eofSeqs, disableEscape);\r\n                    const v = (ch as SxExternalValue).value;\r\n                    s += String(ch);\r\n                } else {\r\n                    throw new Error(`[SX] parseStringOrComment: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            }\r\n\r\n            ch = lookAhead(state, eofSeqs, disableEscape);\r\n        }\r\n\r\n        getChar(state, eofSeqs, disableEscape);\r\n\r\n        if ((ch as SxEof).eof === true) {\r\n            if (! allowPhysicalEof) {\r\n                throw new ScriptTerminationError('parseStringOrComment');\r\n            }\r\n        }\r\n\r\n        strings.push(s);\r\n\r\n        if ((ch as SxEof).eofSeq === valuesStartSeq) {\r\n            values.push(parseList(state, valuesStopChar, []));\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n\r\n    return { strings, values };\r\n}\r\n\r\n\r\nfunction parseString(state: SxParserState, disableEscape: boolean): string {\r\n    return parseStringOrComment(state, ['\"'], null, ')', disableEscape, false).strings[0];\r\n}\r\n\r\n\r\nfunction parseHereDoc(state: SxParserState, symbol: SxSymbol, attrs: SxToken[] | null): SxToken[] {\r\n    const q: SxToken[] = [symbol];\r\n\r\n    if (attrs) {\r\n        q.push(attrs);\r\n    }\r\n\r\n    const inner = parseStringOrComment(state, ['\"\"\"'], '%%%(', ')', false, false);\r\n    for (let i = 0; i < inner.strings.length; i++) {\r\n        q.push(inner.strings[i]);\r\n        if (i < inner.values.length) {\r\n            q.push(inner.values[i]);\r\n        }\r\n    }\r\n\r\n    return q;\r\n}\r\n\r\n\r\nfunction parseSingleLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['\\r', '\\n'], null, ')', false, true).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseMultiLineComment(state: SxParserState): SxComment | ' ' {\r\n    return {\r\n        comment: parseStringOrComment(state, ['|#'], null, ')', false, false).strings[0]\r\n    };\r\n}\r\n\r\n\r\nfunction parseOneToken(state: SxParserState): SxToken {\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case ')':\r\n            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n\r\n        case '(':\r\n            getChar(state);\r\n            return parseList(state, ')', []);\r\n\r\n        case \"'\": case \"`\": case ',':\r\n            {\r\n                getChar(state);\r\n                const ahead = lookAhead(state);\r\n                let isSpliceUnquote = false;\r\n                if (ch === ',' && ahead === '@') {\r\n                    getChar(state);\r\n                    isSpliceUnquote = true;\r\n                }\r\n                skipWhitespaces(state);\r\n                const ret = (ch === \"'\" ?\r\n                        quote :\r\n                        (ch === \"`\" ? backquote : wrapByUnquote))\r\n                    (state, parseOneToken(state)\r\n                );\r\n                return (isSpliceUnquote ? splice(state, ret) : ret);\r\n            }\r\n\r\n        case \".\":\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 2);\r\n                if (state.config.enableSpread && aheads[0] === '.' && aheads[1] === '.') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    skipWhitespaces(state);\r\n                    return spread(state, parseOneToken(state));\r\n                } else {\r\n                    skipWhitespaces(state);\r\n                    return {dotted: parseOneToken(state)};\r\n                }\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            return parseSingleLineComment(state);\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseMultiLineComment(state);\r\n                } else {\r\n                    return parseSymbol(state);\r\n                }\r\n            }\r\n\r\n        case '\"':\r\n            {\r\n                getChar(state);\r\n                const aheads = lookAheads(state, 4);\r\n                if (state.config.enableHereDoc && aheads[0] === '\"' && aheads[1] === '\"') {\r\n                    let isHereDoc = true;\r\n                    if (isEOF(aheads[2]) || isSpace(aheads[2])) {\r\n                        // here doc\r\n                    } else if (isNumberFirstChar(aheads[2])) { // TODO: single +/- char is a symbol.\r\n                        if (aheads[2] === '+' || aheads[2] === '-') {\r\n                            if (! isNumberAfterSignChar(aheads[3])) {\r\n                                isHereDoc = false;\r\n                            }\r\n                        }\r\n                        // here doc\r\n                    } else if (isSymbolFirstChar(aheads[2])) {\r\n                        isHereDoc = false;\r\n                    } else {\r\n                        // here doc\r\n                    }\r\n                    getChar(state);\r\n                    getChar(state);\r\n\r\n                    let sym: SxSymbol | number | null = null;\r\n                    let attrs: SxToken[] | null = null;\r\n                    if (isHereDoc) {\r\n                        sym = {symbol: state.config.reservedNames.Template};\r\n                    } else {\r\n                        sym = parseSymbol(state, ['@']);\r\n                        if (sym === null) {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        if (typeof sym === 'number') {\r\n                            throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                        }\r\n                        const ahs = lookAheads(state, 2);\r\n                        if (ahs[0] === '@') {\r\n                            if (ahs[1] !== '{') {\r\n                                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                            }\r\n                            getChar(state);\r\n                            getChar(state);\r\n                            const a = parseList(state, '}', [{symbol: '@'}]);\r\n                            if (Array.isArray(a)) {\r\n                                attrs = a;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    return parseHereDoc(state, sym, attrs);\r\n                } else {\r\n                    return parseString(state, false);\r\n                }\r\n            }\r\n\r\n        case '@':\r\n            if (state.config.enableVerbatimStringLiteral) {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '\"') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    return parseString(state, true);\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            if (typeof ch !== 'string') {\r\n                if (typeof ch === 'object' && Object.prototype.hasOwnProperty.call(ch, 'value')) {\r\n                    getChar(state);\r\n                    return state.config.wrapExternalValue ? ch : (ch as SxExternalValue).value;\r\n                } else {\r\n                    throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                }\r\n            } else if (isSpace(ch)) {\r\n                break;\r\n            } else if (isNumberFirstChar(ch)) { // TODO: single +/- char is a symbol.\r\n                if (ch === '+' || ch === '-') {\r\n                    const aheads = lookAheads(state, 2);\r\n                    if (! isNumberAfterSignChar(aheads[1])) {\r\n                        return parseSymbol(state);\r\n                    }\r\n                }\r\n                return parseNumber(state);\r\n            } else if (isSymbolFirstChar(ch)) {\r\n                return parseSymbol(state);\r\n            } else {\r\n                throw new Error(`[SX] parseOneToken: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n            }\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseOneToken');\r\n}\r\n\r\n\r\nfunction parseList(state: SxParserState, listStopChar: string, initialList: SxToken[]): SxToken {\r\n    const r: SxToken[] = initialList.slice(0);\r\n    let dotted = false;\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case listStopChar:\r\n            getChar(state);\r\n            if (dotted) {\r\n                return r[0];\r\n            } else {\r\n                return r;\r\n            }\r\n\r\n        default:\r\n            {\r\n                const t = parseOneToken(state);\r\n                if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'dotted')) {\r\n                    if (r.length !== 1) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    dotted = true;\r\n                    if (Array.isArray(t)) {\r\n                        t.unshift(r.pop() as SxToken);\r\n                        r.push(t);\r\n                    } else {\r\n                        r.push({car: r.pop() as SxToken, cdr: (t as SxDottedFragment).dotted});\r\n                    }\r\n                } else if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                    if (! state.config.stripComments) {\r\n                        r.push(t);\r\n                    }\r\n                } else {\r\n                    if (dotted) {\r\n                        throw new Error(`[SX] parseList: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n                    }\r\n                    r.push(t);\r\n                }\r\n            }\r\n            break;\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    throw new ScriptTerminationError('parseList');\r\n}\r\n\r\n\r\n\r\nexport function parse(state: SxParserState) {\r\n    const r: SxToken[] = [];\r\n\r\n    skipWhitespaces(state);\r\n    let ch = lookAhead(state);\r\n\r\n    while (! isEOF(ch)) {\r\n        switch (ch) {\r\n        case '(':\r\n            getChar(state);\r\n            r.push(parseList(state, ')', []));\r\n            break;\r\n\r\n        case \"'\": case \"`\":\r\n            {\r\n                getChar(state);\r\n                skipWhitespaces(state);\r\n                for (;;) {\r\n                    const t = parseOneToken(state);\r\n                    if (typeof t === 'object' && Object.prototype.hasOwnProperty.call(t, 'comment')) {\r\n                        if (! state.config.stripComments) {\r\n                            r.push(t);\r\n                        }\r\n                    } else {\r\n                        r.push((ch === \"'\" ? quote : backquote)(state, t));\r\n                        break;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n\r\n        case ';':\r\n            getChar(state);\r\n            if (state.config.stripComments) {\r\n                parseSingleLineComment(state);\r\n            } else {\r\n                r.push(parseSingleLineComment(state));\r\n            }\r\n            break;\r\n\r\n        case '#':\r\n            {\r\n                const aheads = lookAheads(state, 2);\r\n                if (aheads[1] === '|') {\r\n                    getChar(state);\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseMultiLineComment(state);\r\n                    } else {\r\n                        r.push(parseMultiLineComment(state));\r\n                    }\r\n                } else {\r\n                    getChar(state);\r\n                    if (state.config.stripComments) {\r\n                        parseSingleLineComment(state);\r\n                    } else {\r\n                        r.push(parseSingleLineComment(state));\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n\r\n        case '\"':\r\n            {\r\n                const aheads = lookAheads(state, 3);\r\n                if (aheads[1] === '\"' && aheads[2] === '\"') {\r\n                    r.push(parseOneToken(state));\r\n                    break;\r\n                }\r\n            }\r\n            // FALL_THRU\r\n\r\n        default:\r\n            throw new Error(`[SX] parseInitialState: Invalid syntax at: ${lookCurrentLineHint(state)}.`);\r\n        }\r\n\r\n        skipWhitespaces(state);\r\n        ch = lookAhead(state);\r\n    }\r\n\r\n    return r;\r\n}\r\n","// Copyright (c) 2018, Shellyl_N and Authors\r\n// license: ISC\r\n// https://github.com/shellyln\r\n\r\n\r\n\r\nexport type SxMacro = (state: SxParserState, name: string, formalArgs?: SxSymbol[]) => (list: SxToken[]) => SxToken;\r\n\r\nexport interface SxMacroInfo {\r\n    name: string;\r\n    fn: SxMacro;\r\n\r\n    formalArgs?: SxSymbol[];\r\n    lastIsSpread?: boolean;\r\n    next?: SxMacroInfo;\r\n}\r\n\r\n\r\nexport type SxFunc = (state: SxParserState, name: string) => (...args: any[]) => any;\r\n\r\nexport interface SxFuncInfo {\r\n    name: string;\r\n    fn: SxFunc;\r\n\r\n    // TODO: overloading\r\n    // formalArgs?: SxSymbol[];\r\n    // lastIsSpread?: boolean;\r\n    // next?: SxFuncInfo;\r\n}\r\n\r\n\r\nexport type SxSymbolResolver = (state: SxParserState, name: string) => any;\r\n\r\nexport interface SxSymbolInfo {\r\n    name: string;\r\n    fn: SxSymbolResolver;\r\n}\r\n\r\n\r\nexport interface CapturedScopes { [s: string]: { [s: string]: any; }; }\r\n\r\nexport interface SxScope {\r\n    isBlockLocal: boolean;\r\n    scope: any;           // { [s: string]: any; };\r\n    capturedScopes?: CapturedScopes;\r\n}\r\n\r\n\r\nexport interface SxReservedNames {\r\n    eval: string;\r\n    quote: string;\r\n    backquote: string;\r\n    unquote: string;\r\n    spread: string;\r\n    splice: string;\r\n\r\n    car: string;\r\n    cdr: string;\r\n    cons: string;\r\n    atom: string;\r\n    eq: string;\r\n    list: string;\r\n\r\n    let: string;\r\n    lambda: string;\r\n    self: string;\r\n    defun: string;\r\n    thiz: string;\r\n\r\n    if: string;\r\n    cond: string;\r\n\r\n    while: string;\r\n    doWhile: string;\r\n    until: string;\r\n    doUntil: string;\r\n\r\n    get: string;\r\n    defvar: string;\r\n    setq: string;\r\n    set: string;\r\n    call: string;\r\n\r\n    not: string;\r\n    and: string;\r\n    or: string;\r\n\r\n    isSymbol: string;\r\n    gensym: string;\r\n    raise: string;\r\n    catch: string;\r\n\r\n    Template: string;\r\n}\r\n\r\nexport interface SxParserConfig {\r\n    raiseOnUnresolvedSymbol: boolean;\r\n    enableEvaluate: boolean;\r\n    enableHereDoc: boolean;\r\n    enableSpread: boolean;\r\n    enableSplice: boolean;\r\n    enableShorthands: boolean;\r\n    enableVerbatimStringLiteral: boolean;\r\n    enableTailCallOptimization: boolean;\r\n    enableRegExpMatchOperators: boolean; // IMPORTANT: Turn off to prevent ReDoS when executing untrusted code\r\n    enableCompilationOperators: boolean; // IMPORTANT: Turn off to prevent DoS when executing untrusted code\r\n    stripComments: boolean;\r\n    wrapExternalValue: boolean;\r\n    reservedNames: SxReservedNames;\r\n    returnMultipleRoot: boolean;\r\n    maxEvalCount: number;                // IMPORTANT: Set positive value to prevent DoS when executing untrusted code\r\n\r\n    jsx?: (comp: any, props: any, ...children: any[]) => any;\r\n    JsxFragment?: any;\r\n\r\n    funcs: SxFuncInfo[];\r\n    macros: SxMacroInfo[];\r\n    symbols: SxSymbolInfo[];\r\n\r\n    funcSymbolResolverFallback?: SxFunc;\r\n    valueSymbolResolverFallback?: SxSymbolResolver;\r\n}\r\n\r\nexport interface SxParserState {\r\n    strings: TemplateStringsArray | string[];\r\n    values: any[];\r\n\r\n    index: number;\r\n    pos: number;\r\n    line: number;\r\n\r\n    evalCount: number;\r\n\r\n    scopes: SxScope[];\r\n\r\n    macroMap: Map<string, SxMacroInfo>;\r\n    funcMap: Map<string, SxFuncInfo>;\r\n    symbolMap: Map<string, SxSymbolInfo>;\r\n\r\n    config: SxParserConfig;\r\n}\r\n\r\nexport interface SxEof {\r\n    eof: boolean; // true: truely EOF comes. false: detect virtual EOF.\r\n    eofSeq?: string;\r\n}\r\n\r\nexport interface SxExternalValue {\r\n    value: any;\r\n}\r\n\r\nexport interface SxSymbol {\r\n    'symbol': string;\r\n\r\n    // TODO: debug info\r\n    // _fileName?: string;\r\n    // _line?: number;\r\n    // _col?: number;\r\n}\r\n\r\nexport interface SxComment {\r\n    comment: string;\r\n}\r\n\r\nexport interface SxDottedPair {\r\n    car: SxToken; // left\r\n    cdr: SxToken; // right\r\n}\r\n\r\nexport interface SxDottedFragment {\r\n    dotted: SxToken; // right\r\n}\r\n\r\n\r\nexport type SxTokenChild = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | /*SxToken*/ any[];\r\nexport type SxToken      = SxSymbol | SxDottedPair | SxDottedFragment | SxComment | SxExternalValue | string | number | boolean | null | SxTokenChild[];\r\nexport type SxChar = string | SxEof | SxExternalValue;\r\nexport type SxAtom = SxSymbol | string | number | boolean | null;\r\nexport type SxList = SxDottedPair | SxAtom[];\r\n\r\n\r\n\r\nexport type CompilerOperator = (r: SxToken[], args: SxToken[]) => string;\r\n\r\n\r\nexport interface CompilerContext {\r\n    _$_vars: any[];\r\n    varsCount: number;\r\n    varNames: Map<string, string>;\r\n    varNamesCount: number;\r\n    varDefs: string;\r\n    ops: Map<string, CompilerOperator>;\r\n    makeScope: (scoped: () => void) => void;\r\n    compileToken: (body: any[], i: number) => string;\r\n}\r\n\r\n\r\nexport interface LsxConfig {\r\n    jsx: (comp: any, props: any, ...children: any[]) => any;\r\n    jsxFlagment: any;\r\n    components: object;\r\n}\r\n\r\n\r\nexport class FatalError extends Error {\r\n    public constructor(message?: string | undefined) {\r\n        super(message);\r\n    }\r\n}\r\n\r\n\r\nexport class MaxEvaluationCountError extends FatalError {\r\n    public constructor() {\r\n        super(`[SX] evaluate: The maximum count of evaluations has been exceeded.`);\r\n    }\r\n}\r\n\r\n\r\nexport class ScriptTerminationError extends FatalError {\r\n    public constructor(where: string) {\r\n        super(`[SX] ${where}: Unexpected termination of script.`);\r\n    }\r\n}\r\n\r\n\r\nexport interface SExpressionRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => R;\r\n}\r\n\r\n\r\nexport interface SExpressionTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): R;\r\n    evaluateAST: (ast: SxToken[]) => R;\r\n    repl: () => SExpressionRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionTemplateFn<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncRepl<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    sync: (strings: TemplateStringsArray | string, ...values: any[]) => Promise<R>;\r\n}\r\n\r\n\r\nexport interface SExpressionAsyncTemplateFn<R = SxToken> {\r\n    (strings: TemplateStringsArray | string, ...values: any[]): Promise<R>;\r\n    evaluateAST: (ast: SxToken[]) => Promise<R>;\r\n    repl: () => SExpressionAsyncRepl<R>;\r\n    setGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    appendGlobals: (globals: object) => SExpressionAsyncTemplateFn<R>;\r\n    setStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    setStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartup: (strings: TemplateStringsArray | string, ...values: any[]) => SExpressionAsyncTemplateFn<R>;\r\n    appendStartupAST: (ast: SxToken[]) => SExpressionAsyncTemplateFn<R>;\r\n    install: (installer: (config: SxParserConfig) => SxParserConfig) => SExpressionAsyncTemplateFn<R>;\r\n}\r\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport * from './lib/codegen-ts';\nexport * from './lib/codegen-json-schema';\nexport * from './lib/codegen-proto3';\nexport * from './lib/codegen-graphql';\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { parserInput,\n         ParserFnWithCtx }       from 'fruitsconfits/modules/lib/types';\nimport { getStringParsers }      from 'fruitsconfits/modules/lib/string-parser';\nimport { getObjectParsers }      from 'fruitsconfits/modules/lib/object-parser';\nimport { SxTokenChild,\n         SxToken,\n         SxSymbol,\n         SxParserConfig }        from 'liyad/modules/s-exp/types';\nimport installCore               from 'liyad/modules/s-exp/operators/core';\nimport { SExpression }           from 'liyad/modules/s-exp/interpreters';\nimport { defaultConfig }         from 'liyad/modules/s-exp/defaults';\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         ErrorMessages,\n         TypeAssertionSetValue,\n         TypeAssertionMap }      from './types';\nimport * as operators            from './operators';\nimport { resolveSchema }         from './lib/resolver';\nimport { dummyTargetObject,\n         isUnsafeVarNames }      from './lib/util';\n\n\n\ninterface SxOp {\n    'op': string;\n}\n\ntype AstChild = SxTokenChild | SxOp | undefined;\n\ninterface Ctx {\n    docComment?: string;\n}\ntype Ast = SxToken | AstChild | SxOp | undefined;\n\nconst $s = getStringParsers<Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n});\n\nconst $o = getObjectParsers<Ast[], Ctx, Ast>({\n    rawToToken: rawToken => rawToken,\n    concatTokens: tokens => (tokens.length ?\n        [tokens.reduce((a, b) => String(a) + b)] : []),\n    comparator: (a, b) => a === b,\n});\n\nconst {seq, cls, notCls, clsFn, classes, numbers, cat,\n       once, repeat, qty, zeroWidth, err, beginning, end,\n       first, or, combine, erase, trans, ahead, rules} = $s;\n\n\nconst directiveLineComment =\n    trans(tokens => [[{symbol: 'directive'}, ...tokens]])(\n        erase(qty(2)(cls('/'))),\n        erase(repeat(classes.space)),\n        cat(seq('@tynder-'), repeat(classes.alnum)), // [0]\n        erase(repeat(classes.space)),\n        cat(repeat(notCls('\\r\\n', '\\n', '\\r'))),     // [1]\n        erase(classes.newline), );\n\nconst lineComment =\n    combine(\n        erase(qty(2)(cls('/'))),\n        ahead(repeat(classes.space),\n              notCls('@tynder-'), ),\n        repeat(notCls('\\r\\n', '\\n', '\\r')),\n        classes.newline, );\n\nconst hashLineComment =\n    combine(\n        seq('#'),\n        repeat(notCls('\\r\\n', '\\n', '\\r')),\n        classes.newline, );\n\nconst docComment =\n    combine(\n        seq('/**'),\n        repeat(classes.space),\n        input => {\n            const ret = cat(repeat(notCls('*/')))(input);\n            if (ret.succeeded) {\n                // define a reducer\n                const ctx2 = {...ret.next.context}; // NOTE: context is immutable\n                ctx2.docComment = (ret.tokens[0] as string).trim();\n                ret.next.context = ctx2;\n            }\n            return ret;\n        },\n        seq('*/'), );\n\nconst blockComment =\n    combine(\n        seq('/*'),\n        repeat(notCls('*/')),\n        seq('*/'), );\n\nconst commentOrSpace =\n    first(classes.space, lineComment, hashLineComment, docComment, blockComment);\n\n\nconst trueValue =\n    trans(tokens => [true])\n    (seq('true'));\n\nconst falseValue =\n    trans(tokens => [false])\n    (seq('false'));\n\nconst nullValue =\n    trans(tokens => [null])\n    (seq('null'));\n\nconst undefinedValue =\n    trans(tokens => [void 0])\n    (seq('undefined'));\n\nconst positiveInfinityValue =\n    trans(tokens => [Number.POSITIVE_INFINITY])\n    (qty(0, 1)(seq('+')), seq('Infinity'));\n\nconst negativeInfinityValue =\n    trans(tokens => [Number.NEGATIVE_INFINITY])\n    (seq('-Infinity'));\n\nconst nanValue =\n    trans(tokens => [Number.NaN])\n    (seq('NaN'));\n\n\nconst binaryIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 2)])\n    (numbers.bin(seq('0b')));\n\nconst octalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 8)])\n    (numbers.oct(seq('0o'), seq('0')));\n\nconst hexIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 16)])\n    (numbers.hex(seq('0x'), seq('0X')));\n\nconst decimalIntegerValue =\n    trans(tokens => [Number.parseInt((tokens as string[])[0].replace(/_/g, ''), 10)])\n    (numbers.int);\n\nconst bigDecimalIntegerValue =\n    trans(tokens => [BigInt((tokens as string[])[0].replace(/_/g, '')) as any])\n    (numbers.bigint);\n\nconst floatingPointNumberValue =\n    trans(tokens => [Number.parseFloat((tokens as string[])[0].replace(/_/g, ''))])\n    (numbers.float);\n\nconst numberValue =\n    first(octalIntegerValue,\n          hexIntegerValue,\n          binaryIntegerValue,\n          bigDecimalIntegerValue,\n          floatingPointNumberValue,\n          decimalIntegerValue,\n          positiveInfinityValue,\n          negativeInfinityValue,\n          nanValue, );\n\n\nconst stringEscapeSeq = first(\n    trans(t => ['\\''])(seq('\\\\\\'')),\n    trans(t => ['\\\"'])(seq('\\\\\"')),\n    trans(t => ['\\`'])(seq('\\\\`')),\n    trans(t => ['/'])(seq('\\\\/')),\n    trans(t => ['\\\\'])(seq('\\\\\\\\')),\n    trans(t => [''])(seq('\\\\\\r\\n')),\n    trans(t => [''])(seq('\\\\\\r')),\n    trans(t => [''])(seq('\\\\\\n')),\n    trans(t => ['\\n'])(seq('\\\\n')),\n    trans(t => ['\\r'])(seq('\\\\r')),\n    trans(t => ['\\v'])(seq('\\\\v')),\n    trans(t => ['\\t'])(seq('\\\\t')),\n    trans(t => ['\\b'])(seq('\\\\b')),\n    trans(t => ['\\f'])(seq('\\\\f')),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u')),\n                qty(4, 4)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\u{')),\n                qty(1, 6)(classes.hex),\n                erase(seq('}')), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 16))])(\n        cat(erase(seq('\\\\x')),\n                qty(2, 2)(classes.hex), )),\n    trans(t => [String.fromCodePoint(Number.parseInt((t as string[])[0], 8))])(\n        cat(erase(seq('\\\\')),\n                qty(3, 3)(classes.oct), )));\n\nconst signleQuotStringValue =\n    trans(tokens => [tokens[0]])(\n        erase(seq(\"'\")),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls(\"'\"),\n            ))),\n        erase(seq(\"'\")), );\n\nconst doubleQuotStringValue =\n    trans(tokens => [tokens[0]])(\n        erase(seq('\"')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                combine(cls('\\r', '\\n'), err('Line breaks within strings are not allowed.')),\n                notCls('\"'),\n            ))),\n        erase(seq('\"')), );\n\nconst backQuotStringValue =\n    trans(tokens => [tokens[0]])(\n        erase(seq('`')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                notCls('`'),\n            ))),\n        erase(seq('`')), );\n\nconst stringValue =\n    first(signleQuotStringValue, doubleQuotStringValue, backQuotStringValue);\n\nconst regexpStringValue =\n    // TODO: '/' ']' '\\\\' in character class '[]' is not parsed correctly.\n    trans(tokens => [{value: tokens[1] ?\n            new RegExp(tokens[0] as string, tokens[1] as string) :\n            new RegExp(tokens[0] as string)}])(\n        erase(seq('/')),\n            cat(repeat(first(\n                stringEscapeSeq,\n                notCls('/'),\n            ))),\n        erase(seq('/')),\n        cat(qty(0)(cls('g', 'i', 'm', 's', 'u', 'y'))), );\n\n\nconst symbolName =\n    trans(tokens => tokens)\n    (cat(combine(classes.alpha, repeat(classes.alnum))));\n\nconst decoratorSymbolName =\n    trans(tokens => [{symbol: (tokens as string[])[0]}])\n    (cat(combine(seq('@'), classes.alpha, repeat(classes.alnum))));\n\n\nconst simpleConstExpr =\n    first(trueValue, falseValue, nullValue, undefinedValue,\n          numberValue, stringValue, );\n\nconst objKey =\n    first(stringValue, symbolName);\n\nconst listValue = first(\n    trans(tokens => [[]])(erase(\n        seq('['),\n            repeat(commentOrSpace),\n        seq(']'), )),\n    trans(tokens => {\n        const ast: Ast = [{symbol: '$list'}];\n        for (const token of tokens) {\n            ast.push(token as any);\n        }\n        return [ast];\n    })(\n        erase(seq('[')),\n            combine(\n                erase(repeat(commentOrSpace)),\n                first(input => listValue(input),   // NOTE: recursive definitions\n                      input => objectValue(input), //       should place as lambda.\n                      simpleConstExpr,\n                      ),\n                erase(repeat(commentOrSpace)), ),\n            repeat(combine(\n                erase(repeat(commentOrSpace),\n                      seq(','),\n                      repeat(commentOrSpace)),\n                first(input => listValue(input),   // NOTE: recursive definitions\n                      input => objectValue(input), //       should place as lambda.\n                      simpleConstExpr,\n                      ),\n                erase(repeat(commentOrSpace)), )),\n            qty(0, 1)(erase(\n                seq(','),\n                repeat(commentOrSpace), )),\n            first(ahead(seq(']')), err('listValue: Unexpected token has appeared.')),\n        erase(seq(']')),\n    ), );\n\nconst objectKeyValuePair =\n    combine(\n        objKey,\n        erase(repeat(commentOrSpace),\n              first(seq(':'), err('\":\" is needed.')),\n              repeat(commentOrSpace)),\n        first(input => listValue(input),   // NOTE: recursive definitions\n              input => objectValue(input), //       should place as lambda.\n              simpleConstExpr,\n              err('object value is needed.')), );\n\nconst objectValue = first(\n    trans(tokens => [[{symbol: '#'}]])(erase(\n        seq('{'),\n            repeat(commentOrSpace),\n        seq('}'),\n    )),\n    trans(tokens => {\n        const ast: Ast = [{symbol: '#'}];\n        for (let i = 0; i < tokens.length; i += 2) {\n            if (isUnsafeVarNames(dummyTargetObject, tokens[i] as string)) {\n                throw new Error(`Unsafe symbol name is appeared in object literal: ${tokens[i]}`);\n            }\n            ast.push([tokens[i], tokens[i + 1]]);\n        }\n        return [ast];\n    })(\n        erase(seq('{')),\n            combine(\n                erase(repeat(commentOrSpace)),\n                objectKeyValuePair,\n                erase(repeat(commentOrSpace)), ),\n            repeat(combine(\n                erase(seq(','),\n                      repeat(commentOrSpace)),\n                objectKeyValuePair,\n                erase(repeat(commentOrSpace)), )),\n            qty(0, 1)(erase(\n                seq(','),\n                repeat(commentOrSpace), )),\n            first(ahead(seq('}')), err('objectValue: Unexpected token has appeared.')),\n        erase(seq('}')),\n    ), );\n\nconst constExpr =\n    first(simpleConstExpr,\n          listValue,\n          objectValue, );\n\n\n// const primitiveValue = trans(tokens => [[{symbol: 'primitiveValue'}, tokens[0]]])(\n//     first(trueValue, falseValue, nullValue, undefinedValue,\n//           numberValue, stringValue, ));\n\nconst primitiveValueNoNullUndefined =\n    trans(tokens => [[{symbol: 'primitiveValue'}, tokens[0]]])(\n        first(trueValue, falseValue,\n              numberValue, stringValue, ));\n\n\nconst primitiveTypeName =\n    trans(tokens => [[{symbol: 'primitive'}, tokens[0]]])(\n        first(seq('number?'), seq('integer?'), seq('bigint?'), seq('string?'), seq('boolean?'), // TODO: '?' is allowed in the sequence assertion\n              seq('number'), seq('integer'), seq('bigint'), seq('string'), seq('boolean'), ));  // TODO: function\n\nconst additionalPropPrimitiveTypeName =\n    first(seq('number'), seq('string'));\n\nconst nullUndefinedTypeName =\n    trans(tokens => [[{symbol: 'primitive'}, tokens[0]]])(\n        first(seq('null'), seq('undefined'), seq('any'), seq('unknown'), seq('never')), );\n\nconst simpleTypeName =\n    first(primitiveTypeName,\n          nullUndefinedTypeName,\n          trans(tokens =>\n                [[{symbol: 'ref'}, tokens[0]]])(\n            ahead(notCls('Array', 'Partial', 'Pick', 'Omit')),\n            symbolName, ));\n\n\nconst sequenceType =\n    trans(tokens => [[{symbol: 'sequenceOf'}, ...tokens]])(\n        combine(\n            erase(seq('[')),\n                combine(\n                    erase(repeat(commentOrSpace)),\n                    input => spreadOrComplexType(first(seq(','), seq(']')))(input),\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(\n                    erase(seq(','),\n                        repeat(commentOrSpace)),\n                    input => spreadOrComplexType(first(seq(','), seq(']')))(input),\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq(']')), err('sequenceType: Unexpected token has appeared.')),\n            erase(seq(']')), ));\n\n\nconst arraySizeFactorInner =\n    first(\n        trans(tokens => [[{symbol: '#'}, ['max', tokens[0]]]])(\n            erase(seq('..')),\n            erase(repeat(commentOrSpace)),\n            decimalIntegerValue, ),\n        trans(tokens => [[{symbol: '#'}, ['min', tokens[0]], ['max', tokens[1]]]])(\n            decimalIntegerValue,\n            erase(repeat(commentOrSpace)),\n            erase(seq('..')),\n            erase(repeat(commentOrSpace)),\n            decimalIntegerValue, ),\n        trans(tokens => [[{symbol: '#'}, ['min', tokens[0]]]])(\n            decimalIntegerValue,\n            erase(repeat(commentOrSpace)),\n            erase(seq('..')), ),\n        trans(tokens => [[{symbol: '#'}, ['max', tokens[0]]]])(\n            decimalIntegerValue, ));\n\nconst arraySizeFactor =\n    trans(tokens =>\n        tokens.length > 0 ?\n            tokens :\n            [[{symbol: '#'}]])(\n        erase(seq('[')),\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(arraySizeFactorInner),\n            erase(repeat(commentOrSpace)),\n        erase(seq(']')), );\n\nconst complexArrayType =\n    trans(tokens => [[{symbol: 'repeated'}, tokens[0], tokens[1]]])(\n        erase(seq('Array')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Array type.'), ),        // [0]\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                arraySizeFactorInner,                               // [1]\n                erase(repeat(commentOrSpace)), )),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Array type.'), ),\n        erase(seq('>')), );\n\nconst partialType =\n    trans(tokens => [[{symbol: 'partial'}, tokens[0], tokens[1]]])(\n        erase(seq('Partial')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Partial type.'), ),      // [0]\n            erase(repeat(commentOrSpace)),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Partial type.'), ),\n        erase(seq('>')), );\n\nconst pickOrOmitType =\n    trans(tokens => [[{symbol: tokens[0] === 'Pick' ? 'picked' : 'omit'}, tokens[1], ...tokens.slice(2)]])(\n        first(seq('Pick'),\n              seq('Omit'), ),                                       // [0]\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            first(input => complexType(first(seq(','), seq('>')))(input),\n                  err('type is expected in Partial type.'), ),      // [1]\n            erase(repeat(commentOrSpace)),\n            combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                    stringValue,                                    // [2]\n                    qty(0)(combine(\n                        erase(repeat(commentOrSpace)),\n                        erase(seq('|')),\n                        erase(repeat(commentOrSpace)),\n                        stringValue, )),                            // [3],...\n                erase(repeat(commentOrSpace)), ),\n        first(ahead(seq('>')),\n              err('\\'>\\' is expected in Pick|Omit type.'), ),\n        erase(seq('>')), );\n\nconst genericOrSimpleType =\n    trans(tokens => [tokens[0]])(                     // remove generics parameters\n        simpleTypeName,                               // [0]\n        erase(repeat(commentOrSpace)),\n        qty(0, 1)(combine(\n            erase(seq('<')),\n                combine(                              // [1]\n                    erase(repeat(commentOrSpace)),\n                    first(input => complexType(first(seq(','), seq('>')))(input),\n                          err('type is expected in generic type.'), ),\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(                       // [2]...\n                    erase(seq(','),\n                          repeat(commentOrSpace)),\n                    first(input => complexType(first(seq(','), seq('>')))(input),\n                          err('type is expected in generic type.'), ),\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq('>')), err('genericType: Unexpected token has appeared.')),\n            erase(seq('>')), )));\n\nconst spreadType =\n    trans(tokens => [[{symbol: 'spread'}, tokens[0], tokens[1]]])(\n        erase(seq('...')),\n        erase(repeat(commentOrSpace)),\n        erase(seq('<')),\n            erase(repeat(commentOrSpace)),\n            input => complexType(first(seq(','), seq('>')))(input),\n            erase(repeat(commentOrSpace)),\n            qty(0, 1)(combine(\n                erase(seq(',')),\n                erase(repeat(commentOrSpace)),\n                arraySizeFactorInner,\n                erase(repeat(commentOrSpace)), )),\n        erase(seq('>')), );\n\n\nconst decorator =\n    trans(tokens => [tokens])(\n        decoratorSymbolName,\n        qty(0, 1)(first(\n            combine(erase(\n                seq('('),\n                    repeat(commentOrSpace),\n                seq(')'), )),\n            combine(\n                erase(seq('(')),\n                    combine(\n                        erase(repeat(commentOrSpace)),\n                        first(regexpStringValue, constExpr),\n                        erase(repeat(commentOrSpace)), ),\n                    repeat(combine(\n                        erase(repeat(commentOrSpace)),\n                        erase(seq(',')),\n                        erase(repeat(commentOrSpace)),\n                        first(regexpStringValue, constExpr),\n                        erase(repeat(commentOrSpace)), )),\n                    qty(0, 1)(erase(\n                        seq(','),\n                        repeat(commentOrSpace), )),\n                erase(seq(')')),\n            ), )));\n\nconst decoratorsClause =\n    trans(tokens => tokens)(\n        repeat(combine(\n            decorator,\n            erase(repeat(commentOrSpace)), )));\n\n\nconst complexTypeInnerWOSinpleArrayType = (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    first(primitiveValueNoNullUndefined,\n          genericOrSimpleType,\n          partialType,\n          pickOrOmitType,\n          complexArrayType,\n          sequenceType,\n          input => interfaceDefInner(seq(','))(input), );\n\nconst complexTypeInnerRoot: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => {\n            let ty = [{symbol: '$pipe'}, tokens[1], ...(tokens[0] as Ast[])];\n            if (tokens[2] !== null) {\n                for (const z of tokens[2] as Ast[]) {\n                    ty = [{symbol: 'repeated'}, ty, z];\n                }\n            }\n            return ([[\n                ty,\n                ...(tokens[3] ? [tokens[3]] : []),\n                ...tokens.slice(4),\n            ]]);\n        })(                                                              // [0]\n        trans(tokens => [tokens])(qty(0, 1)(decoratorsClause)),          // [1]\n        first(                                                           // [2]\n            input => complexTypeInnerWOSinpleArrayType(edge)(input),\n            combine(\n                erase(seq('(')),\n                    erase(repeat(commentOrSpace)),\n                    input => complexType(edge)(input),\n                    erase(repeat(commentOrSpace)),\n                erase(seq(')')), )),\n            combine(\n                trans(tokens => tokens[0] !== null ? [tokens] : [null])(\n                    first(\n                        qty(1)(combine(\n                            erase(repeat(commentOrSpace)),\n                            arraySizeFactor,\n                        )),\n                        zeroWidth(() => null), )),\n            combine(first(\n                trans(tokens => [tokens[0], ...(tokens[1] as Ast[])])(\n                    qty(1)(combine(\n                        erase(repeat(commentOrSpace)),\n                        trans(tokens => [{op: tokens[0]} as any])(or(seq('&'), seq('|'), seq('-'))),\n                        erase(repeat(commentOrSpace)),\n                        input => complexTypeInnerRoot(edge)(input), ))),\n                trans(tokens => [])(), ))));\n\n\nconst binaryOp = (op: string, op1: any, op2: any) => {\n    return [{symbol: op}, op1, op2];\n};\n\nconst isOperator = (v: any, op: string) => {\n    if (typeof v === 'object' && v.op === op) {\n        return true;\n    }\n    return false;\n};\n\nconst isValue = (v: any) => {\n    // TODO: check type\n    return true;\n};\n\n\n// production rules:\n//   S -> S \"&\" S\nconst complexTypeExprRule3 = $o.trans(tokens => [binaryOp('intersect', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '&')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"|\" S\nconst complexTypeExprRule2 = $o.trans(tokens => [binaryOp('oneOf', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '|')),\n    $o.clsFn(t => isValue(t)),\n);\n\n// production rules:\n//   S -> S \"-\" S\nconst complexTypeExprRule1 = $o.trans(tokens => [binaryOp('subtract', tokens[0], tokens[2])])(\n    $o.clsFn(t => isValue(t)),\n    $o.clsFn(t => isOperator(t, '-')),\n    $o.clsFn(t => isValue(t)),\n);\n\nconst complexType = (edge: ParserFnWithCtx<string, Ctx, Ast>) => rules({\n    rules: [\n        complexTypeExprRule3,\n        complexTypeExprRule2,\n        complexTypeExprRule1,\n    ],\n    check: $o.combine($o.classes.any, $o.end()),\n})(trans(tokens => tokens[0] as Ast[])(complexTypeInnerRoot(edge)));\n\n\nconst spreadOrComplexType: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (edge: ParserFnWithCtx<string, Ctx, Ast>) =>\n    first(spreadType, complexType(edge));\n\n\nconst typeDef =\n    trans(tokens => [[{symbol: 'def'}, tokens[1], [{symbol: 'docComment'}, tokens[2], tokens[0] ] ]])(\n        erase(seq('type')),\n            input => {                                               // TODO: extract function\n                const ret = zeroWidth(() => [])(input);\n                if (ret.succeeded) {\n                    const text = ret.next.context.docComment;\n                    ret.next.context = {...ret.next.context};\n                    delete ret.next.context.docComment;\n                    ret.tokens.length = 0;\n                    ret.tokens.push(text ? text : null);\n                }\n                return ret;\n            },                                                       // [0]\n            erase(repeat(commentOrSpace)),\n            symbolName,                                              // [1]\n            erase(repeat(commentOrSpace)),\n        erase(seq('=')),\n            erase(repeat(commentOrSpace)),\n            input => complexType(first(seq(','), seq(';')))(input),  // [2]\n            erase(repeat(commentOrSpace)),\n        erase(seq(';')), );\n\n\nconst interfaceExtendsClause =\n    trans(tokens => [\n            [{symbol: '$list'},\n                ...tokens.map(x => [{symbol: 'ref'}, x])], ])(\n        erase(seq('extends')),\n        erase(repeat(commentOrSpace)),\n        symbolName,\n        repeat(combine(\n            erase(repeat(commentOrSpace)),\n            erase(seq(',')),\n            erase(repeat(commentOrSpace)),\n            symbolName, )));\n\nconst interfaceKey =\n    first(\n        trans(tokens => [[{symbol: '$list'}, ...tokens]])(\n            erase(seq('[')),\n                erase(repeat(commentOrSpace),\n                      objKey,\n                      repeat(commentOrSpace),\n                      seq(':'),\n                      repeat(commentOrSpace), ),\n                repeat(combine(\n                    first(regexpStringValue,\n                          additionalPropPrimitiveTypeName, ),\n                    erase(repeat(commentOrSpace),\n                          seq('|'),\n                          repeat(commentOrSpace), ))),\n                first(regexpStringValue,\n                      additionalPropPrimitiveTypeName, ),\n                erase(repeat(commentOrSpace)),\n            erase(seq(']')), ),\n        objKey, );\n\nconst interfaceKeyTypePair = (separator: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => [\n            [{symbol: '$list'},\n                tokens[2],\n                [{symbol: '$pipe'},\n                    tokens[3] === '?' ?\n                        [{symbol: 'optional'}, tokens[4]] :\n                        tokens[4], ...(tokens[0] as Ast[]), ],\n                tokens[1], ]])(\n        trans(tokens => [tokens])(first(\n            decoratorsClause,\n            zeroWidth(() => []), )),                // [0] decorators\n        input => {\n            const ret = zeroWidth(() => [])(input);\n            if (ret.succeeded) {\n                const text = ret.next.context.docComment;\n                ret.next.context = {...ret.next.context};\n                delete ret.next.context.docComment;\n                ret.tokens.length = 0;\n                ret.tokens.push(text ? text : null);\n            }\n            return ret;\n        },                                          // [1]\n        interfaceKey,                               // [2] key\n        first(                                      // [3] '?' | ''\n            combine(\n                erase(repeat(commentOrSpace)),\n                seq('?'),\n                erase(repeat(commentOrSpace)), ),\n            zeroWidth(() => ['']), ),\n        erase(repeat(commentOrSpace),\n            first(seq(':'), err('\":\" is needed.')),\n            repeat(commentOrSpace), ),\n        first(                                      // [4] type\n            input => complexType(first(separator, seq('}')))(input),\n            err('interface member type is needed.'), ));\n\nconst interfaceDefInner: (separator: ParserFnWithCtx<string, Ctx, Ast>) => ParserFnWithCtx<string, Ctx, Ast> =\n    (separator: ParserFnWithCtx<string, Ctx, Ast>) =>\n    trans(tokens => [[{symbol: 'objectType'}, ...tokens]])(\n        first(\n            combine(erase(\n                seq('{'),\n                    repeat(commentOrSpace),\n                seq('}'), )),\n            combine(\n                erase(seq('{')),\n                    combine(\n                        erase(repeat(commentOrSpace)),\n                        interfaceKeyTypePair(separator),\n                        erase(repeat(commentOrSpace)), ),\n                    repeat(combine(\n                        erase(separator,\n                              repeat(commentOrSpace)),\n                        interfaceKeyTypePair(separator),\n                        erase(repeat(commentOrSpace)), )),\n                    qty(0, 1)(erase(\n                        separator,\n                        repeat(commentOrSpace), )),\n                    first(ahead(seq('}')), err('interfaceDefInner: Unexpected token has appeared.')),\n                erase(seq('}')), )));\n\nconst interfaceDef =\n    trans(tokens => [\n        [{symbol: 'def'},\n            tokens[1],\n            [{symbol: 'docComment'},\n                [{symbol: 'derived'}, tokens[3], [{symbol: '$spread'}, tokens[2]]],\n                tokens[0], ]]])(\n    erase(seq('interface')),\n        input => {                               // TODO: extract function\n            const ret = zeroWidth(() => [])(input);\n            if (ret.succeeded) {\n                const text = ret.next.context.docComment;\n                ret.next.context = {...ret.next.context};\n                delete ret.next.context.docComment;\n                ret.tokens.length = 0;\n                ret.tokens.push(text ? text : null);\n            }\n            return ret;\n        },                                       // [0] base types\n        erase(repeat(commentOrSpace)),\n        symbolName,                              // [1] symbol\n        erase(repeat(commentOrSpace)),\n        first(interfaceExtendsClause,            // [2]\n              zeroWidth(() => []), ),\n        erase(repeat(commentOrSpace)),\n    input => interfaceDefInner(seq(';'))(input), // [3]\n);\n\n\nconst enumKeyValue =\n    trans(tokens => [[{symbol: '$list'}, tokens[1], tokens[2], tokens[0]]])(\n        input => {\n            const ret = zeroWidth(() => [])(input);\n            if (ret.succeeded) {\n                const text = ret.next.context.docComment;\n                ret.next.context = {...ret.next.context};\n                delete ret.next.context.docComment;\n                ret.tokens.length = 0;\n                ret.tokens.push(text ? text : null);\n            }\n            return ret;\n        },                                       // [0]\n        symbolName,\n        erase(repeat(commentOrSpace)),\n        first(\n            combine(\n                erase(seq('=')),\n                erase(repeat(commentOrSpace)),\n                first(decimalIntegerValue,\n                      stringValue, ),\n                erase(repeat(commentOrSpace)), ),\n            zeroWidth(() => null), ));\n\nconst enumDef =\n    trans(tokens => [\n        [{symbol: 'def'}, tokens[1],\n            [{symbol: 'docComment'},\n                [{symbol: 'enumType'}, ...tokens.slice(2)],\n                tokens[0], ]]])(\n    erase(seq('enum')),\n        input => {                               // TODO: extract function\n            const ret = zeroWidth(() => [])(input);\n            if (ret.succeeded) {\n                const text = ret.next.context.docComment;\n                ret.next.context = {...ret.next.context};\n                delete ret.next.context.docComment;\n                ret.tokens.length = 0;\n                ret.tokens.push(text ? text : null);\n            }\n            return ret;\n        },                                       // [0]\n        erase(repeat(commentOrSpace)),\n        symbolName,\n        erase(repeat(commentOrSpace)),\n    first(\n        combine(erase(\n            seq('{'),\n                repeat(commentOrSpace),\n            seq('}'), )),\n        combine(\n            erase(seq('{')),\n                combine(\n                    erase(repeat(commentOrSpace)),\n                    enumKeyValue,\n                    erase(repeat(commentOrSpace)), ),\n                repeat(combine(\n                    erase(seq(','),\n                          repeat(commentOrSpace)),\n                    enumKeyValue,\n                    erase(repeat(commentOrSpace)), )),\n                qty(0, 1)(erase(\n                    seq(','),\n                    repeat(commentOrSpace), )),\n                first(ahead(seq('}')), err('enumDef: Unexpected token has appeared.')),\n            erase(seq('}')), )));\n\n\nconst internalDef =\n    first(typeDef,\n          interfaceDef,\n          enumDef, );\n\n\nconst exportedDef =\n    trans(tokens => [[{symbol: 'export'}, tokens[0]]])(\n        erase(seq('export'),\n              repeat(commentOrSpace), ),\n        internalDef, );\n\n\nconst defStatement =\n    trans(tokens => [\n        [{symbol: '$local'}, [\n                [{symbol: '_ty'}, tokens[1]],\n            ],\n            [{symbol: 'redef'},\n                {symbol: '_ty'},\n                [{symbol: '$pipe'}, {symbol: '_ty'}, ...(tokens[0] as Ast[])], ]]])(\n        trans(tokens => [tokens])(first(\n            decoratorsClause,\n            zeroWidth(() => []), )),      // [0] decorators\n        first(exportedDef,                // [1] body\n              internalDef), );\n\n\nconst externalTypeDef =\n    trans(tokens => [[{symbol: 'external'}, ...tokens]])(\n        erase(seq('external')),\n            erase(repeat(commentOrSpace)),\n            symbolName,\n            repeat(combine(\n                erase(repeat(commentOrSpace)),\n                erase(cls(',')),\n                erase(repeat(commentOrSpace)),\n                symbolName,\n                erase(repeat(commentOrSpace)),\n            )),\n            erase(repeat(commentOrSpace)),\n        erase(cls(';')), );\n\nconst importStatement =\n    trans(tokens => [[{symbol: 'passthru'}, tokens[0]]])(\n        cat(seq('import'),\n            repeat(commentOrSpace),\n            cat(repeat(notCls(';'))),\n            cls(';'), ));\n\n\nconst definition =\n    first(directiveLineComment,\n          defStatement,\n          externalTypeDef,\n          importStatement, );\n\nconst program =\n    combine(\n        erase(repeat(commentOrSpace)),\n        repeat(combine(\n            definition,\n            erase(repeat(commentOrSpace)), )),\n        end(), );\n\n\nexport function parse(s: string) {\n    const z = program(parserInput(s, {/* TODO: set initial state to the context */}));\n    if (! z.succeeded) {\n        throw new Error(z.message);\n    }\n    return z.tokens;\n}\n\n\nconst lisp = (() => {\n    let config: SxParserConfig = Object.assign({}, defaultConfig);\n    config.reservedNames = Object.assign({}, config.reservedNames, {\n        Template: '$concat',\n    });\n    config = installCore(config);\n    config.stripComments = true;\n    return SExpression(config);\n})();\n\n\n// tslint:disable: object-literal-key-quotes\nexport function compile(s: string) {\n    const mapTyToTySet = new Map<TypeAssertion, TypeAssertionSetValue>();\n    const schema: TypeAssertionMap = new Map<string, TypeAssertionSetValue>();\n    let gensymCount = 0;\n\n    const def = (name: SxSymbol | string, ty: TypeAssertion): TypeAssertion => {\n        let ret = ty;\n\n        const sym = typeof name === 'string' ? name : name.symbol;\n        if (isUnsafeVarNames(dummyTargetObject, sym)) {\n            throw new Error(`Unsafe symbol name is appeared: ${sym}`);\n        }\n\n        if (! mapTyToTySet.has(ret)) {\n            const originalTypeName = ret.typeName;\n            ret = operators.withName(operators.withTypeName(\n                originalTypeName ?\n                    operators.withOriginalTypeName(ret, originalTypeName) :\n                    ret,\n                sym), sym);\n        }\n\n        const tySet = mapTyToTySet.has(ret) ?\n            mapTyToTySet.get(ret) as TypeAssertionSetValue :\n            {ty: ret, exported: false, resolved: false};\n\n        schema.set(sym, tySet);\n\n        if (! mapTyToTySet.has(ret)) {\n            // TODO: aliases are not exported correctly\n            mapTyToTySet.set(ret, tySet);\n        }\n        return ret;\n    };\n\n    const ref = (name: SxSymbol | string): TypeAssertion => {\n        const sym = typeof name === 'string' ? name : name.symbol;\n        if (isUnsafeVarNames(dummyTargetObject, sym)) {\n            throw new Error(`Unsafe symbol name is appeared: ${sym}`);\n        }\n\n        if (! schema.has(sym)) {\n            return ({\n                kind: 'symlink',\n                symlinkTargetName: sym,\n                name: sym,\n                typeName: sym,\n            });\n        }\n        let ty = (schema.get(sym) as TypeAssertionSetValue).ty;\n        if (ty.noOutput) {\n            ty = {...ty};\n            delete ty.noOutput;\n        }\n        return ty;\n    };\n\n    const external = (...names: string[]) => {\n        for (const name of names) {\n            const ty = def(name, operators.primitive('any'));\n            ty.noOutput = true;\n        }\n    };\n\n    lisp.setGlobals({\n        picked: operators.picked,        // TODO: BUG: Members are lost if operator is called before resolution\n        omit: operators.omit,            // TODO: BUG: Members are lost if operator is called before resolution\n        partial: operators.partial,      // TODO: BUG: Members are lost if operator is called before resolution\n        intersect: operators.intersect,  // TODO: BUG: Members are lost if operator is called before resolution\n        oneOf: operators.oneOf,\n        subtract: operators.subtract,    // TODO: BUG: Members are lost if operator is called before resolution\n        primitive: operators.primitive,\n        primitiveValue: operators.primitiveValue,\n        optional: operators.optional,\n        repeated: operators.repeated,\n        sequenceOf: operators.sequenceOf,\n        spread: operators.spread,\n        enumType: operators.enumType,\n        objectType: operators.objectType,\n        derived: operators.derived,\n        def,\n        ref,\n        export: (ty: TypeAssertion) => {\n            // NOTE: 'ty' should already be registered to 'mapTyToTySet' and 'schema'\n            const tySet = mapTyToTySet.has(ty) ?\n                mapTyToTySet.get(ty) as TypeAssertionSetValue :\n                {ty, exported: false, resolved: false};\n            tySet.exported = true;\n            return ty;\n        },\n        redef: (original: TypeAssertion, ty: TypeAssertion) => {\n            if (original === ty) {\n                return ty;\n            }\n            // NOTE: 'ty' should already be registered to 'mapTyToTySet' and 'schema'\n            const tySet = mapTyToTySet.has(original) ?\n                mapTyToTySet.get(original) as TypeAssertionSetValue :\n                {ty: original, exported: false, resolved: false};\n            tySet.ty = ty;\n            mapTyToTySet.set(tySet.ty, tySet);\n            if (ty.name) {\n                schema.set(ty.name, tySet);\n            }\n            return tySet.ty;\n        },\n        external,\n        passthru: (str: string) => {\n            const ty: TypeAssertion = {\n                kind: 'never',\n                passThruCodeBlock: str,\n            };\n            schema.set(`__$$$gensym_${gensymCount++}$$$__`, {ty, exported: false, resolved: false});\n            return ty;\n        },\n        directive: (name: string, body: string) => {\n            switch (name) {\n            case '@tynder-external':\n                external(...body.split(',').map(x => x.trim()));\n                break;\n            default:\n                throw new Error(`Unknown directive is appeared: ${name}`);\n            }\n            return [];\n        },\n        docComment: operators.withDocComment,\n        '@range': (minValue: number | string, maxValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withRange(minValue, maxValue)(ty),\n        '@minValue': (minValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMinValue(minValue)(ty),\n        '@maxValue': (maxValue: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMaxValue(maxValue)(ty),\n        '@greaterThan': (greaterThan: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withGreaterThan(greaterThan)(ty),\n        '@lessThan': (lessThan: number | string) => (ty: PrimitiveTypeAssertion) =>\n            operators.withLessThan(lessThan)(ty),\n        '@minLength': (minLength: number) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMinLength(minLength)(ty),\n        '@maxLength': (maxLength: number) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMaxLength(maxLength)(ty),\n        '@match': (pattern: RegExp) => (ty: PrimitiveTypeAssertion) =>\n            operators.withMatch(pattern)(ty),\n        '@msg': (messages: string | ErrorMessages) => (ty: TypeAssertion) =>\n            operators.withMsg(messages)(ty),\n        '@msgId': (messageId: string) => (ty: TypeAssertion) =>\n            operators.withMsgId(messageId)(ty),\n    });\n\n    const z = parse(s);\n    lisp.evaluateAST(z as SxToken[]);\n\n    return resolveSchema(schema);\n}\n// tslint:enable: object-literal-key-quotes\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport * from './types';\nexport * from './compiler';\nexport * from './operators';\nexport * from './codegen';\nexport * from './serializer';\nexport * from './validator';\nexport * from './picker';\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../types';\n\n\n\nfunction formatGraphQlCodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction generateGraphQlCodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    switch (ty.primitiveName) {\n    case 'number':\n        return 'Float';\n    case 'integer':\n        return 'Int';\n    case 'bigint':\n        return 'String';\n    case 'string':\n        return 'String';\n    case 'boolean':\n        return 'Boolean';\n    case 'undefined': case 'null': default:\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    // TODO: Function, DateStr, DateTimeStr\n}\n\n\nfunction generateGraphQlCodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    if (ty.value === void 0) {\n        return 'Any'; // TODO: Any is invalid type.\n    }\n    switch (typeof ty.value) {\n        case 'number':\n            return 'Float';\n        case 'bigint':\n            return 'String';\n        case 'string':\n            return 'String';\n        case 'boolean':\n            return 'Boolean';\n        default:\n            return 'Any'; // TODO: Any is invalid type.\n    }\n}\n\n\nfunction generateGraphQlCodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (`[${ty.repeated.typeName ?\n            ty.repeated.typeName :\n            generateGraphQlCodeInner(ty.repeated, false, ctx)}${\n                ty.repeated.kind === 'optional' ? '' : '!'}]`\n    );\n}\n\n\nfunction generateGraphQlCodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateGraphQlCodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return 'Any'; // TODO: Any is invalid type.\n}\n\n\nfunction generateGraphQlCodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    return `${ty.oneOf\n        .map(x => x.typeName ?\n            x.typeName :\n            generateGraphQlCodeInner(x, false, ctx)).join(' | ')}`;\n}\n\n\nfunction generateGraphQlCodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return `${ty.values.map(x => `${x[1]}`).join(' | ')}`; // TODO: invalid syntax\n}\n\n\nfunction generateGraphQlCodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.filter(x => !(x[2])).length === 0) {\n        return '{}';\n    }\n    const sep = '\\n';\n\n    const memberLines =\n        ty.members\n        .map(x =>\n            `${formatGraphQlCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                x[0]}: ${\n                x[1].typeName ?\n                    `${x[1].typeName}` :\n                    generateGraphQlCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})}${\n                x[1].kind === 'optional' ? '' : '!'}`);\n\n    return (\n        `{\\n${memberLines.join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateGraphQlCodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    let ret = '';\n\n    switch (ty.kind) {\n    case 'optional':\n        return generateGraphQlCodeInner(ty.optional, isInterface, ctx);\n    case 'one-of':\n        return generateGraphQlCodeOneOf(ty, ctx); // TODO: inline union is invalid.\n    case 'spread':\n        return generateGraphQlCodeSpread(ty, ctx);\n    case 'sequence':\n        return generateGraphQlCodeSequence(ty, ctx);\n    case 'never':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'any':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'unknown':\n        ret = 'Any'; // TODO: Any is invalid type.\n        break;\n    case 'primitive':\n        ret = generateGraphQlCodePrimitive(ty, ctx);\n        break;\n    case 'primitive-value':\n        ret = generateGraphQlCodePrimitiveValue(ty, ctx);\n        break;\n    case 'repeated':\n        ret = generateGraphQlCodeRepeated(ty, ctx);\n        break;\n    case 'enum':\n        ret = generateGraphQlCodeEnum(ty, ctx);\n        break;\n    case 'object':\n        ret = generateGraphQlCodeObject(ty, isInterface, ctx);\n        break;\n    case 'symlink':\n        ret = ty.symlinkTargetName;\n        break;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n    return ret + '';\n}\n\n\nexport function generateGraphQlCode(types: TypeAssertionMap): string {\n    let code = `\\nscalar Any\\n\\n`;\n\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            code += `scalar ${ty[0]}\\n\\n`;\n            continue;\n        }\n        code += formatGraphQlCodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].ty.kind === 'object') {\n            code += `type ${ty[0]} ${\n                generateGraphQlCodeInner(ty[1].ty, true, ctx)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `enum ${ty[0]} {\\n${\n                ty[1].ty.values\n                    .map(x => `${\n                        formatGraphQlCodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                        indent1}${x[0]}\\n`)\n                    .join('')}${indent0}}\\n\\n`;\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            code += `union ${ty[0]} = ${generateGraphQlCodeInner(ty[1].ty, false, ctx)}\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap } from '../types';\nimport * as JsonSchema      from '../types/json-schema-types';\n\n\n\nfunction addMetaInfo(a: JsonSchema.JsonSchemaAssertion, ty: TypeAssertion) {\n    const a2 = {...a};\n    let changed = false;\n\n    if (ty.docComment) {\n        a2.description = ty.docComment;\n    }\n    switch (ty.kind) {\n    case 'repeated':\n        if (typeof ty.min === 'number') {\n            (a2 as JsonSchema.JsonSchemaArrayAssertion).minItems = ty.min;\n            changed = true;\n        }\n        if (typeof ty.max === 'number') {\n            (a2 as JsonSchema.JsonSchemaArrayAssertion).maxItems = ty.max;\n            changed = true;\n        }\n        break;\n    case 'primitive':\n        if (typeof ty.minValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).minimum = ty.minValue;\n            changed = true;\n        }\n        if (typeof ty.maxValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).maximum = ty.maxValue;\n            changed = true;\n        }\n        if (typeof ty.greaterThanValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).exclusiveMinimum = ty.greaterThanValue;\n            changed = true;\n        }\n        if (typeof ty.lessThanValue === 'number') {\n            (a2 as JsonSchema.JsonSchemaNumberAssertion).exclusiveMaximum = ty.lessThanValue;\n            changed = true;\n        }\n        if (typeof ty.minLength === 'number') {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).minLength = ty.minLength;\n            changed = true;\n        }\n        if (typeof ty.maxLength === 'number') {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).maxLength = ty.maxLength;\n            changed = true;\n        }\n        if (ty.pattern) {\n            (a2 as JsonSchema.JsonSchemaStringAssertion).pattern = ty.pattern.source;\n            changed = true;\n        }\n        break;\n    }\n    return (changed ? a2 : a);\n}\n\nfunction generateJsonSchemaInner(schema: TypeAssertionMap, ty: TypeAssertion, nestLevel: number): JsonSchema.JsonSchemaAssertion {\n    if (0 < nestLevel && ty.typeName) {\n        const ret: JsonSchema.JsonSchemaRefAssertion = {\n            $ref: `#/definitions/${ty.typeName}`,\n        };\n        const r2 = addMetaInfo(ret, ty);\n        if (ret !== r2) {\n            // NOTE: `$ref` cannot have value constraints.\n            return generateJsonSchemaInner(schema, ty, 0);\n        } else {\n            return ret;\n        }\n    }\n\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const ret: JsonSchema.JsonSchemaRefAssertion = {\n                $ref: `#/definitions/${ty.symlinkTargetName}`,\n            };\n            const r2 = addMetaInfo(ret, ty);\n            if (ret !== r2) {\n                // NOTE: `$ref` cannot have value constraints.\n                const t2 = schema.get(ty.symlinkTargetName)?.ty;\n                if (t2) {\n                    return generateJsonSchemaInner(schema, t2, 0);\n                } else {\n                    // Drop constraints.\n                    return ret;\n                }\n            } else {\n                return ret;\n            }\n        }\n    case 'repeated':\n        {\n            const ret: JsonSchema.JsonSchemaArrayAssertion = {\n                type: 'array',\n                items: generateJsonSchemaInner(schema, ty.repeated, nestLevel + 1),\n            };\n            if (typeof ty.min === 'number') {\n                ret.minItems = ty.min;\n            }\n            if (typeof ty.max === 'number') {\n                ret.maxItems = ty.max;\n            }\n            return addMetaInfo(ret, ty);\n        }\n    case 'sequence':\n        {\n            const ret: JsonSchema.JsonSchemaArrayAssertion = {\n                type: 'array',\n                items: { anyOf: ty.sequence.map(x => generateJsonSchemaInner(schema, x, nestLevel + 1)) },\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'spread':\n        {\n            return generateJsonSchemaInner(schema, ty.spread, nestLevel + 1);\n        }\n    case 'one-of':\n        {\n            const ret: JsonSchema.JsonSchemaAnyOfAssertion = {\n                anyOf: ty.oneOf.map(x => generateJsonSchemaInner(schema, x, nestLevel + 1)),\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'optional':\n        {\n            const ret: JsonSchema.JsonSchemaOneOfAssertion = {\n                oneOf: [\n                    generateJsonSchemaInner(schema, ty.optional, nestLevel + 1),\n                    {type: 'null'},\n                ],\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'enum':\n        {\n            const ret: JsonSchema.JsonSchemaTsEnumAssertion = {\n                type: ['string', 'number'],\n                enum: ty.values.map(x => x[1]),\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'object':\n        {\n            const properties: JsonSchema.JsonSchemaObjectPropertyAssertion = {};\n            const patternProperties: JsonSchema.JsonSchemaObjectPropertyAssertion = {};\n            let patternPropsCount = 0;\n            const required: string[] = [];\n            for (const m of ty.members) {\n                const z = generateJsonSchemaInner(schema,\n                    m[1].kind === 'optional' ?\n                        m[1].optional :\n                        m[1],\n                    nestLevel + 1);\n\n                if (m[3]) {\n                    z.description = m[3];\n                } else {\n                    delete z.description;\n                }\n                properties[m[0]] = z;\n\n                if (m[1].kind !== 'optional') {\n                    required.push(m[0]);\n                }\n            }\n            for (const m of ty.additionalProps || []) {\n                const z = generateJsonSchemaInner(schema, m[1], nestLevel + 1);\n                if (m[3]) {\n                    z.description = m[3];\n                } else {\n                    delete z.description;\n                }\n                for (const k of m[0]) {\n                    patternPropsCount++;\n                    switch (k) {\n                    case 'number':\n                        patternProperties['^[0-9]+$'] = z;\n                        break;\n                    case 'string':\n                        patternProperties['^.+$'] = z;\n                        break;\n                    default:\n                        patternProperties[k.source] = z;\n                        break;\n                    }\n                }\n            }\n            const ret: JsonSchema.JsonSchemaObjectAssertion = {\n                type: 'object',\n                properties,\n                ...(0 < patternPropsCount ? {patternProperties} : {}),\n                ...(0 < required.length ? {required} : {}),\n                additionalProperties: false,\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'primitive':\n        {\n            switch (ty.primitiveName) {\n            case 'null': case 'undefined':\n                {\n                    const ret: JsonSchema.JsonSchemaNullAssertion = {\n                        type: 'null',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'number': case 'bigint':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberAssertion = {\n                        type: 'number',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'integer':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberAssertion = {\n                        type: 'integer',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'string':\n                {\n                    const ret: JsonSchema.JsonSchemaStringAssertion = {\n                        type: 'string',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'boolean':\n                {\n                    const ret: JsonSchema.JsonSchemaBooleanAssertion = {\n                        type: 'boolean',\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            }\n            // TODO: Function, DateStr, DateTimeStr\n        }\n    case 'primitive-value':\n        {\n            switch (typeof ty.value) {\n            case 'number':\n                {\n                    const ret: JsonSchema.JsonSchemaNumberValueAssertion = {\n                        type: 'number',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'bigint':\n                {\n                    const ret: JsonSchema.JsonSchemaBigintNumberValueAssertion = {\n                        type: 'number',\n                        enum: [ty.value.toString()],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'string':\n                {\n                    const ret: JsonSchema.JsonSchemaStringValueAssertion = {\n                        type: 'string',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            case 'boolean':\n                {\n                    const ret: JsonSchema.JsonSchemaBooleanValueAssertion = {\n                        type: 'boolean',\n                        enum: [ty.value],\n                    };\n                    return addMetaInfo(ret, ty);\n                }\n            default:\n                throw new Error(`Unknown primitive-value assertion: ${typeof ty.value}`);\n            }\n        }\n    case 'never':\n        {\n            const ret: JsonSchema.JsonSchemaNullAssertion = {\n                type: 'null',\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'any':\n        {\n            const ret: JsonSchema.JsonSchemaAnyAssertion = {\n                type: ['null', 'number', 'string', 'boolean', 'array', 'object'],\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'unknown':\n        {\n            const ret: JsonSchema.JsonSchemaUnknownAssertion = {\n                type: ['number', 'string', 'boolean', 'array', 'object'],\n            };\n            return addMetaInfo(ret, ty);\n        }\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateJsonSchemaObject(schema: TypeAssertionMap) {\n    const ret: JsonSchema.JsonSchemaRootAssertion = {\n        $schema: 'http://json-schema.org/draft-06/schema#',\n        definitions: {},\n    };\n    for (const ty of schema.entries()) {\n        if (ty[1].ty.noOutput) {\n            continue;\n        }\n        (ret.definitions as object)[ty[0]] = generateJsonSchemaInner(schema, ty[1].ty, 0);\n    }\n    return ret;\n}\n\n\nexport function generateJsonSchema(schema: TypeAssertionMap, asTs?: boolean): string {\n    const ret = generateJsonSchemaObject(schema);\n\n    if (asTs) {\n        return (\n            `\\n// tslint:disable: object-literal-key-quotes\\n` +\n            `const schema = ${JSON.stringify(ret, null, 2)};\\nexport default schema;` +\n            `\\n// tslint:enable: object-literal-key-quotes\\n`\n        );\n    } else {\n        return JSON.stringify(ret, null, 2);\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../types';\nimport { escapeString }   from '../lib/escape';\n\n\n\nfunction formatProto3CodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction generateProto3CodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    switch (ty.primitiveName) {\n    case 'number':\n        return 'double';\n    case 'integer':\n        return 'int32';\n    case 'bigint':\n        return 'string';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'bool';\n    case 'undefined': case 'null': default:\n        return 'google.protobuf.Any';\n    }\n    // TODO: Function, integer, DateStr, DateTimeStr\n}\n\n\nfunction generateProto3CodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'google.protobuf.Any';\n    }\n    if (ty.value === void 0) {\n        return 'google.protobuf.Any';\n    }\n    switch (typeof ty.value) {\n    case 'number':\n        return 'double';\n    case 'bigint':\n        return 'string';\n    case 'string':\n        return 'string';\n    case 'boolean':\n        return 'bool';\n    default:\n        return 'google.protobuf.Any';\n    }\n}\n\n\nfunction generateProto3CodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (`repeated ${ty.repeated.typeName ?\n            ty.repeated.typeName :\n            generateProto3CodeInner(ty.repeated, false, ctx)}`\n    );\n}\n\n\nfunction generateProto3CodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateProto3CodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return 'google.protobuf.Any';\n}\n\n\nfunction generateProto3CodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    return 'google.protobuf.Any';\n}\n\n\nfunction generateProto3CodeOptional(ty: OptionalAssertion, ctx: CodegenContext) {\n    const r = generateProto3CodeInner(ty.optional, false, ctx);\n    switch (r) {\n    case 'double':\n        return 'google.protobuf.DoubleValue';\n    case 'string':\n        return 'google.protobuf.StringValue';\n    case 'bool':\n        return 'google.protobuf.BoolValue';\n    default:\n        return 'google.protobuf.Any';\n    }\n}\n\n\nfunction generateProto3CodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return `(${ty.values.map(x => `${x[1]}`).join(' | ')})`;\n}\n\n\nfunction generateProto3CodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.filter(x => !(x[2])).length === 0) {\n        return '{}';\n    }\n    const sep = isInterface ? ';\\n' : ',\\n';\n    let count = 1;\n\n    const memberLines =\n        ty.members\n        .map(x =>\n            `${formatProto3CodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                x[1].typeName ?\n                    x[1].typeName :\n                    generateProto3CodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})} ${\n                x[0]} = ${count++}`);\n\n    return (\n        `{\\n${memberLines.join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateProto3CodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    switch (ty.kind) {\n    case 'never': case 'any': case 'unknown':\n        return 'google.protobuf.Any';\n    case 'primitive':\n        return generateProto3CodePrimitive(ty, ctx);\n    case 'primitive-value':\n        return generateProto3CodePrimitiveValue(ty, ctx);\n    case 'repeated':\n        return generateProto3CodeRepeated(ty, ctx);\n    case 'spread':\n        return generateProto3CodeSpread(ty, ctx);\n    case 'sequence':\n        return generateProto3CodeSequence(ty, ctx);\n    case 'one-of':\n        return generateProto3CodeOneOf(ty, ctx);\n    case 'optional':\n        return generateProto3CodeOptional(ty, ctx);\n    case 'enum':\n        return generateProto3CodeEnum(ty, ctx);\n    case 'object':\n        return generateProto3CodeObject(ty, isInterface, ctx);\n    case 'symlink':\n        return ty.symlinkTargetName;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateProto3Code(types: TypeAssertionMap): string {\n    let code =\n`\nsyntax = \"proto3\";\nimport \"google/protobuf/wrappers.proto\";\nimport \"google/protobuf/any.proto\";\n\n`;\n\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `message ${ty[0]} {\\n${indent1}google.protobuf.Any value = 1;\\n${indent0}}\\n\\n`;\n            continue;\n        }\n        code += formatProto3CodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].ty.kind === 'object') {\n            code += `message ${ty[0]} ${\n                generateProto3CodeInner(ty[1].ty, true, ctx)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            if (0 < ty[1].ty.values.filter(x => typeof x[1] !== 'number').length) {\n                code += `message ${ty[0]} {\\n${indent1}google.protobuf.Any value = 1;\\n${indent0}}\\n\\n`;\n            } else {\n                code += `enum ${ty[0]} {\\n${\n                    ty[1].ty.values\n                        .map(x => `${\n                            formatProto3CodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                            indent1}${(() => {\n                                if (typeof x[1] === 'number') {\n                                    return `${x[0]} = ${x[1]}`;\n                                } else {\n                                    return `${x[0]} = '${escapeString(x[1])}'`;\n                                }\n                            })()};\\n`)\n                        .join('')}${indent0}}\\n\\n`;\n            }\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            // nothing to do\n        } else {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            code += `message ${ty[0]} {\\n${indent1}${generateProto3CodeInner(ty[1].ty, false, ctx)} value = 1;\\n${indent0}}\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         AdditionalPropsKey,\n         ObjectAssertion,\n         TypeAssertionMap,\n         CodegenContext } from '../types';\nimport { escapeString }   from '../lib/escape';\n\n\n\nfunction formatTypeScriptCodeDocComment(ty: TypeAssertion | string, nestLevel: number) {\n    let code = '';\n    const indent = '    '.repeat(nestLevel);\n    const docComment = typeof ty === 'string' ? ty : ty.docComment;\n    if (docComment) {\n        if (0 <= docComment.indexOf('\\n')) {\n            code += `${indent}/**\\n${indent}  ${\n                docComment\n                    .split('\\n')\n                    .map(x => x.trimLeft())\n                    .join(`\\n${indent} `)}\\n${indent} */\\n`;\n        } else {\n            code += `${indent}/** ${docComment} */\\n`;\n        }\n    }\n    return code;\n}\n\n\nfunction generateTypeScriptCodePrimitive(ty: PrimitiveTypeAssertion, ctx: CodegenContext) {\n    // TODO: Function, DateStr, DateTimeStr\n    switch (ty.primitiveName) {\n    case 'integer':\n        return 'number';\n    default:\n        return ty.primitiveName;\n    }\n}\n\n\nfunction generateTypeScriptCodePrimitiveValue(ty: PrimitiveValueTypeAssertion, ctx: CodegenContext) {\n    if (ty.value === null) {\n        return 'null';\n    }\n    if (ty.value === void 0) {\n        return 'undefined';\n    }\n    switch (typeof ty.value) {\n    case 'string':\n        return `'${escapeString(ty.value)}'`;\n    case 'bigint':\n        return `${ty.value.toString()}n`;\n    default:\n        return ty.value.toString();\n    }\n}\n\n\nfunction generateTypeScriptCodeRepeated(ty: RepeatedAssertion, ctx: CodegenContext) {\n    return (ty.repeated.kind === 'primitive' ||\n            ty.repeated.kind === 'never' ||\n            ty.repeated.kind === 'any' ||\n            ty.repeated.kind === 'unknown' ||\n            ty.repeated.kind === 'object' ||\n            ty.repeated.kind === 'symlink' ||\n            (ty.repeated.kind === 'one-of' && ty.repeated.typeName) ?\n        `${ty.repeated.typeName ?\n            ty.repeated.typeName :\n            generateTypeScriptCodeInner(ty.repeated, false, ctx)}[]` :\n        `Array<${ty.repeated.typeName ?\n            ty.repeated.typeName :\n            generateTypeScriptCodeInner(ty.repeated, false, ctx)}>`\n    );\n}\n\n\nfunction generateTypeScriptCodeSpread(ty: SpreadAssertion, ctx: CodegenContext) {\n    return '';\n}\n\n\nfunction generateTypeScriptCodeSequence(ty: SequenceAssertion, ctx: CodegenContext) {\n    return `[${\n        ty.sequence\n            .filter(x => x.kind !== 'spread')\n            .map(x => x.typeName ?\n                x.typeName :\n                generateTypeScriptCodeInner(x, false, {...ctx, nestLevel: ctx.nestLevel + 1}))\n            .join(', ')}]`;\n}\n\n\nfunction generateTypeScriptCodeOneOf(ty: OneOfAssertion, ctx: CodegenContext) {\n    return `(${ty.oneOf\n        .map(x => x.typeName ?\n            x.typeName :\n            generateTypeScriptCodeInner(x, false, ctx)).join(' | ')})`;\n}\n\n\nfunction generateTypeScriptCodeOptional(ty: OptionalAssertion, ctx: CodegenContext) {\n    return generateTypeScriptCodeInner(ty.optional, false, ctx);\n}\n\n\nfunction generateTypeScriptCodeEnum(ty: EnumAssertion, ctx: CodegenContext) {\n    return `(${ty.values.map(x => `${x[1]}`).join(' | ')})`;\n}\n\n\nfunction formatAdditionalPropsName(ak: AdditionalPropsKey, i: number) {\n    return (`[propName${i}: ${ak.map(x => typeof x === 'string' ? x : 'string').join(' | ')}]`);\n}\n\n\nfunction generateTypeScriptCodeObject(ty: ObjectAssertion, isInterface: boolean, ctx: CodegenContext) {\n    if (ty.members.filter(x => !(x[2])).length === 0) {\n        return '{}';\n    }\n    const sep = isInterface ? ';\\n' : ',\\n';\n\n    const memberLines =\n        ty.members.filter(x => !(x[2]))\n        .map(x =>\n            `${formatTypeScriptCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                x[0]}${x[1].kind === 'optional' ? '?' : ''}: ${\n                x[1].typeName ?\n                    x[1].typeName :\n                    generateTypeScriptCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})}`);\n\n    const additionalPropsLines =\n        ty.additionalProps?.filter(x => !(x[2]))\n        .map((x, i) =>\n            `${formatTypeScriptCodeDocComment(x[3] || '', ctx.nestLevel + 1)}${\n                '    '.repeat(ctx.nestLevel + 1)}${\n                formatAdditionalPropsName(x[0], i)}${x[1].kind === 'optional' ? '?' : ''}: ${\n                x[1].typeName ?\n                    x[1].typeName :\n                    generateTypeScriptCodeInner(x[1], false, {...ctx, nestLevel: ctx.nestLevel + 1})}`) || [];\n\n    return (\n        `{\\n${memberLines.concat(additionalPropsLines).join(sep)}${sep}${'    '.repeat(ctx.nestLevel)}}`\n    );\n}\n\n\nfunction generateTypeScriptCodeInner(ty: TypeAssertion, isInterface: boolean, ctx: CodegenContext): string {\n    switch (ty.kind) {\n    case 'never':\n        return 'never';\n    case 'any':\n        return 'any';\n    case 'unknown':\n        return 'unknown';\n    case 'primitive':\n        return generateTypeScriptCodePrimitive(ty, ctx);\n    case 'primitive-value':\n        return generateTypeScriptCodePrimitiveValue(ty, ctx);\n    case 'repeated':\n        return generateTypeScriptCodeRepeated(ty, ctx);\n    case 'spread':\n        return generateTypeScriptCodeSpread(ty, ctx);\n    case 'sequence':\n        return generateTypeScriptCodeSequence(ty, ctx);\n    case 'one-of':\n        return generateTypeScriptCodeOneOf(ty, ctx);\n    case 'optional':\n        return generateTypeScriptCodeOptional(ty, ctx);\n    case 'enum':\n        return generateTypeScriptCodeEnum(ty, ctx);\n    case 'object':\n        return generateTypeScriptCodeObject(ty, isInterface, ctx);\n    case 'symlink':\n        return ty.symlinkTargetName;\n    case 'operator':\n        throw new Error(`Unexpected type assertion: ${(ty as any).kind}`);\n    default:\n        throw new Error(`Unknown type assertion: ${(ty as any).kind}`);\n    }\n}\n\n\nexport function generateTypeScriptCode(types: TypeAssertionMap): string {\n    let code = '';\n    const ctx = {nestLevel: 0};\n    for (const ty of types.entries()) {\n        if (ty[1].ty.noOutput) {\n            continue;\n        }\n        code += formatTypeScriptCodeDocComment(ty[1].ty, ctx.nestLevel);\n        if (ty[1].exported) {\n            code += 'export ';\n        }\n        if (ty[1].ty.kind === 'object') {\n            code += `interface ${ty[0]}${\n                ty[1].ty.baseTypes && ty[1].ty.baseTypes.length ? ` extends ${\n                    ty[1].ty.baseTypes\n                        .filter(x => x.typeName)\n                        .map(x => x.typeName)\n                        .join(', ')}` : ''} ${\n                generateTypeScriptCodeInner(ty[1].ty, true, ctx)}\\n\\n`;\n        } else if (ty[1].ty.kind === 'enum') {\n            const indent0 = '    '.repeat(ctx.nestLevel);\n            const indent1 = '    '.repeat(ctx.nestLevel + 1);\n            let value: number | null = 0;\n            code += `enum ${ty[0]} {\\n${\n                ty[1].ty.values\n                    .map(x => `${\n                        formatTypeScriptCodeDocComment(x[2] || '', ctx.nestLevel + 1)}${\n                        indent1}${(() => {\n                            if (value !== null && x[1] === value) {\n                                value++;\n                                return `${x[0]}`;\n                            } else {\n                                if (typeof x[1] === 'number') {\n                                    value = x[1] + 1;\n                                    return `${x[0]} = ${x[1]}`;\n                                } else {\n                                    return `${x[0]} = '${escapeString(x[1])}'`;\n                                }\n                            }\n                        })()},\\n`)\n                    .join('')}${indent0}}\\n\\n`;\n        } else if (ty[1].ty.kind === 'never' && ty[1].ty.passThruCodeBlock) {\n            code += `${ty[1].ty.passThruCodeBlock}\\n\\n`;\n        } else {\n            code += `type ${ty[0]} = ${\n                ty[1].ty.originalTypeName ||\n                generateTypeScriptCodeInner(ty[1].ty, false, ctx)};\\n\\n`;\n        }\n    }\n    return code;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ValidationContext } from '../types';\n\n\n\nexport class ValidationError extends Error {\n    public ty?: TypeAssertion;\n    public ctx?: ValidationContext;\n    public constructor(message: string, ty?: TypeAssertion, ctx?: ValidationContext) {\n        super(message);\n        this.ty = ty;\n        this.ctx = ctx;\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport function escapeString(s: string) {\n    return (s\n        .replace(/\\x08/g, '\\\\b')\n        .replace(/\\f/g, '\\\\f')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\v/g, '\\\\v')\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\'/g, '\\\\\\'')\n        .replace(/\\\"/g, '\\\\\\\"')\n        .replace(/\\`/g, '\\\\\\`')\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         ErrorMessages,\n         TypeAssertionErrorMessageConstraints,\n         TypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         ObjectAssertion,\n         ValidationContext } from '../types';\nimport { escapeString }      from './escape';\n\n\nexport const errorTypeNames = [\n    '',\n    'InvalidDefinition',\n    'Required',\n    'TypeUnmatched',\n    'AdditionalPropUnmatched',\n    'RepeatQtyUnmatched',\n    'SequenceUnmatched',\n    'ValueRangeUnmatched',\n    'ValuePatternUnmatched',\n    'ValueLengthUnmatched',\n    'ValueUnmatched',\n];\n\n\nexport const defaultMessages: ErrorMessages = {\n    invalidDefinition:       '\"%{name}\" of \"%{parentType}\" type definition is invalid.',\n    required:                '\"%{name}\" of \"%{parentType}\" is required.',\n    typeUnmatched:           '\"%{name}\" of \"%{parentType}\" should be type \"%{expectedType}\".',\n    additionalPropUnmatched: '\"%{addtionalProps}\" of \"%{parentType}\" are not matched to additional property patterns.',\n    repeatQtyUnmatched:      '\"%{name}\" of \"%{parentType}\" should repeat %{repeatQty} times.',\n    sequenceUnmatched:       '\"%{name}\" of \"%{parentType}\" sequence is not matched',\n    valueRangeUnmatched:     '\"%{name}\" of \"%{parentType}\" value should be in the range %{minValue} to %{maxValue}.',\n    valuePatternUnmatched:   '\"%{name}\" of \"%{parentType}\" value should be matched to pattern \"%{pattern}\"',\n    valueLengthUnmatched:    '\"%{name}\" of \"%{parentType}\" length should be in the range %{minLength} to %{maxLength}.',\n    valueUnmatched:          '\"%{name}\" of \"%{parentType}\" value should be \"%{expectedValue}\".',\n};\n\n\ntype TopRepeatable = RepeatedAssertion | SpreadAssertion | OptionalAssertion | null;\n\n\ninterface ReportErrorArguments {\n    ctx: ValidationContext;\n    substitutions?: [[string, string]]; // addtional or overwritten substitution values\n}\n\n\nfunction getErrorMessage(errType: ErrorTypes, ...messages: ErrorMessages[]) {\n    for (const m of messages) {\n        switch (errType) {\n        case ErrorTypes.InvalidDefinition:\n            if (m.invalidDefinition) {\n                return m.invalidDefinition;\n            }\n            break;\n        case ErrorTypes.Required:\n            if (m.required) {\n                return m.required;\n            }\n            break;\n        case ErrorTypes.TypeUnmatched:\n            if (m.typeUnmatched) {\n                return m.typeUnmatched;\n            }\n            break;\n        case ErrorTypes.AdditionalPropUnmatched:\n            if (m.additionalPropUnmatched) {\n                return m.additionalPropUnmatched;\n            }\n            break;\n        case ErrorTypes.RepeatQtyUnmatched:\n            if (m.repeatQtyUnmatched) {\n                return m.repeatQtyUnmatched;\n            }\n            break;\n        case ErrorTypes.SequenceUnmatched:\n            if (m.sequenceUnmatched) {\n                return m.sequenceUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueRangeUnmatched:\n            if (m.valueRangeUnmatched) {\n                return m.valueRangeUnmatched;\n            }\n            break;\n        case ErrorTypes.ValuePatternUnmatched:\n            if (m.valuePatternUnmatched) {\n                return m.valuePatternUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueLengthUnmatched:\n            if (m.valueLengthUnmatched) {\n                return m.valueLengthUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueUnmatched:\n            if (m.valueUnmatched) {\n                return m.valueUnmatched;\n            }\n            break;\n        }\n    }\n    return '';\n}\n\n\nfunction nvl(v: any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? v : alt\n    );\n}\n\n\nfunction findTopNamedAssertion(ctx: ValidationContext): TypeAssertion | null {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.name && x.name !== x.typeName) || null;\n    return ret;\n}\n\n\nfunction findTopObjectAssertion(ctx: ValidationContext): ObjectAssertion | null {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.kind === 'object') as ObjectAssertion || null;\n    return ret;\n}\n\n\nfunction findTopRepeatableAssertion(ctx: ValidationContext): TopRepeatable {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.kind === 'repeated' || x.kind === 'spread' || x.kind === 'optional'\n                ) as RepeatedAssertion | SpreadAssertion | OptionalAssertion || null;\n    return ret;\n}\n\n\nfunction getExpectedType(ty: TypeAssertion): string {\n    switch (ty.kind) {\n    case 'repeated':\n        return `(repeated ${getExpectedType(ty.repeated)})`;\n    case 'spread':\n        return getExpectedType(ty.spread);\n    case 'sequence':\n        return '(sequence)';\n    case 'primitive':\n        return ty.primitiveName;\n    case 'primitive-value':\n        return `(value ${\n            typeof ty.value === 'string' ?\n                `'${String(ty.value)}'` :\n                String(ty.value)})`;\n    case 'optional':\n        return getExpectedType(ty.optional);\n    case 'one-of':\n        return `(one of ${ty.oneOf.map(x => getExpectedType(x)).join(', ')}`;\n    case 'never': case 'any': case 'unknown':\n        return ty.kind;\n    case 'symlink':\n        return ty.symlinkTargetName;\n    default:\n        return ty.typeName ? ty.typeName : '?';\n    }\n}\n\n\nexport function formatErrorMessage(\n        msg: string, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments,\n        values: {dataPath: string, topRepeatable: TopRepeatable, parentType: string}) {\n\n    let ret = msg;\n    // TODO: complex type object members' custom error messages are not displayed?\n    // TODO: escapeString() is needed?\n\n    const tr = values.topRepeatable;\n\n    const dict = new Map<string, string>([\n        ['expectedType',\n            escapeString(getExpectedType(ty))],\n        ['type',\n            escapeString(typeof data)],\n        ['expectedValue',\n            escapeString(\n                ty.kind === 'primitive-value' ?\n                    String(ty.value) :\n                ty.kind === 'enum' ?\n                    ty.typeName ?\n                        `enum member of ${ty.typeName}` :\n                        '?' :\n                '?')],\n        ['value',\n            escapeString(String(data))],\n        ['repeatQty',\n            escapeString(\n                tr ?\n                    tr.kind !== 'optional' ? `${\n                        nvl(tr.min, '')}${\n                            (tr.min !== null && tr.min !== void 0) ||\n                            (tr.max !== null && tr.max !== void 0) ? '..' : ''}${\n                            nvl(tr.max, '')}` :\n                        '0..1' :\n                    '?')],\n        ['minValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minValue, nvl(ty.greaterThanValue, '(smallest)'))}` : '?')],\n        ['maxValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxValue, nvl(ty.lessThanValue, '(biggest)'))}` : '?')],\n        ['pattern',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${ty.pattern ? `/${ty.pattern.source}/${ty.pattern.flags}` : '(pattern)'}` : '?')],\n        ['minLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minLength, '0')}` : '?')],\n        ['maxLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxLength, '(biggest)')}` : '?')],\n        ['name',\n            escapeString(\n                `${ty.kind !== 'repeated' && values.dataPath.endsWith('repeated)') ?\n                    'repeated item of ' :\n                   ty.kind !== 'sequence' && values.dataPath.endsWith('sequence)') ?\n                    'sequence item of ' : ''}${\n                (ty.name && ty.name !== ty.typeName ? ty.name : null) ||\n                    findTopNamedAssertion(args.ctx)?.name || '?'}`)],\n        ['parentType',\n            escapeString(\n                findTopObjectAssertion(args.ctx)?.typeName || ty.typeName || values.parentType || '?')],\n        ['dataPath',\n            values.dataPath],\n\n        ...(args.substitutions || []),\n    ]);\n\n    for (const ent of dict.entries()) {\n        ret = ret.replace(new RegExp(`%{${ent[0]}}`), ent[1]);\n    }\n\n    return ret;\n}\n\n\nexport function reportError(\n        errType: ErrorTypes, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments) {\n\n    const messages: ErrorMessages[] = [];\n    if (ty.messages) {\n        messages.push(ty.messages);\n    }\n    if (args.ctx.errorMessages) {\n        messages.push(args.ctx.errorMessages);\n    }\n    messages.push(defaultMessages);\n\n    let parentType = '';\n    const dataPathArray: string[] = [];\n    for (let i = 0; i < args.ctx.typeStack.length; i++) {\n        const p = args.ctx.typeStack[i];\n        const next = args.ctx.typeStack[i + 1];\n        const pt = Array.isArray(p) ? p[0] : p;\n        const pi = Array.isArray(next) ? next[1] : void 0;\n\n        let isSet = false;\n        if (pt.kind === 'repeated') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathArray.push(`${pt.name}.(${pi !== void 0 ? `${pi}:` : ''}repeated)`);\n                } else {\n                    dataPathArray.push(`(repeated)`);\n                }\n                isSet = true;\n            }\n        } else if (pt.kind === 'sequence') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathArray.push(`${pt.name}.(${pi !== void 0 ? `${pi}:` : ''}sequence)`);\n                } else {\n                    dataPathArray.push(`(sequence)`);\n                }\n                isSet = true;\n            }\n        }\n        if (! isSet) {\n            if (pt.name) {\n                dataPathArray.push(`${pt.name}`);\n            } else if (pt.typeName) {\n                dataPathArray.push(`${pt.typeName}`);\n            }\n        }\n        if (!parentType && pt.typeName) {\n            parentType = pt.typeName;\n        }\n    }\n    const dataPath = dataPathArray.join('.');\n\n    const topRepeatable: TopRepeatable = findTopRepeatableAssertion(args.ctx);\n    const values = {dataPath, topRepeatable, parentType};\n\n    const constraints: TypeAssertionErrorMessageConstraints = {};\n    const cSrces: TypeAssertionErrorMessageConstraints[] = [ty as any];\n    if (errType === ErrorTypes.RepeatQtyUnmatched && topRepeatable) {\n        cSrces.unshift(topRepeatable as any);\n    }\n    for (const cSrc of cSrces) {\n        if (nvl(cSrc.minValue, false)) {\n            constraints.minValue = cSrc.minValue;\n        }\n        if (nvl(cSrc.maxValue, false)) {\n            constraints.maxValue = cSrc.maxValue;\n        }\n        if (nvl(cSrc.greaterThanValue, false)) {\n            constraints.greaterThanValue = cSrc.greaterThanValue;\n        }\n        if (nvl(cSrc.lessThanValue, false)) {\n            constraints.lessThanValue = cSrc.lessThanValue;\n        }\n        if (nvl(cSrc.minLength, false)) {\n            constraints.minLength = cSrc.minLength;\n        }\n        if (nvl(cSrc.maxLength, false)) {\n            constraints.maxLength = cSrc.maxLength;\n        }\n        if (nvl(cSrc.pattern, false)) {\n            const pat = cSrc.pattern as any as RegExp;\n            constraints.pattern = `/${pat.source}/${pat.flags}`;\n        }\n        if (nvl(cSrc.min, false)) {\n            constraints.min = cSrc.min;\n        }\n        if (nvl(cSrc.max, false)) {\n            constraints.max = cSrc.max;\n        }\n    }\n\n    const val: {value?: any} = {};\n    switch (typeof data) {\n    case 'number': case 'bigint': case 'string': case 'boolean': case 'undefined':\n        val.value = data;\n        break;\n    case 'object':\n        if (data === null) {\n            val.value = data;\n        }\n    }\n\n    if (ty.messageId) {\n        args.ctx.errors.push({\n            code: `${ty.messageId}-${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message ?\n                ty.message :\n                getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else if (ty.message) {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message, data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    }\n}\n\n\nexport function reportErrorWithPush(\n        errType: ErrorTypes, data: any,\n        tyidx: [TypeAssertion, number | string | undefined],\n        args: ReportErrorArguments) {\n\n    try {\n        args.ctx.typeStack.push(tyidx);\n        reportError(errType, data, tyidx[0], args);\n    } finally {\n        args.ctx.typeStack.pop();\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap,\n         TypeAssertionSetValue,\n         AssertionSymlink,\n         SymbolResolverOperators,\n         SymbolResolverContext } from '../types';\nimport * as operators            from '../operators';\n\n\n\nfunction mergeTypeAndSymlink(ty: TypeAssertion, link: AssertionSymlink): TypeAssertion {\n    const link2 = {...link};\n    delete link2.kind;\n    delete link2.symlinkTargetName;\n    return ({...ty, ...link2} as any as TypeAssertion);\n}\n\n\nfunction updateSchema(original: TypeAssertion, schema: TypeAssertionMap, ty: TypeAssertion, typeName: string | undefined) {\n    if (typeName && schema.has(typeName)) {\n        const z: TypeAssertionSetValue = schema.get(typeName) as TypeAssertionSetValue;\n        if (z.ty === original) {\n            schema.set(typeName, {...z, ty, resolved: true});\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveSymbols(schema: TypeAssertionMap, ty: TypeAssertion, ctx: SymbolResolverContext): TypeAssertion {\n    const ctx2 = {...ctx, nestLevel: ctx.nestLevel + 1};\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const x = schema.get(ty.symlinkTargetName);\n            if (! x) {\n                throw new Error(`Undefined symbol '${ty.symlinkTargetName}' is referred.`);\n            }\n            if (0 <= ctx.symlinkStack.findIndex(s => s === ty.symlinkTargetName)) {\n                return ty;\n            }\n            return (\n                resolveSymbols(\n                    schema,\n                    mergeTypeAndSymlink(x.ty, ty),\n                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.symlinkTargetName]},\n                )\n            );\n        }\n    case 'repeated':\n        return updateSchema(ty, schema, {\n            ...ty,\n            repeated: resolveSymbols(schema, ty.repeated, ctx2),\n        }, ty.typeName);\n    case 'spread':\n        return updateSchema(ty, schema, {\n            ...ty,\n            spread: resolveSymbols(schema, ty.spread, ctx2),\n        }, ty.typeName);\n    case 'sequence':\n        return updateSchema(ty, schema, {\n            ...ty,\n            sequence: ty.sequence.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'one-of':\n        return updateSchema(ty, schema, {\n            ...ty,\n            oneOf: ty.oneOf.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'optional':\n        return updateSchema(ty, schema, {\n            ...ty,\n            optional: resolveSymbols(schema, ty.optional, ctx2),\n        }, ty.typeName);\n    case 'object':\n        {\n            if (0 < ctx.nestLevel && ty.typeName && 0 <= ctx.symlinkStack.findIndex(s => s === ty.typeName)) {\n                if (schema.has(ty.typeName)) {\n                    const z = schema.get(ty.typeName) as TypeAssertionSetValue;\n                    if (z.resolved) {\n                        return z.ty;\n                    }\n                }\n            }\n\n            const baseSymlinks = ty.baseTypes?.filter(x => x.kind === 'symlink') as AssertionSymlink[];\n            if (baseSymlinks && baseSymlinks.length > 0) {\n                const exts = baseSymlinks\n                    .map(x => resolveSymbols(schema, x, ctx2))\n                    .filter(x => x.kind === 'object');\n                // TODO: if x.kind !== 'object' items exist -> error?\n                const d2 = resolveSymbols(\n                    schema,\n                    operators.derived({\n                        ...ty,\n                        ...(ty.baseTypes ? {\n                            baseTypes: ty.baseTypes.filter(x => x.kind !== 'symlink'),\n                        } : {}),\n                    }, ...exts),\n                    ty.typeName ?\n                        {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2,\n                );\n                return updateSchema(ty, schema, {\n                    ...ty,\n                    ...d2,\n                }, ty.typeName);\n            } else {\n                return updateSchema(ty, schema, {\n                    ...{\n                        ...ty,\n                        members: ty.members\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    },\n                    ...(ty.additionalProps && 0 < ty.additionalProps.length ? {\n                        additionalProps: ty.additionalProps\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    } : {}),\n                }, ty.typeName);\n            }\n        }\n    case 'operator':\n        if (ctx2.operators) {\n            const ctx3 = ty.typeName ?\n                {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2;\n            const operands = ty.operands.map(x => {\n                if (typeof x === 'object' && x.kind) {\n                    return resolveSymbols(schema, x, ctx3);\n                }\n                return x;\n            });\n            if (0 < operands.filter(x => x && typeof x === 'object' &&\n                    (x.kind === 'symlink' || x.kind === 'operator')).length) {\n                throw new Error(`Unresolved type operator is found: ${ty.operator}`);\n            }\n            if (! ctx2.operators[ty.operator]) {\n                throw new Error(`Undefined type operator is found: ${ty.operator}`);\n            }\n            const ty2 = {...ty};\n            delete ty2.operator;\n            delete ty2.operands;\n            return updateSchema(\n                ty, schema,\n                {\n                    ...ty2,\n                    ...resolveSymbols(schema, ctx2.operators[ty.operator](...operands), ctx3),\n                },\n                ty.typeName,\n            );\n        } else {\n            return ty;\n        }\n    default:\n        return ty;\n    }\n}\n\n\nconst resolverOps: SymbolResolverOperators = {\n    picked: operators.picked,\n    omit: operators.omit,\n    partial: operators.partial,\n    intersect: operators.intersect,\n    subtract: operators.subtract,\n};\n\n\nexport function resolveSchema(schema: TypeAssertionMap): TypeAssertionMap {\n    for (const ent of schema.entries()) {\n        const ty = resolveSymbols(schema, ent[1].ty, {nestLevel: 0, symlinkStack: [ent[0]], operators: resolverOps});\n        ent[1].ty = ty;\n    }\n\n    return schema;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable-next-line:function-constructor\nconst globalObj = Function('return this')();\nconst objConstructor = ({}).constructor; // NOTE: objConstructor            === Object\nconst funConstructor = Function;         // NOTE: ({}).toString.constructor === Function\n\n\nexport const dummyTargetObject = {};\n\n\nexport function isUnsafeVarNames(target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        return true;\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (objConstructor.hasOwnProperty(varName)) {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            if (con.hasOwnProperty(varName)) {\n                return true;\n            }\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        if (!target.hasOwnProperty(varName)) {\n            // function's prototypes' members\n            return true;\n        }\n    }\n    return false;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveValueTypes,\n         PrimitiveValueTypeNames,\n         OptionalPrimitiveValueTypeNames,\n         PlaceholderTypeNames,\n         OptionalPlaceholderTypeNames,\n         ErrorMessages,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertionMember,\n         AdditionalPropsKey,\n         AdditionalPropsMember,\n         ObjectAssertion,\n         AssertionSymlink,\n         AssertionOperator,\n         TypeAssertion }    from './types';\nimport { dummyTargetObject,\n         isUnsafeVarNames } from './lib/util';\n\n\n\n// emulate Pick<T> // ex. Pick<Foo, 'a' | 'b'>\nexport function picked(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const name of names) {\n                const member = ty.members.find(x => x[0] === name);\n                if (member) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'picked',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Omit<T> // ex. Omit<Foo, 'a' | 'b'>\nexport function omit(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                if (! names.find(name => member[0] === name)) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'omit',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Partial<T>\nexport function partial(ty: TypeAssertion): TypeAssertion {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                let m: ObjectAssertionMember = member[1].kind === 'optional' ?\n                    member :\n                    [member[0], optional(member[1]), ...member.slice(2)] as ObjectAssertionMember;\n                if (m[2]) {\n                    m = [...m] as any;\n                    if (3 < m.length) {\n                        m[2] = false;\n                    } else {\n                        m.length = 2;\n                    }\n                }\n                m[1].name = m[0];\n                const optTy = {...(m[1] as OptionalAssertion).optional};\n                (m[1] as OptionalAssertion).optional = optTy;\n                if (optTy.name && optTy.name !== optTy.typeName) {\n                    delete optTy.name;\n                }\n                if (!optTy.name && optTy.typeName) {\n                    optTy.name = optTy.typeName;\n                }\n                members.push(m);\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'partial',\n                operands: [ty],\n            });\n        }\n    default:\n        return ty;\n    }\n}\n\n\n// intersection (a & b)\nexport function intersect(...types: TypeAssertion[]): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty intersection type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'intersect',\n            operands: types.slice(),\n        });\n    }\n    let lastTy: TypeAssertion | null = null;\n    const members = new Map<string, ObjectAssertionMember>();\n\n    for (const ty of types) {\n        if (ty && typeof ty === 'object') {\n            if (lastTy && lastTy.kind !== ty.kind) {\n                return ({\n                    kind: 'never',\n                });\n            }\n            lastTy = ty;\n            if (ty.kind === 'object') {\n                for (const m of ty.members) {\n                    if (m[2]) {\n                        const m2: ObjectAssertionMember = [...m] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.set(m[0], m2); // Overwrite if exists\n                    } else {\n                        members.set(m[0], m);  // Overwrite if exists\n                    }\n                }\n            }\n        } else {\n            return ({\n                kind: 'never',\n            });\n        }\n    }\n    if (lastTy && lastTy.kind !== 'object') {\n        return lastTy;\n    } else {\n        return ({\n            kind: 'object',\n            members: Array.from(members.values()),\n        });\n    }\n}\n\n\n// union (a | b)\nexport function oneOf(...types: Array<PrimitiveValueTypes | TypeAssertion>): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty union type is not allowed.`);\n    }\n    if (types.length === 1) {\n        const ty = types[0];\n        if (ty && typeof ty === 'object') {\n            return ty;\n        } else {\n            return primitiveValue(ty);\n        }\n    }\n    const ret: OneOfAssertion = {\n        kind: 'one-of',\n        oneOf: [],\n    };\n    for (const ty of types) {\n        // TODO: remove same type\n        if (ty && typeof ty === 'object') {\n            if (ty.kind === 'one-of') {\n                ret.oneOf = ret.oneOf.concat(ty.oneOf);\n            } else {\n                ret.oneOf.push(ty);\n            }\n        } else {\n            ret.oneOf.push(primitiveValue(ty));\n        }\n    }\n    return ret;\n}\n\n\n// subtraction (a - b)\nexport function subtract(...types: TypeAssertion[]): ObjectAssertion | AssertionOperator {\n    if (types.length === 0) {\n        throw new Error(`Empty subtraction type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'subtract',\n            operands: types.slice(),\n        });\n    }\n    let ret = types[0];\n    if (!ret || typeof ret !== 'object' || ret.kind !== 'object') {\n        throw new Error(`First parameter of subtraction type should be 'object'.`);\n    }\n    for (const ty of types.slice(1)) {\n        if (ty && typeof ty === 'object' && ty.kind === 'object') {\n            ret = omit(ret, ...ty.members.map(m => m[0]));\n        }\n    }\n    return ret;\n}\n\n\nexport function primitive(typeName: PrimitiveValueTypeNames |\n                                    OptionalPrimitiveValueTypeNames |\n                                    PlaceholderTypeNames |\n                                    OptionalPlaceholderTypeNames):\n        PrimitiveTypeAssertion | OptionalAssertion | NeverTypeAssertion | AnyTypeAssertion | UnknownTypeAssertion {\n    switch (typeName) {\n    case 'never':\n        return ({\n            kind: 'never',\n        });\n    case 'any':\n        return ({\n            kind: 'any',\n        });\n    case 'unknown':\n        return ({\n            kind: 'unknown',\n        });\n    case 'number':\n        // FALL_THRU\n    case 'integer':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        // FALL_THRU\n    case 'null':\n        // FALL_THRU\n    case 'undefined':\n        return ({\n            kind: 'primitive',\n            primitiveName: typeName,\n        });\n    case 'never?':\n        return (optional({\n            kind: 'never',\n        }));\n    case 'any?':\n        return (optional({\n            kind: 'any',\n        }));\n    case 'unknown?':\n        return (optional({\n            kind: 'unknown',\n        }));\n    case 'number?':\n        // FALL_THRU\n    case 'integer?':\n        // FALL_THRU\n    case 'bigint?':\n        // FALL_THRU\n    case 'string?':\n        // FALL_THRU\n    case 'boolean?':\n        // FALL_THRU\n    case 'null?':\n        // FALL_THRU\n    case 'undefined?':\n        return (optional({\n            kind: 'primitive',\n            primitiveName: typeName.substring(0, typeName.length - 1) as any,\n        }));\n    default:\n        throw new Error(`Unknown primitive type assertion: ${typeName}`);\n    }\n    // TODO: Function, DateStr, DateTimeStr, Funtion?, DateStr?, DateTimeStr?\n}\n\n\nexport function regexpPatternStringType(pattern: RegExp): PrimitiveTypeAssertion {\n    return ({\n        kind: 'primitive',\n        primitiveName: 'string',\n        pattern,\n    });\n}\n\n\nexport function primitiveValue(value: PrimitiveValueTypes): PrimitiveValueTypeAssertion {\n    if (value === null || value === void 0) {\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    } else switch (typeof value) {\n    case 'number':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    default:\n        throw new Error(`Unknown primitive value assertion: ${value}`);\n    }\n}\n\n\nexport function optional(ty: PrimitiveValueTypes | TypeAssertion): OptionalAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        if (ty.kind === 'optional') {\n            return ty;\n        } else {\n            return ({\n                kind: 'optional',\n                optional: ty,\n                ...(ty.typeName ? {typeName: ty.typeName} : {}),\n            });\n        }\n    } else {\n        return ({\n            kind: 'optional',\n            optional: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function repeated(\n        ty: PrimitiveValueTypeNames | TypeAssertion, option?:\n        Partial<Pick<RepeatedAssertion, 'max'> & Pick<RepeatedAssertion, 'min'>>): RepeatedAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: ty,\n        });\n    } else {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: primitive(ty),\n        });\n    }\n}\n\n\nexport function sequenceOf(...seq: Array<PrimitiveValueTypes | TypeAssertion>): SequenceAssertion {\n    return ({\n        kind: 'sequence',\n        sequence: seq.map(ty => ty && typeof ty === 'object' && ty.kind ? ty : primitiveValue(ty)),\n    });\n}\n\n\nexport function spread(\n        ty: PrimitiveValueTypes | TypeAssertion,\n        option?: Partial<Pick<SpreadAssertion, 'max'> & Pick<SpreadAssertion, 'min'>>): SpreadAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: ty,\n        });\n    } else {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function enumType(...values: Array<[string, number | string | null, string?]>): EnumAssertion {\n    const ar = values.slice();\n    let value = 0;\n    for (let i = 0; i < ar.length; i++) {\n        if (isUnsafeVarNames(dummyTargetObject, ar[i][0])) {\n            throw new Error(`Unsafe symbol name is appeared in enum assertion: ${ar[i][0]}`);\n        }\n\n        if (ar[i][1] === null || ar[i][1] === void 0) {\n            ar[i][1] = value++;\n        } else if (typeof ar[i][1] === 'number') {\n            value = (ar[i][1] as number) + 1;\n        }\n        if (! ar[i][2]) {\n            ar[i].length = 2;\n        }\n    }\n    return ({\n        kind: 'enum',\n        values: ar as Array<[string, number | string, string?]>,\n    });\n}\n\n\nexport function objectType(\n        ...members: Array<[\n            string | AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>): ObjectAssertion {\n    const revMembers = members.slice().reverse();\n    for (const x of members) {\n        if (typeof x[0] === 'string') {\n            if (isUnsafeVarNames(dummyTargetObject, x[0])) {\n                throw new Error(`Unsafe symbol name is appeared in object assertion: ${x[0]}`);\n            }\n            if (members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n                throw new Error(`Duplicated member is found: ${x[0]}`);\n            }\n        }\n    }\n\n    const membersProps: ObjectAssertionMember[] = (members\n        .filter(\n            x => typeof x[0] === 'string') as\n                Array<[string, PrimitiveValueTypes | TypeAssertion, string?]>)\n        .map(\n            x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n                [x[0], withName(x[1], x[0]), x[2]] :\n                [x[0], withName(primitiveValue(x[1]), x[0]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as ObjectAssertionMember);\n\n    const additionalProps: AdditionalPropsMember[] = (members\n        .filter(x => typeof x[0] !== 'string') as Array<[\n            AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>)\n        .map(x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n            x :\n            [x[0], primitiveValue(x[1]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as AdditionalPropsMember);\n\n    return ({\n        ...{\n            kind: 'object',\n            members: membersProps,\n        },\n        ...(0 < additionalProps.length ? {\n            additionalProps,\n        } : {}),\n    });\n}\n\n\nfunction checkRecursiveExtends(ty: ObjectAssertion, base: ObjectAssertion | AssertionSymlink): boolean {\n    if (ty === base) {\n        return false;\n    }\n    if (ty.typeName &&\n        (ty.typeName === base.typeName ||\n         (base.kind === 'symlink' && ty.typeName === base.symlinkTargetName))) {\n        return false;\n    }\n    if (base.kind === 'object' && base.baseTypes) {\n        for (const z of base.baseTypes) {\n            if (! checkRecursiveExtends(ty, z)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nexport function derived(ty: ObjectAssertion, ...exts: TypeAssertion[]): ObjectAssertion {\n    const ret: ObjectAssertion = {\n        kind: 'object',\n        members: [],\n        baseTypes: [],\n    };\n\n    for (const ext of exts) {\n        switch (ext.kind) {\n        case 'object':\n            if (! checkRecursiveExtends(ty, ext)) {\n                throw new Error(`Recursive extend is found: ${ty.name || '(unnamed)'}`);\n            }\n            for (const m of ext.members) {\n                if (! ret.members.find(x => x[0] === m[0])) {\n                    ret.members.push([m[0], m[1], true, ...m.slice(3)] as ObjectAssertionMember);\n                }\n                // TODO: Check for different types with the same name.\n            }\n        // FALL_THRU\n        case 'symlink':\n            (ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).push(ext);\n            break;\n        case 'operator':\n            {\n                throw new Error(`Unresolved type operator is found: ${ext.operator}`);\n            }\n        }\n        // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n        //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n    }\n    ret.members = ty.members.concat(ret.members);\n    if (ty.baseTypes) {\n        ret.baseTypes = ty.baseTypes\n            .filter(x => x.kind !== 'symlink')\n            .concat(ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>);\n    }\n    if ((ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).length === 0) {\n        delete ret.baseTypes;\n    }\n\n    const revMembers = ret.members.slice().reverse();\n    for (const x of ret.members) {\n        if (ret.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            throw new Error(`Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`);\n        }\n    }\n\n    let additionalProps: AdditionalPropsMember[] = [];\n    if (ret.baseTypes) {\n        for (const base of ret.baseTypes) {\n            if (base.kind === 'object') {\n                if (base.additionalProps && 0 < base.additionalProps.length) {\n                    additionalProps = additionalProps.concat(\n                        base.additionalProps.map(x =>\n                            [x[0], x[1], true, ...x.slice(3)] as AdditionalPropsMember));\n                }\n            }\n            // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n            //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n        }\n    }\n    if (ty.additionalProps && 0 < ty.additionalProps.length) {\n        additionalProps = additionalProps.concat(ty.additionalProps); // TODO: concat order\n    }\n    if (0 < additionalProps.length) {\n        ret.additionalProps = additionalProps;\n    }\n\n    return ret;\n}\n\n\nexport function symlinkType(name: string): AssertionSymlink {\n    return ({\n        kind: 'symlink',\n        symlinkTargetName: name,\n    });\n}\n\n\nexport function withName(ty: TypeAssertion, name: string) {\n    if (! name) {\n        return ty;\n    }\n    return ({...ty, name});\n}\n\n\nexport function withTypeName(ty: TypeAssertion, typeName: string) {\n    if (! typeName) {\n        return ty;\n    }\n    return ({...ty, typeName});\n}\n\n\nexport function withOriginalTypeName(ty: TypeAssertion, originalTypeName: string) {\n    if (! originalTypeName) {\n        return ty;\n    }\n    return ({...ty, originalTypeName});\n}\n\n\nexport function withDocComment(ty: TypeAssertion, docComment: string) {\n    if (! docComment) {\n        return ty;\n    }\n    return ({...ty, docComment});\n}\n\n\nexport function withRange(minValue: number | string, maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'minValue' should be number or string.`);\n        }\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue, maxValue});\n        }\n    };\n}\n\n\nexport function withMinValue(minValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@minValue' parameter 'minValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue});\n        }\n    };\n}\n\n\nexport function withMaxValue(maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@maxValue' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxValue});\n        }\n    };\n}\n\n\nexport function withGreaterThan(greaterThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof greaterThanValue !== 'number' && typeof greaterThanValue !== 'string') {\n            throw new Error(`Decorator '@greaterThan' parameter 'greaterThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, greaterThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, greaterThanValue});\n        }\n    };\n}\n\n\nexport function withLessThan(lessThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof lessThanValue !== 'number' && typeof lessThanValue !== 'string') {\n            throw new Error(`Decorator '@lessThan' parameter 'lessThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, lessThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, lessThanValue});\n        }\n    };\n}\n\n\nexport function withMinLength(minLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minLength !== 'number') {\n            throw new Error(`Decorator '@minLength' parameter 'minLength' should be number.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minLength});\n        }\n    };\n}\n\n\nexport function withMaxLength(maxLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxLength !== 'number') {\n            throw new Error(`Decorator '@maxLength' parameter 'maxLength' should be number.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxLength});\n        }\n    };\n}\n\n\nexport function withMatch(pattern: RegExp) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof pattern !== 'object') {\n            throw new Error(`Decorator '@match' parameter 'pattern' should be RegExp.`);\n        }\n        if ((ty as TypeAssertion)?.kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, pattern}});\n        } else {\n            if (!ty || ty.kind !== 'primitive' || ty.primitiveName !== 'string') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, pattern});\n        }\n    };\n}\n\n\nexport function withMsg<T extends TypeAssertion>(messages: string | ErrorMessages): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            if (typeof messages === 'string') {\n                const ret = ({\n                    ...ty,\n                    message: messages,\n                    optional: {...(ty as OptionalAssertion).optional, message: messages},\n                });\n                delete ret.messages;\n                delete ret.optional.messages;\n                return ret;\n            } else {\n                const ret = ({\n                    ...ty,\n                    messages,\n                    optional: {...(ty as OptionalAssertion).optional, messages},\n                });\n                delete ret.message;\n                delete ret.optional.message;\n                return ret;\n            }\n        } else {\n            if (typeof messages === 'string') {\n                const ret = ({...ty, message: messages});\n                delete ret.messages;\n                return ret;\n            } else {\n                const ret = ({...ty, messages});\n                delete ret.message;\n                return ret;\n            }\n        }\n    };\n}\n\n\nexport function withMsgId<T extends TypeAssertion>(messageId: string): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            return ({\n                ...ty,\n                messageId,\n                optional: {...(ty as OptionalAssertion).optional, messageId},\n            });\n        } else {\n            return ({...ty, messageId});\n        }\n    };\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { RecursivePartial,\n         TypeAssertion,\n         ValidationContext } from './types';\nimport { ValidationError }   from './lib/errors';\nimport { isUnsafeVarNames }  from './lib/util';\nimport { validate }          from './validator';\n\n\n\nfunction pickMapper(value: any, ty: TypeAssertion) {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const ret = Array.isArray(value) ? [] : {};\n\n            const dataMembers = new Set<string>();\n            if (! Array.isArray(value)) {\n                for (const m in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n\n            for (const x of ty.members) {\n                if (Object.hasOwnProperty.call(value, x[0])) {\n                    dataMembers.delete(x[0]);\n                    ret[x[0]] = value[x[0]];\n                }\n            }\n            if (ty.additionalProps && 0 < ty.additionalProps.length) {\n                function* getAdditionalMembers() {\n                    for (const m of dataMembers.values()) {\n                        yield m;\n                    }\n                    if (Array.isArray(value)) {\n                        for (let i = 0; i < value.length; i++) {\n                            yield String(i);\n                        }\n                    }\n                }\n                for (const m of getAdditionalMembers()) {\n                    ret[m] = value[m];\n                }\n            }\n            return ret;\n        }\n    default:\n        return value;\n    }\n}\n\n\nexport function pickRoot<T>(data: T, ty: TypeAssertion, ctx: ValidationContext): T {\n    switch (ty.kind) {\n    case 'never':\n        throw new ValidationError(`Type unmatched: ${(ty as any).kind}`, ty, ctx);\n    case 'any':\n        // FALL_THRU\n    case 'unknown':\n        // FALL_THRU\n    case 'primitive':\n        // FALL_THRU\n    case 'primitive-value':\n        // FALL_THRU\n    case 'repeated':\n        // FALL_THRU\n    case 'sequence':\n        // FALL_THRU\n    case 'one-of':\n        // FALL_THRU\n    case 'enum':\n        // FALL_THRU\n    case 'object':\n        {\n            const r = validate<T>(data, ty, ctx);\n            if (r) {\n                return r.value;\n            } else {\n                throw new ValidationError('Validation failed.', ty, ctx);\n            }\n        }\n    case 'spread': case 'optional': case 'symlink': case 'operator':\n        throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n    default:\n        throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n    }\n}\n\n\nexport function pick<T>(data: T, ty: TypeAssertion, ctx?: Partial<ValidationContext>): RecursivePartial<T> {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n        mapper: pickMapper,\n    };\n    try {\n        return pickRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nfunction merge(data: any, needle: any) {\n    if (data === null || data === void 0) {\n        return needle;\n    }\n    switch (typeof data) {\n    case 'object':\n        if (Array.isArray(data)) {\n            return [...needle];\n        } else {\n            const r: any = {...data};\n            for (const k in needle) {\n                if (Object.prototype.hasOwnProperty.call(needle, k)) {\n                    if (isUnsafeVarNames(r, k)) {\n                        continue;\n                    }\n                    r[k] = merge(r[k], needle[k]);\n                }\n            }\n            return r;\n        }\n    default:\n        return needle;\n    }\n}\n\n\nexport function patch<T>(data: T, needle: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): T {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    const validated = pick<T>(needle, ty, ctx2);\n    return merge(data, validated);\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ObjectAssertion,\n         SerializedSchemaInfo,\n         TypeAssertionSetValue,\n         TypeAssertionMap } from './types';\nimport { resolveSchema }    from './lib/resolver';\n\n\n\nexport const TynderSchemaVersion = 'tynder/1.0';\n\n\nfunction serializeInner(ty: TypeAssertion, nestLevel: number): TypeAssertion {\n    if (0 < nestLevel && ty.typeName) {\n        return ({\n            kind: 'symlink',\n            symlinkTargetName: ty.typeName,\n            // TODO: preserve informations (doc comments, name, typeName, ...)\n        });\n    }\n\n    const ret: TypeAssertion = {...ty};\n    switch (ret.kind) {\n    case 'never': case 'any': case 'unknown': case 'symlink': case 'operator':\n        break;\n    case 'primitive-value':\n        if (typeof ret.value === 'bigint') {\n            ret.value = String(ret.value);\n            ret.primitiveName = 'bigint';\n        }\n        break;\n    case 'primitive':\n        if (ret.pattern) {\n            ret.pattern = `/${ret.pattern.source}/${ret.pattern.flags}` as any;\n        }\n        break;\n    case 'repeated':\n        ret.repeated = serializeInner(ret.repeated, nestLevel + 1);\n        break;\n    case 'spread':\n        ret.spread = serializeInner(ret.spread, nestLevel + 1);\n        break;\n    case 'sequence':\n        ret.sequence = ret.sequence.map(x => serializeInner(x, nestLevel + 1));\n        break;\n    case 'one-of':\n        ret.oneOf = ret.oneOf.map(x => serializeInner(x, nestLevel + 1));\n        break;\n    case 'optional':\n        ret.optional = serializeInner(ret.optional, nestLevel + 1);\n        break;\n    case 'enum':\n        ret.values = ret.values.slice().map(x => x[2] === null || x[2] === void 0 ? x.slice(0, 2) : x) as any;\n        break;\n    case 'object':\n        ret.members = ret.members.map(x => [x[0], serializeInner(x[1], nestLevel + 1), ...x.slice(2)]) as any;\n        if (ret.baseTypes) {\n            // NOTE: convert 'baseTypes' to 'symlink'.\n            ret.baseTypes = ret.baseTypes.map(x => serializeInner(x, nestLevel + 1)) as ObjectAssertion[];\n        }\n        break;\n    default:\n        throw new Error(`Unknown type assertion: ${(ret as any).kind}`);\n    }\n\n    delete ret.passThruCodeBlock;\n    return ret;\n}\n\n\nexport function serializeToObject(schema: TypeAssertionMap): SerializedSchemaInfo {\n    const ret: SerializedSchemaInfo = {\n        version: TynderSchemaVersion,\n        ns: {},\n    };\n    const current = {};\n\n    for (const ty of schema.entries()) {\n        current[ty[0]] = serializeInner(ty[1].ty, 0);\n    }\n\n    ret.ns['.'] = current;\n\n    return ret;\n}\n\n\nexport function serialize(schema: TypeAssertionMap, asTs?: boolean): string {\n    const ret = serializeToObject(schema);\n\n    if (asTs) {\n        return (\n            `\\n// tslint:disable: object-literal-key-quotes\\n` +\n            `const schema = ${JSON.stringify(ret, null, 2)};\\nexport default schema;` +\n            `\\n// tslint:enable: object-literal-key-quotes\\n`\n        );\n    } else {\n        return JSON.stringify(ret, null, 2);\n    }\n}\n\n\nfunction deserializeInner(ty: TypeAssertion) {\n    const ret: TypeAssertion = {...ty};\n    switch (ret.kind) {\n    case 'never': case 'any': case 'unknown':\n    case 'enum': case 'symlink': case 'operator':\n        // NOTE: 'symlink' and 'operator' will resolved by calling 'resolveSymbols()' in 'deserialize()'.\n        break;\n    case 'primitive-value':\n        if (ret.primitiveName === 'bigint') {\n            delete ret.primitiveName;\n            ret.value = BigInt(ret.value);\n        }\n        break;\n    case 'primitive':\n        if (ret.pattern) {\n            const m = (/^\\/(.*)\\/([gimsuy]*)$/s).exec(ret.pattern as any);\n            if (m) {\n                ret.pattern = new RegExp(m[1], m[2]);\n            } else {\n                throw new Error(`Unknown pattern match assertion: ${ret.pattern as any}`);\n            }\n        }\n        break;\n    case 'repeated':\n        ret.repeated = deserializeInner(ret.repeated);\n        break;\n    case 'spread':\n        ret.spread = deserializeInner(ret.spread);\n        break;\n    case 'sequence':\n        ret.sequence = ret.sequence.map(x => deserializeInner(x));\n        break;\n    case 'one-of':\n        ret.oneOf = ret.oneOf.map(x => deserializeInner(x));\n        break;\n    case 'optional':\n        ret.optional = deserializeInner(ret.optional);\n        break;\n    case 'object':\n        ret.members = ret.members.map(x => [x[0], deserializeInner(x[1]), x.slice(2)]) as any;\n        // NOTE: keep 'baseTypes' as 'symlink'.\n        break;\n    default:\n        throw new Error(`Unknown type assertion: ${(ret as any).kind}`);\n    }\n    return ret;\n}\n\n\nexport function deserializeFromObject(obj: any) {\n    if (obj.version !== TynderSchemaVersion) {\n        throw new Error(`Unknown schema version: ${obj.version}`);\n    }\n\n    const schema: TypeAssertionMap = new Map<string, TypeAssertionSetValue>();\n    const current = obj.ns['.'];\n\n    for (const k in current) {\n        if (! Object.prototype.hasOwnProperty.call(current, k)) {\n            continue;\n        }\n        schema.set(k, {\n            ty: deserializeInner(current[k]),\n            exported: false,\n            resolved: false,\n        });\n    }\n\n    return resolveSchema(schema);\n}\n\n\nexport function deserialize(text: string) {\n    const parsed = JSON.parse(text);\n    return deserializeFromObject(parsed);\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PrimitiveTypeAssertionConstraints,\n         RepeatedAssertionConstraints,\n         ErrorMessages,\n         TypeAssertion } from './types/tynder-schema-types';\n\nexport * from './types/tynder-schema-types';\n\n\n\n// https://stackoverflow.com/questions/41980195/recursive-partialt-in-typescript\nexport type RecursivePartial<T> = {\n    [P in keyof T]?:\n      T[P] extends (infer U)[] ? RecursivePartial<U>[] :\n      T[P] extends object ? RecursivePartial<T[P]> :\n      T[P];\n};\n\n\nexport type TypeAssertionErrorMessageConstraints =\n    Partial<Omit<PrimitiveTypeAssertionConstraints &\n        RepeatedAssertionConstraints, 'pattern'> &\n        {pattern: string}>;\n\n\nexport interface TypeAssertionErrorMessage {\n    code: string;\n    message: string;\n    dataPath: string;\n    constraints: TypeAssertionErrorMessageConstraints;\n    value?: any; // Only number, bigint, string, boolean, undefined, null\n}\n\n\nexport interface ValidationContext {\n    checkAll?: boolean;\n    noAdditionalProps?: boolean;\n    errorMessages?: ErrorMessages;\n\n    // maxDepth: number;\n    // depth: number;\n    mapper?: (value: any, ty: TypeAssertion) => any;\n\n    // === returned values ===\n    errors: TypeAssertionErrorMessage[];\n\n    // === internal use ===\n    typeStack: Array<                 // For error reporting (keyword substitutions)\n        TypeAssertion |\n        [TypeAssertion,\n         number | string | undefined] // [1]: data index\n        >;\n                                      // NOTE: DO NOT reassign!\n                                      //   Push or pop items instead of reassign.\n    schema?: TypeAssertionMap;        //   To resolve 'symlink' assertion,\n                                      //   the context need to have a schema instance.\n}\n\n\nexport interface TypeAssertionSetValue {\n    ty: TypeAssertion;\n    exported: boolean;\n    resolved: boolean;\n}\n\n\nexport type TypeAssertionMap = Map<string, TypeAssertionSetValue>;\n\n\nexport interface SymbolResolverOperators {\n    [propName: string]: (...args: Array<TypeAssertion | string>) => TypeAssertion;\n}\n\nexport interface SymbolResolverContext {\n    nestLevel: number;\n    symlinkStack: string[]; // For detecting recursive type\n    operators?: SymbolResolverOperators; // TODO: Add it to resolve backref in type operator's operands\n}\n\n\nexport interface CodegenContext {\n    nestLevel: number;\n    schema?: TypeAssertionMap; // To resolve 'symlink' assertion, the context need to have a schema instance.\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport type PrimitiveValueTypes = number | bigint | string | boolean | null | undefined;                                            // TODO: Function\nexport type PrimitiveValueTypeNames = 'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'null' | 'undefined';                // TODO: Function, DateStr, DateTimeStr\nexport type OptionalPrimitiveValueTypeNames = 'number?' | 'integer?' | 'bigint?' | 'string?' | 'boolean?' | 'null?' | 'undefined?'; // TODO: Function?, DateStr?, DateTimeStr?\nexport type PlaceholderTypeNames = 'never' | 'any' | 'unknown';\nexport type OptionalPlaceholderTypeNames = 'never?' | 'any?' | 'unknown?';\n\n\n\nexport enum ErrorTypes {\n    InvalidDefinition = 1,\n    Required,                // (all)\n    TypeUnmatched,           // Never/Unknown/Primitive/Object\n    AdditionalPropUnmatched, // Additional prop\n    RepeatQtyUnmatched,      // Repeated/Spread\n    SequenceUnmatched,       // Sequence\n    ValueRangeUnmatched,     // Primitive: minValue, maxValue, greaterThanValue, lessThanValue\n    ValuePatternUnmatched,   // Primitive: pattern\n    ValueLengthUnmatched,    // Primitive: minLength, maxLength\n    ValueUnmatched,          // PrimitiveValue\n}\n\n\nexport type ErrorMessages = Partial<{\n    invalidDefinition: string,\n    required: string,\n    typeUnmatched: string,\n    additionalPropUnmatched: string,\n    repeatQtyUnmatched: string,\n    sequenceUnmatched: string,\n    valueRangeUnmatched: string,\n    valuePatternUnmatched: string,\n    valueLengthUnmatched: string,\n    valueUnmatched: string,\n}>;\n\n\nexport interface TypeAssertionBase {\n    messageId?: string;\n    message?: string;           // Only one of 'message' or 'messages' can be set.\n    messages?: ErrorMessages;   // Only one of 'message' or 'messages' can be set.\n    name?: string;              // Member name or 'typeName' below. For error reporting and codegen.\n    typeName?: string;          // Named user defined 'type' or 'interface' name. For error reporting and codegen.\n    originalTypeName?: string;  // To keep right hand side type name of `type Y = X;`.\n    docComment?: string;        // Doc comment.\n    passThruCodeBlock?: string; // Store a pass-thru code block (e.g. import statement). use it with kind===never\n    noOutput?: boolean;         // If true, skip code generation.\n}\n\n\nexport interface NeverTypeAssertion extends TypeAssertionBase {\n    kind: 'never';\n}\n\n\nexport interface AnyTypeAssertion extends TypeAssertionBase {\n    kind: 'any';\n}\n\n\nexport interface UnknownTypeAssertion extends TypeAssertionBase {\n    kind: 'unknown';\n}\n\n\nexport interface PrimitiveTypeAssertionConstraints {\n    minValue?: number | string | null; // TODO: bigint\n    maxValue?: number | string | null; // TODO: bigint\n    greaterThanValue?: number | string | null;\n    lessThanValue?: number | string | null;\n    minLength?: number | null;\n    maxLength?: number | null;\n    pattern?: RegExp | null;\n}\n\n\nexport interface PrimitiveTypeAssertion extends TypeAssertionBase, PrimitiveTypeAssertionConstraints {\n    kind: 'primitive';\n    primitiveName: PrimitiveValueTypeNames;\n}\n\n\nexport interface PrimitiveValueTypeAssertion extends TypeAssertionBase {\n    kind: 'primitive-value';\n    value: PrimitiveValueTypes;\n    primitiveName?: 'bigint'; // for deserializer hinting\n}\n\n\nexport interface RepeatedAssertionConstraints {\n    min: number | null;\n    max: number | null;\n}\n\n\nexport interface RepeatedAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'repeated';\n    repeated: TypeAssertion;\n}\n\n\nexport interface SpreadAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'spread';\n    spread: TypeAssertion;\n}\n\n\nexport interface SequenceAssertion extends TypeAssertionBase {\n    kind: 'sequence';\n    sequence: TypeAssertion[];\n}\n\n\nexport interface OneOfAssertion extends TypeAssertionBase {\n    kind: 'one-of';\n    oneOf: TypeAssertion[];\n}\n\n\nexport interface OptionalAssertion extends TypeAssertionBase {\n    kind: 'optional';\n    optional: TypeAssertion;\n}\n\n\nexport interface EnumAssertion extends TypeAssertionBase {\n    kind: 'enum';\n    values: Array<[\n        string,           // enum key\n        number | string,  // enum value\n        string?,          // doc comment\n    ]>;\n}\n\n\nexport type ObjectAssertionMember = [\n    string,         // name\n    TypeAssertion,  // type\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n    string,         // doc comment\n];\n\n\n\nexport type AdditionalPropsKey = Array<'string' | 'number' | RegExp>;\n\n\nexport type AdditionalPropsMember = [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n    string,              // doc comment\n];\n\n\nexport interface ObjectAssertion extends TypeAssertionBase {\n    kind: 'object';\n    members: ObjectAssertionMember[];\n    additionalProps?: AdditionalPropsMember[];\n    baseTypes?: Array<ObjectAssertion | AssertionSymlink>;\n}\n\n\nexport interface AssertionSymlink extends TypeAssertionBase {\n    kind: 'symlink';\n    symlinkTargetName: string;\n}\n\n\n// TODO: Add it to resolve backref in type operator's operands\nexport interface AssertionOperator extends TypeAssertionBase {\n    kind: 'operator';\n    operator: string;\n    operands: Array<TypeAssertion | string>;\n}\n\n\nexport type TypeAssertion =\n    NeverTypeAssertion |\n    AnyTypeAssertion |\n    UnknownTypeAssertion |\n    PrimitiveTypeAssertion |\n    PrimitiveValueTypeAssertion |\n    RepeatedAssertion |\n    SpreadAssertion |\n    SequenceAssertion |\n    OneOfAssertion |\n    OptionalAssertion |\n    EnumAssertion |\n    ObjectAssertion |\n    AssertionSymlink |\n    AssertionOperator;\n\n\nexport interface SerializedSchemaInfo {\n    version: string;\n    ns: {\n        [namespaceName: string]: {\n            [typeName: string]: TypeAssertion;\n        }\n    };\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SequenceAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertion,\n         ValidationContext,\n         TypeAssertionMap }    from './types';\nimport { ValidationError }     from './lib/errors';\nimport { isUnsafeVarNames }    from './lib/util';\nimport { reportError,\n         reportErrorWithPush } from './lib/reporter';\nimport { resolveSymbols }      from './lib/resolver';\n\n\n\nfunction validateNeverTypeAssertion<T>(\n    data: any, ty: NeverTypeAssertion, ctx: ValidationContext): null {\n\n    reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateAnyTypeAssertion<T>(\n    data: any, ty: AnyTypeAssertion, ctx: ValidationContext): {value: T} {\n\n    // always matched\n    return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n}\n\n\nfunction validateUnknownTypeAssertion<T>(\n    data: any, ty: UnknownTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    // always matched\n    return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n}\n\n\nfunction validatePrimitiveTypeAssertion<T>(\n    data: any, ty: PrimitiveTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (ty.primitiveName === 'null') {\n        if (data !== null) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (ty.primitiveName === 'integer') {\n        if (typeof data !== 'number') {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n        if (Math.trunc(data) !== data) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (typeof data !== ty.primitiveName) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    // TODO: Function, DateStr, DateTimeStr\n\n    let err = false;\n    let valueRangeErr = false;\n    switch (typeof ty.minValue) {\n    case 'number': case 'string':\n        if (data < ty.minValue) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxValue) {\n    case 'number': case 'string':\n        if (data > ty.maxValue) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.greaterThanValue) {\n    case 'number': case 'string':\n        if (data <= ty.greaterThanValue) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.lessThanValue) {\n    case 'number': case 'string':\n        if (data >= ty.lessThanValue) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n\n    let valueLengthErr = false;\n    switch (typeof ty.minLength) {\n    case 'number':\n        if (typeof data !== 'string' || data.length < ty.minLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxLength) {\n    case 'number':\n        if (typeof data !== 'string' || data.length > ty.maxLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n\n    if (ty.pattern) {\n        if (! ty.pattern.test(data)) {\n            reportError(ErrorTypes.ValuePatternUnmatched, data, ty, {ctx});\n            err = true;\n        }\n    }\n    const ret = !err ?\n        {value: ctx.mapper ? ctx.mapper(data, ty) : data} :\n        null;\n    return ret;\n}\n\n\nfunction validatePrimitiveValueTypeAssertion<T>(\n    data: any, ty: PrimitiveValueTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const ret = data === ty.value ?\n        {value: ctx.mapper ? ctx.mapper(data, ty) : data} :\n        null;\n    if (! ret) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    }\n    return ret;\n}\n\n\nfunction validateRepeatedAssertion<T>(\n    data: any, ty: RepeatedAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.min === 'number' && data.length < ty.min) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.max === 'number' && data.length > ty.max) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    const retVals: any[] = [];\n    for (let i = 0; i < data.length; i++) {\n        const x = data[i];\n        const r = validateRoot<T>(x, ty.repeated, ctx, i);\n        if (! r) {\n            return null;\n        }\n        retVals.push(r.value);\n    }\n    return {value: retVals as any};\n}\n\n\nfunction validateSequenceAssertion<T>(\n    data: any, ty: SequenceAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    let dIdx = 0, // index of data\n        sIdx = 0; // index of types\n    let spreadLen = 0;\n    let optionalOmitted = false;\n\n    const checkSpreadQuantity = (ts: SpreadAssertion, index: number) => {\n        if (typeof ts.min === 'number' && spreadLen < ts.min) {\n            reportErrorWithPush(\n                spreadLen === 0 ?\n                    ErrorTypes.TypeUnmatched :\n                    ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        if (typeof ts.max === 'number' && spreadLen > ts.max) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const checkOptionalQuantity = (ts: OptionalAssertion, index: number) => {\n        if (spreadLen === 0) {\n            // All subsequent 'optional' assertions should be 'spreadLen === 0'.\n            optionalOmitted = true;\n        } else if (optionalOmitted) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        } else if (spreadLen > 1) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const retVals: any[] = [];\n    while (dIdx < data.length && sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.spread, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkSpreadQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else if (ts.kind === 'optional') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.optional, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkOptionalQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else {\n            const r = validateRoot<T>(data[dIdx], ts, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                sIdx++;\n            } else {\n                return null;\n            }\n        }\n    }\n    while (sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            if (! checkSpreadQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else if (ts.kind === 'optional') {\n            if (! checkOptionalQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, dIdx], {ctx});\n            return null;\n        }\n    }\n\n    const ret = data.length === dIdx ? {value: retVals as any} : null;\n    if (! ret) {\n        reportError(ErrorTypes.SequenceUnmatched, data, ty, {ctx});\n    }\n    return ret;\n}\n\n\nfunction validateOneOfAssertion<T>(\n    data: any, ty: OneOfAssertion, ctx: ValidationContext): {value: T} | null {\n\n    for (const tyOne of ty.oneOf) {\n        const savedErrLen = ctx.errors.length;\n        const r = validateRoot<T>(data, tyOne, ctx);\n        if (! r) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n            continue;\n        }\n        return r;\n    }\n    reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateEnumAssertion<T>(\n    data: any, ty: EnumAssertion, ctx: ValidationContext): {value: T} | null {\n\n    for (const v of ty.values) {\n        if (data === v[1]) {\n            return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n        }\n    }\n    reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nconst NumberPattern = /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)$/;\n\n\nfunction validateObjectAssertion<T>(\n    data: any, ty: ObjectAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let retVal = Array.isArray(data) ? [...data] : {...data};\n    const revMembers = ty.members.slice().reverse();\n    for (const x of ty.members) {\n        if (ty.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(\n                `Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`, ty, ctx);\n        }\n    }\n\n    if (data === null || typeof data !== 'object') {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        if (ctx && ctx.checkAll) {\n            retVal = null;\n        } else {\n            return null;\n        }\n    } else {\n        const dataMembers = new Set<string>();\n        if (ctx.noAdditionalProps || ty.additionalProps && 0 < ty.additionalProps.length) {\n            if (! Array.isArray(data)) {\n                for (const m in data) {\n                    if (Object.prototype.hasOwnProperty.call(data, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n        }\n        if (ctx.noAdditionalProps && Array.isArray(data) && 0 < data.length) {\n            const aps = ty.additionalProps || [];\n            if (aps.filter(x => x[0].includes('number')).length === 0) {\n                reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                    ctx,\n                    substitutions: [['addtionalProps', '[number]']],\n                });\n                if (ctx && ctx.checkAll) {\n                    retVal = null;\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        for (const x of ty.members) {\n            dataMembers.delete(x[0]);\n            if (Object.prototype.hasOwnProperty.call(data, x[0])) {\n                const ret = validateRoot<T>(\n                    data[x[0]],\n                    x[1].kind === 'optional' ?  // TODO: set name at compile time\n                        {\n                            ...x[1].optional,\n                            name: x[0],\n                            message: x[1].message,\n                            messages: x[1].messages,\n                            messageId: x[1].messageId,\n                        } : x[1],\n                    ctx);\n\n                if (ret) {\n                    if (retVal) {\n                        if (isUnsafeVarNames(retVal, x[0])) {\n                            continue;\n                        }\n                        retVal[x[0]] = ret.value;\n                    }\n                } else {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                if (x[1].kind !== 'optional') {\n                    reportErrorWithPush(ErrorTypes.Required, data, [x[1], void 0], {ctx});\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ty.additionalProps && 0 < ty.additionalProps.length) {\n            function* getAdditionalMembers() {\n                for (const m of dataMembers.values()) {\n                    yield m;\n                }\n                if (Array.isArray(data)) {\n                    for (let i = 0; i < data.length; i++) {\n                        yield String(i);\n                    }\n                }\n            }\n            for (const m of getAdditionalMembers()) {\n                let allowImplicit = false;\n                const matchedAssertions: TypeAssertion[] = [];\n\n                for (const ap of ty.additionalProps) {\n                    for (const pt of ap[0]) {\n                        const at = ap[1];\n                        if (pt === 'number') {\n                            if (NumberPattern.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        } else if (pt === 'string') {\n                            matchedAssertions.push(at);\n                        } else {\n                            if (pt.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        }\n                        if (at.kind === 'optional') {\n                            allowImplicit = true;\n                        }\n                    }\n                }\n                if (matchedAssertions.length === 0) {\n                    if (allowImplicit) {\n                        continue;\n                    }\n                    reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                        ctx,\n                        substitutions: [['addtionalProps', m]],\n                    });\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                        continue;\n                    } else {\n                        return null;\n                    }\n                }\n\n                dataMembers.delete(m);\n                let hasError = false;\n                const savedErrLen = ctx.errors.length;\n\n                for (const at of matchedAssertions) {\n                    const ret = validateRoot<T>(data[m], at.kind === 'optional' ?\n                        {\n                            ...at.optional,\n                            message: at.message,\n                            messages: at.messages,\n                            messageId: at.messageId,\n                            name: m,\n                        } : {\n                            ...at,\n                            name: m,\n                        }, ctx);\n                    if (ret) {\n                        if (retVal) {\n                            hasError = false;\n                            ctx.errors.length = savedErrLen;\n                            if (isUnsafeVarNames(retVal, m)) {\n                                continue;\n                            }\n                            retVal[m] = ret.value;\n                        }\n                        break;\n                    } else {\n                        hasError = true;\n                    }\n                }\n                if (hasError) {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ctx.noAdditionalProps && 0 < dataMembers.size) {\n            reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                ctx,\n                substitutions: [['addtionalProps', Array.from(dataMembers.values()).join(', ')]],\n            });\n            if (ctx && ctx.checkAll) {\n                retVal = null;\n            } else {\n                return null;\n            }\n        }\n    }\n    if (! retVal) {\n        // TODO: Child is unmatched. reportError?\n        // TODO: report object's custom error message\n    }\n    return retVal ? {value: (ctx && ctx.mapper) ? ctx.mapper(retVal, ty) : retVal} : null;\n}\n\n\nexport function validateRoot<T>(\n    data: any, ty: TypeAssertion, ctx: ValidationContext, dataIndex?: number | string): {value: T} | null {\n\n    try {\n        ctx.typeStack.push(\n            typeof dataIndex === 'number' || typeof dataIndex === 'string' ?\n            [ty, dataIndex] : ty);\n\n        switch (ty.kind) {\n        case 'never':\n            return validateNeverTypeAssertion(data, ty, ctx);\n        case 'any':\n            return validateAnyTypeAssertion(data, ty, ctx);\n        case 'unknown':\n            return validateUnknownTypeAssertion(data, ty, ctx);\n        case 'primitive':\n            return validatePrimitiveTypeAssertion(data, ty, ctx);\n        case 'primitive-value':\n            return validatePrimitiveValueTypeAssertion(data, ty, ctx);\n        case 'repeated':\n            return validateRepeatedAssertion(data, ty, ctx);\n        case 'sequence':\n            return validateSequenceAssertion(data, ty, ctx);\n        case 'one-of':\n            return validateOneOfAssertion(data, ty, ctx);\n        case 'enum':\n            return validateEnumAssertion(data, ty, ctx);\n        case 'object':\n            return validateObjectAssertion(data, ty, ctx);\n        case 'symlink':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved symbol '${ty.symlinkTargetName}' is appeared.`, ty, ctx);\n        case 'operator':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved type operator is found: ${ty.operator}`, ty, ctx);\n        case 'spread': case 'optional':\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n        default:\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n        }\n    } finally {\n        ctx.typeStack.pop();\n    }\n}\n\n\nexport function validate<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): {value: T} | null {\n\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    try {\n        return validateRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nexport function getType(schema: TypeAssertionMap, name: string): TypeAssertion {\n    if (schema.has(name)) {\n        return schema.get(name)?.ty as TypeAssertion;\n    }\n    throw new Error(`Undefined type name is referred: ${name}`);\n}\n"],"sourceRoot":""}