{"version":3,"sources":["webpack://tynder/webpack/universalModuleDefinition","webpack://tynder/webpack/bootstrap","webpack://tynder/./src/constraints/unique.ts","webpack://tynder/./src/index-rt.ts","webpack://tynder/./src/lib/errors.ts","webpack://tynder/./src/lib/escape.ts","webpack://tynder/./src/lib/reporter.ts","webpack://tynder/./src/lib/resolver.ts","webpack://tynder/./src/lib/util.ts","webpack://tynder/./src/operators.ts","webpack://tynder/./src/picker.ts","webpack://tynder/./src/stereotypes/date.ts","webpack://tynder/./src/stereotypes/noop.ts","webpack://tynder/./src/types.ts","webpack://tynder/./src/types/tynder-schema-types.ts","webpack://tynder/./src/validator.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;QCVA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAMA,MAAM,YAAY,GAAG,gEAArB;;AAGA,MAAM,YAAY,GAAa,CAAC,IAAD,EAAY,MAAZ,KAAgC;AAC3D,QAAM,GAAG,GAAU,EAAnB;;AACA,MAAI,IAAI,MAAM,CAAC,MAAf,EAAuB;AACnB,SAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AACxB,UAAI,kEAAgB,CAAC,2DAAD,EAAoB,KAApB,CAApB,EAAgD;AAC5C,cAAM,IAAI,KAAJ,CAAU,GAAG,YAAY,IAAI,KAAK,EAAlC,CAAN;AACH;;AACD,SAAG,CAAC,IAAJ,CAAS,IAAI,CAAC,KAAD,CAAb;AACH;AACJ,GAPD,MAOO;AACH,OAAG,CAAC,IAAJ,CAAS,IAAT;AACH;;AACD,SAAO,GAAP;AACH,CAbD;;AAgBA,MAAM,aAAa,GAAa,CAAC,IAAD,EAAY,MAAZ,KAAgC;;;AAC5D,QAAM,GAAG,GAAU,EAAnB;;AACA,MAAI,IAAI,MAAM,CAAC,MAAf,EAAuB;AACnB,SAAK,MAAM,KAAX,IAAoB,MAApB,EAA4B;AACxB,UAAI,kEAAgB,CAAC,2DAAD,EAAoB,KAApB,CAApB,EAAgD;AAC5C,cAAM,IAAI,KAAJ,CAAU,GAAG,YAAY,IAAI,KAAK,EAAlC,CAAN;AACH;;AACD,SAAG,CAAC,IAAJ,CAAQ,MAAC,IAAI,CAAC,KAAD,CAAL,MAAY,IAAZ,IAAY,aAAZ,GAAY,EAAZ,GAAgB,GAAxB;AACH;AACJ,GAPD,MAOO;AACH,OAAG,CAAC,IAAJ,CAAS,IAAT;AACH;;AACD,SAAO,GAAP;AACH,CAbD;;AAgBA,MAAM,UAAU,GAAI,MAAD,IAAqB;AACpC,SAAQ,CAAC,IAAD,EAAY,IAAZ,KAAyB;AAC7B,UAAM,MAAM,GAAG,sCAAsC,IAAI,EAAzD;;AACA,QAAI,CAAE,KAAK,CAAC,OAAN,CAAc,IAAd,CAAN,EAA2B;AACvB,YAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;;AAED,UAAM,MAAM,GAAa,EAAzB;;AACA,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,YAAM,CAAC,IAAP,CAAY,IAAZ;AACH,KAFD,MAEO,IAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AAC5B,WAAK,MAAM,CAAX,IAAgB,IAAhB,EAAsB;AAClB,YAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACvB,gBAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;AACJ;;AACD,YAAM,CAAC,IAAP,CAAY,GAAG,IAAf;AACH;;AAED,UAAM,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,CAAC,IAAI,MAAM,CAAC,CAAD,EAAI,MAAJ,CAApB,CAAf;;AACA,SAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACpC,SAAG,EAAE,KAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAAM,CAAC,MAA3B,EAAmC,CAAC,EAApC,EAAwC;AACzC,YAAI,CAAC,KAAK,CAAV,EAAa;AACT;AACH;;AACD,cAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB;AACA,cAAM,CAAC,GAAG,MAAM,CAAC,CAAD,CAAhB;;AACA,aAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,CAAC,CAAC,MAAtB,EAA8B,CAAC,EAA/B,EAAmC;AAAE;AACjC,cAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAd,EAAmB;AACf,qBAAS,GAAT;AACH;AACJ;;AACD,eAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GApCD;AAqCH,CAtCD;;AAyCO,MAAM,WAAW,GAA0C,CAC9D,CAAC,QAAD,EAAW;AACP,OAAK,EAAE,CAAC,UAAD,EAAa,UAAb,CADA;AAEP,OAAK,EAAE,UAAU,CAAC,YAAD;AAFV,CAAX,CAD8D,EAK9D,CAAC,iBAAD,EAAoB;AAChB,OAAK,EAAE,CAAC,UAAD,EAAa,UAAb,CADS;AAEhB,OAAK,EAAE,UAAU,CAAC,aAAD;AAFD,CAApB,CAL8D,CAA3D,C;;;;;;;;;;;;ACxFP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEO,MAAM,WAAW,GAAgC,CACpD,GAAG,6DADiD,CAAjD;AAIA,MAAM,iBAAiB,GAA0C,CACpE,GAAG,+DADiE,CAAjE,C;;;;;;;;;;;;ACnBP;AAAA;AAAA;AACA;AACA;AAQM,MAAO,eAAP,SAA+B,KAA/B,CAAoC;AAGtC,cAAmB,OAAnB,EAAoC,EAApC,EAAwD,GAAxD,EAAwF;AACpF,UAAM,OAAN;AACA,SAAK,EAAL,GAAU,EAAV;AACA,SAAK,GAAL,GAAW,GAAX;AACH;;AAPqC,C;;;;;;;;;;;;ACV1C;AAAA;AAAA;AACA;AACA;AAGM,SAAU,YAAV,CAAuB,CAAvB,EAAgC;AAClC,SAAQ,CAAC,CACJ,OADG,CACK,OADL,EACc,KADd,EAEH,OAFG,CAEK,KAFL,EAEY,KAFZ,EAGH,OAHG,CAGK,KAHL,EAGY,KAHZ,EAIH,OAJG,CAIK,KAJL,EAIY,KAJZ,EAKH,OALG,CAKK,KALL,EAKY,KALZ,EAMH,OANG,CAMK,KANL,EAMY,KANZ,EAOH,OAPG,CAOK,KAPL,EAOY,MAPZ,EAQH,OARG,CAQK,KARL,EAQY,MARZ,EASH,OATG,CASK,KATL,EASY,MATZ,EAUH,OAVG,CAUK,KAVL,EAUY,MAVZ,CAAR;AAYH,C;;;;;;;;;;;;AClBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAQA;AACA;AAGO,MAAM,cAAc,GAAG,CAC1B,EAD0B,EAE1B,mBAF0B,EAG1B,UAH0B,EAI1B,eAJ0B,EAK1B,yBAL0B,EAM1B,oBAN0B,EAO1B,mBAP0B,EAQ1B,qBAR0B,EAS1B,uBAT0B,EAU1B,sBAV0B,EAW1B,gBAX0B,CAAvB;AAeA,MAAM,eAAe,GAAkB;AAC1C,mBAAiB,EAAQ,0DADiB;AAE1C,UAAQ,EAAiB,2CAFiB;AAG1C,eAAa,EAAY,gEAHiB;AAI1C,yBAAuB,EAAE,yFAJiB;AAK1C,oBAAkB,EAAO,gEALiB;AAM1C,mBAAiB,EAAQ,sDANiB;AAO1C,qBAAmB,EAAM,uFAPiB;AAQ1C,uBAAqB,EAAI,8EARiB;AAS1C,sBAAoB,EAAK,0FATiB;AAU1C,gBAAc,EAAW;AAViB,CAAvC;;AAuBP,SAAS,eAAT,CAAyB,OAAzB,EAA8C,GAAG,QAAjD,EAA0E;AACtE,OAAK,MAAM,CAAX,IAAgB,QAAhB,EAA0B;AACtB,YAAQ,OAAR;AACA,WAAK,iDAAU,CAAC,iBAAhB;AACI,YAAI,CAAC,CAAC,iBAAN,EAAyB;AACrB,iBAAO,CAAC,CAAC,iBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,QAAhB;AACI,YAAI,CAAC,CAAC,QAAN,EAAgB;AACZ,iBAAO,CAAC,CAAC,QAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,aAAhB;AACI,YAAI,CAAC,CAAC,aAAN,EAAqB;AACjB,iBAAO,CAAC,CAAC,aAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,uBAAhB;AACI,YAAI,CAAC,CAAC,uBAAN,EAA+B;AAC3B,iBAAO,CAAC,CAAC,uBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,kBAAhB;AACI,YAAI,CAAC,CAAC,kBAAN,EAA0B;AACtB,iBAAO,CAAC,CAAC,kBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,iBAAhB;AACI,YAAI,CAAC,CAAC,iBAAN,EAAyB;AACrB,iBAAO,CAAC,CAAC,iBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,mBAAhB;AACI,YAAI,CAAC,CAAC,mBAAN,EAA2B;AACvB,iBAAO,CAAC,CAAC,mBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,qBAAhB;AACI,YAAI,CAAC,CAAC,qBAAN,EAA6B;AACzB,iBAAO,CAAC,CAAC,qBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,oBAAhB;AACI,YAAI,CAAC,CAAC,oBAAN,EAA4B;AACxB,iBAAO,CAAC,CAAC,oBAAT;AACH;;AACD;;AACJ,WAAK,iDAAU,CAAC,cAAhB;AACI,YAAI,CAAC,CAAC,cAAN,EAAsB;AAClB,iBAAO,CAAC,CAAC,cAAT;AACH;;AACD;AAlDJ;AAoDH;;AACD,SAAO,EAAP;AACH;;AAGD,SAAS,0BAAT,CAAoC,GAApC,EAA0D;AACtD,QAAM,GAAG,GAAG,GAAG,CAAC,SAAJ,CACP,KADO,GAEP,OAFO,GAGP,GAHO,CAGH,CAAC,IAAI,KAAK,CAAC,OAAN,CAAc,CAAd,IAAmB,CAAC,CAAC,CAAD,CAApB,GAA0B,CAH5B,EAIP,IAJO,CAIF,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,UAAX,IAAyB,CAAC,CAAC,IAAF,KAAW,QAApC,IAAgD,CAAC,CAAC,IAAF,KAAW,UAJ9D,KAKgE,IAL5E;AAMA,SAAO,GAAP;AACH;;AAGD,SAAS,eAAT,CAAyB,EAAzB,EAA0C;AACtC,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,UAAL;AACI,aAAO,aAAa,eAAe,CAAC,EAAE,CAAC,QAAJ,CAAa,GAAhD;;AACJ,SAAK,QAAL;AACI,aAAO,eAAe,CAAC,EAAE,CAAC,MAAJ,CAAtB;;AACJ,SAAK,UAAL;AACI,aAAO,YAAP;;AACJ,SAAK,WAAL;AACI,aAAO,EAAE,CAAC,aAAV;;AACJ,SAAK,iBAAL;AACI,aAAO,UACH,OAAO,EAAE,CAAC,KAAV,KAAoB,QAApB,GACI,IAAI,MAAM,CAAC,EAAE,CAAC,KAAJ,CAAU,GADxB,GAEI,MAAM,CAAC,EAAE,CAAC,KAAJ,CAAU,GAHxB;;AAIJ,SAAK,UAAL;AACI,aAAO,eAAe,CAAC,EAAE,CAAC,QAAJ,CAAtB;;AACJ,SAAK,QAAL;AACI,aAAO,WAAW,EAAE,CAAC,KAAH,CAAS,GAAT,CAAa,CAAC,IAAI,eAAe,CAAC,CAAD,CAAjC,EAAsC,IAAtC,CAA2C,IAA3C,CAAgD,GAAlE;;AACJ,SAAK,OAAL;AAAc,SAAK,KAAL;AAAY,SAAK,SAAL;AACtB,aAAO,EAAE,CAAC,IAAV;;AACJ,SAAK,SAAL;AACI,aAAO,EAAE,CAAC,iBAAV;;AACJ;AACI,aAAO,EAAE,CAAC,QAAH,GAAc,EAAE,CAAC,QAAjB,GAA4B,GAAnC;AAvBJ;AAyBH;;AAGK,SAAU,kBAAV,CACE,GADF,EACe,IADf,EAC0B,EAD1B,EAEE,IAFF,EAGE,MAHF,EAGiG;AAEnG,MAAI,GAAG,GAAG,GAAV,CAFmG,CAGnG;AACA;;AAEA,QAAM,EAAE,GAAG,MAAM,CAAC,aAAlB;AAEA,QAAM,IAAI,GAAG,IAAI,GAAJ,CAAwB,CACjC,CAAC,cAAD,EACI,EAAE,CAAC,UAAH,GACI,EAAE,CAAC,UADP,GAEA,4DAAY,CAAC,eAAe,CAAC,EAAD,CAAhB,CAHhB,CADiC,EAKjC,CAAC,MAAD,EACI,4DAAY,CAAC,OAAO,IAAR,CADhB,CALiC,EAOjC,CAAC,eAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,iBAAZ,GACI,MAAM,CAAC,EAAE,CAAC,KAAJ,CADV,GAEA,EAAE,CAAC,IAAH,KAAY,MAAZ,GACI,EAAE,CAAC,QAAH,GACI,kBAAkB,EAAE,CAAC,QAAQ,EADjC,GAEI,GAHR,GAIA,GAPQ,CADhB,CAPiC,EAgBjC,CAAC,OAAD,EACI,4DAAY,CAAC,MAAM,CAAC,IAAD,CAAP,CADhB,CAhBiC,EAkBjC,CAAC,WAAD,EACI,4DAAY,CACR,EAAE,GACE,EAAE,CAAC,IAAH,KAAY,UAAZ,GAAyB,GACrB,iDAAG,CAAC,EAAE,CAAC,GAAJ,EAAS,EAAT,CAAY,GACV,EAAE,CAAC,GAAH,KAAW,IAAX,IAAmB,EAAE,CAAC,GAAH,KAAW,KAAK,CAApC,IACC,EAAE,CAAC,GAAH,KAAW,IAAX,IAAmB,EAAE,CAAC,GAAH,KAAW,KAAK,CADpC,GACyC,IADzC,GACgD,EAAE,GAClD,iDAAG,CAAC,EAAE,CAAC,GAAJ,EAAS,EAAT,CAAY,EAJvB,GAKI,MANN,GAOE,GARI,CADhB,CAlBiC,EA4BjC,CAAC,UAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,WAAZ,GACI,GAAG,iDAAG,CAAC,EAAE,CAAC,QAAJ,EAAc,iDAAG,CAAC,EAAE,CAAC,gBAAJ,EAAsB,YAAtB,CAAjB,CAAqD,EAD/D,GACoE,GAF5D,CADhB,CA5BiC,EAgCjC,CAAC,UAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,WAAZ,GACI,GAAG,iDAAG,CAAC,EAAE,CAAC,QAAJ,EAAc,iDAAG,CAAC,EAAE,CAAC,aAAJ,EAAmB,WAAnB,CAAjB,CAAiD,EAD3D,GACgE,GAFxD,CADhB,CAhCiC,EAoCjC,CAAC,SAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,WAAZ,GACI,GAAG,EAAE,CAAC,OAAH,GAAa,IAAI,EAAE,CAAC,OAAH,CAAW,MAAM,IAAI,EAAE,CAAC,OAAH,CAAW,KAAK,EAAtD,GAA2D,WAAW,EAD7E,GACkF,GAF1E,CADhB,CApCiC,EAwCjC,CAAC,WAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,WAAZ,GACI,GAAG,iDAAG,CAAC,EAAE,CAAC,SAAJ,EAAe,GAAf,CAAmB,EAD7B,GACkC,GAF1B,CADhB,CAxCiC,EA4CjC,CAAC,WAAD,EACI,4DAAY,CACR,EAAE,CAAC,IAAH,KAAY,WAAZ,GACI,GAAG,iDAAG,CAAC,EAAE,CAAC,SAAJ,EAAe,WAAf,CAA2B,EADrC,GAC0C,GAFlC,CADhB,CA5CiC,EAgDjC,CAAC,MAAD,EACI,4DAAY,CACR,GAAG,EAAE,CAAC,IAAH,KAAY,UAAZ,IAA0B,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAAyB,WAAzB,CAA1B,GACC,mBADD,GAEA,EAAE,CAAC,IAAH,KAAY,UAAZ,IAA0B,MAAM,CAAC,QAAP,CAAgB,QAAhB,CAAyB,WAAzB,CAA1B,GACC,mBADD,GACuB,EAAE,GAC5B,MAAM,CAAC,SAAP,IAAoB,GAAG,EALf,CADhB,CAhDiC,EAuDjC,CAAC,YAAD,EACI,4DAAY,CACR,MAAM,CAAC,UAAP,IAAqB,GADb,CADhB,CAvDiC,EA0DjC,CAAC,UAAD,EACI,MAAM,CAAC,QADX,CA1DiC,EA6DjC,IAAI,IAAI,CAAC,aAAL,IAAsB,EAA1B,CA7DiC,CAAxB,CAAb;;AAgEA,OAAK,MAAM,GAAX,IAAkB,IAAI,CAAC,OAAL,EAAlB,EAAkC;AAC9B,OAAG,GAAG,GAAG,CAAC,OAAJ,CAAY,IAAI,MAAJ,CAAW,KAAK,GAAG,CAAC,CAAD,CAAG,GAAtB,CAAZ,EAAwC,GAAG,CAAC,CAAD,CAA3C,CAAN;AACH;;AAED,SAAO,GAAP;AACH;AASK,SAAU,WAAV,CACE,OADF,EACuB,IADvB,EACkC,EADlC,EAEE,IAFF,EAE4B;AAE9B,QAAM,QAAQ,GAAoB,EAAlC;;AACA,MAAI,EAAE,CAAC,QAAP,EAAiB;AACb,YAAQ,CAAC,IAAT,CAAc,EAAE,CAAC,QAAjB;AACH;;AACD,MAAI,IAAI,CAAC,GAAL,CAAS,aAAb,EAA4B;AACxB,YAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,GAAL,CAAS,aAAvB;AACH;;AACD,UAAQ,CAAC,IAAT,CAAc,eAAd;AAEA,QAAM,kBAAkB,GAAoB,EAA5C;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,MAAvC,EAA+C,CAAC,EAAhD,EAAoD;AAChD,UAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,CAAnB,CAAV;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,CAAC,GAAG,CAAvB,CAAb;AACA,UAAM,EAAE,GAAG,KAAK,CAAC,OAAN,CAAc,CAAd,IAAmB,CAAC,CAAC,CAAD,CAApB,GAA0B,CAArC;AACA,UAAM,EAAE,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,IAAsB,IAAI,CAAC,CAAD,CAA1B,GAAgC,KAAK,CAAhD;AAEA,QAAI,KAAK,GAAG,KAAZ;;AACA,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,UAAI,CAAC,KAAK,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,MAAnB,GAA4B,CAAtC,EAAyC;AACrC,YAAI,EAAE,CAAC,IAAP,EAAa;AACT,4BAAkB,CAAC,IAAnB,CAAwB;AAAC,gBAAI,EAAE,KAAP;AAAc,gBAAI,EAAE,EAAE,CAAC;AAAvB,WAAxB;AACH;;AACD,0BAAkB,CAAC,IAAnB,CAAwB;AAAC,cAAI,EAAE,OAAP;AAAgB,cAAI,EAAE,IAAI,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAG,EAAE,GAArB,GAA2B,EAAE;AAAvD,SAAxB;AACA,aAAK,GAAG,IAAR;AACH;AACJ,KARD,MAQO,IAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AAC/B,UAAI,CAAC,KAAK,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,MAAnB,GAA4B,CAAtC,EAAyC;AACrC,YAAI,EAAE,CAAC,IAAP,EAAa;AACT,4BAAkB,CAAC,IAAnB,CAAwB;AAAC,gBAAI,EAAE,KAAP;AAAc,gBAAI,EAAE,EAAE,CAAC;AAAvB,WAAxB;AACH;;AACD,0BAAkB,CAAC,IAAnB,CAAwB;AAAC,cAAI,EAAE,OAAP;AAAgB,cAAI,EAAE,IAAI,EAAE,KAAK,KAAK,CAAZ,GAAgB,GAAG,EAAE,GAArB,GAA2B,EAAE;AAAvD,SAAxB;AACA,aAAK,GAAG,IAAR;AACH;AACJ;;AACD,QAAI,CAAE,KAAN,EAAa;AACT,UAAI,EAAE,CAAC,IAAP,EAAa;AACT,YAAI,CAAC,KAAK,CAAV,EAAa;AACT,cAAI,EAAE,CAAC,QAAP,EAAiB;AACb,8BAAkB,CAAC,IAAnB,CAAwB;AAAC,kBAAI,EAAE,MAAP;AAAe,kBAAI,EAAE,EAAE,CAAC;AAAxB,aAAxB;AACH,WAFD,MAEO;AACH,8BAAkB,CAAC,IAAnB,CAAwB;AAAC,kBAAI,EAAE,KAAP;AAAc,kBAAI,EAAE,EAAE,CAAC;AAAvB,aAAxB;AACH;AACJ,SAND,MAMO;AACH,gBAAM,GAAG,GAAG,kBAAkB,CAAC,MAA/B;;AACA,cAAI,GAAG,IAAI,kBAAkB,CAAC,GAAG,GAAG,CAAP,CAAlB,CAA4B,IAA5B,KAAqC,MAAhD,EAAwD;AACpD,gBAAI,EAAE,CAAC,IAAH,KAAY,QAAZ,IAAwB,IAAxB,IAAgC,EAAE,CAAC,QAAvC,EAAiD;AAC7C,gCAAkB,CAAC,IAAnB,CAAwB;AAAC,oBAAI,EAAE,MAAP;AAAe,oBAAI,EAAE,EAAE,CAAC;AAAxB,eAAxB;AACH,aAFD,MAEO;AACH,gCAAkB,CAAC,IAAnB,CAAwB;AAAC,oBAAI,EAAE,KAAP;AAAc,oBAAI,EAAE,EAAE,CAAC;AAAvB,eAAxB,EADG,CAC8D;AACpE;AACJ,WAND,MAMO;AACH,gBAAI,EAAE,CAAC,QAAP,EAAiB;AACb,gCAAkB,CAAC,IAAnB,CAAwB;AAAC,oBAAI,EAAE,MAAP;AAAe,oBAAI,EAAE,EAAE,CAAC;AAAxB,eAAxB;AACH,aAFD,MAEO;AACH,gCAAkB,CAAC,IAAnB,CAAwB;AAAC,oBAAI,EAAE,KAAP;AAAc,oBAAI,EAAE,EAAE,CAAC;AAAvB,eAAxB;AACH;AACJ;AACJ;AACJ,OAvBD,MAuBO,IAAI,EAAE,CAAC,QAAP,EAAiB;AACpB,0BAAkB,CAAC,IAAnB,CAAwB;AAAC,cAAI,EAAE,MAAP;AAAe,cAAI,EAAE,EAAE,CAAC;AAAxB,SAAxB;AACH;AACJ;AACJ;;AAED,MAAI,QAAQ,GAAG,EAAf;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,kBAAkB,CAAC,MAAvC,EAA+C,CAAC,EAAhD,EAAoD;AAChD,UAAM,CAAC,GAAG,kBAAkB,CAAC,CAAD,CAA5B;AACA,YAAQ,IAAI,CAAC,CAAC,IAAd;;AACA,QAAI,CAAC,GAAG,CAAJ,KAAU,kBAAkB,CAAC,MAAjC,EAAyC;AACrC;AACH;;AACD,YAAQ,IAAI,CAAC,CAAC,IAAF,KAAW,MAAX,GAAoB,GAApB,GAA0B,GAAtC;AACH;;AAED,MAAI,UAAU,GAAG,EAAjB;AACA,MAAI,SAAS,GAAG,EAAhB;;AACA,OAAK,IAAI,CAAC,GAAG,kBAAkB,CAAC,MAAnB,GAA4B,CAAzC,EAA4C,KAAK,CAAjD,EAAoD,CAAC,EAArD,EAAyD;AACrD,UAAM,CAAC,GAAG,kBAAkB,CAAC,CAAD,CAA5B;;AACA,QAAI,CAAC,CAAC,IAAF,KAAW,MAAf,EAAuB;AACnB,UAAI,CAAC,KAAK,CAAN,IAAW,CAAC,KAAK,kBAAkB,CAAC,MAAnB,GAA4B,CAAjD,EAAoD;AAChD,cAAM,CAAC,GAAG,kBAAkB,CAAC,CAAC,GAAG,CAAL,CAA5B;;AACA,YAAI,CAAC,CAAC,IAAF,KAAW,OAAf,EAAwB;AACpB,mBADoB,CACV;AACb;AACJ,OANkB,CAMD;;;AAClB,gBAAU,GAAG,CAAC,CAAC,IAAf;;AACA,WAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAjB,EAAoB,CAAC,GAAG,kBAAkB,CAAC,MAA3C,EAAmD,CAAC,EAApD,EAAwD;AACpD,cAAM,CAAC,GAAG,kBAAkB,CAAC,CAAD,CAA5B;;AACA,YAAI,CAAC,CAAC,IAAF,KAAW,KAAf,EAAsB;AAClB,mBAAS,GAAG,CAAC,CAAC,IAAd;AACA;AACH;AACJ;;AACD;AACH;AACJ;;AACD,MAAI,CAAE,UAAN,EAAkB;AACd,SAAK,IAAI,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,MAAnB,GAA4B,CAAzC,EAA4C,KAAK,CAAjD,EAAoD,CAAC,EAArD,EAAyD;AACrD,YAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,CAAnB,CAAV;AACA,YAAM,EAAE,GAAG,KAAK,CAAC,OAAN,CAAc,CAAd,IAAmB,CAAC,CAAC,CAAD,CAApB,GAA0B,CAArC;;AACA,UAAI,EAAE,CAAC,QAAP,EAAiB;AACb,kBAAU,GAAG,EAAE,CAAC,QAAhB;AACH;AACJ;AACJ;;AAED,QAAM,aAAa,GAAkB,0BAA0B,CAAC,IAAI,CAAC,GAAN,CAA/D;AACA,QAAM,MAAM,GAAG;AAAC,YAAD;AAAW,iBAAX;AAA0B,cAA1B;AAAsC;AAAtC,GAAf;AAEA,QAAM,WAAW,GAAyC,EAA1D;AACA,QAAM,MAAM,GAA2C,CAAC,EAAD,CAAvD;;AAEA,MAAI,OAAO,KAAK,iDAAU,CAAC,kBAAvB,IAA6C,aAAjD,EAAgE;AAC5D,UAAM,CAAC,OAAP,CAAe,aAAf;AACH;;AAED,OAAK,MAAM,IAAX,IAAmB,MAAnB,EAA2B;AACvB,QAAI,iDAAG,CAAC,IAAI,CAAC,QAAN,EAAgB,KAAhB,CAAP,EAA+B;AAC3B,iBAAW,CAAC,QAAZ,GAAuB,IAAI,CAAC,QAA5B;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,QAAN,EAAgB,KAAhB,CAAP,EAA+B;AAC3B,iBAAW,CAAC,QAAZ,GAAuB,IAAI,CAAC,QAA5B;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,gBAAN,EAAwB,KAAxB,CAAP,EAAuC;AACnC,iBAAW,CAAC,gBAAZ,GAA+B,IAAI,CAAC,gBAApC;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,aAAN,EAAqB,KAArB,CAAP,EAAoC;AAChC,iBAAW,CAAC,aAAZ,GAA4B,IAAI,CAAC,aAAjC;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,SAAN,EAAiB,KAAjB,CAAP,EAAgC;AAC5B,iBAAW,CAAC,SAAZ,GAAwB,IAAI,CAAC,SAA7B;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,SAAN,EAAiB,KAAjB,CAAP,EAAgC;AAC5B,iBAAW,CAAC,SAAZ,GAAwB,IAAI,CAAC,SAA7B;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,OAAN,EAAe,KAAf,CAAP,EAA8B;AAC1B,YAAM,GAAG,GAAG,IAAI,CAAC,OAAjB;AACA,iBAAW,CAAC,OAAZ,GAAsB,IAAI,GAAG,CAAC,MAAM,IAAI,GAAG,CAAC,KAAK,EAAjD;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,GAAN,EAAW,KAAX,CAAP,EAA0B;AACtB,iBAAW,CAAC,GAAZ,GAAkB,IAAI,CAAC,GAAvB;AACH;;AACD,QAAI,iDAAG,CAAC,IAAI,CAAC,GAAN,EAAW,KAAX,CAAP,EAA0B;AACtB,iBAAW,CAAC,GAAZ,GAAkB,IAAI,CAAC,GAAvB;AACH;AACJ;;AAED,QAAM,GAAG,GAAkB,EAA3B;;AAEA,UAAQ,OAAO,IAAf;AACA,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe,SAAK,SAAL;AAAgB,SAAK,WAAL;AACzD,SAAG,CAAC,KAAJ,GAAY,IAAZ;AACA;;AACJ,SAAK,QAAL;AACI,UAAI,IAAI,KAAK,IAAb,EAAmB;AACf,WAAG,CAAC,KAAJ,GAAY,IAAZ;AACH;;AAPL;;AAUA,MAAI,EAAE,CAAC,SAAP,EAAkB;AACd,QAAI,CAAC,GAAL,CAAS,MAAT,CAAgB,IAAhB,CAAoB;AAChB,UAAI,EAAE,GAAG,EAAE,CAAC,SAAS,IAAI,cAAc,CAAC,OAAD,CAAS,EADhC;AAEhB,aAAO,EAAE,kBAAkB,CAAC,EAAE,CAAC,OAAH,GACxB,EAAE,CAAC,OADqB,GAExB,eAAe,CAAC,OAAD,EAAU,GAAG,QAAb,CAFQ,EAEgB,IAFhB,EAEsB,EAFtB,EAE0B,IAF1B,EAEgC,MAFhC,CAFX;AAKhB,cALgB;AAMhB;AANgB,OAOb,GAPa,CAApB;AASH,GAVD,MAUO,IAAI,EAAE,CAAC,OAAP,EAAgB;AACnB,QAAI,CAAC,GAAL,CAAS,MAAT,CAAgB,IAAhB,CAAoB;AAChB,UAAI,EAAE,GAAG,cAAc,CAAC,OAAD,CAAS,EADhB;AAEhB,aAAO,EAAE,kBAAkB,CAAC,EAAE,CAAC,OAAJ,EAAa,IAAb,EAAmB,EAAnB,EAAuB,IAAvB,EAA6B,MAA7B,CAFX;AAGhB,cAHgB;AAIhB;AAJgB,OAKb,GALa,CAApB;AAOH,GARM,MAQA;AACH,QAAI,CAAC,GAAL,CAAS,MAAT,CAAgB,IAAhB,CAAoB;AAChB,UAAI,EAAE,GAAG,cAAc,CAAC,OAAD,CAAS,EADhB;AAEhB,aAAO,EAAE,kBAAkB,CAAC,eAAe,CAAC,OAAD,EAAU,GAAG,QAAb,CAAhB,EAAwC,IAAxC,EAA8C,EAA9C,EAAkD,IAAlD,EAAwD,MAAxD,CAFX;AAGhB,cAHgB;AAIhB;AAJgB,OAKb,GALa,CAApB;AAOH;AACJ;AAGK,SAAU,mBAAV,CACE,OADF,EACuB,IADvB,EAEE,KAFF,EAGE,IAHF,EAG4B;AAE9B,MAAI;AACA,QAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,IAAnB,CAAwB,KAAxB;AACA,eAAW,CAAC,OAAD,EAAU,IAAV,EAAgB,KAAK,CAAC,CAAD,CAArB,EAA0B,IAA1B,CAAX;AACH,GAHD,SAGU;AACN,QAAI,CAAC,GAAL,CAAS,SAAT,CAAmB,GAAnB;AACH;AACJ,C;;;;;;;;;;;;AChcD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAWA;AACA;;AAIA,SAAS,mBAAT,CAA6B,EAA7B,EAAgD,IAAhD,EAAsE;AAClE,QAAM,KAAK,qBAAO,IAAP,CAAX;AACA,SAAO,KAAK,CAAC,IAAb;AACA,SAAO,KAAK,CAAC,iBAAb;AACA,SAAO,KAAK,CAAC,UAAb;AACA,SAAQ,gCAAI,EAAJ,GAAW,KAAX,CAAR;AACH;;AAGD,SAAS,YAAT,CAAsB,QAAtB,EAA+C,MAA/C,EAAyE,EAAzE,EAA4F,QAA5F,EAAwH;AACpH,MAAI,QAAQ,IAAI,MAAM,CAAC,GAAP,CAAW,QAAX,CAAhB,EAAsC;AAClC,UAAM,CAAC,GAA0B,MAAM,CAAC,GAAP,CAAW,QAAX,CAAjC;;AACA,QAAI,CAAC,CAAC,EAAF,KAAS,QAAb,EAAuB;AACnB,YAAM,CAAC,GAAP,CAAW,QAAX,EAAmB,gCAAM,CAAN,GAAO;AAAE,UAAF;AAAM,gBAAQ,EAAE;AAAhB,OAAP,CAAnB;AACH;AACJ;;AACD,SAAO,EAAP;AACH;;AAGK,SAAU,kBAAV,CACE,EADF,EACqB,OADrB,EACsC,iBADtC,EACmE,SADnE,EACoF;AAEtF,QAAM,WAAW,GAAG,CAAC,EAAD,EAAoB,QAApB,EAAkD,SAAlD,KAAuE;AACvF,QAAI,QAAJ,EAAc;AACV,aAAO,gCACA,EADA,GACE;AACL,gBAAQ,EAAE,SAAS,KAAK,CAAd,GACN,GAAG,OAAO,IAAI,iBAAiB,CAAC,IAAlB,CAAuB,GAAvB,CAA2B,EADnC,GAEN,GAAG,QAAQ,IAAI,SAAS;AAHvB,OADF,CAAP;AAMH,KAPD,MAOO;AACH,aAAO,EAAP;AACH;AACJ,GAXD;;AAaA,OAAK,IAAI,CAAC,GAAG,SAAb,EAAwB,CAAC,GAAG,iBAAiB,CAAC,MAA9C,EAAsD,CAAC,EAAvD,EAA2D;AACvD,UAAM,SAAS,GAAG,iBAAiB,CAAC,CAAD,CAAnC;;AAEA,YAAQ,EAAE,CAAC,IAAX;AACA,WAAK,UAAL;AACI,eAAO,kBAAkB,CAAC,EAAE,CAAC,QAAJ,EAAc,OAAd,EAAuB,iBAAvB,EAA0C,CAAC,GAAG,CAA9C,CAAzB;;AACJ,WAAK,QAAL;AACI,aAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,OAAnB,EAA4B;AACxB,cAAI,SAAS,KAAK,CAAC,CAAC,CAAD,CAAnB,EAAwB;AACpB,mBAAO,WAAW,CACd,kBAAkB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,OAAP,EAAgB,iBAAhB,EAAmC,CAAC,GAAG,CAAvC,CADJ,EAEd,EAAE,CAAC,QAFW,EAGd,SAHc,CAAlB;AAKH;AACJ;;AACD,YAAI,EAAE,CAAC,eAAP,EAAwB;AACpB,eAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,eAAnB,EAAoC;AAChC,iBAAK,MAAM,CAAX,IAAgB,CAAC,CAAC,CAAD,CAAjB,EAAsB;AAClB,sBAAQ,CAAR;AACA,qBAAK,QAAL;AACI,sBAAI,uDAAa,CAAC,IAAd,CAAmB,SAAnB,CAAJ,EAAmC;AAC/B,2BAAO,kBAAkB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,OAAP,EAAgB,iBAAhB,EAAmC,CAAC,GAAG,CAAvC,CAAzB;AACH;;AACD;;AACJ,qBAAK,QAAL;AACI,yBAAO,kBAAkB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,OAAP,EAAgB,iBAAhB,EAAmC,CAAC,GAAG,CAAvC,CAAzB;;AACJ;AACI,sBAAI,CAAC,CAAC,IAAF,CAAO,SAAP,CAAJ,EAAuB;AACnB,2BAAO,kBAAkB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,OAAP,EAAgB,iBAAhB,EAAmC,CAAC,GAAG,CAAvC,CAAzB;AACH;;AACD;AAZJ;AAcH;AACJ;AACJ;;AACD,cAAM,IAAI,KAAJ,CAAU,sCAAsC,SAAS,EAAzD,CAAN;;AACJ,WAAK,SAAL;AACI,YAAI,CAAE,EAAE,CAAC,QAAT,EAAmB;AACf,gBAAM,IAAI,KAAJ,CAAU,4CAA4C,SAAS,EAA/D,CAAN;AACH;;AACD,eAAO,cACA;AACC,cAAI,EAAE,SADP;AAEC,2BAAiB,EAAE,OAFpB;AAGC,cAAI,EAAE,SAHP;AAIC,kBAAQ,EAAE;AAJX,SADA,EAOC,IAAI,iBAAiB,CAAC,MAAtB,GAA+B;AAC/B,oBAAU,EAAE;AADmB,SAA/B,GAEA,EATD,CAAP;;AAWJ;AACI;AACA,cAAM,IAAI,KAAJ,CAAU,4CAA4C,EAAE,CAAC,IAAI,KAAK,SAAS,EAA3E,CAAN;AAnDJ;AAqDH;;AACD,SAAO,EAAP;AACH;AAGK,SAAU,cAAV,CAAyB,MAAzB,EAAmD,EAAnD,EAAsE,GAAtE,EAAgG;;;AAClG,QAAM,IAAI,mCAAO,GAAP,GAAU;AAAE,aAAS,EAAE,GAAG,CAAC,SAAJ,GAAgB;AAA7B,GAAV,CAAV;;AACA,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,SAAL;AACI;AACI,cAAM,CAAC,GAAG,MAAM,CAAC,GAAP,CAAW,EAAE,CAAC,iBAAd,CAAV;;AACA,YAAI,CAAE,CAAN,EAAS;AACL,gBAAM,IAAI,KAAJ,CAAU,qBAAqB,EAAE,CAAC,iBAAiB,gBAAnD,CAAN;AACH;;AACD,YAAI,KAAK,GAAG,CAAC,YAAJ,CAAiB,SAAjB,CAA2B,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,iBAAzC,CAAT,EAAsE;AAClE,iBAAO,EAAP;AACH;;AAED,cAAM,GAAG,qBAAO,EAAP,CAAT;AACA,YAAI,GAAG,GAAG,CAAC,CAAC,EAAZ;;AACA,YAAI,EAAE,CAAC,UAAH,IAAiB,IAAI,EAAE,CAAC,UAAH,CAAc,MAAvC,EAA+C;AAC3C,aAAG,qBACI,kBAAkB,CAAC,GAAD,EAAM,EAAE,CAAC,iBAAT,EAA4B,EAAE,CAAC,UAA/B,EAA2C,CAA3C,CADtB,CAAH;AAGA,aAAG,CAAC,QAAJ,GAAe,GAAG,CAAC,QAAnB;AACH;;AAED,eACI,cAAc,CACV,MADU,EAEV,mBAAmB,CAAC,GAAD,EAAM,GAAN,CAFT,EAEmB,gCACzB,IADyB,GACrB;AAAE,sBAAY,EAAE,CAAC,GAAG,IAAI,CAAC,YAAT,EAAuB,GAAG,CAAC,iBAA3B;AAAhB,SADqB,CAFnB,CADlB;AAOH;;AACL,SAAK,UAAL;AACI,aAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GACrB;AACL,gBAAQ,EAAE,cAAc,CAAC,MAAD,EAAS,EAAE,CAAC,QAAZ,EAAsB,IAAtB;AADnB,OADqB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;;AAIJ,SAAK,QAAL;AACI,aAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GACrB;AACL,cAAM,EAAE,cAAc,CAAC,MAAD,EAAS,EAAE,CAAC,MAAZ,EAAoB,IAApB;AADjB,OADqB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;;AAIJ,SAAK,UAAL;AACI,aAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GACrB;AACL,gBAAQ,EAAE,EAAE,CAAC,QAAH,CAAY,GAAZ,CAAgB,CAAC,IAAI,cAAc,CAAC,MAAD,EAAS,CAAT,EAAY,IAAZ,CAAnC;AADL,OADqB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;;AAIJ,SAAK,QAAL;AACI,aAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GACrB;AACL,aAAK,EAAE,EAAE,CAAC,KAAH,CAAS,GAAT,CAAa,CAAC,IAAI,cAAc,CAAC,MAAD,EAAS,CAAT,EAAY,IAAZ,CAAhC;AADF,OADqB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;;AAIJ,SAAK,UAAL;AACI,aAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GACrB;AACL,gBAAQ,EAAE,cAAc,CAAC,MAAD,EAAS,EAAE,CAAC,QAAZ,EAAsB,IAAtB;AADnB,OADqB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;;AAIJ,SAAK,QAAL;AACI;AACI,YAAI,IAAI,GAAG,CAAC,SAAR,IAAqB,EAAE,CAAC,QAAxB,IAAoC,KAAK,GAAG,CAAC,YAAJ,CAAiB,SAAjB,CAA2B,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,QAAzC,CAA7C,EAAiG;AAC7F,cAAI,MAAM,CAAC,GAAP,CAAW,EAAE,CAAC,QAAd,CAAJ,EAA6B;AACzB,kBAAM,CAAC,GAAG,MAAM,CAAC,GAAP,CAAW,EAAE,CAAC,QAAd,CAAV;;AACA,gBAAI,CAAC,CAAC,QAAN,EAAgB;AACZ,qBAAO,CAAC,CAAC,EAAT;AACH;AACJ;AACJ;;AAED,cAAM,YAAY,GAAG,QAAE,CAAC,SAAH,MAAY,IAAZ,IAAY,aAAZ,GAAY,MAAZ,GAAY,GAAE,MAAF,CAAS,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,SAAzB,CAAjC;;AACA,YAAI,YAAY,IAAI,YAAY,CAAC,MAAb,GAAsB,CAAtC,IAA2C,CAAC,GAAG,CAAC,iBAApD,EAAuE;AACnE,gBAAM,IAAI,GAAG,YAAY,CACpB,GADQ,CACJ,CAAC,IAAI,cAAc,CAAC,MAAD,EAAS,CAAT,EAAY,IAAZ,CADf,EAER,MAFQ,CAED,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,QAFf,CAAb,CADmE,CAInE;;AACA,gBAAM,EAAE,GAAG,cAAc,CACrB,MADqB,EAErB,mDAAiB,gCACV,EADU,GAET,EAAE,CAAC,SAAH,GAAe;AACf,qBAAS,EAAE,EAAE,CAAC,SAAH,CAAa,MAAb,CAAoB,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,SAApC;AADI,WAAf,GAEA,EAJS,CAAjB,EAKG,GAAG,IALN,CAFqB,EAQrB,EAAE,CAAC,QAAH,GAAa,gCACL,IADK,GACD;AAAE,wBAAY,EAAE,CAAC,GAAG,IAAI,CAAC,YAAT,EAAuB,EAAE,CAAC,QAA1B;AAAhB,WADC,CAAb,GACmE,IAT9C,CAAzB;AAWA,iBAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,gCACvB,EADuB,GAEvB,EAFuB,CAAX,EAGhB,EAAE,CAAC,QAHa,CAAnB;AAIH,SApBD,MAoBO;AACH,iBAAO,YAAY,CAAC,EAAD,EAAK,MAAL,EAAW,8EAEnB,EAFmB,GAEjB;AACL,mBAAO,EAAE,EAAE,CAAC,OAAH,CACJ,GADI,CACA,CAAC,IAAI,CACN,CAAC,CAAC,CAAD,CADK,EAEN,cAAc,CAAC,MAAD,EAAS,CAAC,CAAC,CAAD,CAAV,EAAe,EAAE,CAAC,QAAH,GAAa,gCAClC,IADkC,GAC9B;AAAE,0BAAY,EAAE,CAAC,GAAG,IAAI,CAAC,YAAT,EAAuB,EAAE,CAAC,QAA1B;AAAhB,aAD8B,CAAb,GACsC,IADrD,CAFR,EAIN,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAJG,CADL;AADJ,WAFiB,IAWtB,EAAE,CAAC,eAAH,IAAsB,IAAI,EAAE,CAAC,eAAH,CAAmB,MAA7C,GAAsD;AACtD,2BAAe,EAAE,EAAE,CAAC,eAAH,CACZ,GADY,CACR,CAAC,IAAI,CACN,CAAC,CAAC,CAAD,CADK,EAEN,cAAc,CAAC,MAAD,EAAS,CAAC,CAAC,CAAD,CAAV,EAAe,EAAE,CAAC,QAAH,GAAa,gCAClC,IADkC,GAC9B;AAAE,0BAAY,EAAE,CAAC,GAAG,IAAI,CAAC,YAAT,EAAuB,EAAE,CAAC,QAA1B;AAAhB,aAD8B,CAAb,GACsC,IADrD,CAFR,EAIN,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAJG,CADG;AADqC,WAAtD,GAQA,EAnBsB,GAoBtB,EAAE,CAAC,SAAH,IAAgB,IAAI,EAAE,CAAC,SAAH,CAAa,MAAjC,GAA0C;AAC1C,qBAAS,EAAE,GAAG,CAAC,iBAAJ,GACP,EAAE,CAAC,SAAH,CACK,GADL,CACS,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,SAAX,GAAuB,cAAc,CAAC,MAAD,EAAS,CAAT,EAAY,IAAZ,CAArC,GAAyD,CADvE,EAEK,MAFL,CAEY,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,QAF5B,CADO,GAIP,EAAE,CAAC;AALmC,WAA1C,GAMA,EA1BsB,CAAX,EA2BhB,EAAE,CAAC,QA3Ba,CAAnB;AA4BH;AACJ;;AACL,SAAK,UAAL;AACI,UAAI,IAAI,CAAC,SAAT,EAAoB;AAChB,cAAM,IAAI,GAAG,EAAE,CAAC,QAAH,GAAa,gCAClB,IADkB,GACd;AAAE,sBAAY,EAAE,CAAC,GAAG,IAAI,CAAC,YAAT,EAAuB,EAAE,CAAC,QAA1B;AAAhB,SADc,CAAb,GACsD,IADnE;AAEA,cAAM,QAAQ,GAAG,EAAE,CAAC,QAAH,CAAY,GAAZ,CAAgB,CAAC,IAAG;AACjC,cAAI,OAAO,CAAP,KAAa,QAAb,IAAyB,CAAC,CAAC,IAA/B,EAAqC;AACjC,mBAAO,cAAc,CAAC,MAAD,EAAS,CAAT,EAAY,IAAZ,CAArB;AACH;;AACD,iBAAO,CAAP;AACH,SALgB,CAAjB;;AAMA,YAAI,IAAI,QAAQ,CAAC,MAAT,CAAgB,CAAC,IAAI,CAAC,IAAI,OAAO,CAAP,KAAa,QAAlB,KACpB,CAAC,CAAC,IAAF,KAAW,SAAX,IAAwB,CAAC,CAAC,IAAF,KAAW,UADf,CAArB,EACiD,MADzD,EACiE;AAC7D,gBAAM,IAAI,KAAJ,CAAU,sCAAsC,EAAE,CAAC,QAAQ,EAA3D,CAAN;AACH;;AACD,YAAI,CAAE,IAAI,CAAC,SAAL,CAAe,EAAE,CAAC,QAAlB,CAAN,EAAmC;AAC/B,gBAAM,IAAI,KAAJ,CAAU,qCAAqC,EAAE,CAAC,QAAQ,EAA1D,CAAN;AACH;;AACD,cAAM,GAAG,qBAAO,EAAP,CAAT;AACA,eAAO,GAAG,CAAC,QAAX;AACA,eAAO,GAAG,CAAC,QAAX;AACA,eAAO,YAAY,CACf,EADe,EACX,MADW,EACL,gCAEH,GAFG,GAGH,cAAc,CAAC,MAAD,EAAS,IAAI,CAAC,SAAL,CAAe,EAAE,CAAC,QAAlB,EAA4B,GAAG,QAA/B,CAAT,EAAmD,IAAnD,CAHX,CADK,EAMf,EAAE,CAAC,QANY,CAAnB;AAQH,OA3BD,MA2BO;AACH,eAAO,EAAP;AACH;;AACL;AACI,aAAO,EAAP;AApJJ;AAsJH;AAGD,MAAM,WAAW,GAA4B;AACzC,QAAM,EAAE,iDADiC;AAEzC,MAAI,EAAE,+CAFmC;AAGzC,SAAO,EAAE,kDAHgC;AAIzC,WAAS,EAAE,oDAJ8B;AAKzC,UAAQ,EAAE,mDAAkB;AALa,CAA7C;AASM,SAAU,aAAV,CAAwB,MAAxB,EAAkD,IAAlD,EAA6E;AAC/E,OAAK,MAAM,GAAX,IAAkB,MAAM,CAAC,OAAP,EAAlB,EAAoC;AAChC,UAAM,EAAE,GAAG,cAAc,CAAC,MAAD,EAAS,GAAG,CAAC,CAAD,CAAH,CAAO,EAAhB,EAAkB,gCAAM,IAAN,GAAU;AAAE,eAAS,EAAE,CAAb;AAAgB,kBAAY,EAAE,CAAC,GAAG,CAAC,CAAD,CAAJ,CAA9B;AAAwC,eAAS,EAAE;AAAnD,KAAV,CAAlB,CAAzB;AACA,OAAG,CAAC,CAAD,CAAH,CAAO,EAAP,GAAY,EAAZ;AACH;;AAED,SAAO,MAAP;AACH,C;;;;;;;;;;;;AC9RD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA,MAAM,SAAS,GAAG,QAAQ,CAAC,aAAD,CAAR,EAAlB;AACA,MAAM,cAAc,GAAI,EAAD,CAAK,WAA5B,C,CAAyC;;AACzC,MAAM,cAAc,GAAG,QAAvB,C,CAAyC;;AAGlC,MAAM,aAAa,GAAG,4BAAtB;AACA,MAAM,aAAa,GAAG,yCAAtB;AACA,MAAM,WAAW,GAAG,0BAApB;AACA,MAAM,eAAe,GAC5B,kLADO;AAEA,MAAM,mBAAmB,GAC7B,qJADI;AAIA,MAAM,iBAAiB,GAAG,EAA1B;AAGD,SAAU,gBAAV,CAA2B,MAA3B,EAAwC,OAAxC,EAAuD;AACzD,MAAI,MAAM,KAAK,SAAX,IACA,OAAO,KAAK,WADZ,IAEA,OAAO,KAAK,kBAFZ,IAEkC,OAAO,KAAK,kBAF9C,IAGA,OAAO,KAAK,kBAHZ,IAGkC,OAAO,KAAK,kBAHlD,EAGsE;AAClE,WAAO,IAAP;AACH;;AACD,MAAI,OAAO,KAAK,WAAZ,IAA2B,OAAO,KAAK,aAA3C,EAA0D;AACtD,QAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,KAAK,KAAK,CAAnC,IAAwC,OAAO,MAAP,KAAkB,UAA9D,EAA0E;AACtE,aAAO,IAAP;AACH;AACJ;;AACD,MAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,KAAK,KAAK,CAAnC,IAAwC,MAAM,KAAK,cAAvD,EAAuE;AACnE,QAAI,cAAc,CAAC,cAAf,CAA8B,OAA9B,CAAJ,EAA4C;AACxC,aAAO,IAAP;AACH;AACJ;;AACD,MAAI,MAAM,KAAK,IAAX,IAAmB,MAAM,KAAK,KAAK,CAAnC,IAAwC,MAAM,KAAK,cAAvD,EAAuE;AACnE;AACA,QAAI,GAAG,GAAQ,cAAf;;AACA,WAAO,GAAP,EAAY;AACR,UAAI,GAAG,CAAC,cAAJ,CAAmB,OAAnB,CAAJ,EAAiC;AAC7B,eAAO,IAAP;AACH;;AACD,SAAG,GAAG,GAAG,CAAC,SAAV;AACH;AACJ;;AACD,MAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AAC9B,QAAI,CAAC,MAAM,CAAC,cAAP,CAAsB,OAAtB,CAAL,EAAqC;AACjC;AACA,aAAO,IAAP;AACH;AACJ;;AACD,SAAO,KAAP;AACH;AAGK,SAAU,GAAV,CAAc,CAAd,EAAsB,GAAtB,EAA8B;AAChC,SACI,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,KAAK,CAAzB,GAA6B,CAA7B,GAAiC,GADrC;AAGH;AAGK,SAAU,IAAV,CAAe,CAAf,EAAuB,CAAvB,EAA2C,GAA3C,EAAmD;AACrD,SACI,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,KAAK,CAAzB,GAA6B,CAAC,CAAC,CAAD,CAA9B,GAAoC,GADxC;AAGH,C;;;;;;;;;;;;ACxED;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;CAgCA;;AACM,SAAU,MAAV,CAAiB,EAAjB,EAAoC,GAAG,KAAvC,EAAsD;AACxD,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,QAAL;AACI;AACI,cAAM,OAAO,GAA4B,EAAzC;;AACA,aAAK,MAAM,IAAX,IAAmB,KAAnB,EAA0B;AACtB,gBAAM,MAAM,GAAG,EAAE,CAAC,OAAH,CAAW,IAAX,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,IAA9B,CAAf;;AACA,cAAI,MAAJ,EAAY;AACR,gBAAI,MAAM,CAAC,CAAD,CAAV,EAAe;AACX,oBAAM,EAAE,GAA0B,CAAC,GAAG,MAAJ,CAAlC;;AACA,kBAAI,IAAI,EAAE,CAAC,MAAX,EAAmB;AACf,kBAAE,CAAC,CAAD,CAAF,GAAQ,KAAR;AACH,eAFD,MAEO;AACH,kBAAE,CAAC,MAAH,GAAY,CAAZ;AACH;;AACD,qBAAO,CAAC,IAAR,CAAa,EAAb;AACH,aARD,MAQO;AACH,qBAAO,CAAC,IAAR,CAAa,MAAb;AACH;AACJ;AACJ;;AACD,eAAQ;AACJ,cAAI,EAAE,QADF;AAEJ;AAFI,SAAR;AAIH;;AACL,SAAK,SAAL;AAAgB,SAAK,UAAL;AACZ;AACI,eAAQ;AACJ,cAAI,EAAE,UADF;AAEJ,kBAAQ,EAAE,QAFN;AAGJ,kBAAQ,EAAE,CAAC,EAAD,EAAK,GAAG,KAAR;AAHN,SAAR;AAKH;;AACL;AACI,aAAQ;AACJ,YAAI,EAAE,QADF;AAEJ,eAAO,EAAE;AAFL,OAAR;AAlCJ;AAuCH,C,CAGD;;AACM,SAAU,IAAV,CAAe,EAAf,EAAkC,GAAG,KAArC,EAAoD;AACtD,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,QAAL;AACI;AACI,cAAM,OAAO,GAA4B,EAAzC;;AACA,aAAK,MAAM,MAAX,IAAqB,EAAE,CAAC,OAAxB,EAAiC;AAC7B,cAAI,CAAE,KAAK,CAAC,IAAN,CAAW,IAAI,IAAI,MAAM,CAAC,CAAD,CAAN,KAAc,IAAjC,CAAN,EAA8C;AAC1C,gBAAI,MAAM,CAAC,CAAD,CAAV,EAAe;AACX,oBAAM,EAAE,GAA0B,CAAC,GAAG,MAAJ,CAAlC;;AACA,kBAAI,IAAI,EAAE,CAAC,MAAX,EAAmB;AACf,kBAAE,CAAC,CAAD,CAAF,GAAQ,KAAR;AACH,eAFD,MAEO;AACH,kBAAE,CAAC,MAAH,GAAY,CAAZ;AACH;;AACD,qBAAO,CAAC,IAAR,CAAa,EAAb;AACH,aARD,MAQO;AACH,qBAAO,CAAC,IAAR,CAAa,MAAb;AACH;AACJ;AACJ;;AACD,eAAQ;AACJ,cAAI,EAAE,QADF;AAEJ;AAFI,SAAR;AAIH;;AACL,SAAK,SAAL;AAAgB,SAAK,UAAL;AACZ;AACI,eAAQ;AACJ,cAAI,EAAE,UADF;AAEJ,kBAAQ,EAAE,MAFN;AAGJ,kBAAQ,EAAE,CAAC,EAAD,EAAK,GAAG,KAAR;AAHN,SAAR;AAKH;;AACL;AACI,aAAQ;AACJ,YAAI,EAAE,QADF;AAEJ,eAAO,EAAE;AAFL,OAAR;AAjCJ;AAsCH,C,CAGD;;AACM,SAAU,OAAV,CAAkB,EAAlB,EAAmC;AACrC,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,QAAL;AACI;AACI,cAAM,OAAO,GAA4B,EAAzC;;AACA,aAAK,MAAM,MAAX,IAAqB,EAAE,CAAC,OAAxB,EAAiC;AAC7B,cAAI,CAAC,GAA0B,MAAM,CAAC,CAAD,CAAN,CAAU,IAAV,KAAmB,UAAnB,GAC3B,MAD2B,GAE3B,CAAC,MAAM,CAAC,CAAD,CAAP,EAAY,QAAQ,CAAC,MAAM,CAAC,CAAD,CAAP,CAApB,EAAiC,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,CAApC,CAFJ;;AAGA,cAAI,CAAC,CAAC,CAAD,CAAL,EAAU;AACN,aAAC,GAAG,CAAC,GAAG,CAAJ,CAAJ;;AACA,gBAAI,IAAI,CAAC,CAAC,MAAV,EAAkB;AACd,eAAC,CAAC,CAAD,CAAD,GAAO,KAAP;AACH,aAFD,MAEO;AACH,eAAC,CAAC,MAAF,GAAW,CAAX;AACH;AACJ;;AACD,WAAC,CAAC,CAAD,CAAD,CAAK,IAAL,GAAY,CAAC,CAAC,CAAD,CAAb;AACA,gBAAM,KAAK,qBAAQ,CAAC,CAAC,CAAD,CAAD,CAA2B,QAAnC,CAAX;AACC,WAAC,CAAC,CAAD,CAAD,CAA2B,QAA3B,GAAsC,KAAtC;;AACD,cAAI,KAAK,CAAC,IAAN,IAAc,KAAK,CAAC,IAAN,KAAe,KAAK,CAAC,QAAvC,EAAiD;AAC7C,mBAAO,KAAK,CAAC,IAAb;AACH;;AACD,cAAI,CAAC,KAAK,CAAC,IAAP,IAAe,KAAK,CAAC,QAAzB,EAAmC;AAC/B,iBAAK,CAAC,IAAN,GAAa,KAAK,CAAC,QAAnB;AACH;;AACD,iBAAO,CAAC,IAAR,CAAa,CAAb;AACH;;AACD,eAAQ;AACJ,cAAI,EAAE,QADF;AAEJ;AAFI,SAAR;AAIH;;AACL,SAAK,SAAL;AAAgB,SAAK,UAAL;AACZ;AACI,eAAQ;AACJ,cAAI,EAAE,UADF;AAEJ,kBAAQ,EAAE,SAFN;AAGJ,kBAAQ,EAAE,CAAC,EAAD;AAHN,SAAR;AAKH;;AACL;AACI,aAAO,EAAP;AAzCJ;AA2CH,C,CAGD;;AACM,SAAU,SAAV,CAAoB,GAAG,KAAvB,EAA6C;AAC/C,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAM,IAAI,KAAJ,CAAU,yCAAV,CAAN;AACH;;AACD,MAAI,IAAI,KAAK,CAAC,MAAN,CAAa,CAAC,IAAI,CAAC,IAAI,OAAO,CAAP,KAAa,QAAlB,KACjB,CAAC,CAAC,IAAF,KAAW,SAAX,IAAwB,CAAC,CAAC,IAAF,KAAW,UADlB,CAAlB,EACiD,MADzD,EACiE;AAC7D,WAAQ;AACJ,UAAI,EAAE,UADF;AAEJ,cAAQ,EAAE,WAFN;AAGJ,cAAQ,EAAE,KAAK,CAAC,KAAN;AAHN,KAAR;AAKH;;AACD,MAAI,MAAM,GAAyB,IAAnC;AACA,QAAM,OAAO,GAAG,IAAI,GAAJ,EAAhB;;AAEA,OAAK,MAAM,EAAX,IAAiB,KAAjB,EAAwB;AACpB,QAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAAxB,EAAkC;AAC9B,UAAI,MAAM,IAAI,MAAM,CAAC,IAAP,KAAgB,EAAE,CAAC,IAAjC,EAAuC;AACnC,eAAQ;AACJ,cAAI,EAAE;AADF,SAAR;AAGH;;AACD,YAAM,GAAG,EAAT;;AACA,UAAI,EAAE,CAAC,IAAH,KAAY,QAAhB,EAA0B;AACtB,aAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,OAAnB,EAA4B;AACxB,cAAI,CAAC,CAAC,CAAD,CAAL,EAAU;AACN,kBAAM,EAAE,GAA0B,CAAC,GAAG,CAAJ,CAAlC;;AACA,gBAAI,IAAI,EAAE,CAAC,MAAX,EAAmB;AACf,gBAAE,CAAC,CAAD,CAAF,GAAQ,KAAR;AACH,aAFD,MAEO;AACH,gBAAE,CAAC,MAAH,GAAY,CAAZ;AACH;;AACD,mBAAO,CAAC,GAAR,CAAY,CAAC,CAAC,CAAD,CAAb,EAAkB,EAAlB,EAPM,CAOiB;AAC1B,WARD,MAQO;AACH,mBAAO,CAAC,GAAR,CAAY,CAAC,CAAC,CAAD,CAAb,EAAkB,CAAlB,EADG,CACoB;AAC1B;AACJ;AACJ;AACJ,KAtBD,MAsBO;AACH,aAAQ;AACJ,YAAI,EAAE;AADF,OAAR;AAGH;AACJ;;AACD,MAAI,MAAM,IAAI,MAAM,CAAC,IAAP,KAAgB,QAA9B,EAAwC;AACpC,WAAO,MAAP;AACH,GAFD,MAEO;AACH,WAAQ;AACJ,UAAI,EAAE,QADF;AAEJ,aAAO,EAAE,KAAK,CAAC,IAAN,CAAW,OAAO,CAAC,MAAR,EAAX;AAFL,KAAR;AAIH;AACJ,C,CAGD;;AACM,SAAU,KAAV,CAAgB,GAAG,KAAnB,EAAoE;AACtE,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAM,IAAI,KAAJ,CAAU,kCAAV,CAAN;AACH;;AACD,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAM,EAAE,GAAG,KAAK,CAAC,CAAD,CAAhB;;AACA,QAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAAxB,EAAkC;AAC9B,aAAO,EAAP;AACH,KAFD,MAEO;AACH,aAAO,cAAc,CAAC,EAAD,CAArB;AACH;AACJ;;AACD,QAAM,GAAG,GAAmB;AACxB,QAAI,EAAE,QADkB;AAExB,SAAK,EAAE;AAFiB,GAA5B;;AAIA,OAAK,MAAM,EAAX,IAAiB,KAAjB,EAAwB;AACpB;AACA,QAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAAxB,EAAkC;AAC9B,UAAI,EAAE,CAAC,IAAH,KAAY,QAAhB,EAA0B;AACtB,WAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,KAAJ,CAAU,MAAV,CAAiB,EAAE,CAAC,KAApB,CAAZ;AACH,OAFD,MAEO;AACH,WAAG,CAAC,KAAJ,CAAU,IAAV,CAAe,EAAf;AACH;AACJ,KAND,MAMO;AACH,SAAG,CAAC,KAAJ,CAAU,IAAV,CAAe,cAAc,CAAC,EAAD,CAA7B;AACH;AACJ;;AACD,SAAO,GAAP;AACH,C,CAGD;;AACM,SAAU,QAAV,CAAmB,GAAG,KAAtB,EAA4C;AAC9C,MAAI,KAAK,CAAC,MAAN,KAAiB,CAArB,EAAwB;AACpB,UAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;AACH;;AACD,MAAI,IAAI,KAAK,CAAC,MAAN,CAAa,CAAC,IAAI,CAAC,IAAI,OAAO,CAAP,KAAa,QAAlB,KACjB,CAAC,CAAC,IAAF,KAAW,SAAX,IAAwB,CAAC,CAAC,IAAF,KAAW,UADlB,CAAlB,EACiD,MADzD,EACiE;AAC7D,WAAQ;AACJ,UAAI,EAAE,UADF;AAEJ,cAAQ,EAAE,UAFN;AAGJ,cAAQ,EAAE,KAAK,CAAC,KAAN;AAHN,KAAR;AAKH;;AACD,MAAI,GAAG,GAAG,KAAK,CAAC,CAAD,CAAf;;AACA,MAAI,CAAC,GAAD,IAAQ,OAAO,GAAP,KAAe,QAAvB,IAAmC,GAAG,CAAC,IAAJ,KAAa,QAApD,EAA8D;AAC1D,UAAM,IAAI,KAAJ,CAAU,yDAAV,CAAN;AACH;;AACD,OAAK,MAAM,EAAX,IAAiB,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAjB,EAAiC;AAC7B,QAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAApB,IAAgC,EAAE,CAAC,IAAH,KAAY,QAAhD,EAA0D;AACtD,SAAG,GAAG,IAAI,CAAC,GAAD,EAAM,GAAG,EAAE,CAAC,OAAH,CAAW,GAAX,CAAe,CAAC,IAAI,CAAC,CAAC,CAAD,CAArB,CAAT,CAAV;AACH;AACJ;;AACD,SAAO,GAAP;AACH;AAGK,SAAU,SAAV,CAAoB,QAApB,EAG0D;AAE5D,UAAQ,QAAR;AACA,SAAK,OAAL;AACI,aAAQ;AACJ,YAAI,EAAE;AADF,OAAR;;AAGJ,SAAK,KAAL;AACI,aAAQ;AACJ,YAAI,EAAE;AADF,OAAR;;AAGJ,SAAK,SAAL;AACI,aAAQ;AACJ,YAAI,EAAE;AADF,OAAR;;AAGJ,SAAK,QAAL,CAbA,CAcI;;AACJ,SAAK,SAAL,CAfA,CAgBI;;AACJ,SAAK,QAAL,CAjBA,CAkBI;;AACJ,SAAK,QAAL,CAnBA,CAoBI;;AACJ,SAAK,SAAL,CArBA,CAsBI;;AACJ,SAAK,MAAL,CAvBA,CAwBI;;AACJ,SAAK,WAAL;AACI,aAAQ;AACJ,YAAI,EAAE,WADF;AAEJ,qBAAa,EAAE;AAFX,OAAR;;AAIJ,SAAK,QAAL;AACI,aAAQ,QAAQ,CAAC;AACb,YAAI,EAAE;AADO,OAAD,CAAhB;;AAGJ,SAAK,MAAL;AACI,aAAQ,QAAQ,CAAC;AACb,YAAI,EAAE;AADO,OAAD,CAAhB;;AAGJ,SAAK,UAAL;AACI,aAAQ,QAAQ,CAAC;AACb,YAAI,EAAE;AADO,OAAD,CAAhB;;AAGJ,SAAK,SAAL,CA1CA,CA2CI;;AACJ,SAAK,UAAL,CA5CA,CA6CI;;AACJ,SAAK,SAAL,CA9CA,CA+CI;;AACJ,SAAK,SAAL,CAhDA,CAiDI;;AACJ,SAAK,UAAL,CAlDA,CAmDI;;AACJ,SAAK,OAAL,CApDA,CAqDI;;AACJ,SAAK,YAAL;AACI,aAAQ,QAAQ,CAAC;AACb,YAAI,EAAE,WADO;AAEb,qBAAa,EAAE,QAAQ,CAAC,SAAT,CAAmB,CAAnB,EAAsB,QAAQ,CAAC,MAAT,GAAkB,CAAxC;AAFF,OAAD,CAAhB;;AAIJ;AACI,YAAM,IAAI,KAAJ,CAAU,qCAAqC,QAAQ,EAAvD,CAAN;AA5DJ,GAF4D,CAgE5D;;AACH;AAGK,SAAU,uBAAV,CAAkC,OAAlC,EAAiD;AACnD,SAAQ;AACJ,QAAI,EAAE,WADF;AAEJ,iBAAa,EAAE,QAFX;AAGJ;AAHI,GAAR;AAKH;AAGK,SAAU,cAAV,CAAyB,KAAzB,EAAmD;AACrD,MAAI,KAAK,KAAK,IAAV,IAAkB,KAAK,KAAK,KAAK,CAArC,EAAwC;AACpC,WAAQ;AACJ,UAAI,EAAE,iBADF;AAEJ;AAFI,KAAR;AAIH,GALD,MAKO,QAAQ,OAAO,KAAf;AACP,SAAK,QAAL,CADO,CAEH;;AACJ,SAAK,QAAL,CAHO,CAIH;;AACJ,SAAK,QAAL,CALO,CAMH;;AACJ,SAAK,SAAL;AACI,aAAQ;AACJ,YAAI,EAAE,iBADF;AAEJ;AAFI,OAAR;;AAIJ;AACI,YAAM,IAAI,KAAJ,CAAU,sCAAsC,KAAK,EAArD,CAAN;AAbG;AAeV;AAGK,SAAU,QAAV,CAAmB,EAAnB,EAA0D;AAC5D,MAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAApB,IAAgC,EAAE,CAAC,IAAvC,EAA6C;AACzC,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,aAAO,EAAP;AACH,KAFD,MAEO;AACH,aAAO;AACH,YAAI,EAAE,UADH;AAEH,gBAAQ,EAAE;AAFP,SAGC,EAAE,CAAC,QAAH,GAAc;AAAC,gBAAQ,EAAE,EAAE,CAAC;AAAd,OAAd,GAAwC,EAHzC,CAAP;AAKH;AACJ,GAVD,MAUO;AACH,WAAQ;AACJ,UAAI,EAAE,UADF;AAEJ,cAAQ,EAAE,cAAc,CAAC,EAAD;AAFpB,KAAR;AAIH;AACJ;AAGK,SAAU,QAAV,CACE,EADF,EAC+C,MAD/C,EAE0E;AAC5E,MAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAApB,IAAgC,EAAE,CAAC,IAAvC,EAA6C;AACzC,WAAQ;AACJ,UAAI,EAAE,UADF;AAEJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAFzD;AAGJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAHzD;AAIJ,cAAQ,EAAE;AAJN,KAAR;AAMH,GAPD,MAOO;AACH,WAAQ;AACJ,UAAI,EAAE,UADF;AAEJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAFzD;AAGJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAHzD;AAIJ,cAAQ,EAAE,SAAS,CAAC,EAAD;AAJf,KAAR;AAMH;AACJ;AAGK,SAAU,UAAV,CAAqB,GAAG,GAAxB,EAAuE;AACzE,SAAQ;AACJ,QAAI,EAAE,UADF;AAEJ,YAAQ,EAAE,GAAG,CAAC,GAAJ,CAAQ,EAAE,IAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAApB,IAAgC,EAAE,CAAC,IAAnC,GAA0C,EAA1C,GAA+C,cAAc,CAAC,EAAD,CAA3E;AAFN,GAAR;AAIH;AAGK,SAAU,MAAV,CACE,EADF,EAEE,MAFF,EAE+E;AACjF,MAAI,EAAE,IAAI,OAAO,EAAP,KAAc,QAApB,IAAgC,EAAE,CAAC,IAAvC,EAA6C;AACzC,WAAQ;AACJ,UAAI,EAAE,QADF;AAEJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAFzD;AAGJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAHzD;AAIJ,YAAM,EAAE;AAJJ,KAAR;AAMH,GAPD,MAOO;AACH,WAAQ;AACJ,UAAI,EAAE,QADF;AAEJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAFzD;AAGJ,SAAG,EAAE,MAAM,IAAI,OAAO,MAAM,CAAC,GAAd,KAAsB,QAAhC,GAA2C,MAAM,CAAC,GAAlD,GAAwD,IAHzD;AAIJ,YAAM,EAAE,cAAc,CAAC,EAAD;AAJlB,KAAR;AAMH;AACJ;AAGK,SAAU,QAAV,CAAmB,GAAG,MAAtB,EAA8E;AAChF,QAAM,EAAE,GAAG,MAAM,CAAC,KAAP,EAAX;AACA,MAAI,KAAK,GAAG,CAAZ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,EAAE,CAAC,MAAvB,EAA+B,CAAC,EAAhC,EAAoC;AAChC,QAAI,kEAAgB,CAAC,2DAAD,EAAoB,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,CAApB,CAApB,EAAmD;AAC/C,YAAM,IAAI,KAAJ,CAAU,qDAAqD,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,CAAQ,EAAvE,CAAN;AACH;;AAED,QAAI,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,MAAa,IAAb,IAAqB,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,MAAa,KAAK,CAA3C,EAA8C;AAC1C,QAAE,CAAC,CAAD,CAAF,CAAM,CAAN,IAAW,KAAK,EAAhB;AACH,KAFD,MAEO,IAAI,OAAO,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,CAAP,KAAoB,QAAxB,EAAkC;AACrC,WAAK,GAAI,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,IAAsB,CAA/B;AACH;;AACD,QAAI,CAAE,EAAE,CAAC,CAAD,CAAF,CAAM,CAAN,CAAN,EAAgB;AACZ,QAAE,CAAC,CAAD,CAAF,CAAM,MAAN,GAAe,CAAf;AACH;AACJ;;AACD,SAAQ;AACJ,QAAI,EAAE,MADF;AAEJ,UAAM,EAAE;AAFJ,GAAR;AAIH;AAGK,SAAU,UAAV,CACE,GAAG,OADL,EAKI;AACN,QAAM,UAAU,GAAG,OAAO,CAAC,KAAR,GAAgB,OAAhB,EAAnB;;AACA,OAAK,MAAM,CAAX,IAAgB,OAAhB,EAAyB;AACrB,QAAI,OAAO,CAAC,CAAC,CAAD,CAAR,KAAgB,QAApB,EAA8B;AAC1B,UAAI,kEAAgB,CAAC,2DAAD,EAAoB,CAAC,CAAC,CAAD,CAArB,CAApB,EAA+C;AAC3C,cAAM,IAAI,KAAJ,CAAU,uDAAuD,CAAC,CAAC,CAAD,CAAG,EAArE,CAAN;AACH;;AACD,UAAI,OAAO,CAAC,IAAR,CAAa,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAA5B,MAAqC,UAAU,CAAC,IAAX,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAA/B,CAAzC,EAA8E;AAC1E,cAAM,IAAI,KAAJ,CAAU,+BAA+B,CAAC,CAAC,CAAD,CAAG,EAA7C,CAAN;AACH;AACJ;AACJ;;AAED,QAAM,YAAY,GAA6B,OAAO,CACjD,MAD0C,CAEvC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAD,CAAR,KAAgB,QAFkB,EAI1C,GAJ0C,CAKvC,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,IAAQ,OAAO,CAAC,CAAC,CAAD,CAAR,KAAgB,QAAxB,IAAoC,CAAC,CAAC,CAAD,CAAD,CAAK,IAAzC,GACD,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,QAAQ,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,CAAf,EAA6B,CAAC,CAAC,CAAD,CAA9B,CADC,GAED,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,QAAQ,CAAC,cAAc,CAAC,CAAC,CAAC,CAAD,CAAF,CAAf,EAAuB,CAAC,CAAC,CAAD,CAAxB,CAAf,EAA6C,CAAC,CAAC,CAAD,CAA9C,CAPmC,EAQ1C,GAR0C,CASvC,CAAC,IAAK,CAAC,CAAC,CAAD,CAAD,GACF,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,EAAa,KAAb,EAAoB,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAvB,CADE,GAEF,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,CAXmC,CAA/C;AAaA,QAAM,eAAe,GAA6B,OAAO,CACpD,MAD6C,CACtC,CAAC,IAAI,OAAO,CAAC,CAAC,CAAD,CAAR,KAAgB,QADiB,EAM7C,GAN6C,CAMzC,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,IAAQ,OAAO,CAAC,CAAC,CAAD,CAAR,KAAgB,QAAxB,IAAoC,CAAC,CAAC,CAAD,CAAD,CAAK,IAAzC,GACN,CADM,GAEN,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,cAAc,CAAC,CAAC,CAAC,CAAD,CAAF,CAArB,EAA6B,CAAC,CAAC,CAAD,CAA9B,CAR0C,EAS7C,GAT6C,CAU1C,CAAC,IAAK,CAAC,CAAC,CAAD,CAAD,GACF,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,EAAa,KAAb,EAAoB,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAvB,CADE,GAEF,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,CAZsC,CAAlD;AAcA,SAAO,cACA;AACC,QAAI,EAAE,QADP;AAEC,WAAO,EAAE;AAFV,GADA,EAKC,IAAI,eAAe,CAAC,MAApB,GAA6B;AAC7B;AAD6B,GAA7B,GAEA,EAPD,CAAP;AASH;;AAGD,SAAS,qBAAT,CAA+B,EAA/B,EAAoD,IAApD,EAA4F;AACxF,MAAI,EAAE,KAAK,IAAX,EAAiB;AACb,WAAO,KAAP;AACH;;AACD,MAAI,EAAE,CAAC,QAAH,KACC,EAAE,CAAC,QAAH,KAAgB,IAAI,CAAC,QAArB,IACC,IAAI,CAAC,IAAL,KAAc,SAAd,IAA2B,EAAE,CAAC,QAAH,KAAgB,IAAI,CAAC,iBAFlD,CAAJ,EAE2E;AACvE,WAAO,KAAP;AACH;;AACD,MAAI,IAAI,CAAC,IAAL,KAAc,QAAd,IAA0B,IAAI,CAAC,SAAnC,EAA8C;AAC1C,SAAK,MAAM,CAAX,IAAgB,IAAI,CAAC,SAArB,EAAgC;AAC5B,UAAI,CAAE,qBAAqB,CAAC,EAAD,EAAK,CAAL,CAA3B,EAAoC;AAChC,eAAO,KAAP;AACH;AACJ;AACJ;;AACD,SAAO,IAAP;AACH;;AAGK,SAAU,OAAV,CAAkB,EAAlB,EAAuC,GAAG,IAA1C,EAA+D;AACjE,QAAM,GAAG,GAAoB;AACzB,QAAI,EAAE,QADmB;AAEzB,WAAO,EAAE,EAFgB;AAGzB,aAAS,EAAE;AAHc,GAA7B;;AAMA,OAAK,MAAM,GAAX,IAAkB,IAAlB,EAAwB;AACpB,YAAQ,GAAG,CAAC,IAAZ;AACA,WAAK,QAAL;AACI,YAAI,CAAE,qBAAqB,CAAC,EAAD,EAAK,GAAL,CAA3B,EAAsC;AAClC,gBAAM,IAAI,KAAJ,CAAU,8BAA8B,EAAE,CAAC,IAAH,IAAW,WAAW,EAA9D,CAAN;AACH;;AACD,aAAK,MAAM,CAAX,IAAgB,GAAG,CAAC,OAApB,EAA6B;AACzB,cAAI,CAAE,GAAG,CAAC,OAAJ,CAAY,IAAZ,CAAiB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAhC,CAAN,EAA4C;AACxC,eAAG,CAAC,OAAJ,CAAY,IAAZ,CAAiB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,EAAa,IAAb,EAAmB,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAtB,CAAjB;AACH,WAHwB,CAIzB;;AACH;;AACL;;AACA,WAAK,SAAL;AACK,WAAG,CAAC,SAAJ,CAA4D,IAA5D,CAAiE,GAAjE;AACD;;AACJ,WAAK,UAAL;AACI;AACI,gBAAM,IAAI,KAAJ,CAAU,sCAAsC,GAAG,CAAC,QAAQ,EAA5D,CAAN;AACH;AAlBL,KADoB,CAqBpB;AACA;;AACH;;AACD,KAAG,CAAC,OAAJ,GAAc,EAAE,CAAC,OAAH,CAAW,MAAX,CAAkB,GAAG,CAAC,OAAtB,CAAd;;AACA,MAAI,EAAE,CAAC,SAAP,EAAkB;AACd,OAAG,CAAC,SAAJ,GAAgB,EAAE,CAAC,SAAH,CACX,MADW,CACJ,CAAC,IAAI,CAAC,CAAC,IAAF,KAAW,SADZ,EAEX,MAFW,CAEJ,GAAG,CAAC,SAFA,CAAhB;AAGH;;AACD,MAAK,GAAG,CAAC,SAAJ,CAA4D,MAA5D,KAAuE,CAA5E,EAA+E;AAC3E,WAAO,GAAG,CAAC,SAAX;AACH;;AAED,QAAM,UAAU,GAAG,GAAG,CAAC,OAAJ,CAAY,KAAZ,GAAoB,OAApB,EAAnB;;AACA,OAAK,MAAM,CAAX,IAAgB,GAAG,CAAC,OAApB,EAA6B;AACzB,QAAI,GAAG,CAAC,OAAJ,CAAY,IAAZ,CAAiB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAAhC,MAAyC,UAAU,CAAC,IAAX,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAA/B,CAA7C,EAAkF;AAC9E,YAAM,IAAI,KAAJ,CAAU,+BAA+B,CAAC,CAAC,CAAD,CAAG,OAAO,EAAE,CAAC,IAAH,IAAW,WAAW,EAA1E,CAAN;AACH;AACJ;;AAED,MAAI,eAAe,GAA4B,EAA/C;;AACA,MAAI,GAAG,CAAC,SAAR,EAAmB;AACf,SAAK,MAAM,IAAX,IAAmB,GAAG,CAAC,SAAvB,EAAkC;AAC9B,UAAI,IAAI,CAAC,IAAL,KAAc,QAAlB,EAA4B;AACxB,YAAI,IAAI,CAAC,eAAL,IAAwB,IAAI,IAAI,CAAC,eAAL,CAAqB,MAArD,EAA6D;AACzD,yBAAe,GAAG,eAAe,CAAC,MAAhB,CACd,IAAI,CAAC,eAAL,CAAqB,GAArB,CAAyB,CAAC,IACtB,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,CAAC,CAAC,CAAD,CAAR,EAAa,IAAb,EAAmB,GAAG,CAAC,CAAC,KAAF,CAAQ,CAAR,CAAtB,CADJ,CADc,CAAlB;AAGH;AACJ,OAP6B,CAQ9B;AACA;;AACH;AACJ;;AACD,MAAI,EAAE,CAAC,eAAH,IAAsB,IAAI,EAAE,CAAC,eAAH,CAAmB,MAAjD,EAAyD;AACrD,mBAAe,GAAG,eAAe,CAAC,MAAhB,CAAuB,EAAE,CAAC,eAA1B,CAAlB,CADqD,CACS;AACjE;;AACD,MAAI,IAAI,eAAe,CAAC,MAAxB,EAAgC;AAC5B,OAAG,CAAC,eAAJ,GAAsB,eAAtB;AACH;;AAED,SAAO,GAAP;AACH;AAGK,SAAU,WAAV,CAAsB,IAAtB,EAAkC;AACpC,SAAQ;AACJ,QAAI,EAAE,SADF;AAEJ,qBAAiB,EAAE;AAFf,GAAR;AAIH;AAGK,SAAU,QAAV,CAAmB,EAAnB,EAAsC,IAAtC,EAAkD;AACpD,MAAI,CAAE,IAAN,EAAY;AACR,WAAO,EAAP;AACH;;AACD,SAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,GAAP,CAAP;AACH;AAGK,SAAU,YAAV,CAAuB,EAAvB,EAA0C,QAA1C,EAA0D;AAC5D,MAAI,CAAE,QAAN,EAAgB;AACZ,WAAO,EAAP;AACH;;AACD,SAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,GAAP,CAAP;AACH;AAGK,SAAU,oBAAV,CAA+B,EAA/B,EAAkD,gBAAlD,EAA0E;AAC5E,MAAI,CAAE,gBAAN,EAAwB;AACpB,WAAO,EAAP;AACH;;AACD,SAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,GAAP,CAAP;AACH;AAGK,SAAU,cAAV,CAAyB,EAAzB,EAA4C,UAA5C,EAA8D;AAChE,MAAI,CAAE,UAAN,EAAkB;AACd,WAAO,EAAP;AACH;;AACD,SAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,GAAP,CAAP;AACH;AAGK,SAAU,SAAV,CAAoB,QAApB,EAA+C,QAA/C,EAAwE;AAC1E,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,QAAP,KAAoB,QAApB,IAAgC,OAAO,QAAP,KAAoB,QAAxD,EAAkE;AAC9D,YAAM,IAAI,KAAJ,CAAU,qEAAV,CAAN;AACH;;AACD,QAAI,OAAO,QAAP,KAAoB,QAApB,IAAgC,OAAO,QAAP,KAAoB,QAAxD,EAAkE;AAC9D,YAAM,IAAI,KAAJ,CAAU,qEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,0EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE,kBAAF;AAAY;AAAZ,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,0EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAF;AAAY;AAAZ,OAAP,CAAP;AACH;AACJ,GAnBD;AAoBH;AAGK,SAAU,YAAV,CAAuB,QAAvB,EAAgD;AAClD,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,QAAP,KAAoB,QAApB,IAAgC,OAAO,QAAP,KAAoB,QAAxD,EAAkE;AAC9D,YAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,YAAV,CAAuB,QAAvB,EAAgD;AAClD,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,QAAP,KAAoB,QAApB,IAAgC,OAAO,QAAP,KAAoB,QAAxD,EAAkE;AAC9D,YAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,eAAV,CAA0B,gBAA1B,EAA2D;AAC7D,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,gBAAP,KAA4B,QAA5B,IAAwC,OAAO,gBAAP,KAA4B,QAAxE,EAAkF;AAC9E,YAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,gFAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,gFAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,YAAV,CAAuB,aAAvB,EAAqD;AACvD,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,aAAP,KAAyB,QAAzB,IAAqC,OAAO,aAAP,KAAyB,QAAlE,EAA4E;AACxE,YAAM,IAAI,KAAJ,CAAU,wEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,6EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,aAAV,CAAwB,SAAxB,EAAyC;AAC3C,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,aAAV,CAAwB,SAAxB,EAAyC;AAC3C,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,YAAM,IAAI,KAAJ,CAAU,gEAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAvB,EAAoC;AAChC,cAAM,IAAI,KAAJ,CAAU,8EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,SAAV,CAAoB,OAApB,EAAmC;AACrC,SAAQ,EAAD,IAA+B;AAClC,QAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC7B,YAAM,IAAI,KAAJ,CAAU,0DAAV,CAAN;AACH;;AACD,QAAK,EAAoB,CAAC,IAArB,KAA8B,UAAnC,EAA+C;AAC3C,YAAM,GAAG,GAAI,EAA+B,CAAC,QAA7C;;AACA,UAAI,GAAG,CAAC,IAAJ,KAAa,WAAjB,EAA8B;AAC1B,cAAM,IAAI,KAAJ,CAAU,0EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE,gBAAQ,kCAAM,GAAN,GAAS;AAAE;AAAF,SAAT;AAAV,OAAP,CAAP;AACH,KAND,MAMO;AACH,UAAI,CAAC,EAAD,IAAO,EAAE,CAAC,IAAH,KAAY,WAAnB,IAAkC,EAAE,CAAC,aAAH,KAAqB,QAA3D,EAAqE;AACjE,cAAM,IAAI,KAAJ,CAAU,0EAAV,CAAN;AACH;;AACD,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAhBD;AAiBH;AAGK,SAAU,cAAV,CAAkD,UAAlD,EAAoE;AACtE,MAAI,OAAO,UAAP,KAAsB,QAA1B,EAAoC;AAChC,UAAM,IAAI,KAAJ,CAAU,kEAAV,CAAN;AACH;;AACD,MAAI,kEAAgB,CAAC,2DAAD,EAAoB,UAApB,CAApB,EAAqD;AACjD,UAAM,IAAI,KAAJ,CAAU,2DAA2D,UAAU,EAA/E,CAAN;AACH;;AACD,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,gBAAQ,kCACA,EAAwB,CAAC,QADzB,GACiC;AACrC;AADqC,SADjC;AADH,OADM,CAAf;AAOA,aAAO,GAAP;AACH,KATD,MASO;AACH,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL;AADK,OADM,CAAf;AAIA,aAAO,GAAP;AACH;AACJ,GAjBD;AAkBH;AAGK,SAAU,cAAV,CAAkD,IAAlD,EAAgE,IAAhE,EAA0E;AAC5E,MAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,UAAM,IAAI,KAAJ,CAAU,4DAAV,CAAN;AACH;;AACD,MAAI,kEAAgB,CAAC,2DAAD,EAAoB,IAApB,CAApB,EAA+C;AAC3C,UAAM,IAAI,KAAJ,CAAU,2DAA2D,IAAI,EAAzE,CAAN;AACH;;AACD,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,YAAM,GAAG,GAAI,EAAwB,CAAC,QAAtC;AACA,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,gBAAQ,kCACD,GADC,GACE;AACN,2BAAiB,EAAE,GAAG,CAAC,iBAAJ,GACb,GAAG,CAAC,iBAAJ,CAAsB,KAAtB,GAA8B,IAA9B,CAAmC,IAAnC,CADa,GAEb,CAAC,IAAD,CAHA;AAIN,+BAAqB,EAAE,GAAG,CAAC,qBAAJ,GAClB,gCAAK,GAAG,CAAC,qBAAT,GAA8B;AAAE,aAAC,IAAD,GAAQ;AAAV,WAA9B,CADkB,GAEjB;AAAC,aAAC,IAAD,GAAQ;AAAT;AANA,SADF;AADH,OADM,CAAf;AAYA,aAAO,GAAP;AACH,KAfD,MAeO;AACH,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,yBAAiB,EAAE,EAAE,CAAC,iBAAH,GACb,EAAE,CAAC,iBAAH,CAAqB,KAArB,GAA6B,IAA7B,CAAkC,IAAlC,CADa,GAEb,CAAC,IAAD,CAHD;AAIL,6BAAqB,EAAE,EAAE,CAAC,qBAAH,GAClB,gCAAK,EAAE,CAAC,qBAAR,GAA6B;AAAE,WAAC,IAAD,GAAQ;AAAV,SAA7B,CADkB,GAEjB;AAAC,WAAC,IAAD,GAAQ;AAAT;AAND,OADM,CAAf;AASA,aAAO,GAAP;AACH;AACJ,GA5BD;AA6BH;AAGK,SAAU,aAAV,GAAuB;AACzB,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,gBAAQ,kCACA,EAAwB,CAAC,QADzB,GACiC;AACrC,mBAAS,EAAE;AAD0B,SADjC;AADH,OADM,CAAf;AAOA,aAAO,GAAP;AACH,KATD,MASO;AACH,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,iBAAS,EAAE;AADN,OADM,CAAf;AAIA,aAAO,GAAP;AACH;AACJ,GAjBD;AAkBH;AAGK,SAAU,cAAV,GAAwB;AAC1B,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,gBAAQ,kCACA,EAAwB,CAAC,QADzB,GACiC;AACrC,2BAAiB,EAAE;AADkB,SADjC;AADH,OADM,CAAf;AAOA,aAAO,GAAP;AACH,KATD,MASO;AACH,YAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL,yBAAiB,EAAE;AADd,OADM,CAAf;AAIA,aAAO,GAAP;AACH;AACJ,GAjBD;AAkBH;AAGK,SAAU,QAAV,CAA4C,IAA5C,EAAqD;AACvD,SAAQ,EAAD,IAAU;AACb,UAAM,GAAG,GAAM,gCACR,EADQ,GACN;AACL;AADK,KADM,CAAf;AAIA,WAAO,GAAP;AACH,GAND;AAOH;AAGK,SAAU,OAAV,CAA2C,QAA3C,EAA2E;AAC7E,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,cAAM,GAAG,GAAG,gCACL,EADK,GACH;AACL,iBAAO,EAAE,QADJ;AAEL,kBAAQ,kCAAO,EAAwB,CAAC,QAAhC,GAAwC;AAAE,mBAAO,EAAE;AAAX,WAAxC;AAFH,SADG,CAAZ;AAKA,eAAO,GAAG,CAAC,QAAX;AACA,eAAO,GAAG,CAAC,QAAJ,CAAa,QAApB;AACA,eAAO,GAAP;AACH,OATD,MASO;AACH,cAAM,GAAG,GAAG,gCACL,EADK,GACH;AACL,kBADK;AAEL,kBAAQ,kCAAO,EAAwB,CAAC,QAAhC,GAAwC;AAAE;AAAF,WAAxC;AAFH,SADG,CAAZ;AAKA,eAAO,GAAG,CAAC,OAAX;AACA,eAAO,GAAG,CAAC,QAAJ,CAAa,OAApB;AACA,eAAO,GAAP;AACH;AACJ,KApBD,MAoBO;AACH,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,cAAM,GAAG,GAAG,gCAAK,EAAL,GAAO;AAAE,iBAAO,EAAE;AAAX,SAAP,CAAZ;AACA,eAAO,GAAG,CAAC,QAAX;AACA,eAAO,GAAP;AACH,OAJD,MAIO;AACH,cAAM,GAAG,GAAG,gCAAK,EAAL,GAAO;AAAE;AAAF,SAAP,CAAZ;AACA,eAAO,GAAG,CAAC,OAAX;AACA,eAAO,GAAP;AACH;AACJ;AACJ,GAhCD;AAiCH;AAGK,SAAU,SAAV,CAA6C,SAA7C,EAA8D;AAChE,SAAQ,EAAD,IAAU;AACb,QAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,aAAO,gCACA,EADA,GACE;AACL,iBADK;AAEL,gBAAQ,kCAAO,EAAwB,CAAC,QAAhC,GAAwC;AAAE;AAAF,SAAxC;AAFH,OADF,CAAP;AAKH,KAND,MAMO;AACH,aAAO,gCAAK,EAAL,GAAO;AAAE;AAAF,OAAP,CAAP;AACH;AACJ,GAVD;AAWH,C;;;;;;;;;;;;ACt/BD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;;AAIA,SAAS,UAAT,CAAoB,KAApB,EAAgC,EAAhC,EAAiD;AAC7C,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,QAAL;AACI;AACI,cAAM,GAAG,GAAG,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,EAAvB,GAA4B,EAAxC;AAEA,cAAM,WAAW,GAAG,IAAI,GAAJ,EAApB;;AACA,YAAI,CAAE,KAAK,CAAC,OAAN,CAAc,KAAd,CAAN,EAA4B;AACxB,eAAK,MAAM,CAAX,IAAgB,KAAhB,EAAuB;AACnB,gBAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,KAArC,EAA4C,CAA5C,CAAJ,EAAoD;AAChD,yBAAW,CAAC,GAAZ,CAAgB,CAAhB;AACH;AACJ;AACJ;;AAED,aAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,OAAnB,EAA4B;AACxB,cAAI,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAA2B,KAA3B,EAAkC,CAAC,CAAC,CAAD,CAAnC,CAAJ,EAA6C;AACzC,uBAAW,CAAC,MAAZ,CAAmB,CAAC,CAAC,CAAD,CAApB;AACA,eAAG,CAAC,CAAC,CAAC,CAAD,CAAF,CAAH,GAAY,KAAK,CAAC,CAAC,CAAC,CAAD,CAAF,CAAjB;AACH;AACJ;;AACD,YAAI,EAAE,CAAC,eAAH,IAAsB,IAAI,EAAE,CAAC,eAAH,CAAmB,MAAjD,EAAyD;AACrD,oBAAU,oBAAV,GAA8B;AAC1B,iBAAK,MAAM,CAAX,IAAgB,WAAW,CAAC,MAAZ,EAAhB,EAAsC;AAClC,oBAAM,CAAN;AACH;;AACD,gBAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACtB,mBAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAAK,CAAC,MAA1B,EAAkC,CAAC,EAAnC,EAAuC;AACnC,sBAAM,MAAM,CAAC,CAAD,CAAZ;AACH;AACJ;AACJ;;AACD,eAAK,MAAM,CAAX,IAAgB,oBAAoB,EAApC,EAAwC;AACpC,eAAG,CAAC,CAAD,CAAH,GAAS,KAAK,CAAC,CAAD,CAAd;AACH;AACJ;;AACD,eAAO,GAAP;AACH;;AACL;AACI,aAAO,KAAP;AAtCJ;AAwCH;;AAGK,SAAU,QAAV,CAAsB,IAAtB,EAA+B,EAA/B,EAAkD,GAAlD,EAAwE;AAC1E,UAAQ,EAAE,CAAC,IAAX;AACA,SAAK,OAAL;AACI,YAAM,IAAI,2DAAJ,CAAoB,mBAAoB,EAAU,CAAC,IAAI,EAAvD,EAA2D,EAA3D,EAA+D,GAA/D,CAAN;;AACJ,SAAK,KAAL,CAHA,CAII;;AACJ,SAAK,SAAL,CALA,CAMI;;AACJ,SAAK,WAAL,CAPA,CAQI;;AACJ,SAAK,iBAAL,CATA,CAUI;;AACJ,SAAK,UAAL,CAXA,CAYI;;AACJ,SAAK,UAAL,CAbA,CAcI;;AACJ,SAAK,QAAL,CAfA,CAgBI;;AACJ,SAAK,MAAL,CAjBA,CAkBI;;AACJ,SAAK,QAAL;AACI;AACI,cAAM,CAAC,GAAG,2DAAQ,CAAI,IAAJ,EAAU,EAAV,EAAc,GAAd,CAAlB;;AACA,YAAI,CAAJ,EAAO;AACH,iBAAO,CAAC,CAAC,KAAT;AACH,SAFD,MAEO;AACH,gBAAM,IAAI,2DAAJ,CAAoB,oBAApB,EAA0C,EAA1C,EAA8C,GAA9C,CAAN;AACH;AACJ;;AACL,SAAK,QAAL;AAAe,SAAK,UAAL;AAAiB,SAAK,SAAL;AAAgB,SAAK,UAAL;AAC5C,YAAM,IAAI,2DAAJ,CAAoB,8BAA+B,EAAU,CAAC,IAAI,EAAlE,EAAsE,EAAtE,EAA0E,GAA1E,CAAN;;AACJ;AACI,YAAM,IAAI,2DAAJ,CAAoB,2BAA4B,EAAU,CAAC,IAAI,EAA/D,EAAmE,EAAnE,EAAuE,GAAvE,CAAN;AA/BJ;AAiCH;AAGK,SAAU,IAAV,CAAkB,IAAlB,EAA2B,EAA3B,EAA8C,GAA9C,EAA8E;AAChF,QAAM,IAAI,+BACH;AAAC,UAAM,EAAE,EAAT;AAAa,aAAS,EAAE;AAAxB,GADG,EAEF,GAAG,IAAI,EAFL,GAEQ;AACd,UAAM,EAAE;AADM,GAFR,CAAV;;AAKA,MAAI;AACA,WAAO,QAAQ,CAAI,IAAJ,EAAU,EAAV,EAAc,IAAd,CAAf;AACH,GAFD,SAEU;AACN,QAAI,GAAJ,EAAS;AACL,SAAG,CAAC,MAAJ,GAAa,IAAI,CAAC,MAAlB;AACH;AACJ;AACJ;;AAGD,SAAS,KAAT,CAAe,IAAf,EAA0B,MAA1B,EAAqC;AACjC,MAAI,IAAI,KAAK,IAAT,IAAiB,IAAI,KAAK,KAAK,CAAnC,EAAsC;AAClC,WAAO,MAAP;AACH;;AACD,UAAQ,OAAO,IAAf;AACA,SAAK,QAAL;AACI,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACrB,eAAO,CAAC,GAAG,MAAJ,CAAP;AACH,OAFD,MAEO;AACH,cAAM,CAAC,qBAAY,IAAZ,CAAP;;AACA,aAAK,MAAM,CAAX,IAAgB,MAAhB,EAAwB;AACpB,cAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,MAArC,EAA6C,CAA7C,CAAJ,EAAqD;AACjD,gBAAI,kEAAgB,CAAC,CAAD,EAAI,CAAJ,CAApB,EAA4B;AACxB;AACH;;AACD,aAAC,CAAC,CAAD,CAAD,GAAO,KAAK,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,MAAM,CAAC,CAAD,CAAb,CAAZ;AACH;AACJ;;AACD,eAAO,CAAP;AACH;;AACL;AACI,aAAO,MAAP;AAjBJ;AAmBH;;AAGK,SAAU,KAAV,CAAmB,IAAnB,EAA4B,MAA5B,EAAyC,EAAzC,EAA4D,GAA5D,EAA4F;AAC9F,QAAM,IAAI,iBACH;AAAC,UAAM,EAAE,EAAT;AAAa,aAAS,EAAE;AAAxB,GADG,EAEF,GAAG,IAAI,EAFL,CAAV;AAIA,QAAM,SAAS,GAAG,IAAI,CAAI,MAAJ,EAAY,EAAZ,EAAgB,IAAhB,CAAtB;AACA,SAAO,KAAK,CAAC,IAAD,EAAO,SAAP,CAAZ;AACH,C;;;;;;;;;;;;AChJD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAMA,MAAM,SAAS,GAAG,gCAAlB;AACA,MAAM,cAAc,GAAG,iDAAvB;;AAGA,MAAM,OAAN,SAAsB,IAAtB,CAA0B;AAOtB,cACI,IADJ,EAC4B,KAD5B,EAC4C,IAD5C,EAEI,KAFJ,EAEoB,OAFpB,EAEsC,OAFtC,EAEwD,EAFxD,EAEmE;AAE/D;;AACA,QAAI,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACjB;AACH;;AACD,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,UAAI,yDAAe,CAAC,IAAhB,CAAqB,IAArB,CAAJ,EAAgC;AAC5B;AACA,aAAK,OAAL,CAAa,IAAI,CAAC,KAAL,CAAW,IAAX,CAAb,EAF4B,CAEI;AACnC,OAHD,MAGO,IAAI,qDAAW,CAAC,IAAZ,CAAiB,IAAjB,CAAJ,EAA4B;AAC/B;AACA,cAAM,CAAC,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAV,CAF+B,CAEC;;AAChC,aAAK,OAAL,CAAa,IAAI,CAAC,GAAL,CAAS,CAAC,CAAC,cAAF,EAAT,EAA6B,CAAC,CAAC,WAAF,EAA7B,EAA8C,CAAC,CAAC,UAAF,EAA9C,CAAb;AACH,OAJM,MAIA,IAAI,6DAAmB,CAAC,IAApB,CAAyB,IAAzB,CAAJ,EAAoC;AACvC;AACA,cAAM,CAAC,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAV,CAFuC,CAEP;;AAChC,aAAK,OAAL,CAAa,IAAI,CAAC,GAAL,CAAS,CAAC,CAAC,WAAF,EAAT,EAA0B,CAAC,CAAC,QAAF,EAA1B,EAAwC,CAAC,CAAC,OAAF,EAAxC,EACT,CAAC,CAAC,QAAF,EADS,EACK,CAAC,CAAC,UAAF,EADL,EACqB,CAAC,CAAC,UAAF,EADrB,EACqC,CAAC,CAAC,eAAF,EADrC,CAAb;AAEH,OALM,MAKA;AACH,aAAK,OAAL,CAAa,GAAb;AACH;;AACD;AACH;;AAED,SAAK,UAAL,CAAgB,CAAhB;AAEA,SAAK,cAAL,CAAoB,IAApB;AACA,SAAK,WAAL,CAAiB,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,CAArD;AACA,SAAK,UAAL,CAAgB,OAAO,IAAP,KAAgB,QAAhB,GAA2B,IAA3B,GAAkC,CAAlD;AACA,SAAK,WAAL,CAAiB,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,CAArD;AACA,SAAK,aAAL,CAAmB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,CAA3D;AACA,SAAK,aAAL,CAAmB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,CAA3D;AACA,SAAK,kBAAL,CAAwB,OAAO,EAAP,KAAc,QAAd,GAAyB,EAAzB,GAA8B,CAAtD;AACH;;AAEM,aAAW;AACd,WAAO,KAAK,cAAL,EAAP;AACH;;AAEM,UAAQ;AACX,WAAO,KAAK,WAAL,EAAP;AACH;;AAEM,SAAO;AACV,WAAO,KAAK,UAAL,EAAP;AACH;;AAEM,UAAQ;AACX,WAAO,KAAK,WAAL,EAAP;AACH;;AAEM,YAAU;AACb,WAAO,KAAK,aAAL,EAAP;AACH;;AAEM,YAAU;AACb,WAAO,KAAK,aAAL,EAAP;AACH;;AAEM,iBAAe;AAClB,WAAO,KAAK,kBAAL,EAAP;AACH;;AAvEqB;;AA6E1B,MAAM,MAAN,SAAqB,IAArB,CAAyB;AAOrB,cACI,IADJ,EAC4B,KAD5B,EAC4C,IAD5C,EAEI,KAFJ,EAEoB,OAFpB,EAEsC,OAFtC,EAEwD,EAFxD,EAEmE;AAE/D;;AACA,QAAI,IAAI,KAAK,KAAK,CAAlB,EAAqB;AACjB;AACH;;AACD,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC1B,UAAI,yDAAe,CAAC,IAAhB,CAAqB,IAArB,CAAJ,EAAgC;AAC5B;AACA,aAAK,OAAL,CAAa,IAAI,CAAC,KAAL,CAAW,IAAX,CAAb,EAF4B,CAEI;AACnC,OAHD,MAGO,IAAI,qDAAW,CAAC,IAAZ,CAAiB,IAAjB,CAAJ,EAA4B;AAC/B;AACA,cAAM,CAAC,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAV,CAF+B,CAEC;;AAChC,cAAM,CAAC,GAAG,IAAI,IAAJ,CAAS,CAAC,CAAC,cAAF,EAAT,EAA6B,CAAC,CAAC,WAAF,EAA7B,EAA8C,CAAC,CAAC,UAAF,EAA9C,CAAV;AACA,aAAK,OAAL,CAAa,CAAC,CAAC,OAAF,EAAb;AACH,OALM,MAKA,IAAI,6DAAmB,CAAC,IAApB,CAAyB,IAAzB,CAAJ,EAAoC;AACvC;AACA,cAAM,CAAC,GAAG,IAAI,IAAJ,CAAS,IAAT,CAAV,CAFuC,CAEP;;AAChC,aAAK,OAAL,CAAa,CAAC,CAAC,OAAF,EAAb;AACH,OAJM,MAIA;AACH,aAAK,OAAL,CAAa,GAAb;AACH;;AACD;AACH;;AAED,SAAK,OAAL,CAAa,CAAb;AAEA,SAAK,WAAL,CAAiB,IAAjB;AACA,SAAK,QAAL,CAAc,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,CAAlD;AACA,SAAK,OAAL,CAAa,OAAO,IAAP,KAAgB,QAAhB,GAA2B,IAA3B,GAAkC,CAA/C;AACA,SAAK,QAAL,CAAc,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,CAAlD;AACA,SAAK,UAAL,CAAgB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,CAAxD;AACA,SAAK,UAAL,CAAgB,OAAO,OAAP,KAAmB,QAAnB,GAA8B,OAA9B,GAAwC,CAAxD;AACA,SAAK,eAAL,CAAqB,OAAO,EAAP,KAAc,QAAd,GAAyB,EAAzB,GAA8B,CAAnD;AACH;;AA3CoB;;AAwDzB,SAAS,mBAAT,CAA6B,QAA7B,EAAwD,cAAxD,EAA8E;AAC1E,QAAM,MAAM,GAAG,sCAAsC,cAAc,EAAnE;;AACA,MAAI,OAAO,cAAP,KAA0B,QAA9B,EAAwC;AACpC,UAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;;AACD,MAAI,cAAc,CAAC,UAAf,CAA0B,GAA1B,CAAJ,EAAoC;AAChC,UAAM,OAAO,GAAG,cAAc,CAAC,KAAf,CAAqB,CAArB,EAAwB,KAAxB,CAA8B,GAA9B,CAAhB;AACA,QAAI,CAAC,GAAG,IAAI,QAAJ,EAAR;AACA,UAAM,GAAG,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,EAAyD,CAAC,CAAC,QAAF,EAAzD,EAAuE,CAAC,CAAC,UAAF,EAAvE,CAAZ;AACA,UAAM,KAAK,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,CAAd;AACA,KAAC,GAAG,GAAJ;;AACA,SAAK,MAAM,CAAX,IAAgB,OAAhB,EAAyB;AACrB,cAAQ,CAAR;AACA,aAAK,SAAL;AAAgB,aAAK,KAAL;AACZ,WAAC,GAAG,GAAJ;AACA;;AACJ,aAAK,OAAL;AACI,WAAC,GAAG,KAAJ;AACA;;AACJ,aAAK,kBAAL;AAAyB,aAAK,qBAAL;AACrB,WAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAA9B,EAAiC,CAAjC,CAAJ;AACA;;AACJ,aAAK,iBAAL;AACI,WAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,EAA9B,EAAkC,EAAlC,CAAJ;AACA;;AACJ,aAAK,kBAAL;AACI,WAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAA5C,CAAJ;AACA;;AACJ,aAAK,iBAAL;AACI,WAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,KAAe,CAA7C,EAAgD,CAAhD,CAAJ;AACA;;AACJ;AACI,cAAI,CAAC,CAAC,UAAF,CAAa,mBAAb,CAAJ,EAAuC;AACnC,kBAAM,CAAC,GAAG,SAAS,CAAC,IAAV,CAAe,CAAf,CAAV;;AACA,gBAAI,CAAJ,EAAO;AACH,oBAAM,CAAC,GAAG,MAAM,CAAC,QAAP,CAAgB,CAAC,CAAC,CAAD,CAAjB,EAAsB,EAAtB,CAAV;;AACA,kBAAI,IAAI,CAAJ,IAAS,CAAC,IAAI,EAAlB,EAAsB;AAClB,sBAAM,EAAE,GAAG,CAAC,CAAC,QAAF,KAAe,CAA1B;AACA,oBAAI,EAAE,GAAG,CAAC,CAAC,WAAF,EAAT;;AACA,oBAAI,EAAE,GAAG,CAAT,EAAY;AACR,oBAAE;AACL;;AACD,iBAAC,GAAG,IAAI,QAAJ,CAAa,EAAb,EAAiB,CAAC,GAAG,CAArB,EAAwB,CAAxB,CAAJ;AACH,eAPD,MAOO;AACH,sBAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;AACJ,aAZD,MAYO;AACH,oBAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;AACJ,WAjBD,MAiBO;AACH,kBAAM,CAAC,GAAG,cAAc,CAAC,IAAf,CAAoB,CAApB,CAAV;;AACA,gBAAI,CAAJ,EAAO;AACH,kBAAI,CAAC,GAAG,MAAM,CAAC,QAAP,CAAgB,CAAC,CAAC,CAAD,CAAjB,EAAsB,EAAtB,CAAR;;AACA,sBAAQ,CAAC,CAAC,CAAD,CAAT;AACA,qBAAK,IAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,WAAF,KAAkB,CAAtB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,WAAF,KAAkB,CAAtB;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAb,EAAgB,CAAC,CAAC,QAAF,EAAhB,EAA8B,CAAC,CAAC,OAAF,EAA9B,EACA,CAAC,CAAC,QAAF,EADA,EACc,CAAC,CAAC,UAAF,EADd,EAC8B,CAAC,CAAC,UAAF,EAD9B,EAC8C,CAAC,CAAC,eAAF,EAD9C,CAAJ;AAEA;;AACJ,qBAAK,IAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI,uBAAC,IAAI,CAAL;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,QAAF,KAAe,CAAnB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,QAAF,KAAe,CAAnB;AACA;AATJ;;AAWA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAA9B,EAAiC,CAAC,CAAC,OAAF,EAAjC,EACA,CAAC,CAAC,QAAF,EADA,EACc,CAAC,CAAC,UAAF,EADd,EAC8B,CAAC,CAAC,UAAF,EAD9B,EAC8C,CAAC,CAAC,eAAF,EAD9C,CAAJ;AAEA;;AACJ,qBAAK,KAAL;AAAY,qBAAK,MAAL;AACR,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,OAAF,KAAc,CAAlB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,OAAF,KAAc,CAAlB;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAA5C,EACA,CAAC,CAAC,QAAF,EADA,EACc,CAAC,CAAC,UAAF,EADd,EAC8B,CAAC,CAAC,UAAF,EAD9B,EAC8C,CAAC,CAAC,eAAF,EAD9C,CAAJ;AAEA;;AACJ,qBAAK,IAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,QAAF,KAAe,CAAnB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,QAAF,KAAe,CAAnB;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,EACA,CADA,EACG,CAAC,CAAC,UAAF,EADH,EACmB,CAAC,CAAC,UAAF,EADnB,EACmC,CAAC,CAAC,eAAF,EADnC,CAAJ;AAEA;;AACJ,qBAAK,KAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,UAAF,KAAiB,CAArB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,UAAF,KAAiB,CAArB;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,EACA,CAAC,CAAC,QAAF,EADA,EACc,CADd,EACiB,CAAC,CAAC,UAAF,EADjB,EACiC,CAAC,CAAC,eAAF,EADjC,CAAJ;AAEA;;AACJ,qBAAK,KAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,UAAF,KAAiB,CAArB;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,UAAF,KAAiB,CAArB;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,EACA,CAAC,CAAC,QAAF,EADA,EACc,CAAC,CAAC,UAAF,EADd,EAC8B,CAD9B,EACiC,CAAC,CAAC,eAAF,EADjC,CAAJ;AAEA;;AACJ,qBAAK,IAAL;AACI,0BAAQ,CAAC,CAAC,CAAD,CAAT;AACA,yBAAK,GAAL;AACI;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,eAAF,KAAsB,CAA1B;AACA;;AACJ,yBAAK,GAAL;AACI,uBAAC,GAAG,CAAC,CAAC,eAAF,KAAsB,CAA1B;AACA;AARJ;;AAUA,mBAAC,GAAG,IAAI,QAAJ,CAAa,CAAC,CAAC,WAAF,EAAb,EAA8B,CAAC,CAAC,QAAF,EAA9B,EAA4C,CAAC,CAAC,OAAF,EAA5C,EACA,CAAC,CAAC,QAAF,EADA,EACc,CAAC,CAAC,UAAF,EADd,EAC8B,CAAC,CAAC,UAAF,EAD9B,EAC8C,CAD9C,CAAJ;AAEA;;AACJ;AACI,wBAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AArGJ;AAuGH,aAzGD,MAyGO;AACH,kBAAI,EAAE,qDAAW,CAAC,IAAZ,CAAiB,CAAjB,KAAuB,yDAAe,CAAC,IAAhB,CAAqB,CAArB,CAAvB,IAAkD,6DAAmB,CAAC,IAApB,CAAyB,CAAzB,CAApD,CAAJ,EAAsF;AAClF,sBAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;;AACD,eAAC,GAAG,IAAI,QAAJ,CAAa,CAAb,CAAJ;AACH;AACJ;;AAtJL;AAwJH;;AACD,WAAO,CAAP;AACH,GAjKD,MAiKO;AACH,QAAI,CAAE,qDAAW,CAAC,IAAZ,CAAiB,cAAjB,CAAN,EAAwC;AACpC,YAAM,IAAI,KAAJ,CAAU,MAAV,CAAN;AACH;;AACD,WAAO,IAAI,QAAJ,CAAa,cAAb,CAAP;AACH;AACJ;;AAGM,MAAM,cAAc,GAAe;AACtC,UAAQ,EAAG,KAAD,IAAmB;AACzB,WACI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,qDAAW,CAAC,IAAZ,CAAiB,KAAjB,CAA7B,GACM;AAAE,WAAK,EAAG,IAAI,OAAJ,CAAY,KAAZ,CAAD,CAAqB,OAArB;AAAT,KADN,GAEM,IAHV;AAKH,GAPqC;AAQtC,iBAAe,EAAE,cAAc,IAAG;AAC9B,UAAM,CAAC,GAAG,mBAAmB,CAAC,OAAD,EAAU,cAAV,CAA7B;AACA,WAAQ,IAAI,OAAJ,CAAY,CAAC,CAAC,WAAF,EAAZ,EAA6B,CAAC,CAAC,QAAF,EAA7B,EAA2C,CAAC,CAAC,OAAF,EAA3C,CAAD,CAA0D,OAA1D,EAAP;AACH,GAXqC;AAYtC,SAAO,EAAE,CAAC,CAAD,EAAY,CAAZ,KAA0B,CAAC,GAAG,CAZD;AAatC,QAAM,EAAE;AAb8B,CAAnC;AAiBA,MAAM,gBAAgB,mCACtB,cADsB,GACR;AACjB,UAAQ,EAAG,KAAD,IAAmB;AACzB,QAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,qDAAW,CAAC,IAAZ,CAAiB,KAAjB,CAAjC,EAA0D;AACtD,aAAQ;AAAE,aAAK,EAAG,IAAI,MAAJ,CAAW,KAAX,CAAD,CAAoB,OAApB;AAAT,OAAR;AACH,KAFD,MAEO;AACH,aAAO,IAAP;AACH;AACJ,GAPgB;AAQjB,iBAAe,EAAE,cAAc,IAAG;AAC9B,UAAM,CAAC,GAAG,mBAAmB,CAAC,MAAD,EAAS,cAAT,CAA7B;AACA,WAAQ,IAAI,MAAJ,CAAW,CAAC,CAAC,WAAF,EAAX,EAA4B,CAAC,CAAC,QAAF,EAA5B,EAA0C,CAAC,CAAC,OAAF,EAA1C,CAAD,CAAyD,OAAzD,EAAP;AACH;AAXgB,CADQ,CAAtB;AAgBA,MAAM,kBAAkB,GAAe;AAC1C,UAAQ,EAAG,KAAD,IAAmB;AACzB,WACI,OAAO,KAAP,KAAiB,QAAjB,KAA8B,yDAAe,CAAC,IAAhB,CAAqB,KAArB,KAA+B,6DAAmB,CAAC,IAApB,CAAyB,KAAzB,CAA7D,IACM;AAAE,WAAK,EAAG,IAAI,OAAJ,CAAY,KAAZ,CAAD,CAAqB,OAArB;AAAT,KADN,CACgD;AADhD,MAEM,IAHV;AAKH,GAPyC;AAQ1C,iBAAe,EAAE,cAAc,IAAI,mBAAmB,CAAC,OAAD,EAAU,cAAV,CAAnB,CAA6C,OAA7C,EARO;AAS1C,SAAO,EAAE,CAAC,CAAD,EAAY,CAAZ,KAA0B,CAAC,GAAG,CATG;AAU1C,QAAM,EAAE;AAVkC,CAAvC;AAcA,MAAM,oBAAoB,mCAC1B,kBAD0B,GACR;AACrB,UAAQ,EAAG,KAAD,IAAmB;AACzB,WACI,OAAO,KAAP,KAAiB,QAAjB,KAA8B,yDAAe,CAAC,IAAhB,CAAqB,KAArB,KAA+B,6DAAmB,CAAC,IAApB,CAAyB,KAAzB,CAA7D,IACM;AAAE,WAAK,EAAG,IAAI,MAAJ,CAAW,KAAX,CAAD,CAAoB,OAApB;AAAT,KADN,GAEM,IAHV;AAKH,GAPoB;AAQrB,iBAAe,EAAE,cAAc,IAAI,mBAAmB,CAAC,MAAD,EAAS,cAAT,CAAnB,CAA4C,OAA5C;AARd,CADQ,CAA1B;AAaA,MAAM,WAAW,GAAgC,CACpD,CAAC,MAAD,EAAS,cAAT,CADoD,EAEpD,CAAC,QAAD,EAAW,gBAAX,CAFoD,EAGpD,CAAC,UAAD,EAAa,kBAAb,CAHoD,EAIpD,CAAC,YAAD,EAAe,oBAAf,CAJoD,CAAjD,C;;;;;;;;;;;;AChYP;AAAA;AAAA;AACA;AACA;AAOO,MAAM,cAAc,GAAe;AACtC,UAAQ,EAAG,KAAD,IAAe;AACrB,WAAQ;AAAE;AAAF,KAAR;AACH,GAHqC;AAItC,iBAAe,EAAG,cAAD,IAAwB;AACrC,WAAO,cAAP;AACH,GANqC;AAOtC,SAAO,EAAE,CAAC,CAAD,EAAS,CAAT,KAAmB;AACxB;AACA,UAAM,GAAG,GAAG,OAAO,CAAnB;AACA,UAAM,GAAG,GAAG,OAAO,CAAnB;;AACA,QAAI,GAAG,KAAK,GAAZ,EAAiB;AACb,aAAO,GAAP;AACH;;AACD,YAAQ,GAAR;AACA,WAAK,QAAL;AACI,YAAI,MAAM,CAAC,KAAP,CAAa,CAAb,KAAmB,MAAM,CAAC,KAAP,CAAa,CAAb,CAAvB,EAAwC;AACpC,iBAAO,CAAP;AACH,SAFD,MAEO;AACH,iBAAO,CAAC,GAAG,CAAX;AACH;;AACL;AACI,YAAI,CAAC,KAAK,CAAV,EAAa;AACT,iBAAO,CAAP;AACH,SAFD,MAEO,IAAI,CAAC,GAAG,CAAR,EAAW;AACd,iBAAO,CAAP;AACH,SAFM,MAEA,IAAI,CAAC,GAAG,CAAR,EAAW;AACd,iBAAO,CAAC,CAAR;AACH,SAFM,MAEA;AACH,iBAAO,GAAP;AACH;;AAhBL;AAkBH,GAhCqC;AAiCtC,QAAM,EAAE;AAjC8B,CAAnC,C;;;;;;;;;;;;ACTP;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AAWA,IAAY,UAAZ;;AAAA,WAAY,UAAZ,EAAsB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACH,CAXD,EAAY,UAAU,KAAV,UAAU,MAAtB,E;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAkBA;AACA;AAEA;AAEA;AACA;;AAIA,SAAS,gBAAT,CACI,IADJ,EACe,EADf,EACkC,GADlC,EACwD;AAGpD,MAAI,EAAE,CAAC,UAAH,IAAiB,GAAG,CAAC,WAAzB,EAAsC;AAClC,QAAI,GAAG,CAAC,WAAJ,CAAgB,GAAhB,CAAoB,EAAE,CAAC,UAAvB,CAAJ,EAAwC;AACpC,YAAM,UAAU,GAAG,GAAG,CAAC,WAAJ,CAAgB,GAAhB,CAAoB,EAAE,CAAC,UAAvB,CAAnB;AACA,YAAM,MAAM,GAAG,UAAU,CAAC,QAAX,CAAoB,IAApB,CAAf;;AACA,UAAI,MAAJ,EAAY;AACR,eAAQ;AACJ,eAAK,EAAE,MAAM,CAAC,KADV;AAEJ;AAFI,SAAR;AAIH,OALD,MAKO;AACH,eAAO,IAAP;AACH;AACJ,KAXD,MAWO;AACH,YAAM,IAAI,KAAJ,CAAU,sCAAsC,EAAE,CAAC,UAAU,EAA7D,CAAN;AACH;AACJ;;AACD,SAAO,KAAP;AACH;;AAGD,SAAS,SAAT,CACI,UADJ,EAII,KAJJ,EAIc;AAEV,UAAQ,UAAR;AACA,SAAK,QAAL;AACI,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC3B,eAAO,KAAP;AACH,OAFD,MAEO;AACH,cAAM,CAAC,GAAG,MAAM,CAAC,UAAP,CAAkB,MAAM,CAAC,KAAD,CAAxB,CAAV;;AACA,YAAI,MAAM,CAAC,KAAP,CAAa,CAAb,CAAJ,EAAqB;AACjB,iBAAO,MAAM,CAAC,KAAK,SAAL,SAAK,WAAL,WAAS,CAAV,CAAb;AACH,SAFD,MAEO;AACH,iBAAO,CAAP;AACH;AACJ;;AACL,SAAK,SAAL;AACI,UAAI,OAAO,KAAP,KAAiB,QAAjB,IAA6B,IAAI,CAAC,KAAL,CAAW,KAAX,MAAsB,KAAvD,EAA8D;AAC1D,eAAO,KAAP;AACH,OAFD,MAEO;AACH,YAAI,CAAC,GAAG,MAAM,CAAC,UAAP,CAAkB,MAAM,CAAC,KAAD,CAAxB,CAAR;;AACA,YAAI,MAAM,CAAC,KAAP,CAAa,CAAb,CAAJ,EAAqB;AACjB,WAAC,GAAG,MAAM,CAAC,KAAK,SAAL,SAAK,WAAL,WAAS,CAAV,CAAV;AACH;;AACD,eAAO,IAAI,CAAC,KAAL,CAAW,CAAX,CAAP;AACH;;AACL,SAAK,QAAL;AACI,UAAI;AACA,eAAO,MAAM,CAAC,KAAK,SAAL,SAAK,WAAL,WAAS,CAAV,CAAb;AACH,OAFD,CAEE,WAAM;AACJ,eAAO,GAAP;AACH;;AACL,SAAK,QAAL;AACI,aAAO,MAAM,CAAC,KAAD,CAAb;;AACJ,SAAK,SAAL;AACI,aAAO,OAAO,CAAC,KAAD,CAAd;;AACJ,SAAK,WAAL;AACI,aAAO,KAAK,CAAZ;;AACJ,SAAK,MAAL;AACI,aAAO,IAAP;;AACJ;AACI,aAAO,KAAP;AArCJ;AAuCH;;AAGD,SAAS,sBAAT,CACI,IADJ,EACe,EADf,EACkC,GADlC,EACwD;AAEpD,MAAI,EAAE,CAAC,iBAAH,IAAwB,GAAG,CAAC,iBAAhC,EAAmD;AAC/C,SAAK,MAAM,MAAX,IAAqB,EAAE,CAAC,iBAAxB,EAA2C;AACvC,UAAI,GAAG,CAAC,iBAAJ,CAAsB,GAAtB,CAA0B,MAA1B,CAAJ,EAAuC;AACnC,cAAM,EAAE,GAAG,GAAG,CAAC,iBAAJ,CAAsB,GAAtB,CAA0B,MAA1B,CAAX;;AACA,YAAI,EAAE,CAAC,KAAH,IAAY,CAAC,EAAE,CAAC,KAAH,CAAS,QAAT,CAAkB,EAAE,CAAC,IAArB,CAAjB,EAA6C;AACzC,iBAAO,IAAP;AACH;;AACD,YAAI,CAAE,EAAE,CAAC,KAAH,CAAS,IAAT,EAAe,EAAE,CAAC,qBAAH,IAA4B,EAAE,CAAC,qBAAH,CAAyB,MAAzB,CAA3C,CAAN,EAAoF;AAChF,iBAAO,IAAP;AACH;AACJ,OARD,MAQO;AACH,cAAM,IAAI,KAAJ,CAAU,sCAAsC,MAAM,EAAtD,CAAN;AACH;AACJ;;AACD,WAAO,IAAP;AACH;;AACD,SAAO,KAAP;AACH;;AAGD,SAAS,0BAAT,CACI,IADJ,EACe,EADf,EACuC,GADvC,EAC6D;AAEzD,mEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,GAArC,CAAX;AACA,SAAO,IAAP;AACH;;AAGD,SAAS,wBAAT,CACI,IADJ,EACe,EADf,EACqC,GADrC,EAC2D;AAEvD,MAAI,KAAK,GAAG,gBAAgB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA5B;;AACA,MAAI,KAAK,KAAK,IAAd,EAAoB;AAChB,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH,GAHD,MAGO,IAAI,KAAK,KAAK,KAAd,EAAqB;AACxB,SAAK,GAAG;AACJ,WAAK,EAAE,IADH;AAEJ,gBAAU,EAAE,gEAAc;AAFtB,KAAR;AAIH;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,UAAnB;;AAEA,MAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAA9C,EAAoD;AAChD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH,GAjBsD,CAmBvD;;;AACA,SAAQ;AAAC,SAAK,EAAE,GAAG,CAAC,MAAJ,GACV,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B,IAAvC,EAA6C,EAA7C,CADU,GAEC,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B;AAFrC,GAAR;AAGH;;AAGD,SAAS,4BAAT,CACI,IADJ,EACe,EADf,EACyC,GADzC,EAC+D;AAE3D,MAAI,KAAK,GAAG,gBAAgB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA5B;;AACA,MAAI,KAAK,KAAK,IAAd,EAAoB;AAChB,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH,GAHD,MAGO,IAAI,KAAK,KAAK,KAAd,EAAqB;AACxB,SAAK,GAAG;AACJ,WAAK,EAAE,IADH;AAEJ,gBAAU,EAAE,gEAAc;AAFtB,KAAR;AAIH;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,UAAnB;;AAEA,MAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAA9C,EAAoD;AAChD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH,GAjB0D,CAmB3D;;;AACA,SAAQ;AAAC,SAAK,EAAE,GAAG,CAAC,MAAJ,GACV,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B,IAAvC,EAA6C,EAA7C,CADU,GAEC,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B;AAFrC,GAAR;AAGH;;AAGD,SAAS,8BAAT,CACI,IADJ,EACe,EADf,EAC2C,GAD3C,EACiE;AAE7D,QAAM,SAAS,GAAG,EAAE,CAAC,SAAH,GAAe,SAAS,CAAC,EAAE,CAAC,aAAJ,EAAmB,IAAnB,CAAxB,GAAmD,IAArE;;AAEA,MAAI,EAAE,CAAC,aAAH,KAAqB,MAAzB,EAAiC;AAC7B,QAAI,SAAS,KAAK,IAAlB,EAAwB;AACpB,uEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,OAArC,CAAX;AACA,aAAO,IAAP;AACH;AACJ,GALD,MAKO,IAAI,EAAE,CAAC,aAAH,KAAqB,SAAzB,EAAoC;AACvC,QAAI,OAAO,SAAP,KAAqB,QAAzB,EAAmC;AAC/B,uEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,OAArC,CAAX;AACA,aAAO,IAAP;AACH;;AACD,QAAI,IAAI,CAAC,KAAL,CAAW,SAAX,MAA0B,SAA9B,EAAyC;AACrC,uEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,OAArC,CAAX;AACA,aAAO,IAAP;AACH;AACJ,GATM,MASA,IAAI,OAAO,SAAP,KAAqB,EAAE,CAAC,aAA5B,EAA2C;AAC9C,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH,GArB4D,CAsB7D;;;AAEA,MAAI,KAAK,GAAG,gBAAgB,CAAC,SAAD,EAAY,EAAZ,EAAgB,GAAhB,CAA5B;;AACA,MAAI,KAAK,KAAK,IAAd,EAAoB;AAChB,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH,GAHD,MAGO,IAAI,KAAK,KAAK,KAAd,EAAqB;AACxB,SAAK,GAAG;AACJ,WAAK,EAAE,SADH;AAEJ,gBAAU,EAAE,EAAE,CAAC,SAAH,GAAe,gEAAf,GAAgC,gEAAc;AAFtD,KAAR;AAIH;;AAED,QAAM,MAAM,GAAG,KAAK,CAAC,KAArB;AACA,QAAM,IAAI,GAAG,KAAK,CAAC,UAAnB;AACA,MAAI,GAAG,GAAG,KAAV;AAEA,MAAI,aAAa,GAAG,KAApB;;AACA,UAAQ,OAAO,EAAE,CAAC,QAAlB;AACA,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe;AAC1B,UAAI,IAAI,CAAC,OAAL,CAAa,MAAb,EAAqB,IAAI,CAAC,eAAL,CAAqB,EAAE,CAAC,QAAxB,CAArB,IAA0D,CAA9D,EAAiE;AAC7D,YAAI,CAAE,aAAN,EAAqB;AACjB,2EAAW,CAAC,iDAAU,CAAC,mBAAZ,EAAiC,IAAjC,EAAuC,EAAvC,EAA2C;AAAC;AAAD,WAA3C,CAAX;AACH;;AACD,qBAAa,GAAG,IAAhB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAUA,UAAQ,OAAO,EAAE,CAAC,QAAlB;AACA,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe;AAC1B,UAAI,IAAI,CAAC,OAAL,CAAa,MAAb,EAAqB,IAAI,CAAC,eAAL,CAAqB,EAAE,CAAC,QAAxB,CAArB,IAA0D,CAA9D,EAAiE;AAC7D,YAAI,CAAE,aAAN,EAAqB;AACjB,2EAAW,CAAC,iDAAU,CAAC,mBAAZ,EAAiC,IAAjC,EAAuC,EAAvC,EAA2C;AAAC;AAAD,WAA3C,CAAX;AACH;;AACD,qBAAa,GAAG,IAAhB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAUA,UAAQ,OAAO,EAAE,CAAC,gBAAlB;AACA,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe;AAC1B,UAAI,IAAI,CAAC,OAAL,CAAa,MAAb,EAAqB,IAAI,CAAC,eAAL,CAAqB,EAAE,CAAC,gBAAxB,CAArB,KAAmE,CAAvE,EAA0E;AACtE,YAAI,CAAE,aAAN,EAAqB;AACjB,2EAAW,CAAC,iDAAU,CAAC,mBAAZ,EAAiC,IAAjC,EAAuC,EAAvC,EAA2C;AAAC;AAAD,WAA3C,CAAX;AACH;;AACD,qBAAa,GAAG,IAAhB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAUA,UAAQ,OAAO,EAAE,CAAC,aAAlB;AACA,SAAK,QAAL;AAAe,SAAK,QAAL;AAAe;AAC1B,UAAI,IAAI,CAAC,OAAL,CAAa,MAAb,EAAqB,IAAI,CAAC,eAAL,CAAqB,EAAE,CAAC,aAAxB,CAArB,KAAgE,CAApE,EAAuE;AACnE,YAAI,CAAE,aAAN,EAAqB;AACjB,2EAAW,CAAC,iDAAU,CAAC,mBAAZ,EAAiC,IAAjC,EAAuC,EAAvC,EAA2C;AAAC;AAAD,WAA3C,CAAX;AACH;;AACD,qBAAa,GAAG,IAAhB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAWA,MAAI,cAAc,GAAG,KAArB;;AACA,UAAQ,OAAO,EAAE,CAAC,SAAlB;AACA,SAAK,QAAL;AACI,UAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,MAAM,CAAC,MAAP,GAAgB,EAAE,CAAC,SAArD,EAAgE;AAC5D,YAAI,CAAE,cAAN,EAAsB;AAClB,2EAAW,CAAC,iDAAU,CAAC,oBAAZ,EAAkC,IAAlC,EAAwC,EAAxC,EAA4C;AAAC;AAAD,WAA5C,CAAX;AACH;;AACD,sBAAc,GAAG,IAAjB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAUA,UAAQ,OAAO,EAAE,CAAC,SAAlB;AACA,SAAK,QAAL;AACI,UAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,MAAM,CAAC,MAAP,GAAgB,EAAE,CAAC,SAArD,EAAgE;AAC5D,YAAI,CAAE,cAAN,EAAsB;AAClB,2EAAW,CAAC,iDAAU,CAAC,oBAAZ,EAAkC,IAAlC,EAAwC,EAAxC,EAA4C;AAAC;AAAD,WAA5C,CAAX;AACH;;AACD,sBAAc,GAAG,IAAjB;AACA,WAAG,GAAG,IAAN;AACH;;AARL;;AAWA,MAAI,EAAE,CAAC,OAAP,EAAgB;AACZ,QAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,CAAC,EAAE,CAAC,OAAH,CAAW,IAAX,CAAgB,MAAhB,CAAnC,EAA4D;AACxD,uEAAW,CAAC,iDAAU,CAAC,qBAAZ,EAAmC,IAAnC,EAAyC,EAAzC,EAA6C;AAAC;AAAD,OAA7C,CAAX;AACA,SAAG,GAAG,IAAN;AACH;AACJ;;AAED,MAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAA9C,EAAoD;AAChD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,OAAG,GAAG,IAAN;AACH;;AAED,QAAM,GAAG,GAAG,CAAC,GAAD,GACN;AAAC,SAAK,EAAE,GAAG,CAAC,MAAJ,GACJ,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B,SAAvC,EAAkD,EAAlD,CADI,GAEO,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B;AAF3C,GADM,GAIN,IAJN;AAKA,SAAO,GAAP;AACH;;AAGD,SAAS,mCAAT,CACI,IADJ,EACe,EADf,EACgD,GADhD,EACsE;AAElE,QAAM,SAAS,GAAG,EAAE,CAAC,SAAH,GAAe,SAAS,CAAC,OAAO,EAAE,CAAC,KAAX,EAAkB,IAAlB,CAAxB,GAAkD,IAApE;AAEA,MAAI,KAAK,GAAG,gBAAgB,CAAC,SAAD,EAAY,EAAZ,EAAgB,GAAhB,CAA5B;;AACA,MAAI,KAAK,KAAK,IAAd,EAAoB;AAChB,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH,GAHD,MAGO,IAAI,KAAK,KAAK,KAAd,EAAqB;AACxB,SAAK,GAAG;AACJ,WAAK,EAAE,SADH;AAEJ,gBAAU,EAAE,EAAE,CAAC,SAAH,GAAe,gEAAf,GAAgC,gEAAc;AAFtD,KAAR;AAIH;;AACD,QAAM,IAAI,GAAG,KAAK,CAAC,UAAnB;AAEA,MAAI,GAAG,GAAG,IAAI,CAAC,OAAL,CAAa,KAAK,CAAC,KAAnB,EAA0B,IAAI,CAAC,eAAL,CAAqB,EAAE,CAAC,KAAxB,CAA1B,MAA8D,CAA9D,GACJ;AAAC,SAAK,EAAE,GAAG,CAAC,MAAJ,GACJ,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B,SAAvC,EAAkD,EAAlD,CADI,GAEO,IAAI,CAAC,MAAL,GAAc,KAAK,CAAC,KAApB,GAA4B;AAF3C,GADI,GAIJ,IAJN;;AAKA,MAAI,CAAE,GAAN,EAAW;AACP,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACH;;AAED,MAAI,GAAG,IAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAArD,EAA2D;AACvD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,OAAG,GAAG,IAAN;AACH;;AAED,SAAO,GAAP;AACH;;AAGD,SAAS,yBAAT,CACI,IADJ,EACe,EADf,EACsC,GADtC,EAC4D;AAExD,MAAI,CAAE,KAAK,CAAC,OAAN,CAAc,IAAd,CAAN,EAA2B;AACvB,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH;;AACD,MAAI,OAAO,EAAE,CAAC,GAAV,KAAkB,QAAlB,IAA8B,IAAI,CAAC,MAAL,GAAc,EAAE,CAAC,GAAnD,EAAwD;AACpD,qEAAW,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,EAAtC,EAA0C;AAAC;AAAD,KAA1C,CAAX;AACA,WAAO,IAAP;AACH;;AACD,MAAI,OAAO,EAAE,CAAC,GAAV,KAAkB,QAAlB,IAA8B,IAAI,CAAC,MAAL,GAAc,EAAE,CAAC,GAAnD,EAAwD;AACpD,qEAAW,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,EAAtC,EAA0C;AAAC;AAAD,KAA1C,CAAX;AACA,WAAO,IAAP;AACH;;AAED,QAAM,OAAO,GAAU,EAAvB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,UAAM,CAAC,GAAG,IAAI,CAAC,CAAD,CAAd;AACA,UAAM,CAAC,GAAG,YAAY,CAAI,CAAJ,EAAO,EAAE,CAAC,QAAV,EAAoB,GAApB,EAAyB,CAAzB,CAAtB;;AACA,QAAI,CAAE,CAAN,EAAS;AACL,aAAO,IAAP;AACH;;AACD,WAAO,CAAC,IAAR,CAAa,CAAC,CAAC,KAAf;AACH;;AAED,MAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAA9C,EAAoD;AAChD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH;;AAED,SAAO;AAAC,SAAK,EAAE;AAAR,GAAP;AACH;;AAGD,SAAS,yBAAT,CACI,IADJ,EACe,EADf,EACsC,GADtC,EAC4D;AAExD,MAAI,CAAE,KAAK,CAAC,OAAN,CAAc,IAAd,CAAN,EAA2B;AACvB,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACA,WAAO,IAAP;AACH;;AACD,MAAI,IAAI,GAAG,CAAX;AAAA,MAAc;AACV,MAAI,GAAG,CADX,CANwD,CAO1C;;AACd,MAAI,SAAS,GAAG,CAAhB;AACA,MAAI,eAAe,GAAG,KAAtB;;AAEA,QAAM,mBAAmB,GAAG,CAAC,EAAD,EAAsB,KAAtB,KAAuC;AAC/D,QAAI,OAAO,EAAE,CAAC,GAAV,KAAkB,QAAlB,IAA8B,SAAS,GAAG,EAAE,CAAC,GAAjD,EAAsD;AAClD,+EAAmB,CACf,SAAS,KAAK,CAAd,GACI,iDAAU,CAAC,aADf,GAEI,iDAAU,CAAC,kBAHA,EAGoB,IAHpB,EAG0B,CAAC,EAAD,EAAK,KAAL,CAH1B,EAGuC;AAAC;AAAD,OAHvC,CAAnB;AAIA,aAAO,IAAP;AACH;;AACD,QAAI,OAAO,EAAE,CAAC,GAAV,KAAkB,QAAlB,IAA8B,SAAS,GAAG,EAAE,CAAC,GAAjD,EAAsD;AAClD,+EAAmB,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,CAAC,EAAD,EAAK,KAAL,CAAtC,EAAmD;AAAC;AAAD,OAAnD,CAAnB;AACA,aAAO,IAAP;AACH;;AACD,WAAO,EAAP;AACH,GAbD;;AAeA,QAAM,qBAAqB,GAAG,CAAC,EAAD,EAAwB,KAAxB,KAAyC;AACnE,QAAI,SAAS,KAAK,CAAlB,EAAqB;AACjB;AACA,qBAAe,GAAG,IAAlB;AACH,KAHD,MAGO,IAAI,eAAJ,EAAqB;AACxB,+EAAmB,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,CAAC,EAAD,EAAK,KAAL,CAAtC,EAAmD;AAAC;AAAD,OAAnD,CAAnB;AACA,aAAO,IAAP;AACH,KAHM,MAGA,IAAI,SAAS,GAAG,CAAhB,EAAmB;AACtB,+EAAmB,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,CAAC,EAAD,EAAK,KAAL,CAAtC,EAAmD;AAAC;AAAD,OAAnD,CAAnB;AACA,aAAO,IAAP;AACH;;AACD,WAAO,EAAP;AACH,GAZD;;AAcA,QAAM,OAAO,GAAU,EAAvB;;AACA,SAAO,IAAI,GAAG,IAAI,CAAC,MAAZ,IAAsB,IAAI,GAAG,EAAE,CAAC,QAAH,CAAY,MAAhD,EAAwD;AACpD,UAAM,EAAE,GAAG,EAAE,CAAC,QAAH,CAAY,IAAZ,CAAX;;AACA,QAAI,EAAE,CAAC,IAAH,KAAY,QAAhB,EAA0B;AACtB,YAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,MAA/B;AACA,YAAM,CAAC,GAAG,YAAY,CAAI,IAAI,CAAC,IAAD,CAAR,EAAgB,EAAE,CAAC,MAAnB,EAA2B,GAA3B,EAAgC,IAAhC,CAAtB;;AACA,UAAI,CAAJ,EAAO;AACH,eAAO,CAAC,IAAR,CAAa,CAAC,CAAC,KAAf;AACA,YAAI;AACJ,iBAAS;AACZ,OAJD,MAIO;AACH;AACA;AACA,WAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;;AACA,YAAI,CAAE,mBAAmB,CAAC,EAAD,EAAK,IAAL,CAAzB,EAAqC;AACjC,iBAAO,IAAP;AACH;;AACD,iBAAS,GAAG,CAAZ;AACA,YAAI;AACP;AACJ,KAjBD,MAiBO,IAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AAC/B,YAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,MAA/B;AACA,YAAM,CAAC,GAAG,YAAY,CAAI,IAAI,CAAC,IAAD,CAAR,EAAgB,EAAE,CAAC,QAAnB,EAA6B,GAA7B,EAAkC,IAAlC,CAAtB;;AACA,UAAI,CAAJ,EAAO;AACH,eAAO,CAAC,IAAR,CAAa,CAAC,CAAC,KAAf;AACA,YAAI;AACJ,iBAAS;AACZ,OAJD,MAIO;AACH;AACA;AACA,WAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;;AACA,YAAI,CAAE,qBAAqB,CAAC,EAAD,EAAK,IAAL,CAA3B,EAAuC;AACnC,iBAAO,IAAP;AACH;;AACD,iBAAS,GAAG,CAAZ;AACA,YAAI;AACP;AACJ,KAjBM,MAiBA;AACH,YAAM,CAAC,GAAG,YAAY,CAAI,IAAI,CAAC,IAAD,CAAR,EAAgB,EAAhB,EAAoB,GAApB,EAAyB,IAAzB,CAAtB;;AACA,UAAI,CAAJ,EAAO;AACH,eAAO,CAAC,IAAR,CAAa,CAAC,CAAC,KAAf;AACA,YAAI;AACJ,YAAI;AACP,OAJD,MAIO;AACH,eAAO,IAAP;AACH;AACJ;AACJ;;AACD,SAAO,IAAI,GAAG,EAAE,CAAC,QAAH,CAAY,MAA1B,EAAkC;AAC9B,UAAM,EAAE,GAAG,EAAE,CAAC,QAAH,CAAY,IAAZ,CAAX;;AACA,QAAI,EAAE,CAAC,IAAH,KAAY,QAAhB,EAA0B;AACtB,UAAI,CAAE,mBAAmB,CAAC,EAAD,EAAK,IAAL,CAAzB,EAAqC;AACjC,eAAO,IAAP;AACH;;AACD,eAAS,GAAG,CAAZ;AACA,UAAI;AACP,KAND,MAMO,IAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AAC/B,UAAI,CAAE,qBAAqB,CAAC,EAAD,EAAK,IAAL,CAA3B,EAAuC;AACnC,eAAO,IAAP;AACH;;AACD,eAAS,GAAG,CAAZ;AACA,UAAI;AACP,KANM,MAMA;AACH,+EAAmB,CAAC,iDAAU,CAAC,kBAAZ,EAAgC,IAAhC,EAAsC,CAAC,EAAD,EAAK,IAAL,CAAtC,EAAkD;AAAC;AAAD,OAAlD,CAAnB;AACA,aAAO,IAAP;AACH;AACJ;;AAED,QAAM,GAAG,GAAG,IAAI,CAAC,MAAL,KAAgB,IAAhB,GAAuB;AAAC,SAAK,EAAE;AAAR,GAAvB,GAAiD,IAA7D;;AACA,MAAI,CAAE,GAAN,EAAW;AACP,qEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,KAAzC,CAAX;AACH;;AAED,MAAI,GAAG,IAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAArD,EAA2D;AACvD,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH;;AAED,SAAO,GAAP;AACH;;AAGD,SAAS,sBAAT,CACI,IADJ,EACe,EADf,EACmC,GADnC,EACyD;AAErD,MAAI,OAAO,GAAG,KAAd;AACA,QAAM,gCAAgC,GAAG,GAAG,CAAC,wBAA7C;AACA,KAAG,CAAC,wBAAJ,GAA+B,KAA/B;AAEA,QAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,MAA/B;AACA,MAAI,KAAK,GAAG,CAAZ;AACA,MAAI,WAAW,GAAG,WAAlB;;AAEA,OAAK,MAAM,KAAX,IAAoB,EAAE,CAAC,KAAvB,EAA8B;AAC1B,UAAM,CAAC,GAAG,YAAY,CAAI,IAAJ,EAAU,KAAV,EAAiB,GAAjB,CAAtB;;AACA,QAAI,CAAJ,EAAO;AACH;AACA,SAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;AACA,SAAG,CAAC,wBAAJ,GAA+B,gCAA/B;AACA,aAAO,CAAP;AACH;;AAED,QAAI,GAAG,CAAC,wBAAR,EAAkC;AAC9B,UAAI,KAAK,KAAK,CAAd,EAAiB;AACb,cAAM,EAAE,GAAG,GAAG,CAAC,MAAJ,CAAW,KAAX,CAAiB,WAAjB,CAAX;AACA,WAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;AACA,WAAG,CAAC,MAAJ,CAAW,IAAX,CAAgB,GAAG,EAAnB;AACH;;AACD,aAAO,GAAG,IAAV;AACA;AACH;;AAED,QAAI,KAAK,KAAK,CAAd,EAAiB;AACb,iBAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,MAAzB;AACH,KAFD,MAEO;AACH,SAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;AACH;;AACD,SAAK;AACR;;AAED,MAAI,CAAE,OAAN,EAAe;AACX,QAAI,CAAE,GAAG,CAAC,QAAV,EAAoB;AAChB;AACA,SAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;AACH;;AACD,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;AACH;;AAED,KAAG,CAAC,wBAAJ,GAA+B,gCAA/B;AACA,SAAO,IAAP;AACH;;AAGD,SAAS,qBAAT,CACI,IADJ,EACe,EADf,EACkC,GADlC,EACwD;AAEpD,OAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,MAAnB,EAA2B;AACvB,QAAI,IAAI,KAAK,CAAC,CAAC,CAAD,CAAd,EAAmB;AACf,aAAQ;AAAC,aAAK,EAAE,GAAG,CAAC,MAAJ,GAAa,GAAG,CAAC,MAAJ,CAAW,IAAX,EAAiB,EAAjB,CAAb,GAAoC;AAA5C,OAAR;AACH;AACJ;;AACD,mEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,GAAtC,CAAX;AACA,SAAO,IAAP;AACH;;AAGD,SAAS,uBAAT,CACI,IADJ,EACe,EADf,EACoC,GADpC,EAC0D;AAEtD,MAAI,MAAM,GAAG,KAAK,CAAC,OAAN,CAAc,IAAd,IAAsB,CAAC,GAAG,IAAJ,CAAtB,GAAiC,kBAAK,IAAL,CAA9C;AACA,QAAM,UAAU,GAAG,EAAE,CAAC,OAAH,CAAW,KAAX,GAAmB,OAAnB,EAAnB;;AACA,OAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,OAAnB,EAA4B;AACxB,QAAI,EAAE,CAAC,OAAH,CAAW,IAAX,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAA/B,MAAwC,UAAU,CAAC,IAAX,CAAgB,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,KAAS,CAAC,CAAC,CAAD,CAA/B,CAA5C,EAAiF;AAC7E,uEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,OAAzC,CAAX;AACA,YAAM,IAAI,2DAAJ,CACF,+BAA+B,CAAC,CAAC,CAAD,CAAG,OAAO,EAAE,CAAC,IAAH,IAAW,WAAW,EAD9D,EACkE,EADlE,EACsE,GADtE,CAAN;AAEH;AACJ;;AAED,MAAI,IAAI,KAAK,IAAT,IAAiB,OAAO,IAAP,KAAgB,QAArC,EAA+C;AAC3C,qEAAW,CAAC,iDAAU,CAAC,aAAZ,EAA2B,IAA3B,EAAiC,EAAjC,EAAqC;AAAC;AAAD,KAArC,CAAX;;AACA,QAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,YAAM,GAAG,IAAT;AACH,KAFD,MAEO;AACH,aAAO,IAAP;AACH;AACJ,GAPD,MAOO;AACH,UAAM,WAAW,GAAG,IAAI,GAAJ,EAApB;;AACA,QAAI,GAAG,CAAC,iBAAJ,IAAyB,EAAE,CAAC,eAAH,IAAsB,IAAI,EAAE,CAAC,eAAH,CAAmB,MAA1E,EAAkF;AAC9E,UAAI,CAAE,KAAK,CAAC,OAAN,CAAc,IAAd,CAAN,EAA2B;AACvB,aAAK,MAAM,CAAX,IAAgB,IAAhB,EAAsB;AAClB,cAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAArC,EAA2C,CAA3C,CAAJ,EAAmD;AAC/C,uBAAW,CAAC,GAAZ,CAAgB,CAAhB;AACH;AACJ;AACJ;AACJ;;AACD,QAAI,GAAG,CAAC,iBAAJ,IAAyB,KAAK,CAAC,OAAN,CAAc,IAAd,CAAzB,IAAgD,IAAI,IAAI,CAAC,MAA7D,EAAqE;AACjE,YAAM,GAAG,GAAG,EAAE,CAAC,eAAH,IAAsB,EAAlC;;AACA,UAAI,GAAG,CAAC,MAAJ,CAAW,CAAC,IAAI,CAAC,CAAC,CAAD,CAAD,CAAK,QAAL,CAAc,QAAd,CAAhB,EAAyC,MAAzC,KAAoD,CAAxD,EAA2D;AACvD,yEAAW,CAAC,iDAAU,CAAC,uBAAZ,EAAqC,IAArC,EAA2C,EAA3C,EAA+C;AACtD,aADsD;AAEtD,uBAAa,EAAE,CAAC,CAAC,gBAAD,EAAmB,UAAnB,CAAD;AAFuC,SAA/C,CAAX;;AAIA,YAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,gBAAM,GAAG,IAAT;AACH,SAFD,MAEO;AACH,iBAAO,IAAP;AACH;AACJ;AACJ;;AAED,SAAK,MAAM,CAAX,IAAgB,EAAE,CAAC,OAAnB,EAA4B;AACxB,iBAAW,CAAC,MAAZ,CAAmB,CAAC,CAAC,CAAD,CAApB;;AACA,UAAI,MAAM,CAAC,SAAP,CAAiB,cAAjB,CAAgC,IAAhC,CAAqC,IAArC,EAA2C,CAAC,CAAC,CAAD,CAA5C,CAAJ,EAAsD;AAClD,cAAM,EAAE,GAAG,CAAC,CAAC,CAAD,CAAD,CAAK,IAAL,KAAc,UAAd,GAA4B;wCAE5B,CAAC,CAAC,CAAD,CAAD,CAAK,Q,GAAQ;AAChB,cAAI,EAAE,CAAC,CAAC,CAAD,CADS;AAEhB,iBAAO,EAAE,CAAC,CAAC,CAAD,CAAD,CAAK,OAFE;AAGhB,kBAAQ,EAAE,CAAC,CAAC,CAAD,CAAD,CAAK,QAHC;AAIhB,mBAAS,EAAE,CAAC,CAAC,CAAD,CAAD,CAAK;AAJA,S,CAFb,GAOH,CAAC,CAAC,CAAD,CAPT;AAQA,cAAM,GAAG,GAAG,YAAY,CAAI,IAAI,CAAC,CAAC,CAAC,CAAD,CAAF,CAAR,EAAgB,EAAhB,EAAoB,GAApB,CAAxB;;AAEA,YAAI,GAAJ,EAAS;AACL,cAAI,MAAJ,EAAY;AACR,gBAAI,kEAAgB,CAAC,MAAD,EAAS,CAAC,CAAC,CAAD,CAAV,CAApB,EAAoC;AAChC;AACH;;AACD,kBAAM,CAAC,CAAC,CAAC,CAAD,CAAF,CAAN,GAAe,GAAG,CAAC,KAAnB;;AACA,gBAAI,EAAE,CAAC,iBAAP,EAA0B;AACtB,iBAAG,CAAC,wBAAJ,GAA+B,IAA/B;AACH;AACJ;AACJ,SAVD,MAUO;AACH,cAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,kBAAM,GAAG,IAAT;AACH,WAFD,MAEO;AACH,mBAAO,IAAP;AACH;AACJ;AACJ,OA5BD,MA4BO;AACH,YAAI,CAAC,CAAC,CAAD,CAAD,CAAK,IAAL,KAAc,UAAlB,EAA8B;AAC1B,mFAAmB,CAAC,iDAAU,CAAC,QAAZ,EAAsB,IAAtB,EAA4B,CAAC,CAAC,CAAC,CAAD,CAAF,EAAO,KAAK,CAAZ,CAA5B,EAA4C;AAAC;AAAD,WAA5C,CAAnB;;AACA,cAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,kBAAM,GAAG,IAAT;AACH,WAFD,MAEO;AACH,mBAAO,IAAP;AACH;AACJ;AACJ;AACJ;;AAED,QAAI,EAAE,CAAC,eAAH,IAAsB,IAAI,EAAE,CAAC,eAAH,CAAmB,MAAjD,EAAyD;AACrD,gBAAU,oBAAV,GAA8B;AAC1B,aAAK,MAAM,CAAX,IAAgB,WAAW,CAAC,MAAZ,EAAhB,EAAsC;AAClC,gBAAM,CAAN;AACH;;AACD,YAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACrB,eAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,EAAlC,EAAsC;AAClC,kBAAM,MAAM,CAAC,CAAD,CAAZ;AACH;AACJ;AACJ;;AACD,WAAK,MAAM,CAAX,IAAgB,oBAAoB,EAApC,EAAwC;AACpC,YAAI,aAAa,GAAG,KAApB;AACA,cAAM,iBAAiB,GAAoB,EAA3C;;AAEA,aAAK,MAAM,EAAX,IAAiB,EAAE,CAAC,eAApB,EAAqC;AACjC,eAAK,MAAM,EAAX,IAAiB,EAAE,CAAC,CAAD,CAAnB,EAAwB;AACpB,kBAAM,EAAE,GAAG,EAAE,CAAC,CAAD,CAAb;;AACA,gBAAI,EAAE,KAAK,QAAX,EAAqB;AACjB,kBAAI,uDAAa,CAAC,IAAd,CAAmB,CAAnB,CAAJ,EAA2B;AACvB,iCAAiB,CAAC,IAAlB,CAAuB,EAAvB;AACH;AACJ,aAJD,MAIO,IAAI,EAAE,KAAK,QAAX,EAAqB;AACxB,+BAAiB,CAAC,IAAlB,CAAuB,EAAvB;AACH,aAFM,MAEA;AACH,kBAAI,EAAE,CAAC,IAAH,CAAQ,CAAR,CAAJ,EAAgB;AACZ,iCAAiB,CAAC,IAAlB,CAAuB,EAAvB;AACH;AACJ;;AACD,gBAAI,EAAE,CAAC,IAAH,KAAY,UAAhB,EAA4B;AACxB,2BAAa,GAAG,IAAhB;AACH;AACJ;AACJ;;AACD,YAAI,iBAAiB,CAAC,MAAlB,KAA6B,CAAjC,EAAoC;AAChC,cAAI,aAAJ,EAAmB;AACf;AACH;;AACD,2EAAW,CAAC,iDAAU,CAAC,uBAAZ,EAAqC,IAArC,EAA2C,EAA3C,EAA+C;AACtD,eADsD;AAEtD,yBAAa,EAAE,CAAC,CAAC,gBAAD,EAAmB,CAAnB,CAAD;AAFuC,WAA/C,CAAX;;AAIA,cAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,kBAAM,GAAG,IAAT;AACA;AACH,WAHD,MAGO;AACH,mBAAO,IAAP;AACH;AACJ;;AAED,mBAAW,CAAC,MAAZ,CAAmB,CAAnB;AACA,YAAI,QAAQ,GAAG,KAAf;AACA,cAAM,WAAW,GAAG,GAAG,CAAC,MAAJ,CAAW,MAA/B;;AAEA,aAAK,MAAM,EAAX,IAAiB,iBAAjB,EAAoC;AAChC,gBAAM,GAAG,GAAG,YAAY,CAAI,IAAI,CAAC,CAAD,CAAR,EAAa,EAAE,CAAC,IAAH,KAAY,UAAZ,GAAwB,gCAElD,EAAE,CAAC,QAF+C,GAEvC;AACd,mBAAO,EAAE,EAAE,CAAC,OADE;AAEd,oBAAQ,EAAE,EAAE,CAAC,QAFC;AAGd,qBAAS,EAAE,EAAE,CAAC,SAHA;AAId,gBAAI,EAAE;AAJQ,WAFuC,CAAxB,GAO9B,gCACI,EADJ,GACM;AACL,gBAAI,EAAE;AADD,WADN,CAPiB,EAUjB,GAViB,CAAxB;;AAWA,cAAI,GAAJ,EAAS;AACL,gBAAI,MAAJ,EAAY;AACR,sBAAQ,GAAG,KAAX;AACA,iBAAG,CAAC,MAAJ,CAAW,MAAX,GAAoB,WAApB;;AACA,kBAAI,kEAAgB,CAAC,MAAD,EAAS,CAAT,CAApB,EAAiC;AAC7B;AACH;;AACD,oBAAM,CAAC,CAAD,CAAN,GAAY,GAAG,CAAC,KAAhB;AACH;;AACD;AACH,WAVD,MAUO;AACH,oBAAQ,GAAG,IAAX;AACH;AACJ;;AACD,YAAI,QAAJ,EAAc;AACV,cAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,kBAAM,GAAG,IAAT;AACH,WAFD,MAEO;AACH,mBAAO,IAAP;AACH;AACJ;AACJ;AACJ;;AAED,QAAI,GAAG,CAAC,iBAAJ,IAAyB,IAAI,WAAW,CAAC,IAA7C,EAAmD;AAC/C,uEAAW,CAAC,iDAAU,CAAC,uBAAZ,EAAqC,IAArC,EAA2C,EAA3C,EAA+C;AACtD,WADsD;AAEtD,qBAAa,EAAE,CAAC,CAAC,gBAAD,EAAmB,KAAK,CAAC,IAAN,CAAW,WAAW,CAAC,MAAZ,EAAX,EAAiC,IAAjC,CAAsC,IAAtC,CAAnB,CAAD;AAFuC,OAA/C,CAAX;;AAIA,UAAI,GAAG,IAAI,GAAG,CAAC,QAAf,EAAyB;AACrB,cAAM,GAAG,IAAT;AACH,OAFD,MAEO;AACH,eAAO,IAAP;AACH;AACJ;AACJ;;AACD,MAAI,CAAE,MAAN,EAAc,CACV;AACA;AACH;;AAED,MAAI,MAAM,IAAI,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAtB,KAA0C,IAAxD,EAA8D;AAC1D,qEAAW,CAAC,iDAAU,CAAC,cAAZ,EAA4B,IAA5B,EAAkC,EAAlC,EAAsC;AAAC;AAAD,KAAtC,CAAX;AACA,WAAO,IAAP;AACH;;AAED,SAAO,MAAM,GAAG;AAAC,SAAK,EAAG,GAAG,IAAI,GAAG,CAAC,MAAZ,GAAsB,GAAG,CAAC,MAAJ,CAAW,MAAX,EAAmB,EAAnB,CAAtB,GAA+C;AAAvD,GAAH,GAAoE,IAAjF;AACH;;AAGK,SAAU,YAAV,CACF,IADE,EACS,EADT,EAC4B,GAD5B,EACoD,SADpD,EAC+E;AAEjF,MAAI;AACA,OAAG,CAAC,SAAJ,CAAc,IAAd,CACI,OAAO,SAAP,KAAqB,QAArB,IAAiC,OAAO,SAAP,KAAqB,QAAtD,GACA,CAAC,EAAD,EAAK,SAAL,CADA,GACkB,EAFtB;;AAIA,YAAQ,EAAE,CAAC,IAAX;AACA,WAAK,OAAL;AACI,eAAO,0BAA0B,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAjC;;AACJ,WAAK,KAAL;AACI,eAAO,wBAAwB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA/B;;AACJ,WAAK,SAAL;AACI,eAAO,4BAA4B,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAnC;;AACJ,WAAK,WAAL;AACI,eAAO,8BAA8B,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAArC;;AACJ,WAAK,iBAAL;AACI,eAAO,mCAAmC,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA1C;;AACJ,WAAK,UAAL;AACI,eAAO,yBAAyB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAhC;;AACJ,WAAK,UAAL;AACI,eAAO,yBAAyB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAAhC;;AACJ,WAAK,QAAL;AACI,eAAO,sBAAsB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA7B;;AACJ,WAAK,MAAL;AACI,eAAO,qBAAqB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA5B;;AACJ,WAAK,QAAL;AACI,eAAO,uBAAuB,CAAC,IAAD,EAAO,EAAP,EAAW,GAAX,CAA9B;;AACJ,WAAK,SAAL;AACI,YAAI,GAAG,CAAC,MAAR,EAAgB;AACZ,iBAAO,YAAY,CAAI,IAAJ,EAAU,oEAAc,CAAC,GAAG,CAAC,MAAL,EAAa,EAAb,EAAiB;AAAC,qBAAS,EAAE,CAAZ;AAAe,wBAAY,EAAE;AAA7B,WAAjB,CAAxB,EAA4E,GAA5E,CAAnB;AACH;;AACD,yEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,SAAzC,CAAX;AACA,cAAM,IAAI,2DAAJ,CAAoB,sBAAsB,EAAE,CAAC,iBAAiB,gBAA9D,EAAgF,EAAhF,EAAoF,GAApF,CAAN;;AACJ,WAAK,UAAL;AACI,YAAI,GAAG,CAAC,MAAR,EAAgB;AACZ,iBAAO,YAAY,CAAI,IAAJ,EAAU,oEAAc,CAAC,GAAG,CAAC,MAAL,EAAa,EAAb,EAAiB;AAAC,qBAAS,EAAE,CAAZ;AAAe,wBAAY,EAAE;AAA7B,WAAjB,CAAxB,EAA4E,GAA5E,CAAnB;AACH;;AACD,yEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,SAAzC,CAAX;AACA,cAAM,IAAI,2DAAJ,CAAoB,sCAAsC,EAAE,CAAC,QAAQ,EAArE,EAAyE,EAAzE,EAA6E,GAA7E,CAAN;;AACJ,WAAK,QAAL;AAAe,WAAK,UAAL;AACX,yEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,SAAzC,CAAX;AACA,cAAM,IAAI,2DAAJ,CAAoB,8BAA+B,EAAU,CAAC,IAAI,EAAlE,EAAsE,EAAtE,EAA0E,GAA1E,CAAN;;AACJ;AACI,yEAAW,CAAC,iDAAU,CAAC,iBAAZ,EAA+B,IAA/B,EAAqC,EAArC,EAAyC;AAAC;AAAD,SAAzC,CAAX;AACA,cAAM,IAAI,2DAAJ,CAAoB,2BAA4B,EAAU,CAAC,IAAI,EAA/D,EAAmE,EAAnE,EAAuE,GAAvE,CAAN;AAtCJ;AAwCH,GA7CD,SA6CU;AACN,OAAG,CAAC,SAAJ,CAAc,GAAd;AACH;AACJ;AAGK,SAAU,QAAV,CACF,IADE,EACS,EADT,EAC4B,GAD5B,EAC4D;AAE9D,QAAM,IAAI,iBACH;AAAC,UAAM,EAAE,EAAT;AAAa,aAAS,EAAE;AAAxB,GADG,EAEF,GAAG,IAAI,EAFL,CAAV;;AAIA,MAAI;AACA,WAAO,YAAY,CAAI,IAAJ,EAAU,EAAV,EAAc,IAAd,CAAnB;AACH,GAFD,SAEU;AACN,QAAI,GAAJ,EAAS;AACL,SAAG,CAAC,MAAJ,GAAa,IAAI,CAAC,MAAlB;AACH;AACJ;AACJ;AAGK,SAAU,MAAV,CACF,IADE,EACS,EADT,EAC4B,GAD5B,EAC4D;AAE9D,SAAQ,CAAC,CAAE,QAAQ,CAAI,IAAJ,EAAU,EAAV,EAAc,GAAd,CAAnB;AACH;AAGK,SAAU,OAAV,CAAkB,MAAlB,EAA4C,IAA5C,EAAwD;;;AAC1D,MAAI,MAAM,CAAC,GAAP,CAAW,IAAX,CAAJ,EAAsB;AAClB,WAAO,YAAM,CAAC,GAAP,CAAW,IAAX,OAAgB,IAAhB,IAAgB,aAAhB,GAAgB,MAAhB,GAAgB,GAAE,EAAzB;AACH;;AACD,QAAM,IAAI,KAAJ,CAAU,oCAAoC,IAAI,EAAlD,CAAN;AACH,C","file":"tynder-rt.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tynder\"] = factory();\n\telse\n\t\troot[\"tynder\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { CustomConstraintInfo } from '../types';\nimport { dummyTargetObject,\n         isUnsafeVarNames }     from '../lib/util';\n\n\n\ntype MapperFn = (data: any, fields: string[]) => any[];\nconst mapperErrMsg = 'Unsafe symbol name is appeared in unique constraint assertion:';\n\n\nconst normalMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field]);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst nonNullMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field] ?? NaN);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst checkerGen = (mapper: MapperFn) => {\n    return ((data: any, args: any) => {\n        const errMsg = `evaluateFormula: invalid parameter ${args}`;\n        if (! Array.isArray(data)) {\n            throw new Error(errMsg);\n        }\n\n        const fields: string[] = [];\n        if (typeof args === 'string') {\n            fields.push(args);\n        } else if (Array.isArray(args)) {\n            for (const z of args) {\n                if (typeof z !== 'string') {\n                    throw new Error(errMsg);\n                }\n            }\n            fields.push(...args);\n        }\n\n        const mapped = data.map(x => mapper(x, fields));\n        for (let i = 0; i < mapped.length; i++) {\n            CMP: for (let j = 0; j < mapped.length; j++) {\n                if (i === j) {\n                    continue;\n                }\n                const a = mapped[i];\n                const b = mapped[j];\n                for (let k = 0; k < a.length; k++) { // TODO: this is slow! more better checking\n                    if (a[k] !== b[k]) {\n                        continue CMP;\n                    }\n                }\n                return false;\n            }\n        }\n\n        return true;\n    });\n};\n\n\nexport const constraints: Array<[string, CustomConstraintInfo]> = [\n    ['unique', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(normalMapper),\n    }],\n    ['unique-non-null', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(nonNullMapper),\n    }],\n];\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype,\n         CustomConstraintInfo }             from './types';\nimport { stereotypes as dateStereotypes }   from './stereotypes/date';\nimport { constraints as uniqueConstraints } from './constraints/unique';\n\nexport * from './types';\nexport * from './operators';\nexport * from './validator';\nexport * from './picker';\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ...dateStereotypes,\n];\n\nexport const customConstraints: Array<[string, CustomConstraintInfo]> = [\n    ...uniqueConstraints,\n];\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ValidationContext } from '../types';\n\n\n\nexport class ValidationError extends Error {\n    public ty?: TypeAssertion;\n    public ctx?: Partial<ValidationContext>;\n    public constructor(message: string, ty?: TypeAssertion, ctx?: Partial<ValidationContext>) {\n        super(message);\n        this.ty = ty;\n        this.ctx = ctx;\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport function escapeString(s: string) {\n    return (s\n        .replace(/\\x08/g, '\\\\b')\n        .replace(/\\f/g, '\\\\f')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\v/g, '\\\\v')\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\'/g, '\\\\\\'')\n        .replace(/\\\"/g, '\\\\\\\"')\n        .replace(/\\`/g, '\\\\\\`')\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         ErrorMessages,\n         TypeAssertionErrorMessageConstraints,\n         TypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         ValidationContext } from '../types';\nimport { escapeString }      from './escape';\nimport { nvl }               from './util';\n\n\nexport const errorTypeNames = [\n    '',\n    'InvalidDefinition',\n    'Required',\n    'TypeUnmatched',\n    'AdditionalPropUnmatched',\n    'RepeatQtyUnmatched',\n    'SequenceUnmatched',\n    'ValueRangeUnmatched',\n    'ValuePatternUnmatched',\n    'ValueLengthUnmatched',\n    'ValueUnmatched',\n];\n\n\nexport const defaultMessages: ErrorMessages = {\n    invalidDefinition:       '\"%{name}\" of \"%{parentType}\" type definition is invalid.',\n    required:                '\"%{name}\" of \"%{parentType}\" is required.',\n    typeUnmatched:           '\"%{name}\" of \"%{parentType}\" should be type \"%{expectedType}\".',\n    additionalPropUnmatched: '\"%{addtionalProps}\" of \"%{parentType}\" are not matched to additional property patterns.',\n    repeatQtyUnmatched:      '\"%{name}\" of \"%{parentType}\" should repeat %{repeatQty} times.',\n    sequenceUnmatched:       '\"%{name}\" of \"%{parentType}\" sequence is not matched',\n    valueRangeUnmatched:     '\"%{name}\" of \"%{parentType}\" value should be in the range %{minValue} to %{maxValue}.',\n    valuePatternUnmatched:   '\"%{name}\" of \"%{parentType}\" value should be matched to pattern \"%{pattern}\"',\n    valueLengthUnmatched:    '\"%{name}\" of \"%{parentType}\" length should be in the range %{minLength} to %{maxLength}.',\n    valueUnmatched:          '\"%{name}\" of \"%{parentType}\" value should be \"%{expectedValue}\".',\n};\n\n\ntype TopRepeatable = RepeatedAssertion | SpreadAssertion | OptionalAssertion | null;\n\n\ninterface ReportErrorArguments {\n    ctx: ValidationContext;\n    substitutions?: [[string, string]]; // addtional or overwritten substitution values\n}\n\n\nfunction getErrorMessage(errType: ErrorTypes, ...messages: ErrorMessages[]) {\n    for (const m of messages) {\n        switch (errType) {\n        case ErrorTypes.InvalidDefinition:\n            if (m.invalidDefinition) {\n                return m.invalidDefinition;\n            }\n            break;\n        case ErrorTypes.Required:\n            if (m.required) {\n                return m.required;\n            }\n            break;\n        case ErrorTypes.TypeUnmatched:\n            if (m.typeUnmatched) {\n                return m.typeUnmatched;\n            }\n            break;\n        case ErrorTypes.AdditionalPropUnmatched:\n            if (m.additionalPropUnmatched) {\n                return m.additionalPropUnmatched;\n            }\n            break;\n        case ErrorTypes.RepeatQtyUnmatched:\n            if (m.repeatQtyUnmatched) {\n                return m.repeatQtyUnmatched;\n            }\n            break;\n        case ErrorTypes.SequenceUnmatched:\n            if (m.sequenceUnmatched) {\n                return m.sequenceUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueRangeUnmatched:\n            if (m.valueRangeUnmatched) {\n                return m.valueRangeUnmatched;\n            }\n            break;\n        case ErrorTypes.ValuePatternUnmatched:\n            if (m.valuePatternUnmatched) {\n                return m.valuePatternUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueLengthUnmatched:\n            if (m.valueLengthUnmatched) {\n                return m.valueLengthUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueUnmatched:\n            if (m.valueUnmatched) {\n                return m.valueUnmatched;\n            }\n            break;\n        }\n    }\n    return '';\n}\n\n\nfunction findTopRepeatableAssertion(ctx: ValidationContext): TopRepeatable {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.kind === 'repeated' || x.kind === 'spread' || x.kind === 'optional'\n                ) as RepeatedAssertion | SpreadAssertion | OptionalAssertion || null;\n    return ret;\n}\n\n\nfunction getExpectedType(ty: TypeAssertion): string {\n    switch (ty.kind) {\n    case 'repeated':\n        return `(repeated ${getExpectedType(ty.repeated)})`;\n    case 'spread':\n        return getExpectedType(ty.spread);\n    case 'sequence':\n        return '(sequence)';\n    case 'primitive':\n        return ty.primitiveName;\n    case 'primitive-value':\n        return `(value ${\n            typeof ty.value === 'string' ?\n                `'${String(ty.value)}'` :\n                String(ty.value)})`;\n    case 'optional':\n        return getExpectedType(ty.optional);\n    case 'one-of':\n        return `(one of ${ty.oneOf.map(x => getExpectedType(x)).join(', ')})`;\n    case 'never': case 'any': case 'unknown':\n        return ty.kind;\n    case 'symlink':\n        return ty.symlinkTargetName;\n    default:\n        return ty.typeName ? ty.typeName : '?';\n    }\n}\n\n\nexport function formatErrorMessage(\n        msg: string, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments,\n        values: {dataPath: string, topRepeatable: TopRepeatable, parentType: string, entryName: string}) {\n\n    let ret = msg;\n    // TODO: complex type object members' custom error messages are not displayed?\n    // TODO: escapeString() is needed?\n\n    const tr = values.topRepeatable;\n\n    const dict = new Map<string, string>([\n        ['expectedType',\n            ty.stereotype ?\n                ty.stereotype :\n            escapeString(getExpectedType(ty))],\n        ['type',\n            escapeString(typeof data)],\n        ['expectedValue',\n            escapeString(\n                ty.kind === 'primitive-value' ?\n                    String(ty.value) :\n                ty.kind === 'enum' ?\n                    ty.typeName ?\n                        `enum member of ${ty.typeName}` :\n                        '?' :\n                '?')],\n        ['value',\n            escapeString(String(data))],\n        ['repeatQty',\n            escapeString(\n                tr ?\n                    tr.kind !== 'optional' ? `${\n                        nvl(tr.min, '')}${\n                            (tr.min !== null && tr.min !== void 0) ||\n                            (tr.max !== null && tr.max !== void 0) ? '..' : ''}${\n                            nvl(tr.max, '')}` :\n                        '0..1' :\n                    '?')],\n        ['minValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minValue, nvl(ty.greaterThanValue, '(smallest)'))}` : '?')],\n        ['maxValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxValue, nvl(ty.lessThanValue, '(biggest)'))}` : '?')],\n        ['pattern',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${ty.pattern ? `/${ty.pattern.source}/${ty.pattern.flags}` : '(pattern)'}` : '?')],\n        ['minLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minLength, '0')}` : '?')],\n        ['maxLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxLength, '(biggest)')}` : '?')],\n        ['name',\n            escapeString(\n                `${ty.kind !== 'repeated' && values.dataPath.endsWith('repeated)') ?\n                    'repeated item of ' :\n                   ty.kind !== 'sequence' && values.dataPath.endsWith('sequence)') ?\n                    'sequence item of ' : ''}${\n                values.entryName || '?'}`)],\n        ['parentType',\n            escapeString(\n                values.parentType || '?')],\n        ['dataPath',\n            values.dataPath],\n\n        ...(args.substitutions || []),\n    ]);\n\n    for (const ent of dict.entries()) {\n        ret = ret.replace(new RegExp(`%{${ent[0]}}`), ent[1]);\n    }\n\n    return ret;\n}\n\n\ninterface DataPathEntry {\n    name: string;\n    kind: 'type' | 'key' | 'index';\n}\n\n\nexport function reportError(\n        errType: ErrorTypes, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments) {\n\n    const messages: ErrorMessages[] = [];\n    if (ty.messages) {\n        messages.push(ty.messages);\n    }\n    if (args.ctx.errorMessages) {\n        messages.push(args.ctx.errorMessages);\n    }\n    messages.push(defaultMessages);\n\n    const dataPathEntryArray: DataPathEntry[] = [];\n\n    for (let i = 0; i < args.ctx.typeStack.length; i++) {\n        const p = args.ctx.typeStack[i];\n        const next = args.ctx.typeStack[i + 1];\n        const pt = Array.isArray(p) ? p[0] : p;\n        const pi = Array.isArray(next) ? next[1] : void 0;\n\n        let isSet = false;\n        if (pt.kind === 'repeated') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}repeated)`});\n                isSet = true;\n            }\n        } else if (pt.kind === 'sequence') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}sequence)`});\n                isSet = true;\n            }\n        }\n        if (! isSet) {\n            if (pt.name) {\n                if (i === 0) {\n                    if (pt.typeName) {\n                        dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                    } else {\n                        dataPathEntryArray.push({kind: 'key', name: pt.name});\n                    }\n                } else {\n                    const len = dataPathEntryArray.length;\n                    if (len && dataPathEntryArray[len - 1].kind === 'type') {\n                        if (pt.kind === 'object' && next && pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name as string}); // NOTE: type inference failed\n                        }\n                    } else {\n                        if (pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name});\n                        }\n                    }\n                }\n            } else if (pt.typeName) {\n                dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n            }\n        }\n    }\n\n    let dataPath = '';\n    for (let i = 0; i < dataPathEntryArray.length; i++) {\n        const p = dataPathEntryArray[i];\n        dataPath += p.name;\n        if (i + 1 === dataPathEntryArray.length) {\n            break;\n        }\n        dataPath += p.kind === 'type' ? ':' : '.';\n    }\n\n    let parentType = '';\n    let entryName = '';\n    for (let i = dataPathEntryArray.length - 1; 0 <= i; i--) {\n        const p = dataPathEntryArray[i];\n        if (p.kind === 'type') {\n            if (i !== 0 && i === dataPathEntryArray.length - 1) {\n                const q = dataPathEntryArray[i - 1];\n                if (q.kind === 'index') {\n                    continue; // e.g.: \"File:acl.(0:repeated).ACL\"\n                }\n            }                 // else: \"File:acl.(0:repeated).ACL:target\"\n            parentType = p.name;\n            for (let j = i + 1; j < dataPathEntryArray.length; j++) {\n                const q = dataPathEntryArray[j];\n                if (q.kind === 'key') {\n                    entryName = q.name;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    if (! parentType) {\n        for (let i = args.ctx.typeStack.length - 1; 0 <= i; i--) {\n            const p = args.ctx.typeStack[i];\n            const pt = Array.isArray(p) ? p[0] : p;\n            if (pt.typeName) {\n                parentType = pt.typeName;\n            }\n        }\n    }\n\n    const topRepeatable: TopRepeatable = findTopRepeatableAssertion(args.ctx);\n    const values = {dataPath, topRepeatable, parentType, entryName};\n\n    const constraints: TypeAssertionErrorMessageConstraints = {};\n    const cSrces: TypeAssertionErrorMessageConstraints[] = [ty as any];\n\n    if (errType === ErrorTypes.RepeatQtyUnmatched && topRepeatable) {\n        cSrces.unshift(topRepeatable as any);\n    }\n\n    for (const cSrc of cSrces) {\n        if (nvl(cSrc.minValue, false)) {\n            constraints.minValue = cSrc.minValue;\n        }\n        if (nvl(cSrc.maxValue, false)) {\n            constraints.maxValue = cSrc.maxValue;\n        }\n        if (nvl(cSrc.greaterThanValue, false)) {\n            constraints.greaterThanValue = cSrc.greaterThanValue;\n        }\n        if (nvl(cSrc.lessThanValue, false)) {\n            constraints.lessThanValue = cSrc.lessThanValue;\n        }\n        if (nvl(cSrc.minLength, false)) {\n            constraints.minLength = cSrc.minLength;\n        }\n        if (nvl(cSrc.maxLength, false)) {\n            constraints.maxLength = cSrc.maxLength;\n        }\n        if (nvl(cSrc.pattern, false)) {\n            const pat = cSrc.pattern as any as RegExp;\n            constraints.pattern = `/${pat.source}/${pat.flags}`;\n        }\n        if (nvl(cSrc.min, false)) {\n            constraints.min = cSrc.min;\n        }\n        if (nvl(cSrc.max, false)) {\n            constraints.max = cSrc.max;\n        }\n    }\n\n    const val: {value?: any} = {};\n\n    switch (typeof data) {\n    case 'number': case 'bigint': case 'string': case 'boolean': case 'undefined':\n        val.value = data;\n        break;\n    case 'object':\n        if (data === null) {\n            val.value = data;\n        }\n    }\n\n    if (ty.messageId) {\n        args.ctx.errors.push({\n            code: `${ty.messageId}-${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message ?\n                ty.message :\n                getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else if (ty.message) {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message, data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    }\n}\n\n\nexport function reportErrorWithPush(\n        errType: ErrorTypes, data: any,\n        tyidx: [TypeAssertion, number | string | undefined],\n        args: ReportErrorArguments) {\n\n    try {\n        args.ctx.typeStack.push(tyidx);\n        reportError(errType, data, tyidx[0], args);\n    } finally {\n        args.ctx.typeStack.pop();\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap,\n         TypeAssertionSetValue,\n         ObjectAssertion,\n         AssertionSymlink,\n         SymbolResolverOperators,\n         ResolveSymbolOptions,\n         SymbolResolverContext } from '../types';\nimport * as operators            from '../operators';\nimport { NumberPattern }         from '../lib/util';\n\n\n\nfunction mergeTypeAndSymlink(ty: TypeAssertion, link: AssertionSymlink): TypeAssertion {\n    const link2 = {...link};\n    delete link2.kind;\n    delete link2.symlinkTargetName;\n    delete link2.memberTree;\n    return ({...ty, ...link2} as any as TypeAssertion);\n}\n\n\nfunction updateSchema(original: TypeAssertion, schema: TypeAssertionMap, ty: TypeAssertion, typeName: string | undefined) {\n    if (typeName && schema.has(typeName)) {\n        const z: TypeAssertionSetValue = schema.get(typeName) as TypeAssertionSetValue;\n        if (z.ty === original) {\n            schema.set(typeName, {...z, ty, resolved: true});\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveMemberNames(\n        ty: TypeAssertion, rootSym: string, memberTreeSymbols: string[], memberPos: number): TypeAssertion {\n\n    const addTypeName = (mt: TypeAssertion, typeName: string | undefined, memberSym: string) => {\n        if (typeName) {\n            return ({\n                ...mt,\n                typeName: memberPos === 0 ?\n                    `${rootSym}.${memberTreeSymbols.join('.')}` :\n                    `${typeName}.${memberSym}`,\n            });\n        } else {\n            return mt;\n        }\n    };\n\n    for (let i = memberPos; i < memberTreeSymbols.length; i++) {\n        const memberSym = memberTreeSymbols[i];\n\n        switch (ty.kind) {\n        case 'optional':\n            return resolveMemberNames(ty.optional, rootSym, memberTreeSymbols, i + 1);\n        case 'object':\n            for (const m of ty.members) {\n                if (memberSym === m[0]) {\n                    return addTypeName(\n                        resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1),\n                        ty.typeName,\n                        memberSym,\n                    );\n                }\n            }\n            if (ty.additionalProps) {\n                for (const m of ty.additionalProps) {\n                    for (const k of m[0]) {\n                        switch (k) {\n                        case 'number':\n                            if (NumberPattern.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        case 'string':\n                            return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                        default:\n                            if (k.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            throw new Error(`Undefined member name is appeared: ${memberSym}`);\n        case 'symlink':\n            if (! ty.typeName) {\n                throw new Error(`Reference of anonymous type is appeared: ${memberSym}`);\n            }\n            return ({\n                ...{\n                    kind: 'symlink',\n                    symlinkTargetName: rootSym,\n                    name: memberSym,\n                    typeName: rootSym,\n                },\n                ...(0 < memberTreeSymbols.length ? {\n                    memberTree: memberTreeSymbols,\n                } : {}),\n            });\n        default:\n            // TODO: kind === 'operator'\n            throw new Error(`Unsupported type kind is appeared: (kind:${ty.kind}).${memberSym}`);\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveSymbols(schema: TypeAssertionMap, ty: TypeAssertion, ctx: SymbolResolverContext): TypeAssertion {\n    const ctx2 = {...ctx, nestLevel: ctx.nestLevel + 1};\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const x = schema.get(ty.symlinkTargetName);\n            if (! x) {\n                throw new Error(`Undefined symbol '${ty.symlinkTargetName}' is referred.`);\n            }\n            if (0 <= ctx.symlinkStack.findIndex(s => s === ty.symlinkTargetName)) {\n                return ty;\n            }\n\n            const ty2 = {...ty};\n            let xTy = x.ty;\n            if (ty.memberTree && 0 < ty.memberTree.length) {\n                xTy = {\n                    ...resolveMemberNames(xTy, ty.symlinkTargetName, ty.memberTree, 0),\n                };\n                ty2.typeName = xTy.typeName;\n            }\n\n            return (\n                resolveSymbols(\n                    schema,\n                    mergeTypeAndSymlink(xTy, ty2),\n                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty2.symlinkTargetName]},\n                )\n            );\n        }\n    case 'repeated':\n        return updateSchema(ty, schema, {\n            ...ty,\n            repeated: resolveSymbols(schema, ty.repeated, ctx2),\n        }, ty.typeName);\n    case 'spread':\n        return updateSchema(ty, schema, {\n            ...ty,\n            spread: resolveSymbols(schema, ty.spread, ctx2),\n        }, ty.typeName);\n    case 'sequence':\n        return updateSchema(ty, schema, {\n            ...ty,\n            sequence: ty.sequence.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'one-of':\n        return updateSchema(ty, schema, {\n            ...ty,\n            oneOf: ty.oneOf.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'optional':\n        return updateSchema(ty, schema, {\n            ...ty,\n            optional: resolveSymbols(schema, ty.optional, ctx2),\n        }, ty.typeName);\n    case 'object':\n        {\n            if (0 < ctx.nestLevel && ty.typeName && 0 <= ctx.symlinkStack.findIndex(s => s === ty.typeName)) {\n                if (schema.has(ty.typeName)) {\n                    const z = schema.get(ty.typeName) as TypeAssertionSetValue;\n                    if (z.resolved) {\n                        return z.ty;\n                    }\n                }\n            }\n\n            const baseSymlinks = ty.baseTypes?.filter(x => x.kind === 'symlink') as AssertionSymlink[];\n            if (baseSymlinks && baseSymlinks.length > 0 && !ctx.isDeserialization) {\n                const exts = baseSymlinks\n                    .map(x => resolveSymbols(schema, x, ctx2))\n                    .filter(x => x.kind === 'object');\n                // TODO: if x.kind !== 'object' items exist -> error?\n                const d2 = resolveSymbols(\n                    schema,\n                    operators.derived({\n                        ...ty,\n                        ...(ty.baseTypes ? {\n                            baseTypes: ty.baseTypes.filter(x => x.kind !== 'symlink'),\n                        } : {}),\n                    }, ...exts),\n                    ty.typeName ?\n                        {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2,\n                );\n                return updateSchema(ty, schema, {\n                    ...ty,\n                    ...d2,\n                }, ty.typeName);\n            } else {\n                return updateSchema(ty, schema, {\n                    ...{\n                        ...ty,\n                        members: ty.members\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    },\n                    ...(ty.additionalProps && 0 < ty.additionalProps.length ? {\n                        additionalProps: ty.additionalProps\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    } : {}),\n                    ...(ty.baseTypes && 0 < ty.baseTypes.length ? {\n                        baseTypes: ctx.isDeserialization ?\n                            ty.baseTypes\n                                .map(x => x.kind === 'symlink' ? resolveSymbols(schema, x, ctx2) : x)\n                                .filter(x => x.kind === 'object') as ObjectAssertion[] :\n                            ty.baseTypes,\n                    } : {}),\n                }, ty.typeName);\n            }\n        }\n    case 'operator':\n        if (ctx2.operators) {\n            const ctx3 = ty.typeName ?\n                {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2;\n            const operands = ty.operands.map(x => {\n                if (typeof x === 'object' && x.kind) {\n                    return resolveSymbols(schema, x, ctx3);\n                }\n                return x;\n            });\n            if (0 < operands.filter(x => x && typeof x === 'object' &&\n                    (x.kind === 'symlink' || x.kind === 'operator')).length) {\n                throw new Error(`Unresolved type operator is found: ${ty.operator}`);\n            }\n            if (! ctx2.operators[ty.operator]) {\n                throw new Error(`Undefined type operator is found: ${ty.operator}`);\n            }\n            const ty2 = {...ty};\n            delete ty2.operator;\n            delete ty2.operands;\n            return updateSchema(\n                ty, schema,\n                {\n                    ...ty2,\n                    ...resolveSymbols(schema, ctx2.operators[ty.operator](...operands), ctx3),\n                },\n                ty.typeName,\n            );\n        } else {\n            return ty;\n        }\n    default:\n        return ty;\n    }\n}\n\n\nconst resolverOps: SymbolResolverOperators = {\n    picked: operators.picked,\n    omit: operators.omit,\n    partial: operators.partial,\n    intersect: operators.intersect,\n    subtract: operators.subtract,\n};\n\n\nexport function resolveSchema(schema: TypeAssertionMap, opts?: ResolveSymbolOptions): TypeAssertionMap {\n    for (const ent of schema.entries()) {\n        const ty = resolveSymbols(schema, ent[1].ty, {...opts, nestLevel: 0, symlinkStack: [ent[0]], operators: resolverOps});\n        ent[1].ty = ty;\n    }\n\n    return schema;\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable-next-line:function-constructor\nconst globalObj = Function('return this')();\nconst objConstructor = ({}).constructor; // NOTE: objConstructor            === Object\nconst funConstructor = Function;         // NOTE: ({}).toString.constructor === Function\n\n\nexport const SymbolPattern = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nexport const NumberPattern = /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)$/;\nexport const DatePattern = /^(\\d{4}-[01]\\d-[0-3]\\d)$/;\nexport const DateTimePattern =\n/^((?:(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))(?:[+-][0-2]\\d:[0-5]\\d|Z))$/;\nexport const DateTimeNoTzPattern =\n   /^((?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))$/;\n\n\nexport const dummyTargetObject = {};\n\n\nexport function isUnsafeVarNames(target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        return true;\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (objConstructor.hasOwnProperty(varName)) {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            if (con.hasOwnProperty(varName)) {\n                return true;\n            }\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        if (!target.hasOwnProperty(varName)) {\n            // function's prototypes' members\n            return true;\n        }\n    }\n    return false;\n}\n\n\nexport function nvl(v: any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? v : alt\n    );\n}\n\n\nexport function nvl2(v: any, f: (x: any) => any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? f(v) : alt\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveValueTypes,\n         PrimitiveValueTypeNames,\n         OptionalPrimitiveValueTypeNames,\n         PlaceholderTypeNames,\n         OptionalPlaceholderTypeNames,\n         ErrorMessages,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertionMember,\n         AdditionalPropsKey,\n         AdditionalPropsMember,\n         ObjectAssertion,\n         AssertionSymlink,\n         AssertionOperator,\n         TypeAssertion }    from './types';\nimport { dummyTargetObject,\n         isUnsafeVarNames } from './lib/util';\n\n\n\n// emulate Pick<T> // ex. Pick<Foo, 'a' | 'b'>\nexport function picked(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const name of names) {\n                const member = ty.members.find(x => x[0] === name);\n                if (member) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'picked',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Omit<T> // ex. Omit<Foo, 'a' | 'b'>\nexport function omit(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                if (! names.find(name => member[0] === name)) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'omit',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Partial<T>\nexport function partial(ty: TypeAssertion): TypeAssertion {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                let m: ObjectAssertionMember = member[1].kind === 'optional' ?\n                    member :\n                    [member[0], optional(member[1]), ...member.slice(2)] as ObjectAssertionMember;\n                if (m[2]) {\n                    m = [...m] as any;\n                    if (3 < m.length) {\n                        m[2] = false;\n                    } else {\n                        m.length = 2;\n                    }\n                }\n                m[1].name = m[0];\n                const optTy = {...(m[1] as OptionalAssertion).optional};\n                (m[1] as OptionalAssertion).optional = optTy;\n                if (optTy.name && optTy.name !== optTy.typeName) {\n                    delete optTy.name;\n                }\n                if (!optTy.name && optTy.typeName) {\n                    optTy.name = optTy.typeName;\n                }\n                members.push(m);\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'partial',\n                operands: [ty],\n            });\n        }\n    default:\n        return ty;\n    }\n}\n\n\n// intersection (a & b)\nexport function intersect(...types: TypeAssertion[]): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty intersection type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'intersect',\n            operands: types.slice(),\n        });\n    }\n    let lastTy: TypeAssertion | null = null;\n    const members = new Map<string, ObjectAssertionMember>();\n\n    for (const ty of types) {\n        if (ty && typeof ty === 'object') {\n            if (lastTy && lastTy.kind !== ty.kind) {\n                return ({\n                    kind: 'never',\n                });\n            }\n            lastTy = ty;\n            if (ty.kind === 'object') {\n                for (const m of ty.members) {\n                    if (m[2]) {\n                        const m2: ObjectAssertionMember = [...m] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.set(m[0], m2); // Overwrite if exists\n                    } else {\n                        members.set(m[0], m);  // Overwrite if exists\n                    }\n                }\n            }\n        } else {\n            return ({\n                kind: 'never',\n            });\n        }\n    }\n    if (lastTy && lastTy.kind !== 'object') {\n        return lastTy;\n    } else {\n        return ({\n            kind: 'object',\n            members: Array.from(members.values()),\n        });\n    }\n}\n\n\n// union (a | b)\nexport function oneOf(...types: Array<PrimitiveValueTypes | TypeAssertion>): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty union type is not allowed.`);\n    }\n    if (types.length === 1) {\n        const ty = types[0];\n        if (ty && typeof ty === 'object') {\n            return ty;\n        } else {\n            return primitiveValue(ty);\n        }\n    }\n    const ret: OneOfAssertion = {\n        kind: 'one-of',\n        oneOf: [],\n    };\n    for (const ty of types) {\n        // TODO: remove same type\n        if (ty && typeof ty === 'object') {\n            if (ty.kind === 'one-of') {\n                ret.oneOf = ret.oneOf.concat(ty.oneOf);\n            } else {\n                ret.oneOf.push(ty);\n            }\n        } else {\n            ret.oneOf.push(primitiveValue(ty));\n        }\n    }\n    return ret;\n}\n\n\n// subtraction (a - b)\nexport function subtract(...types: TypeAssertion[]): ObjectAssertion | AssertionOperator {\n    if (types.length === 0) {\n        throw new Error(`Empty subtraction type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'subtract',\n            operands: types.slice(),\n        });\n    }\n    let ret = types[0];\n    if (!ret || typeof ret !== 'object' || ret.kind !== 'object') {\n        throw new Error(`First parameter of subtraction type should be 'object'.`);\n    }\n    for (const ty of types.slice(1)) {\n        if (ty && typeof ty === 'object' && ty.kind === 'object') {\n            ret = omit(ret, ...ty.members.map(m => m[0]));\n        }\n    }\n    return ret;\n}\n\n\nexport function primitive(typeName: PrimitiveValueTypeNames |\n                                    OptionalPrimitiveValueTypeNames |\n                                    PlaceholderTypeNames |\n                                    OptionalPlaceholderTypeNames):\n        PrimitiveTypeAssertion | OptionalAssertion | NeverTypeAssertion | AnyTypeAssertion | UnknownTypeAssertion {\n    switch (typeName) {\n    case 'never':\n        return ({\n            kind: 'never',\n        });\n    case 'any':\n        return ({\n            kind: 'any',\n        });\n    case 'unknown':\n        return ({\n            kind: 'unknown',\n        });\n    case 'number':\n        // FALL_THRU\n    case 'integer':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        // FALL_THRU\n    case 'null':\n        // FALL_THRU\n    case 'undefined':\n        return ({\n            kind: 'primitive',\n            primitiveName: typeName,\n        });\n    case 'never?':\n        return (optional({\n            kind: 'never',\n        }));\n    case 'any?':\n        return (optional({\n            kind: 'any',\n        }));\n    case 'unknown?':\n        return (optional({\n            kind: 'unknown',\n        }));\n    case 'number?':\n        // FALL_THRU\n    case 'integer?':\n        // FALL_THRU\n    case 'bigint?':\n        // FALL_THRU\n    case 'string?':\n        // FALL_THRU\n    case 'boolean?':\n        // FALL_THRU\n    case 'null?':\n        // FALL_THRU\n    case 'undefined?':\n        return (optional({\n            kind: 'primitive',\n            primitiveName: typeName.substring(0, typeName.length - 1) as any,\n        }));\n    default:\n        throw new Error(`Unknown primitive type assertion: ${typeName}`);\n    }\n    // TODO: Function, DateStr, DateTimeStr, Funtion?, DateStr?, DateTimeStr?\n}\n\n\nexport function regexpPatternStringType(pattern: RegExp): PrimitiveTypeAssertion {\n    return ({\n        kind: 'primitive',\n        primitiveName: 'string',\n        pattern,\n    });\n}\n\n\nexport function primitiveValue(value: PrimitiveValueTypes): PrimitiveValueTypeAssertion {\n    if (value === null || value === void 0) {\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    } else switch (typeof value) {\n    case 'number':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    default:\n        throw new Error(`Unknown primitive value assertion: ${value}`);\n    }\n}\n\n\nexport function optional(ty: PrimitiveValueTypes | TypeAssertion): OptionalAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        if (ty.kind === 'optional') {\n            return ty;\n        } else {\n            return ({\n                kind: 'optional',\n                optional: ty,\n                ...(ty.typeName ? {typeName: ty.typeName} : {}),\n            });\n        }\n    } else {\n        return ({\n            kind: 'optional',\n            optional: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function repeated(\n        ty: PrimitiveValueTypeNames | TypeAssertion, option?:\n        Partial<Pick<RepeatedAssertion, 'max'> & Pick<RepeatedAssertion, 'min'>>): RepeatedAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: ty,\n        });\n    } else {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: primitive(ty),\n        });\n    }\n}\n\n\nexport function sequenceOf(...seq: Array<PrimitiveValueTypes | TypeAssertion>): SequenceAssertion {\n    return ({\n        kind: 'sequence',\n        sequence: seq.map(ty => ty && typeof ty === 'object' && ty.kind ? ty : primitiveValue(ty)),\n    });\n}\n\n\nexport function spread(\n        ty: PrimitiveValueTypes | TypeAssertion,\n        option?: Partial<Pick<SpreadAssertion, 'max'> & Pick<SpreadAssertion, 'min'>>): SpreadAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: ty,\n        });\n    } else {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function enumType(...values: Array<[string, number | string | null, string?]>): EnumAssertion {\n    const ar = values.slice();\n    let value = 0;\n    for (let i = 0; i < ar.length; i++) {\n        if (isUnsafeVarNames(dummyTargetObject, ar[i][0])) {\n            throw new Error(`Unsafe symbol name is appeared in enum assertion: ${ar[i][0]}`);\n        }\n\n        if (ar[i][1] === null || ar[i][1] === void 0) {\n            ar[i][1] = value++;\n        } else if (typeof ar[i][1] === 'number') {\n            value = (ar[i][1] as number) + 1;\n        }\n        if (! ar[i][2]) {\n            ar[i].length = 2;\n        }\n    }\n    return ({\n        kind: 'enum',\n        values: ar as Array<[string, number | string, string?]>,\n    });\n}\n\n\nexport function objectType(\n        ...members: Array<[\n            string | AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>): ObjectAssertion {\n    const revMembers = members.slice().reverse();\n    for (const x of members) {\n        if (typeof x[0] === 'string') {\n            if (isUnsafeVarNames(dummyTargetObject, x[0])) {\n                throw new Error(`Unsafe symbol name is appeared in object assertion: ${x[0]}`);\n            }\n            if (members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n                throw new Error(`Duplicated member is found: ${x[0]}`);\n            }\n        }\n    }\n\n    const membersProps: ObjectAssertionMember[] = (members\n        .filter(\n            x => typeof x[0] === 'string') as\n                Array<[string, PrimitiveValueTypes | TypeAssertion, string?]>)\n        .map(\n            x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n                [x[0], withName(x[1], x[0]), x[2]] :\n                [x[0], withName(primitiveValue(x[1]), x[0]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as ObjectAssertionMember);\n\n    const additionalProps: AdditionalPropsMember[] = (members\n        .filter(x => typeof x[0] !== 'string') as Array<[\n            AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>)\n        .map(x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n            x :\n            [x[0], primitiveValue(x[1]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as AdditionalPropsMember);\n\n    return ({\n        ...{\n            kind: 'object',\n            members: membersProps,\n        },\n        ...(0 < additionalProps.length ? {\n            additionalProps,\n        } : {}),\n    });\n}\n\n\nfunction checkRecursiveExtends(ty: ObjectAssertion, base: ObjectAssertion | AssertionSymlink): boolean {\n    if (ty === base) {\n        return false;\n    }\n    if (ty.typeName &&\n        (ty.typeName === base.typeName ||\n         (base.kind === 'symlink' && ty.typeName === base.symlinkTargetName))) {\n        return false;\n    }\n    if (base.kind === 'object' && base.baseTypes) {\n        for (const z of base.baseTypes) {\n            if (! checkRecursiveExtends(ty, z)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nexport function derived(ty: ObjectAssertion, ...exts: TypeAssertion[]): ObjectAssertion {\n    const ret: ObjectAssertion = {\n        kind: 'object',\n        members: [],\n        baseTypes: [],\n    };\n\n    for (const ext of exts) {\n        switch (ext.kind) {\n        case 'object':\n            if (! checkRecursiveExtends(ty, ext)) {\n                throw new Error(`Recursive extend is found: ${ty.name || '(unnamed)'}`);\n            }\n            for (const m of ext.members) {\n                if (! ret.members.find(x => x[0] === m[0])) {\n                    ret.members.push([m[0], m[1], true, ...m.slice(3)] as ObjectAssertionMember);\n                }\n                // TODO: Check for different types with the same name.\n            }\n        // FALL_THRU\n        case 'symlink':\n            (ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).push(ext);\n            break;\n        case 'operator':\n            {\n                throw new Error(`Unresolved type operator is found: ${ext.operator}`);\n            }\n        }\n        // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n        //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n    }\n    ret.members = ty.members.concat(ret.members);\n    if (ty.baseTypes) {\n        ret.baseTypes = ty.baseTypes\n            .filter(x => x.kind !== 'symlink')\n            .concat(ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>);\n    }\n    if ((ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).length === 0) {\n        delete ret.baseTypes;\n    }\n\n    const revMembers = ret.members.slice().reverse();\n    for (const x of ret.members) {\n        if (ret.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            throw new Error(`Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`);\n        }\n    }\n\n    let additionalProps: AdditionalPropsMember[] = [];\n    if (ret.baseTypes) {\n        for (const base of ret.baseTypes) {\n            if (base.kind === 'object') {\n                if (base.additionalProps && 0 < base.additionalProps.length) {\n                    additionalProps = additionalProps.concat(\n                        base.additionalProps.map(x =>\n                            [x[0], x[1], true, ...x.slice(3)] as AdditionalPropsMember));\n                }\n            }\n            // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n            //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n        }\n    }\n    if (ty.additionalProps && 0 < ty.additionalProps.length) {\n        additionalProps = additionalProps.concat(ty.additionalProps); // TODO: concat order\n    }\n    if (0 < additionalProps.length) {\n        ret.additionalProps = additionalProps;\n    }\n\n    return ret;\n}\n\n\nexport function symlinkType(name: string): AssertionSymlink {\n    return ({\n        kind: 'symlink',\n        symlinkTargetName: name,\n    });\n}\n\n\nexport function withName(ty: TypeAssertion, name: string) {\n    if (! name) {\n        return ty;\n    }\n    return ({...ty, name});\n}\n\n\nexport function withTypeName(ty: TypeAssertion, typeName: string) {\n    if (! typeName) {\n        return ty;\n    }\n    return ({...ty, typeName});\n}\n\n\nexport function withOriginalTypeName(ty: TypeAssertion, originalTypeName: string) {\n    if (! originalTypeName) {\n        return ty;\n    }\n    return ({...ty, originalTypeName});\n}\n\n\nexport function withDocComment(ty: TypeAssertion, docComment: string) {\n    if (! docComment) {\n        return ty;\n    }\n    return ({...ty, docComment});\n}\n\n\nexport function withRange(minValue: number | string, maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'minValue' should be number or string.`);\n        }\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue, maxValue});\n        }\n    };\n}\n\n\nexport function withMinValue(minValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@minValue' parameter 'minValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue});\n        }\n    };\n}\n\n\nexport function withMaxValue(maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@maxValue' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxValue});\n        }\n    };\n}\n\n\nexport function withGreaterThan(greaterThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof greaterThanValue !== 'number' && typeof greaterThanValue !== 'string') {\n            throw new Error(`Decorator '@greaterThan' parameter 'greaterThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, greaterThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, greaterThanValue});\n        }\n    };\n}\n\n\nexport function withLessThan(lessThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof lessThanValue !== 'number' && typeof lessThanValue !== 'string') {\n            throw new Error(`Decorator '@lessThan' parameter 'lessThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, lessThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, lessThanValue});\n        }\n    };\n}\n\n\nexport function withMinLength(minLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minLength !== 'number') {\n            throw new Error(`Decorator '@minLength' parameter 'minLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minLength});\n        }\n    };\n}\n\n\nexport function withMaxLength(maxLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxLength !== 'number') {\n            throw new Error(`Decorator '@maxLength' parameter 'maxLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxLength});\n        }\n    };\n}\n\n\nexport function withMatch(pattern: RegExp) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof pattern !== 'object') {\n            throw new Error(`Decorator '@match' parameter 'pattern' should be RegExp.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, pattern}});\n        } else {\n            if (!ty || ty.kind !== 'primitive' || ty.primitiveName !== 'string') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, pattern});\n        }\n    };\n}\n\n\nexport function withStereotype<T extends TypeAssertion>(stereotype: string): (ty: T) => T {\n    if (typeof stereotype !== 'string') {\n        throw new Error(`Decorator '@stereotype' parameter 'stereotype' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, stereotype)) {\n        throw new Error(`Unsafe symbol name is appeared in stereotype assertion: ${stereotype}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    stereotype,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                stereotype,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withConstraint<T extends TypeAssertion>(name: string, args?: any): (ty: T) => T {\n    if (typeof name !== 'string') {\n        throw new Error(`Decorator '@constraint' parameter 'name' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, name)) {\n        throw new Error(`Unsafe symbol name is appeared in constraint assertion: ${name}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const opt = (ty as OptionalAssertion).optional;\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...opt,\n                    customConstraints: opt.customConstraints\n                        ? opt.customConstraints.slice().push(name)\n                        : [name],\n                    customConstraintsArgs: opt.customConstraintsArgs\n                        ? {...opt.customConstraintsArgs, [name]: args}\n                        : {[name]: args},\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                customConstraints: ty.customConstraints\n                    ? ty.customConstraints.slice().push(name)\n                    : [name],\n                customConstraintsArgs: ty.customConstraintsArgs\n                    ? {...ty.customConstraintsArgs, [name]: args}\n                    : {[name]: args},\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withForceCast<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    forceCast: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                forceCast: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withRecordType<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    isRecordTypeField: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                isRecordTypeField: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withMeta<T extends TypeAssertion>(meta: any): (ty: T) => T {\n    return (ty: T) => {\n        const ret: T = ({\n            ...ty,\n            meta,\n        });\n        return ret;\n    };\n}\n\n\nexport function withMsg<T extends TypeAssertion>(messages: string | ErrorMessages): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            if (typeof messages === 'string') {\n                const ret = ({\n                    ...ty,\n                    message: messages,\n                    optional: {...(ty as OptionalAssertion).optional, message: messages},\n                });\n                delete ret.messages;\n                delete ret.optional.messages;\n                return ret;\n            } else {\n                const ret = ({\n                    ...ty,\n                    messages,\n                    optional: {...(ty as OptionalAssertion).optional, messages},\n                });\n                delete ret.message;\n                delete ret.optional.message;\n                return ret;\n            }\n        } else {\n            if (typeof messages === 'string') {\n                const ret = ({...ty, message: messages});\n                delete ret.messages;\n                return ret;\n            } else {\n                const ret = ({...ty, messages});\n                delete ret.message;\n                return ret;\n            }\n        }\n    };\n}\n\n\nexport function withMsgId<T extends TypeAssertion>(messageId: string): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            return ({\n                ...ty,\n                messageId,\n                optional: {...(ty as OptionalAssertion).optional, messageId},\n            });\n        } else {\n            return ({...ty, messageId});\n        }\n    };\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { RecursivePartial,\n         TypeAssertion,\n         ValidationContext } from './types';\nimport { ValidationError }   from './lib/errors';\nimport { isUnsafeVarNames }  from './lib/util';\nimport { validate }          from './validator';\n\n\n\nfunction pickMapper(value: any, ty: TypeAssertion) {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const ret = Array.isArray(value) ? [] : {};\n\n            const dataMembers = new Set<string>();\n            if (! Array.isArray(value)) {\n                for (const m in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n\n            for (const x of ty.members) {\n                if (Object.hasOwnProperty.call(value, x[0])) {\n                    dataMembers.delete(x[0]);\n                    ret[x[0]] = value[x[0]];\n                }\n            }\n            if (ty.additionalProps && 0 < ty.additionalProps.length) {\n                function* getAdditionalMembers() {\n                    for (const m of dataMembers.values()) {\n                        yield m;\n                    }\n                    if (Array.isArray(value)) {\n                        for (let i = 0; i < value.length; i++) {\n                            yield String(i);\n                        }\n                    }\n                }\n                for (const m of getAdditionalMembers()) {\n                    ret[m] = value[m];\n                }\n            }\n            return ret;\n        }\n    default:\n        return value;\n    }\n}\n\n\nexport function pickRoot<T>(data: T, ty: TypeAssertion, ctx: ValidationContext): T {\n    switch (ty.kind) {\n    case 'never':\n        throw new ValidationError(`Type unmatched: ${(ty as any).kind}`, ty, ctx);\n    case 'any':\n        // FALL_THRU\n    case 'unknown':\n        // FALL_THRU\n    case 'primitive':\n        // FALL_THRU\n    case 'primitive-value':\n        // FALL_THRU\n    case 'repeated':\n        // FALL_THRU\n    case 'sequence':\n        // FALL_THRU\n    case 'one-of':\n        // FALL_THRU\n    case 'enum':\n        // FALL_THRU\n    case 'object':\n        {\n            const r = validate<T>(data, ty, ctx);\n            if (r) {\n                return r.value;\n            } else {\n                throw new ValidationError('Validation failed.', ty, ctx);\n            }\n        }\n    case 'spread': case 'optional': case 'symlink': case 'operator':\n        throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n    default:\n        throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n    }\n}\n\n\nexport function pick<T>(data: T, ty: TypeAssertion, ctx?: Partial<ValidationContext>): RecursivePartial<T> {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n        mapper: pickMapper,\n    };\n    try {\n        return pickRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nfunction merge(data: any, needle: any) {\n    if (data === null || data === void 0) {\n        return needle;\n    }\n    switch (typeof data) {\n    case 'object':\n        if (Array.isArray(data)) {\n            return [...needle];\n        } else {\n            const r: any = {...data};\n            for (const k in needle) {\n                if (Object.prototype.hasOwnProperty.call(needle, k)) {\n                    if (isUnsafeVarNames(r, k)) {\n                        continue;\n                    }\n                    r[k] = merge(r[k], needle[k]);\n                }\n            }\n            return r;\n        }\n    default:\n        return needle;\n    }\n}\n\n\nexport function patch<T>(data: T, needle: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): T {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    const validated = pick<T>(needle, ty, ctx2);\n    return merge(data, validated);\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype }         from '../types';\nimport { DatePattern,\n         DateTimePattern,\n         DateTimeNoTzPattern } from '../lib/util';\n\n\n\nconst FyPattern = /^first-date-of-fy\\(([0-9]+)\\)$/;\nconst FormulaPattern = /^([-+@])([0-9]+)(yr|mo|day|days|hr|min|sec|ms)$/;\n\n\nclass UtcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(),\n                    d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setUTCDate(1);\n\n        this.setUTCFullYear(year);\n        this.setUTCMonth(typeof month === 'number' ? month : 0);\n        this.setUTCDate(typeof date === 'number' ? date : 1);\n        this.setUTCHours(typeof hours === 'number' ? hours : 0);\n        this.setUTCMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setUTCSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setUTCMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n\n    public getFullYear(): number {\n        return this.getUTCFullYear();\n    }\n\n    public getMonth(): number {\n        return this.getUTCMonth();\n    }\n\n    public getDate(): number {\n        return this.getUTCDate();\n    }\n\n    public getHours(): number {\n        return this.getUTCHours();\n    }\n\n    public getMinutes(): number {\n        return this.getUTCMinutes();\n    }\n\n    public getSeconds(): number {\n        return this.getUTCSeconds();\n    }\n\n    public getMilliseconds(): number {\n        return this.getUTCMilliseconds();\n    }\n\n    // NOTE: set???() are not overridden!\n}\n\n\nclass LcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                const l = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n                this.setTime(l.getTime());\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(d.getTime());\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setDate(1);\n\n        this.setFullYear(year);\n        this.setMonth(typeof month === 'number' ? month : 0);\n        this.setDate(typeof date === 'number' ? date : 1);\n        this.setHours(typeof hours === 'number' ? hours : 0);\n        this.setMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n}\n\n\ninterface DateConstructor {\n    new (): Date;\n    // tslint:disable-next-line: unified-signatures\n    new (str: string): Date;\n    new (year: number, month: number, date?: number,\n         hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n}\n\n\nfunction evaluateFormulaBase(dateCtor: DateConstructor, valueOrFormula: string): Date {\n    const errMsg = `evaluateFormula: invalid parameter ${valueOrFormula}`;\n    if (typeof valueOrFormula !== 'string') {\n        throw new Error(errMsg);\n    }\n    if (valueOrFormula.startsWith('=')) {\n        const formula = valueOrFormula.slice(1).split(' ');\n        let d = new dateCtor();\n        const now = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n        const today = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate());\n        d = now;\n        for (const f of formula) {\n            switch (f) {\n            case 'current': case 'now':\n                d = now;\n                break;\n            case 'today':\n                d = today;\n                break;\n            case 'first-date-of-yr': case 'first-date-of-fy(1)':\n                d = new dateCtor(d.getFullYear(), 0, 1);\n                break;\n            case 'last-date-of-yr':\n                d = new dateCtor(d.getFullYear(), 11, 31);\n                break;\n            case 'first-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth(), 1);\n                break;\n            case 'last-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth() + 1, 0);\n                break;\n            default:\n                if (f.startsWith('first-date-of-fy(')) {\n                    const m = FyPattern.exec(f);\n                    if (m) {\n                        const n = Number.parseInt(m[1], 10);\n                        if (0 < n && n <= 12) {\n                            const mo = d.getMonth() + 1;\n                            let yr = d.getFullYear();\n                            if (mo < n) {\n                                yr--;\n                            }\n                            d = new dateCtor(yr, n - 1, 1);\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                } else {\n                    const m = FormulaPattern.exec(f);\n                    if (m) {\n                        let n = Number.parseInt(m[2], 10);\n                        switch (m[3]) {\n                        case 'yr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getFullYear() + n;\n                                break;\n                            case '-':\n                                n = d.getFullYear() - n;\n                                break;\n                            }\n                            d = new dateCtor(n, d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'mo':\n                            switch (m[1]) {\n                            case '@':\n                                n -= 1;\n                                break;\n                            case '+':\n                                n = d.getMonth() + n;\n                                break;\n                            case '-':\n                                n = d.getMonth() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), n, d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'day': case 'days':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getDate() + n;\n                                break;\n                            case '-':\n                                n = d.getDate() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), n,\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'hr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getHours() + n;\n                                break;\n                            case '-':\n                                n = d.getHours() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'min':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMinutes() + n;\n                                break;\n                            case '-':\n                                n = d.getMinutes() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), n, d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'sec':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getSeconds() + n;\n                                break;\n                            case '-':\n                                n = d.getSeconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), n, d.getMilliseconds());\n                            break;\n                        case 'ms':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMilliseconds() + n;\n                                break;\n                            case '-':\n                                n = d.getMilliseconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), n);\n                            break;\n                        default:\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        if (!(DatePattern.test(f) || DateTimePattern.test(f) || DateTimeNoTzPattern.test(f))) {\n                            throw new Error(errMsg);\n                        }\n                        d = new dateCtor(f);\n                    }\n                }\n            }\n        }\n        return d;\n    } else {\n        if (! DatePattern.test(valueOrFormula)) {\n            throw new Error(errMsg);\n        }\n        return new dateCtor(valueOrFormula);\n    }\n}\n\n\nexport const dateStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && DatePattern.test(value)\n                ? { value: (new UtcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(UtcDate, valueOrFormula);\n        return (new UtcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDateStereotype: Stereotype = {\n    ...dateStereotype,\n    tryParse: (value: unknown) => {\n        if (typeof value === 'string' && DatePattern.test(value)) {\n            return ({ value: (new LcDate(value)).getTime() });\n        } else {\n            return null;\n        }\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(LcDate, valueOrFormula);\n        return (new LcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n}\n\n\nexport const datetimeStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new UtcDate(value)).getTime() } // If timezone is not specified, it is local time\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(UtcDate, valueOrFormula).getTime(),\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDatetimeStereotype: Stereotype = {\n    ...datetimeStereotype,\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new LcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(LcDate, valueOrFormula).getTime(),\n}\n\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ['date', dateStereotype],\n    ['lcdate', lcDateStereotype],\n    ['datetime', datetimeStereotype],\n    ['lcdatetime', lcDatetimeStereotype],\n];\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype } from '../types';\n\n\n\nexport const noopStereotype: Stereotype = {\n    tryParse: (value: any) => {\n        return ({ value });\n    },\n    evaluateFormula: (valueOrFormula: any) => {\n        return valueOrFormula;\n    },\n    compare: (a: any, b: any) => {\n        // NOTE: You should pass assertion value (schema value) into 'a'.\n        const tyA = typeof a;\n        const tyB = typeof b;\n        if (tyA !== tyB) {\n            return NaN;\n        }\n        switch (tyA) {\n        case 'number':\n            if (Number.isNaN(a) && Number.isNaN(b)) {\n                return 0;\n            } else {\n                return a - b;\n            }\n        default:\n            if (a === b) {\n                return 0;\n            } else if (a > b) {\n                return 1;\n            } else if (a < b) {\n                return -1;\n            } else {\n                return NaN;\n            }\n        }\n    },\n    doCast: false,\n};\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { PrimitiveTypeAssertionConstraints,\n         RepeatedAssertionConstraints,\n         ErrorMessages,\n         TypeAssertion } from './types/tynder-schema-types';\n\nexport * from './types/tynder-schema-types';\n\n\n\n// https://stackoverflow.com/questions/41980195/recursive-partialt-in-typescript\nexport type RecursivePartial<T> = {\n    [P in keyof T]?:\n      T[P] extends (infer U)[] ? RecursivePartial<U>[] :\n      T[P] extends object ? RecursivePartial<T[P]> :\n      T[P];\n};\n\n\nexport type TypeAssertionErrorMessageConstraints =\n    Partial<Omit<PrimitiveTypeAssertionConstraints &\n        RepeatedAssertionConstraints, 'pattern'> &\n        {pattern: string}>;\n\n\nexport interface TypeAssertionErrorMessage {\n    code: string;\n    message: string;\n    dataPath: string;\n    constraints: TypeAssertionErrorMessageConstraints;\n    value?: any; // Only number, bigint, string, boolean, undefined, null\n}\n\n\n\nexport interface Stereotype {\n    tryParse: (value: any) => {value: any} | null; // for data\n    evaluateFormula: (valueOrFormula: any) => any; // for PrimitiveValue and decorator comparison values\n    compare: (a: any, b: any) => number;\n    doCast: boolean;\n}\n\n\nexport type CustomConstraint = (data: any, args: any) => boolean;\n\n\nexport interface CustomConstraintInfo {\n    kinds?: Array<TypeAssertion['kind']>; // If undefined, all the kinds are allowed.\n    check: CustomConstraint;\n}\n\n\nexport interface ValidationContext {\n    checkAll?: boolean;\n    noAdditionalProps?: boolean;\n    errorMessages?: ErrorMessages;\n\n    // maxDepth: number;\n    // depth: number;\n    mapper?: (value: any, ty: TypeAssertion) => any;\n\n    // === returned values ===\n    errors: TypeAssertionErrorMessage[];\n\n    // === internal use ===\n    typeStack: Array<                 // For error reporting (keyword substitutions)\n        TypeAssertion |\n        [TypeAssertion,\n         number | string | undefined] // [1]: data index\n        >;                            // NOTE: DO NOT reassign!\n                                      //   Push or pop items instead of reassign.\n\n    recordTypeFieldValidated?: boolean;\n\n    // === additional infos ===\n    schema?: TypeAssertionMap;        //   To resolve 'symlink' assertion,\n                                      //   the context need to have a schema instance.\n\n    stereotypes?: Map<string, Stereotype>;\n    customConstraints?: Map<string, CustomConstraintInfo>;\n}\n\n\nexport interface TypeAssertionSetValue {\n    ty: TypeAssertion;\n    exported: boolean;\n    isDeclare: boolean; // for non-pass-thru declare statements\n    resolved: boolean;\n}\n\n\nexport type TypeAssertionMap = Map<string, TypeAssertionSetValue>;\n\n\nexport interface SymbolResolverOperators {\n    [propName: string]: (...args: Array<TypeAssertion | string>) => TypeAssertion;\n}\n\n\nexport interface ResolveSymbolOptions {\n    isDeserialization?: boolean;\n}\n\nexport interface SymbolResolverContext extends ResolveSymbolOptions {\n    nestLevel: number;\n    symlinkStack: string[]; // For detecting recursive type\n    operators?: SymbolResolverOperators; // TODO: Add it to resolve backref in type operator's operands\n}\n\n\nexport interface CodegenContext {\n    nestLevel: number;\n    schema?: TypeAssertionMap; // To resolve 'symlink' assertion, the context need to have a schema instance.\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport type PrimitiveValueTypes = number | bigint | string | boolean | null | undefined;                                            // TODO: Function\nexport type PrimitiveValueTypeNames = 'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'null' | 'undefined';                // TODO: Function, DateStr, DateTimeStr\nexport type OptionalPrimitiveValueTypeNames = 'number?' | 'integer?' | 'bigint?' | 'string?' | 'boolean?' | 'null?' | 'undefined?'; // TODO: Function?, DateStr?, DateTimeStr?\nexport type PlaceholderTypeNames = 'never' | 'any' | 'unknown';\nexport type OptionalPlaceholderTypeNames = 'never?' | 'any?' | 'unknown?';\n\n\n\nexport enum ErrorTypes {\n    InvalidDefinition = 1,\n    Required,                // (all)\n    TypeUnmatched,           // Never/Unknown/Primitive/Object\n    AdditionalPropUnmatched, // Additional prop\n    RepeatQtyUnmatched,      // Repeated/Spread\n    SequenceUnmatched,       // Sequence\n    ValueRangeUnmatched,     // Primitive: minValue, maxValue, greaterThanValue, lessThanValue\n    ValuePatternUnmatched,   // Primitive: pattern\n    ValueLengthUnmatched,    // Primitive: minLength, maxLength\n    ValueUnmatched,          // PrimitiveValue\n}\n\n\nexport type ErrorMessages = Partial<{\n    invalidDefinition: string,\n    required: string,\n    typeUnmatched: string,\n    additionalPropUnmatched: string,\n    repeatQtyUnmatched: string,\n    sequenceUnmatched: string,\n    valueRangeUnmatched: string,\n    valuePatternUnmatched: string,\n    valueLengthUnmatched: string,\n    valueUnmatched: string,\n}>;\n\n\nexport interface TypeAssertionBase {\n    messageId?: string;\n    message?: string;             // Only one of 'message' or 'messages' can be set.\n    messages?: ErrorMessages;     // Only one of 'message' or 'messages' can be set.\n    name?: string;                // Member name or 'typeName' below. For error reporting and codegen.\n    typeName?: string;            // Named user defined 'type' or 'interface' name. For error reporting and codegen.\n    originalTypeName?: string;    // To keep right hand side type name of `type Y = X;`.\n    stereotype?: string;          // `stereotype` decorator value.\n    customConstraints?: string[]; //\n    customConstraintsArgs?: {     //\n        [constraintName: string]: any;\n    };\n    forceCast?: boolean;          // `forceCast` decorator value.\n    isRecordTypeField?: boolean;  // true if `recordType` decorator is set.\n    meta?: any;                   // `meta` decorator value; user defined custom properties (meta informations).\n    docComment?: string;          // Doc comment.\n    passThruCodeBlock?: string;   // Store a pass-thru code block (e.g. import statement). use it with kind===never\n    noOutput?: boolean;           // If true, skip code generation.\n}\n\n\nexport interface NeverTypeAssertion extends TypeAssertionBase {\n    kind: 'never';\n}\n\n\nexport interface AnyTypeAssertion extends TypeAssertionBase {\n    kind: 'any';\n}\n\n\nexport interface UnknownTypeAssertion extends TypeAssertionBase {\n    kind: 'unknown';\n}\n\n\nexport interface PrimitiveTypeAssertionConstraints {\n    minValue?: number | string | null; // TODO: bigint\n    maxValue?: number | string | null; // TODO: bigint\n    greaterThanValue?: number | string | null;\n    lessThanValue?: number | string | null;\n    minLength?: number | null;\n    maxLength?: number | null;\n    pattern?: RegExp | null;\n}\n\n\nexport interface PrimitiveTypeAssertion extends TypeAssertionBase, PrimitiveTypeAssertionConstraints {\n    kind: 'primitive';\n    primitiveName: PrimitiveValueTypeNames;\n}\n\n\nexport interface PrimitiveValueTypeAssertion extends TypeAssertionBase {\n    kind: 'primitive-value';\n    value: PrimitiveValueTypes;\n    primitiveName?: 'bigint'; // for deserializer hinting\n}\n\n\nexport interface RepeatedAssertionConstraints {\n    min: number | null;\n    max: number | null;\n}\n\n\nexport interface RepeatedAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'repeated';\n    repeated: TypeAssertion;\n}\n\n\nexport interface SpreadAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'spread';\n    spread: TypeAssertion;\n}\n\n\nexport interface SequenceAssertion extends TypeAssertionBase {\n    kind: 'sequence';\n    sequence: TypeAssertion[];\n}\n\n\nexport interface OneOfAssertion extends TypeAssertionBase {\n    kind: 'one-of';\n    oneOf: TypeAssertion[];\n}\n\n\nexport interface OptionalAssertion extends TypeAssertionBase {\n    kind: 'optional';\n    optional: TypeAssertion;\n}\n\n\nexport interface EnumAssertion extends TypeAssertionBase {\n    kind: 'enum';\n    values: Array<[\n        string,           // enum key\n        number | string,  // enum value\n        string?,          // doc comment\n    ]>;\n    isConst?: boolean;    // If true, it is `const enum`\n}\n\n\nexport type ObjectAssertionMember = [\n    string,         // name\n    TypeAssertion,  // type\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n    string,         // doc comment\n];\n\n\n\nexport type AdditionalPropsKey = Array<'string' | 'number' | RegExp>;\n\n\nexport type AdditionalPropsMember = [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n    string,              // doc comment\n];\n\n\nexport interface ObjectAssertion extends TypeAssertionBase {\n    kind: 'object';\n    members: ObjectAssertionMember[];\n    additionalProps?: AdditionalPropsMember[];\n    baseTypes?: Array<ObjectAssertion | AssertionSymlink>;\n}\n\n\nexport interface AssertionSymlink extends TypeAssertionBase {\n    kind: 'symlink';\n    symlinkTargetName: string;\n    memberTree?: string[];\n}\n\n\n// TODO: Add it to resolve backref in type operator's operands\nexport interface AssertionOperator extends TypeAssertionBase {\n    kind: 'operator';\n    operator: string;\n    operands: Array<TypeAssertion | string>;\n}\n\n\nexport type TypeAssertion =\n    NeverTypeAssertion |\n    AnyTypeAssertion |\n    UnknownTypeAssertion |\n    PrimitiveTypeAssertion |\n    PrimitiveValueTypeAssertion |\n    RepeatedAssertion |\n    SpreadAssertion |\n    SequenceAssertion |\n    OneOfAssertion |\n    OptionalAssertion |\n    EnumAssertion |\n    ObjectAssertion |\n    AssertionSymlink |\n    AssertionOperator;\n\n\nexport interface SerializedSchemaInfo {\n    version: string;\n    ns: {\n        [namespaceName: string]: {\n            [typeName: string]: TypeAssertion;\n        }\n    };\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SequenceAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertion,\n         ValidationContext,\n         TypeAssertionMap,\n         Stereotype,\n         CustomConstraintInfo } from './types';\nimport { ValidationError }      from './lib/errors';\nimport { NumberPattern,\n         isUnsafeVarNames }     from './lib/util';\nimport { reportError,\n         reportErrorWithPush }  from './lib/reporter';\nimport { resolveSymbols }       from './lib/resolver';\nimport { noopStereotype }       from './stereotypes/noop';\n\n\n\nfunction checkStereotypes(\n    data: any, ty: TypeAssertion, ctx: ValidationContext):\n        {value: any, stereotype: Stereotype} | null | false {\n\n    if (ty.stereotype && ctx.stereotypes) {\n        if (ctx.stereotypes.has(ty.stereotype)) {\n            const stereotype = ctx.stereotypes.get(ty.stereotype) as Stereotype;\n            const parsed = stereotype.tryParse(data);\n            if (parsed) {\n                return ({\n                    value: parsed.value,\n                    stereotype,\n                });\n            } else {\n                return null;\n            }\n        } else {\n            throw new Error(`Undefined stereotype is specified: ${ty.stereotype}`);\n        }\n    }\n    return false;\n}\n\n\nfunction forceCast(\n    targetType:\n        'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'undefined' | 'null' |\n        'symbol' | 'object' | 'function',\n    value: any) {\n\n    switch (targetType) {\n    case 'number':\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            const a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                return Number(value ?? 0);\n            } else {\n                return a;\n            }\n        }\n    case 'integer':\n        if (typeof value === 'number' && Math.trunc(value) === value) {\n            return value;\n        } else {\n            let a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                a = Number(value ?? 0);\n            }\n            return Math.trunc(a);\n        }\n    case 'bigint':\n        try {\n            return BigInt(value ?? 0);\n        } catch {\n            return NaN;\n        }\n    case 'string':\n        return String(value);\n    case 'boolean':\n        return Boolean(value);\n    case 'undefined':\n        return void 0;\n    case 'null':\n        return null;\n    default:\n        return value;\n    }\n}\n\n\nfunction checkCustomConstraints(\n    data: any, ty: TypeAssertion, ctx: ValidationContext): boolean | null {\n\n    if (ty.customConstraints && ctx.customConstraints) {\n        for (const ccName of ty.customConstraints) {\n            if (ctx.customConstraints.has(ccName)) {\n                const cc = ctx.customConstraints.get(ccName) as CustomConstraintInfo;\n                if (cc.kinds && !cc.kinds.includes(ty.kind)) {\n                    return null;\n                }\n                if (! cc.check(data, ty.customConstraintsArgs && ty.customConstraintsArgs[ccName])) {\n                    return null;\n                }\n            } else {\n                throw new Error(`Undefined constraint is specified: ${ccName}`);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n\nfunction validateNeverTypeAssertion<T>(\n    data: any, ty: NeverTypeAssertion, ctx: ValidationContext): null {\n\n    reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateAnyTypeAssertion<T>(\n    data: any, ty: AnyTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validateUnknownTypeAssertion<T>(\n    data: any, ty: UnknownTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validatePrimitiveTypeAssertion<T>(\n    data: any, ty: PrimitiveTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(ty.primitiveName, data) : data;\n\n    if (ty.primitiveName === 'null') {\n        if (chkTarget !== null) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (ty.primitiveName === 'integer') {\n        if (typeof chkTarget !== 'number') {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n        if (Math.trunc(chkTarget) !== chkTarget) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (typeof chkTarget !== ty.primitiveName) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    // TODO: Function, DateStr, DateTimeStr\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n\n    const styVal = chkSt.value;\n    const styp = chkSt.stereotype;\n    let err = false;\n\n    let valueRangeErr = false;\n    switch (typeof ty.minValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.minValue)) < 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.maxValue)) > 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.greaterThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.greaterThanValue)) <= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.lessThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.lessThanValue)) >= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n\n    let valueLengthErr = false;\n    switch (typeof ty.minLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length < ty.minLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length > ty.maxLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n\n    if (ty.pattern) {\n        if (typeof styVal !== 'string' || !ty.pattern.test(styVal)) {\n            reportError(ErrorTypes.ValuePatternUnmatched, data, ty, {ctx});\n            err = true;\n        }\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        err = true;\n    }\n\n    const ret = !err\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    return ret;\n}\n\n\nfunction validatePrimitiveValueTypeAssertion<T>(\n    data: any, ty: PrimitiveValueTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(typeof ty.value, data) : data;\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    let ret = styp.compare(chkSt.value, styp.evaluateFormula(ty.value)) === 0\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    if (! ret) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        ret = null;\n    }\n\n    return ret;\n}\n\n\nfunction validateRepeatedAssertion<T>(\n    data: any, ty: RepeatedAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.min === 'number' && data.length < ty.min) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.max === 'number' && data.length > ty.max) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    const retVals: any[] = [];\n    for (let i = 0; i < data.length; i++) {\n        const x = data[i];\n        const r = validateRoot<T>(x, ty.repeated, ctx, i);\n        if (! r) {\n            return null;\n        }\n        retVals.push(r.value);\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return {value: retVals as any};\n}\n\n\nfunction validateSequenceAssertion<T>(\n    data: any, ty: SequenceAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    let dIdx = 0, // index of data\n        sIdx = 0; // index of types\n    let spreadLen = 0;\n    let optionalOmitted = false;\n\n    const checkSpreadQuantity = (ts: SpreadAssertion, index: number) => {\n        if (typeof ts.min === 'number' && spreadLen < ts.min) {\n            reportErrorWithPush(\n                spreadLen === 0 ?\n                    ErrorTypes.TypeUnmatched :\n                    ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        if (typeof ts.max === 'number' && spreadLen > ts.max) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const checkOptionalQuantity = (ts: OptionalAssertion, index: number) => {\n        if (spreadLen === 0) {\n            // All subsequent 'optional' assertions should be 'spreadLen === 0'.\n            optionalOmitted = true;\n        } else if (optionalOmitted) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        } else if (spreadLen > 1) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const retVals: any[] = [];\n    while (dIdx < data.length && sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.spread, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkSpreadQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else if (ts.kind === 'optional') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.optional, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkOptionalQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else {\n            const r = validateRoot<T>(data[dIdx], ts, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                sIdx++;\n            } else {\n                return null;\n            }\n        }\n    }\n    while (sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            if (! checkSpreadQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else if (ts.kind === 'optional') {\n            if (! checkOptionalQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, dIdx], {ctx});\n            return null;\n        }\n    }\n\n    const ret = data.length === dIdx ? {value: retVals as any} : null;\n    if (! ret) {\n        reportError(ErrorTypes.SequenceUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return ret;\n}\n\n\nfunction validateOneOfAssertion<T>(\n    data: any, ty: OneOfAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let choosed = false;\n    const savedCtxRecordTypeFieldValidated = ctx.recordTypeFieldValidated;\n    ctx.recordTypeFieldValidated = false;\n\n    const savedErrLen = ctx.errors.length;\n    let count = 0;\n    let firstErrLen = savedErrLen;\n\n    for (const tyOne of ty.oneOf) {\n        const r = validateRoot<T>(data, tyOne, ctx);\n        if (r) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n            ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n            return r;\n        }\n\n        if (ctx.recordTypeFieldValidated) {\n            if (count !== 0) {\n                const e2 = ctx.errors.slice(firstErrLen);\n                ctx.errors.length = savedErrLen;\n                ctx.errors.push(...e2);\n            }\n            choosed = true;\n            break;\n        }\n\n        if (count === 0) {\n            firstErrLen = ctx.errors.length;\n        } else {\n            ctx.errors.length = firstErrLen;\n        }\n        count++;\n    }\n\n    if (! choosed) {\n        if (! ctx.checkAll) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n        }\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    }\n\n    ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n    return null;\n}\n\n\nfunction validateEnumAssertion<T>(\n    data: any, ty: EnumAssertion, ctx: ValidationContext): {value: T} | null {\n\n    for (const v of ty.values) {\n        if (data === v[1]) {\n            return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n        }\n    }\n    reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateObjectAssertion<T>(\n    data: any, ty: ObjectAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let retVal = Array.isArray(data) ? [...data] : {...data};\n    const revMembers = ty.members.slice().reverse();\n    for (const x of ty.members) {\n        if (ty.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(\n                `Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`, ty, ctx);\n        }\n    }\n\n    if (data === null || typeof data !== 'object') {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        if (ctx && ctx.checkAll) {\n            retVal = null;\n        } else {\n            return null;\n        }\n    } else {\n        const dataMembers = new Set<string>();\n        if (ctx.noAdditionalProps || ty.additionalProps && 0 < ty.additionalProps.length) {\n            if (! Array.isArray(data)) {\n                for (const m in data) {\n                    if (Object.prototype.hasOwnProperty.call(data, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n        }\n        if (ctx.noAdditionalProps && Array.isArray(data) && 0 < data.length) {\n            const aps = ty.additionalProps || [];\n            if (aps.filter(x => x[0].includes('number')).length === 0) {\n                reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                    ctx,\n                    substitutions: [['addtionalProps', '[number]']],\n                });\n                if (ctx && ctx.checkAll) {\n                    retVal = null;\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        for (const x of ty.members) {\n            dataMembers.delete(x[0]);\n            if (Object.prototype.hasOwnProperty.call(data, x[0])) {\n                const mt = x[1].kind === 'optional' ?  // TODO: set name at compile time\n                    {\n                        ...x[1].optional,\n                        name: x[0],\n                        message: x[1].message,\n                        messages: x[1].messages,\n                        messageId: x[1].messageId,\n                    } : x[1];\n                const ret = validateRoot<T>(data[x[0]], mt, ctx);\n\n                if (ret) {\n                    if (retVal) {\n                        if (isUnsafeVarNames(retVal, x[0])) {\n                            continue;\n                        }\n                        retVal[x[0]] = ret.value;\n                        if (mt.isRecordTypeField) {\n                            ctx.recordTypeFieldValidated = true;\n                        }\n                    }\n                } else {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                if (x[1].kind !== 'optional') {\n                    reportErrorWithPush(ErrorTypes.Required, data, [x[1], void 0], {ctx});\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ty.additionalProps && 0 < ty.additionalProps.length) {\n            function* getAdditionalMembers() {\n                for (const m of dataMembers.values()) {\n                    yield m;\n                }\n                if (Array.isArray(data)) {\n                    for (let i = 0; i < data.length; i++) {\n                        yield String(i);\n                    }\n                }\n            }\n            for (const m of getAdditionalMembers()) {\n                let allowImplicit = false;\n                const matchedAssertions: TypeAssertion[] = [];\n\n                for (const ap of ty.additionalProps) {\n                    for (const pt of ap[0]) {\n                        const at = ap[1];\n                        if (pt === 'number') {\n                            if (NumberPattern.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        } else if (pt === 'string') {\n                            matchedAssertions.push(at);\n                        } else {\n                            if (pt.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        }\n                        if (at.kind === 'optional') {\n                            allowImplicit = true;\n                        }\n                    }\n                }\n                if (matchedAssertions.length === 0) {\n                    if (allowImplicit) {\n                        continue;\n                    }\n                    reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                        ctx,\n                        substitutions: [['addtionalProps', m]],\n                    });\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                        continue;\n                    } else {\n                        return null;\n                    }\n                }\n\n                dataMembers.delete(m);\n                let hasError = false;\n                const savedErrLen = ctx.errors.length;\n\n                for (const at of matchedAssertions) {\n                    const ret = validateRoot<T>(data[m], at.kind === 'optional' ?\n                        {\n                            ...at.optional,\n                            message: at.message,\n                            messages: at.messages,\n                            messageId: at.messageId,\n                            name: m,\n                        } : {\n                            ...at,\n                            name: m,\n                        }, ctx);\n                    if (ret) {\n                        if (retVal) {\n                            hasError = false;\n                            ctx.errors.length = savedErrLen;\n                            if (isUnsafeVarNames(retVal, m)) {\n                                continue;\n                            }\n                            retVal[m] = ret.value;\n                        }\n                        break;\n                    } else {\n                        hasError = true;\n                    }\n                }\n                if (hasError) {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ctx.noAdditionalProps && 0 < dataMembers.size) {\n            reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                ctx,\n                substitutions: [['addtionalProps', Array.from(dataMembers.values()).join(', ')]],\n            });\n            if (ctx && ctx.checkAll) {\n                retVal = null;\n            } else {\n                return null;\n            }\n        }\n    }\n    if (! retVal) {\n        // TODO: Child is unmatched. reportError?\n        // TODO: report object's custom error message\n    }\n\n    if (retVal && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return retVal ? {value: (ctx && ctx.mapper) ? ctx.mapper(retVal, ty) : retVal} : null;\n}\n\n\nexport function validateRoot<T>(\n    data: any, ty: TypeAssertion, ctx: ValidationContext, dataIndex?: number | string): {value: T} | null {\n\n    try {\n        ctx.typeStack.push(\n            typeof dataIndex === 'number' || typeof dataIndex === 'string' ?\n            [ty, dataIndex] : ty);\n\n        switch (ty.kind) {\n        case 'never':\n            return validateNeverTypeAssertion(data, ty, ctx);\n        case 'any':\n            return validateAnyTypeAssertion(data, ty, ctx);\n        case 'unknown':\n            return validateUnknownTypeAssertion(data, ty, ctx);\n        case 'primitive':\n            return validatePrimitiveTypeAssertion(data, ty, ctx);\n        case 'primitive-value':\n            return validatePrimitiveValueTypeAssertion(data, ty, ctx);\n        case 'repeated':\n            return validateRepeatedAssertion(data, ty, ctx);\n        case 'sequence':\n            return validateSequenceAssertion(data, ty, ctx);\n        case 'one-of':\n            return validateOneOfAssertion(data, ty, ctx);\n        case 'enum':\n            return validateEnumAssertion(data, ty, ctx);\n        case 'object':\n            return validateObjectAssertion(data, ty, ctx);\n        case 'symlink':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved symbol '${ty.symlinkTargetName}' is appeared.`, ty, ctx);\n        case 'operator':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved type operator is found: ${ty.operator}`, ty, ctx);\n        case 'spread': case 'optional':\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n        default:\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n        }\n    } finally {\n        ctx.typeStack.pop();\n    }\n}\n\n\nexport function validate<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): {value: T} | null {\n\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    try {\n        return validateRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nexport function isType<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): data is T {\n\n    return (!! validate<T>(data, ty, ctx));\n}\n\n\nexport function getType(schema: TypeAssertionMap, name: string): TypeAssertion {\n    if (schema.has(name)) {\n        return schema.get(name)?.ty as TypeAssertion;\n    }\n    throw new Error(`Undefined type name is referred: ${name}`);\n}\n"],"sourceRoot":""}