{"version":3,"sources":["webpack://tynder/webpack/universalModuleDefinition","webpack://tynder/webpack/bootstrap","webpack://tynder/./src/types/tynder-schema-types.ts","webpack://tynder/./src/lib/util.ts","webpack://tynder/./src/operators.ts","webpack://tynder/./src/lib/protection.ts","webpack://tynder/./src/lib/escape.ts","webpack://tynder/./src/lib/errors.ts","webpack://tynder/./src/lib/resolver.ts","webpack://tynder/./src/lib/reporter.ts","webpack://tynder/./src/stereotypes/noop.ts","webpack://tynder/./src/validator.ts","webpack://tynder/./src/picker.ts","webpack://tynder/./src/stereotypes/date.ts","webpack://tynder/./src/constraints/unique.ts","webpack://tynder/./src/index-rt.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ErrorTypes","SymbolPattern","NumberPattern","DatePattern","DateTimePattern","DateTimeNoTzPattern","nvl","v","alt","nvl2","f","picked","ty","names","kind","members","member","find","x","m2","length","push","operator","operands","omit","partial","optional","slice","optTy","typeName","intersect","types","Error","filter","lastTy","Map","set","Array","from","values","oneOf","primitiveValue","ret","concat","subtract","map","primitive","primitiveName","substring","regexpPatternStringType","pattern","repeated","option","min","max","sequenceOf","seq","sequence","spread","enumType","ar","objectType","revMembers","reverse","membersProps","withName","additionalProps","checkRecursiveExtends","base","symlinkTargetName","baseTypes","z","derived","exts","ext","symlinkType","withTypeName","withOriginalTypeName","originalTypeName","withDocComment","docComment","withRange","minValue","maxValue","opt","withMinValue","withMaxValue","withGreaterThan","greaterThanValue","withLessThan","lessThanValue","withMinLength","minLength","withMaxLength","maxLength","withMatch","withStereotype","stereotype","withConstraint","args","customConstraints","customConstraintsArgs","withForceCast","forceCast","withRecordType","isRecordTypeField","withMeta","meta","withMsg","messages","message","withMsgId","messageId","dummyTargetObject","g","globalObj","objConstructor","funConstructor","Function","e","window","global","globalThis","constructor","toString","isUnsafeVarNames","target","varName","con","__proto__","escapeString","replace","ValidationError","ctx","super","updateSchema","original","schema","has","resolved","resolveMemberNames","rootSym","memberTreeSymbols","memberPos","addTypeName","mt","memberSym","join","k","test","memberTree","resolveSymbols","ctx2","nestLevel","symlinkStack","findIndex","ty2","xTy","link","link2","mergeTypeAndSymlink","baseSymlinks","isDeserialization","d2","operators","ctx3","resolverOps","resolveSchema","opts","ent","entries","errorTypeNames","defaultMessages","invalidDefinition","required","typeUnmatched","additionalPropUnmatched","repeatQtyUnmatched","sequenceUnmatched","valueRangeUnmatched","valuePatternUnmatched","valueLengthUnmatched","valueUnmatched","getErrorMessage","errType","InvalidDefinition","Required","TypeUnmatched","AdditionalPropUnmatched","RepeatQtyUnmatched","SequenceUnmatched","ValueRangeUnmatched","ValuePatternUnmatched","ValueLengthUnmatched","ValueUnmatched","getExpectedType","String","formatErrorMessage","msg","data","tr","topRepeatable","dict","source","flags","dataPath","endsWith","entryName","parentType","substitutions","RegExp","reportError","errorMessages","dataPathEntryArray","typeStack","next","pt","isArray","pi","isSet","len","j","q","constraints","cSrces","unshift","cSrc","pat","val","errors","code","reportErrorWithPush","tyidx","pop","noopStereotype","tryParse","evaluateFormula","valueOrFormula","compare","a","b","tyA","NaN","Number","isNaN","doCast","checkStereotypes","stereotypes","parsed","targetType","parseFloat","Math","trunc","BigInt","Boolean","checkCustomConstraints","ccName","cc","kinds","includes","check","validateRoot","dataIndex","validateNeverTypeAssertion","chkSt","styp","mapper","validateAnyTypeAssertion","validateUnknownTypeAssertion","chkTarget","styVal","err","valueRangeErr","valueLengthErr","validatePrimitiveTypeAssertion","validatePrimitiveValueTypeAssertion","retVals","validateRepeatedAssertion","dIdx","sIdx","spreadLen","optionalOmitted","checkSpreadQuantity","ts","index","checkOptionalQuantity","savedErrLen","validateSequenceAssertion","choosed","savedCtxRecordTypeFieldValidated","recordTypeFieldValidated","count","firstErrLen","tyOne","e2","checkAll","validateOneOfAssertion","validateEnumAssertion","retVal","dataMembers","Set","noAdditionalProps","add","delete","getAdditionalMembers","allowImplicit","matchedAssertions","ap","at","hasError","size","validateObjectAssertion","validate","isType","assertType","getType","pickMapper","pickRoot","pick","patch","needle","merge","FyPattern","FormulaPattern","UtcDate","Date","year","month","date","hours","minutes","seconds","ms","setUTCDate","setUTCFullYear","setUTCMonth","setUTCHours","setUTCMinutes","setUTCSeconds","setUTCMilliseconds","setTime","parse","UTC","getUTCFullYear","getUTCMonth","getUTCDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","LcDate","setDate","setFullYear","setMonth","setHours","setMinutes","setSeconds","setMilliseconds","getTime","evaluateFormulaBase","dateCtor","errMsg","startsWith","formula","split","now","today","exec","parseInt","mo","yr","dateStereotype","datetimeStereotype","mapperErrMsg","checkerGen","fields","mapped","CMP","field"],"mappings":"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","file":"tynder-rt.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"tynder\"] = factory();\n\telse\n\t\troot[\"tynder\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 20);\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport type PrimitiveValueTypes = number | bigint | string | boolean | null | undefined;                                            // TODO: Function\nexport type PrimitiveValueTypeNames = 'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'null' | 'undefined';                // TODO: Function, DateStr, DateTimeStr\nexport type OptionalPrimitiveValueTypeNames = 'number?' | 'integer?' | 'bigint?' | 'string?' | 'boolean?' | 'null?' | 'undefined?'; // TODO: Function?, DateStr?, DateTimeStr?\nexport type PlaceholderTypeNames = 'never' | 'any' | 'unknown';\nexport type OptionalPlaceholderTypeNames = 'never?' | 'any?' | 'unknown?';\n\n\n\nexport enum ErrorTypes {\n    InvalidDefinition = 1,\n    Required,                // (all)\n    TypeUnmatched,           // Never/Unknown/Primitive/Object\n    AdditionalPropUnmatched, // Additional prop\n    RepeatQtyUnmatched,      // Repeated/Spread\n    SequenceUnmatched,       // Sequence\n    ValueRangeUnmatched,     // Primitive: minValue, maxValue, greaterThanValue, lessThanValue\n    ValuePatternUnmatched,   // Primitive: pattern\n    ValueLengthUnmatched,    // Primitive: minLength, maxLength\n    ValueUnmatched,          // PrimitiveValue\n}\n\n\nexport type ErrorMessages = Partial<{\n    invalidDefinition: string,\n    required: string,\n    typeUnmatched: string,\n    additionalPropUnmatched: string,\n    repeatQtyUnmatched: string,\n    sequenceUnmatched: string,\n    valueRangeUnmatched: string,\n    valuePatternUnmatched: string,\n    valueLengthUnmatched: string,\n    valueUnmatched: string,\n}>;\n\n\nexport interface TypeAssertionBase {\n    messageId?: string;\n    message?: string;             // Only one of 'message' or 'messages' can be set.\n    messages?: ErrorMessages;     // Only one of 'message' or 'messages' can be set.\n    name?: string;                // Member name or 'typeName' below. For error reporting and codegen.\n    typeName?: string;            // Named user defined 'type' or 'interface' name. For error reporting and codegen.\n    originalTypeName?: string;    // To keep right hand side type name of `type Y = X;`.\n    stereotype?: string;          // `stereotype` decorator value.\n    customConstraints?: string[]; //\n    customConstraintsArgs?: {     //\n        [constraintName: string]: any;\n    };\n    forceCast?: boolean;          // `forceCast` decorator value.\n    isRecordTypeField?: boolean;  // true if `recordType` decorator is set.\n    meta?: any;                   // `meta` decorator value; user defined custom properties (meta informations).\n    docComment?: string;          // Doc comment.\n    passThruCodeBlock?: string;   // Store a pass-thru code block (e.g. import statement). use it with kind===never\n    noOutput?: boolean;           // If true, skip code generation.\n}\n\n\nexport interface NeverTypeAssertion extends TypeAssertionBase {\n    kind: 'never';\n}\n\n\nexport interface AnyTypeAssertion extends TypeAssertionBase {\n    kind: 'any';\n}\n\n\nexport interface UnknownTypeAssertion extends TypeAssertionBase {\n    kind: 'unknown';\n}\n\n\nexport interface PrimitiveTypeAssertionConstraints {\n    minValue?: number | string | null; // TODO: bigint\n    maxValue?: number | string | null; // TODO: bigint\n    greaterThanValue?: number | string | null;\n    lessThanValue?: number | string | null;\n    minLength?: number | null;\n    maxLength?: number | null;\n    pattern?: RegExp | null;\n}\n\n\nexport interface PrimitiveTypeAssertion extends TypeAssertionBase, PrimitiveTypeAssertionConstraints {\n    kind: 'primitive';\n    primitiveName: PrimitiveValueTypeNames;\n}\n\n\nexport interface PrimitiveValueTypeAssertion extends TypeAssertionBase {\n    kind: 'primitive-value';\n    value: PrimitiveValueTypes;\n    primitiveName?: 'bigint'; // for deserializer hinting\n}\n\n\nexport interface RepeatedAssertionConstraints {\n    min: number | null;\n    max: number | null;\n}\n\n\nexport interface RepeatedAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'repeated';\n    repeated: TypeAssertion;\n}\n\n\nexport interface SpreadAssertion extends TypeAssertionBase, RepeatedAssertionConstraints {\n    kind: 'spread';\n    spread: TypeAssertion;\n}\n\n\nexport interface SequenceAssertion extends TypeAssertionBase {\n    kind: 'sequence';\n    sequence: TypeAssertion[];\n}\n\n\nexport interface OneOfAssertion extends TypeAssertionBase {\n    kind: 'one-of';\n    oneOf: TypeAssertion[];\n}\n\n\nexport interface OptionalAssertion extends TypeAssertionBase {\n    kind: 'optional';\n    optional: TypeAssertion;\n}\n\n\nexport interface EnumAssertion extends TypeAssertionBase {\n    kind: 'enum';\n    values: Array<[\n        string,           // enum key\n        number | string,  // enum value\n        string?,          // doc comment\n    ]>;\n    isConst?: boolean;    // If true, it is `const enum`\n}\n\n\nexport type ObjectAssertionMember = [\n    string,         // name\n    TypeAssertion,  // type\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n] | [\n    string,         // name\n    TypeAssertion,  // type\n    boolean,        // If true, defined by ancestor types\n    string,         // doc comment\n];\n\n\n\nexport type AdditionalPropsKey = Array<'string' | 'number' | RegExp>;\n\n\nexport type AdditionalPropsMember = [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n] | [\n    AdditionalPropsKey,  // name\n    TypeAssertion,       // type\n    boolean,             // If true, defined by ancestor types\n    string,              // doc comment\n];\n\n\nexport interface ObjectAssertion extends TypeAssertionBase {\n    kind: 'object';\n    members: ObjectAssertionMember[];\n    additionalProps?: AdditionalPropsMember[];\n    baseTypes?: Array<ObjectAssertion | AssertionSymlink>;\n}\n\n\nexport interface AssertionSymlink extends TypeAssertionBase {\n    kind: 'symlink';\n    symlinkTargetName: string;\n    memberTree?: string[];\n}\n\n\n// TODO: Add it to resolve backref in type operator's operands\nexport interface AssertionOperator extends TypeAssertionBase {\n    kind: 'operator';\n    operator: string;\n    operands: Array<TypeAssertion | string>;\n}\n\n\nexport type TypeAssertion =\n    NeverTypeAssertion |\n    AnyTypeAssertion |\n    UnknownTypeAssertion |\n    PrimitiveTypeAssertion |\n    PrimitiveValueTypeAssertion |\n    RepeatedAssertion |\n    SpreadAssertion |\n    SequenceAssertion |\n    OneOfAssertion |\n    OptionalAssertion |\n    EnumAssertion |\n    ObjectAssertion |\n    AssertionSymlink |\n    AssertionOperator;\n\n\nexport interface SerializedSchemaInfo {\n    version: string;\n    ns: {\n        [namespaceName: string]: {\n            [typeName: string]: TypeAssertion;\n        }\n    };\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\nexport const SymbolPattern = /^[A-Za-z_$][A-Za-z0-9_$]*$/;\nexport const NumberPattern = /^([\\+\\-]?\\d*\\.?\\d+(?:[Ee][\\+\\-]?\\d+)?)$/;\nexport const DatePattern = /^(\\d{4}-[01]\\d-[0-3]\\d)$/;\nexport const DateTimePattern =\n    /^((?:(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))(?:[+-][0-2]\\d:[0-5]\\d|Z))$/;\nexport const DateTimeNoTzPattern =\n    /^((?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d)|(?:\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d))$/;\n\n\nexport function nvl(v: any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? v : alt\n    );\n}\n\n\nexport function nvl2(v: any, f: (x: any) => any, alt: any) {\n    return (\n        v !== null && v !== void 0 ? f(v) : alt\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveValueTypes,\n         PrimitiveValueTypeNames,\n         OptionalPrimitiveValueTypeNames,\n         PlaceholderTypeNames,\n         OptionalPlaceholderTypeNames,\n         ErrorMessages,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         SequenceAssertion,\n         OneOfAssertion,\n         OptionalAssertion,\n         EnumAssertion,\n         ObjectAssertionMember,\n         AdditionalPropsKey,\n         AdditionalPropsMember,\n         ObjectAssertion,\n         AssertionSymlink,\n         AssertionOperator,\n         TypeAssertion }    from './types';\nimport { dummyTargetObject,\n         isUnsafeVarNames } from './lib/protection';\n\n\n\n// emulate Pick<T> // ex. Pick<Foo, 'a' | 'b'>\nexport function picked(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const name of names) {\n                const member = ty.members.find(x => x[0] === name);\n                if (member) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'picked',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Omit<T> // ex. Omit<Foo, 'a' | 'b'>\nexport function omit(ty: TypeAssertion, ...names: string[]): ObjectAssertion | AssertionOperator {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                if (! names.find(name => member[0] === name)) {\n                    if (member[2]) {\n                        const m2: ObjectAssertionMember = [...member] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.push(m2);\n                    } else {\n                        members.push(member);\n                    }\n                }\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'omit',\n                operands: [ty, ...names],\n            });\n        }\n    default:\n        return ({\n            kind: 'object',\n            members: [],\n        });\n    }\n}\n\n\n// emulate Partial<T>\nexport function partial(ty: TypeAssertion): TypeAssertion {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const members: ObjectAssertionMember[] = [];\n            for (const member of ty.members) {\n                let m: ObjectAssertionMember = member[1].kind === 'optional' ?\n                    member :\n                    [member[0], optional(member[1]), ...member.slice(2)] as ObjectAssertionMember;\n                if (m[2]) {\n                    m = [...m] as any;\n                    if (3 < m.length) {\n                        m[2] = false;\n                    } else {\n                        m.length = 2;\n                    }\n                }\n                m[1].name = m[0];\n                const optTy = {...(m[1] as OptionalAssertion).optional};\n                (m[1] as OptionalAssertion).optional = optTy;\n                if (optTy.name && optTy.name !== optTy.typeName) {\n                    delete optTy.name;\n                }\n                if (!optTy.name && optTy.typeName) {\n                    optTy.name = optTy.typeName;\n                }\n                members.push(m);\n            }\n            return ({\n                kind: 'object',\n                members,\n            });\n        }\n    case 'symlink': case 'operator':\n        {\n            return ({\n                kind: 'operator',\n                operator: 'partial',\n                operands: [ty],\n            });\n        }\n    default:\n        return ty;\n    }\n}\n\n\n// intersection (a & b)\nexport function intersect(...types: TypeAssertion[]): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty intersection type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'intersect',\n            operands: types.slice(),\n        });\n    }\n    let lastTy: TypeAssertion | null = null;\n    const members = new Map<string, ObjectAssertionMember>();\n\n    for (const ty of types) {\n        if (ty && typeof ty === 'object') {\n            if (lastTy && lastTy.kind !== ty.kind) {\n                return ({\n                    kind: 'never',\n                });\n            }\n            lastTy = ty;\n            if (ty.kind === 'object') {\n                for (const m of ty.members) {\n                    if (m[2]) {\n                        const m2: ObjectAssertionMember = [...m] as any;\n                        if (3 < m2.length) {\n                            m2[2] = false;\n                        } else {\n                            m2.length = 2;\n                        }\n                        members.set(m[0], m2); // Overwrite if exists\n                    } else {\n                        members.set(m[0], m);  // Overwrite if exists\n                    }\n                }\n            }\n        } else {\n            return ({\n                kind: 'never',\n            });\n        }\n    }\n    if (lastTy && lastTy.kind !== 'object') {\n        return lastTy;\n    } else {\n        return ({\n            kind: 'object',\n            members: Array.from(members.values()),\n        });\n    }\n}\n\n\n// union (a | b)\nexport function oneOf(...types: Array<PrimitiveValueTypes | TypeAssertion>): TypeAssertion {\n    if (types.length === 0) {\n        throw new Error(`Empty union type is not allowed.`);\n    }\n    if (types.length === 1) {\n        const ty = types[0];\n        if (ty && typeof ty === 'object') {\n            return ty;\n        } else {\n            return primitiveValue(ty);\n        }\n    }\n    const ret: OneOfAssertion = {\n        kind: 'one-of',\n        oneOf: [],\n    };\n    for (const ty of types) {\n        // TODO: remove same type\n        if (ty && typeof ty === 'object') {\n            if (ty.kind === 'one-of') {\n                ret.oneOf = ret.oneOf.concat(ty.oneOf);\n            } else {\n                ret.oneOf.push(ty);\n            }\n        } else {\n            ret.oneOf.push(primitiveValue(ty));\n        }\n    }\n    return ret;\n}\n\n\n// subtraction (a - b)\nexport function subtract(...types: TypeAssertion[]): ObjectAssertion | AssertionOperator {\n    if (types.length === 0) {\n        throw new Error(`Empty subtraction type is not allowed.`);\n    }\n    if (0 < types.filter(x => x && typeof x === 'object' &&\n            (x.kind === 'symlink' || x.kind === 'operator')).length) {\n        return ({\n            kind: 'operator',\n            operator: 'subtract',\n            operands: types.slice(),\n        });\n    }\n    let ret = types[0];\n    if (!ret || typeof ret !== 'object' || ret.kind !== 'object') {\n        throw new Error(`First parameter of subtraction type should be 'object'.`);\n    }\n    for (const ty of types.slice(1)) {\n        if (ty && typeof ty === 'object' && ty.kind === 'object') {\n            ret = omit(ret, ...ty.members.map(m => m[0]));\n        }\n    }\n    return ret;\n}\n\n\nexport function primitive(typeName: PrimitiveValueTypeNames |\n                                    OptionalPrimitiveValueTypeNames |\n                                    PlaceholderTypeNames |\n                                    OptionalPlaceholderTypeNames):\n        PrimitiveTypeAssertion | OptionalAssertion | NeverTypeAssertion | AnyTypeAssertion | UnknownTypeAssertion {\n    switch (typeName) {\n    case 'never':\n        return ({\n            kind: 'never',\n        });\n    case 'any':\n        return ({\n            kind: 'any',\n        });\n    case 'unknown':\n        return ({\n            kind: 'unknown',\n        });\n    case 'number':\n        // FALL_THRU\n    case 'integer':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        // FALL_THRU\n    case 'null':\n        // FALL_THRU\n    case 'undefined':\n        return ({\n            kind: 'primitive',\n            primitiveName: typeName,\n        });\n    case 'never?':\n        return (optional({\n            kind: 'never',\n        }));\n    case 'any?':\n        return (optional({\n            kind: 'any',\n        }));\n    case 'unknown?':\n        return (optional({\n            kind: 'unknown',\n        }));\n    case 'number?':\n        // FALL_THRU\n    case 'integer?':\n        // FALL_THRU\n    case 'bigint?':\n        // FALL_THRU\n    case 'string?':\n        // FALL_THRU\n    case 'boolean?':\n        // FALL_THRU\n    case 'null?':\n        // FALL_THRU\n    case 'undefined?':\n        return (optional({\n            kind: 'primitive',\n            primitiveName: typeName.substring(0, typeName.length - 1) as any,\n        }));\n    default:\n        throw new Error(`Unknown primitive type assertion: ${typeName}`);\n    }\n    // TODO: Function, DateStr, DateTimeStr, Funtion?, DateStr?, DateTimeStr?\n}\n\n\nexport function regexpPatternStringType(pattern: RegExp): PrimitiveTypeAssertion {\n    return ({\n        kind: 'primitive',\n        primitiveName: 'string',\n        pattern,\n    });\n}\n\n\nexport function primitiveValue(value: PrimitiveValueTypes): PrimitiveValueTypeAssertion {\n    if (value === null || value === void 0) {\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    } else switch (typeof value) {\n    case 'number':\n        // FALL_THRU\n    case 'bigint':\n        // FALL_THRU\n    case 'string':\n        // FALL_THRU\n    case 'boolean':\n        return ({\n            kind: 'primitive-value',\n            value,\n        });\n    default:\n        throw new Error(`Unknown primitive value assertion: ${value}`);\n    }\n}\n\n\nexport function optional(ty: PrimitiveValueTypes | TypeAssertion): OptionalAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        if (ty.kind === 'optional') {\n            return ty;\n        } else {\n            return ({\n                kind: 'optional',\n                optional: ty,\n                ...(ty.typeName ? {typeName: ty.typeName} : {}),\n            });\n        }\n    } else {\n        return ({\n            kind: 'optional',\n            optional: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function repeated(\n        ty: PrimitiveValueTypeNames | TypeAssertion, option?:\n        Partial<Pick<RepeatedAssertion, 'max'> & Pick<RepeatedAssertion, 'min'>>): RepeatedAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: ty,\n        });\n    } else {\n        return ({\n            kind: 'repeated',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            repeated: primitive(ty),\n        });\n    }\n}\n\n\nexport function sequenceOf(...seq: Array<PrimitiveValueTypes | TypeAssertion>): SequenceAssertion {\n    return ({\n        kind: 'sequence',\n        sequence: seq.map(ty => ty && typeof ty === 'object' && ty.kind ? ty : primitiveValue(ty)),\n    });\n}\n\n\nexport function spread(\n        ty: PrimitiveValueTypes | TypeAssertion,\n        option?: Partial<Pick<SpreadAssertion, 'max'> & Pick<SpreadAssertion, 'min'>>): SpreadAssertion {\n    if (ty && typeof ty === 'object' && ty.kind) {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: ty,\n        });\n    } else {\n        return ({\n            kind: 'spread',\n            min: option && typeof option.min === 'number' ? option.min : null,\n            max: option && typeof option.max === 'number' ? option.max : null,\n            spread: primitiveValue(ty),\n        });\n    }\n}\n\n\nexport function enumType(...values: Array<[string, number | string | null, string?]>): EnumAssertion {\n    const ar = values.slice();\n    let value = 0;\n    for (let i = 0; i < ar.length; i++) {\n        if (isUnsafeVarNames(dummyTargetObject, ar[i][0])) {\n            throw new Error(`Unsafe symbol name is appeared in enum assertion: ${ar[i][0]}`);\n        }\n\n        if (ar[i][1] === null || ar[i][1] === void 0) {\n            ar[i][1] = value++;\n        } else if (typeof ar[i][1] === 'number') {\n            value = (ar[i][1] as number) + 1;\n        }\n        if (! ar[i][2]) {\n            ar[i].length = 2;\n        }\n    }\n    return ({\n        kind: 'enum',\n        values: ar as Array<[string, number | string, string?]>,\n    });\n}\n\n\nexport function objectType(\n        ...members: Array<[\n            string | AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>): ObjectAssertion {\n    const revMembers = members.slice().reverse();\n    for (const x of members) {\n        if (typeof x[0] === 'string') {\n            if (isUnsafeVarNames(dummyTargetObject, x[0])) {\n                throw new Error(`Unsafe symbol name is appeared in object assertion: ${x[0]}`);\n            }\n            if (members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n                throw new Error(`Duplicated member is found: ${x[0]}`);\n            }\n        }\n    }\n\n    const membersProps: ObjectAssertionMember[] = (members\n        .filter(\n            x => typeof x[0] === 'string') as\n                Array<[string, PrimitiveValueTypes | TypeAssertion, string?]>)\n        .map(\n            x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n                [x[0], withName(x[1], x[0]), x[2]] :\n                [x[0], withName(primitiveValue(x[1]), x[0]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as ObjectAssertionMember);\n\n    const additionalProps: AdditionalPropsMember[] = (members\n        .filter(x => typeof x[0] !== 'string') as Array<[\n            AdditionalPropsKey,\n            PrimitiveValueTypes | TypeAssertion,\n            string?\n        ]>)\n        .map(x => x[1] && typeof x[1] === 'object' && x[1].kind ?\n            x :\n            [x[0], primitiveValue(x[1]), x[2]])\n        .map(\n            x => (x[2] ?\n                [x[0], x[1], false, ...x.slice(2)] :\n                [x[0], x[1]]) as AdditionalPropsMember);\n\n    return ({\n        ...{\n            kind: 'object',\n            members: membersProps,\n        },\n        ...(0 < additionalProps.length ? {\n            additionalProps,\n        } : {}),\n    });\n}\n\n\nfunction checkRecursiveExtends(ty: ObjectAssertion, base: ObjectAssertion | AssertionSymlink): boolean {\n    if (ty === base) {\n        return false;\n    }\n    if (ty.typeName &&\n        (ty.typeName === base.typeName ||\n         (base.kind === 'symlink' && ty.typeName === base.symlinkTargetName))) {\n        return false;\n    }\n    if (base.kind === 'object' && base.baseTypes) {\n        for (const z of base.baseTypes) {\n            if (! checkRecursiveExtends(ty, z)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nexport function derived(ty: ObjectAssertion, ...exts: TypeAssertion[]): ObjectAssertion {\n    const ret: ObjectAssertion = {\n        kind: 'object',\n        members: [],\n        baseTypes: [],\n    };\n\n    for (const ext of exts) {\n        switch (ext.kind) {\n        case 'object':\n            if (! checkRecursiveExtends(ty, ext)) {\n                throw new Error(`Recursive extend is found: ${ty.name || '(unnamed)'}`);\n            }\n            for (const m of ext.members) {\n                if (! ret.members.find(x => x[0] === m[0])) {\n                    ret.members.push([m[0], m[1], true, ...m.slice(3)] as ObjectAssertionMember);\n                }\n                // TODO: Check for different types with the same name.\n            }\n        // FALL_THRU\n        case 'symlink':\n            (ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).push(ext);\n            break;\n        case 'operator':\n            {\n                throw new Error(`Unresolved type operator is found: ${ext.operator}`);\n            }\n        }\n        // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n        //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n    }\n    ret.members = ty.members.concat(ret.members);\n    if (ty.baseTypes) {\n        ret.baseTypes = ty.baseTypes\n            .filter(x => x.kind !== 'symlink')\n            .concat(ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>);\n    }\n    if ((ret.baseTypes as Array<ObjectAssertion | AssertionSymlink>).length === 0) {\n        delete ret.baseTypes;\n    }\n\n    const revMembers = ret.members.slice().reverse();\n    for (const x of ret.members) {\n        if (ret.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            throw new Error(`Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`);\n        }\n    }\n\n    let additionalProps: AdditionalPropsMember[] = [];\n    if (ret.baseTypes) {\n        for (const base of ret.baseTypes) {\n            if (base.kind === 'object') {\n                if (base.additionalProps && 0 < base.additionalProps.length) {\n                    additionalProps = additionalProps.concat(\n                        base.additionalProps.map(x =>\n                            [x[0], x[1], true, ...x.slice(3)] as AdditionalPropsMember));\n                }\n            }\n            // NOTE: 'symlink' base types will resolved by calling `resolveSymbols()`.\n            //       `resolveSymbols()` will call `derived()` after resolve symlink exts.\n        }\n    }\n    if (ty.additionalProps && 0 < ty.additionalProps.length) {\n        additionalProps = additionalProps.concat(ty.additionalProps); // TODO: concat order\n    }\n    if (0 < additionalProps.length) {\n        ret.additionalProps = additionalProps;\n    }\n\n    return ret;\n}\n\n\nexport function symlinkType(name: string): AssertionSymlink {\n    return ({\n        kind: 'symlink',\n        symlinkTargetName: name,\n    });\n}\n\n\nexport function withName(ty: TypeAssertion, name: string) {\n    if (! name) {\n        return ty;\n    }\n    return ({...ty, name});\n}\n\n\nexport function withTypeName(ty: TypeAssertion, typeName: string) {\n    if (! typeName) {\n        return ty;\n    }\n    return ({...ty, typeName});\n}\n\n\nexport function withOriginalTypeName(ty: TypeAssertion, originalTypeName: string) {\n    if (! originalTypeName) {\n        return ty;\n    }\n    return ({...ty, originalTypeName});\n}\n\n\nexport function withDocComment(ty: TypeAssertion, docComment: string) {\n    if (! docComment) {\n        return ty;\n    }\n    return ({...ty, docComment});\n}\n\n\nexport function withRange(minValue: number | string, maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'minValue' should be number or string.`);\n        }\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@range' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@range' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue, maxValue});\n        }\n    };\n}\n\n\nexport function withMinValue(minValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minValue !== 'number' && typeof minValue !== 'string') {\n            throw new Error(`Decorator '@minValue' parameter 'minValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minValue});\n        }\n    };\n}\n\n\nexport function withMaxValue(maxValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxValue !== 'number' && typeof maxValue !== 'string') {\n            throw new Error(`Decorator '@maxValue' parameter 'maxValue' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxValue' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxValue});\n        }\n    };\n}\n\n\nexport function withGreaterThan(greaterThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof greaterThanValue !== 'number' && typeof greaterThanValue !== 'string') {\n            throw new Error(`Decorator '@greaterThan' parameter 'greaterThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, greaterThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@greaterThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, greaterThanValue});\n        }\n    };\n}\n\n\nexport function withLessThan(lessThanValue: number | string) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof lessThanValue !== 'number' && typeof lessThanValue !== 'string') {\n            throw new Error(`Decorator '@lessThan' parameter 'lessThan' should be number or string.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, lessThanValue}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@lessThan' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, lessThanValue});\n        }\n    };\n}\n\n\nexport function withMinLength(minLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof minLength !== 'number') {\n            throw new Error(`Decorator '@minLength' parameter 'minLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, minLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@minLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, minLength});\n        }\n    };\n}\n\n\nexport function withMaxLength(maxLength: number) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof maxLength !== 'number') {\n            throw new Error(`Decorator '@maxLength' parameter 'maxLength' should be number.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, maxLength}});\n        } else {\n            if (!ty || ty.kind !== 'primitive') {\n                throw new Error(`Decorator '@maxLength' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, maxLength});\n        }\n    };\n}\n\n\nexport function withMatch(pattern: RegExp) {\n    return (ty: PrimitiveTypeAssertion) => {\n        if (typeof pattern !== 'object') {\n            throw new Error(`Decorator '@match' parameter 'pattern' should be RegExp.`);\n        }\n        if ((ty as TypeAssertion).kind === 'optional') {\n            const opt = (ty as any as OptionalAssertion).optional;\n            if (opt.kind !== 'primitive') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, optional: {...opt, pattern}});\n        } else {\n            if (!ty || ty.kind !== 'primitive' || ty.primitiveName !== 'string') {\n                throw new Error(`Decorator '@match' cannot be applied to anything other than 'primitive'.`);\n            }\n            return ({...ty, pattern});\n        }\n    };\n}\n\n\nexport function withStereotype<T extends TypeAssertion>(stereotype: string): (ty: T) => T {\n    if (typeof stereotype !== 'string') {\n        throw new Error(`Decorator '@stereotype' parameter 'stereotype' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, stereotype)) {\n        throw new Error(`Unsafe symbol name is appeared in stereotype assertion: ${stereotype}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    stereotype,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                stereotype,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withConstraint<T extends TypeAssertion>(name: string, args?: any): (ty: T) => T {\n    if (typeof name !== 'string') {\n        throw new Error(`Decorator '@constraint' parameter 'name' should be string.`);\n    }\n    if (isUnsafeVarNames(dummyTargetObject, name)) {\n        throw new Error(`Unsafe symbol name is appeared in constraint assertion: ${name}`);\n    }\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const opt = (ty as OptionalAssertion).optional;\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...opt,\n                    customConstraints: opt.customConstraints\n                        ? opt.customConstraints.slice().push(name)\n                        : [name],\n                    customConstraintsArgs: opt.customConstraintsArgs\n                        ? {...opt.customConstraintsArgs, [name]: args}\n                        : {[name]: args},\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                customConstraints: ty.customConstraints\n                    ? ty.customConstraints.slice().push(name)\n                    : [name],\n                customConstraintsArgs: ty.customConstraintsArgs\n                    ? {...ty.customConstraintsArgs, [name]: args}\n                    : {[name]: args},\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withForceCast<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    forceCast: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                forceCast: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withRecordType<T extends TypeAssertion>(): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            const ret: T = ({\n                ...ty,\n                optional: {\n                    ...(ty as OptionalAssertion).optional,\n                    isRecordTypeField: true,\n                },\n            });\n            return ret;\n        } else {\n            const ret: T = ({\n                ...ty,\n                isRecordTypeField: true,\n            });\n            return ret;\n        }\n    };\n}\n\n\nexport function withMeta<T extends TypeAssertion>(meta: any): (ty: T) => T {\n    return (ty: T) => {\n        const ret: T = ({\n            ...ty,\n            meta,\n        });\n        return ret;\n    };\n}\n\n\nexport function withMsg<T extends TypeAssertion>(messages: string | ErrorMessages): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            if (typeof messages === 'string') {\n                const ret = ({\n                    ...ty,\n                    message: messages,\n                    optional: {...(ty as OptionalAssertion).optional, message: messages},\n                });\n                delete ret.messages;\n                delete ret.optional.messages;\n                return ret;\n            } else {\n                const ret = ({\n                    ...ty,\n                    messages,\n                    optional: {...(ty as OptionalAssertion).optional, messages},\n                });\n                delete ret.message;\n                delete ret.optional.message;\n                return ret;\n            }\n        } else {\n            if (typeof messages === 'string') {\n                const ret = ({...ty, message: messages});\n                delete ret.messages;\n                return ret;\n            } else {\n                const ret = ({...ty, messages});\n                delete ret.message;\n                return ret;\n            }\n        }\n    };\n}\n\n\nexport function withMsgId<T extends TypeAssertion>(messageId: string): (ty: T) => T {\n    return (ty: T) => {\n        if (ty.kind === 'optional') {\n            return ({\n                ...ty,\n                messageId,\n                optional: {...(ty as OptionalAssertion).optional, messageId},\n            });\n        } else {\n            return ({...ty, messageId});\n        }\n    };\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\n\n// tslint:disable: no-shadowed-variable\n// tslint:disable: function-constructor\n\n\nexport const dummyTargetObject = {};\n\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\nexport const { g: globalObj, o: objConstructor, f: funConstructor } = (() => {\n    let globalObj = null;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-implied-eval\n        globalObj = Function('return this')();\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! globalObj) {\n        // Fall back (for CSP, etc...)\n        if (typeof window === 'object' && window) {\n            globalObj = window;\n        } else if (typeof global === 'object' && global) {\n            globalObj = global;\n        } else if (typeof globalThis === 'object' && globalThis) {\n            globalObj = globalThis;\n        } else {\n            globalObj = dummyTargetObject;\n        }\n    }\n\n    // NOTE: ({}).constructor === Object\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let objConstructor: ObjectConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = (({}).constructor ?? Object) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! objConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        objConstructor = dummyTargetObject as any;\n    }\n\n    // NOTE: ({}).toString.constructor === Function\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    let funConstructor: FunctionConstructor = null as any;\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = (({}).toString.constructor ?? Function) as any;\n    } catch (e) {\n        // Nothing to do.\n    }\n    if (! funConstructor) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        funConstructor = dummyTargetObject as any;\n    }\n\n    return ({\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        g: globalObj, o: objConstructor, f: funConstructor\n    });\n})();\n\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function isUnsafeVarNames(target: any, varName: string) {\n    if (target === globalObj ||\n        varName === '__proto__' ||\n        varName === '__defineGetter__' || varName === '__defineSetter__' ||\n        varName === '__lookupGetter__' || varName === '__lookupSetter__') {\n        return true;\n    }\n    if (varName === 'prototype' || varName === 'constructor') {\n        if (target === null || target === void 0 || typeof target === 'function') {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === objConstructor) {\n        if (Object.prototype.hasOwnProperty.call(objConstructor, varName)) {\n            return true;\n        }\n    }\n    if (target === null || target === void 0 || target === funConstructor) {\n        // checking 'call', 'arguments', 'caller', ...\n        let con: any = funConstructor;\n        while (con) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n            if (Object.prototype.hasOwnProperty.call(con, varName)) {\n                return true;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n            con = con.__proto__;\n        }\n    }\n    if (typeof target === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unsafe-member-access\n        if (! Object.prototype.hasOwnProperty.call(target, varName)) {\n            // function's prototypes' members\n            return true;\n        }\n    }\n    return false;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nexport function escapeString(s: string) {\n    return (s\n        .replace(/\\x08/g, '\\\\b')\n        .replace(/\\f/g, '\\\\f')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\v/g, '\\\\v')\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\'/g, '\\\\\\'')\n        .replace(/\\\"/g, '\\\\\\\"')\n        .replace(/\\`/g, '\\\\\\`')\n    );\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         ValidationContext } from '../types';\n\n\n\nexport class ValidationError extends Error {\n    public ty?: TypeAssertion;\n    public ctx?: Partial<ValidationContext>;\n    public constructor(message: string, ty?: TypeAssertion, ctx?: Partial<ValidationContext>) {\n        super(message);\n        this.ty = ty;\n        this.ctx = ctx;\n    }\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { TypeAssertion,\n         TypeAssertionMap,\n         TypeAssertionSetValue,\n         ObjectAssertion,\n         AssertionSymlink,\n         SymbolResolverOperators,\n         ResolveSymbolOptions,\n         SymbolResolverContext } from '../types';\nimport * as operators            from '../operators';\nimport { NumberPattern }         from '../lib/util';\n\n\n\nfunction mergeTypeAndSymlink(ty: TypeAssertion, link: AssertionSymlink): TypeAssertion {\n    const link2 = {...link};\n    delete (link2 as any).kind;              // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    delete (link2 as any).symlinkTargetName; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    delete (link2 as any).memberTree;        // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n    return ({...ty, ...link2} as any as TypeAssertion);\n}\n\n\nfunction updateSchema(original: TypeAssertion, schema: TypeAssertionMap, ty: TypeAssertion, typeName: string | undefined) {\n    if (typeName && schema.has(typeName)) {\n        const z: TypeAssertionSetValue = schema.get(typeName) as TypeAssertionSetValue;\n        if (z.ty === original) {\n            schema.set(typeName, {...z, ty, resolved: true});\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveMemberNames(\n        ty: TypeAssertion, rootSym: string, memberTreeSymbols: string[], memberPos: number): TypeAssertion {\n\n    const addTypeName = (mt: TypeAssertion, typeName: string | undefined, memberSym: string) => {\n        if (typeName) {\n            return ({\n                ...mt,\n                typeName: memberPos === 0 ?\n                    `${rootSym}.${memberTreeSymbols.join('.')}` :\n                    `${typeName}.${memberSym}`,\n            });\n        } else {\n            return mt;\n        }\n    };\n\n    for (let i = memberPos; i < memberTreeSymbols.length; i++) {\n        const memberSym = memberTreeSymbols[i];\n\n        switch (ty.kind) {\n        case 'optional':\n            return resolveMemberNames(ty.optional, rootSym, memberTreeSymbols, i + 1);\n        case 'object':\n            for (const m of ty.members) {\n                if (memberSym === m[0]) {\n                    return addTypeName(\n                        resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1),\n                        ty.typeName,\n                        memberSym,\n                    );\n                }\n            }\n            if (ty.additionalProps) {\n                for (const m of ty.additionalProps) {\n                    for (const k of m[0]) {\n                        switch (k) {\n                        case 'number':\n                            if (NumberPattern.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        case 'string':\n                            return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                        default:\n                            if (k.test(memberSym)) {\n                                return resolveMemberNames(m[1], rootSym, memberTreeSymbols, i + 1);\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n            throw new Error(`Undefined member name is appeared: ${memberSym}`);\n        case 'symlink':\n            if (! ty.typeName) {\n                throw new Error(`Reference of anonymous type is appeared: ${memberSym}`);\n            }\n            return ({\n                ...{\n                    kind: 'symlink',\n                    symlinkTargetName: rootSym,\n                    name: memberSym,\n                    typeName: rootSym,\n                },\n                ...(0 < memberTreeSymbols.length ? {\n                    memberTree: memberTreeSymbols,\n                } : {}),\n            });\n        default:\n            // TODO: kind === 'operator'\n            throw new Error(`Unsupported type kind is appeared: (kind:${ty.kind}).${memberSym}`);\n        }\n    }\n    return ty;\n}\n\n\nexport function resolveSymbols(schema: TypeAssertionMap, ty: TypeAssertion, ctx: SymbolResolverContext): TypeAssertion {\n    const ctx2 = {...ctx, nestLevel: ctx.nestLevel + 1};\n    switch (ty.kind) {\n    case 'symlink':\n        {\n            const x = schema.get(ty.symlinkTargetName);\n            if (! x) {\n                throw new Error(`Undefined symbol '${ty.symlinkTargetName}' is referred.`);\n            }\n            if (0 <= ctx.symlinkStack.findIndex(s => s === ty.symlinkTargetName)) {\n                return ty;\n            }\n\n            const ty2 = {...ty};\n            let xTy = x.ty;\n            if (ty.memberTree && 0 < ty.memberTree.length) {\n                xTy = {\n                    ...resolveMemberNames(xTy, ty.symlinkTargetName, ty.memberTree, 0),\n                };\n                ty2.typeName = xTy.typeName;\n            }\n\n            return (\n                resolveSymbols(\n                    schema,\n                    mergeTypeAndSymlink(xTy, ty2),\n                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty2.symlinkTargetName]},\n                )\n            );\n        }\n    case 'repeated':\n        return updateSchema(ty, schema, {\n            ...ty,\n            repeated: resolveSymbols(schema, ty.repeated, ctx2),\n        }, ty.typeName);\n    case 'spread':\n        return updateSchema(ty, schema, {\n            ...ty,\n            spread: resolveSymbols(schema, ty.spread, ctx2),\n        }, ty.typeName);\n    case 'sequence':\n        return updateSchema(ty, schema, {\n            ...ty,\n            sequence: ty.sequence.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'one-of':\n        return updateSchema(ty, schema, {\n            ...ty,\n            oneOf: ty.oneOf.map(x => resolveSymbols(schema, x, ctx2)),\n        }, ty.typeName);\n    case 'optional':\n        return updateSchema(ty, schema, {\n            ...ty,\n            optional: resolveSymbols(schema, ty.optional, ctx2),\n        }, ty.typeName);\n    case 'object':\n        {\n            if (0 < ctx.nestLevel && ty.typeName && 0 <= ctx.symlinkStack.findIndex(s => s === ty.typeName)) {\n                if (schema.has(ty.typeName)) {\n                    const z = schema.get(ty.typeName) as TypeAssertionSetValue;\n                    if (z.resolved) {\n                        return z.ty;\n                    }\n                }\n            }\n\n            const baseSymlinks = ty.baseTypes?.filter(x => x.kind === 'symlink') as AssertionSymlink[];\n            if (baseSymlinks && baseSymlinks.length > 0 && !ctx.isDeserialization) {\n                const exts = baseSymlinks\n                    .map(x => resolveSymbols(schema, x, ctx2))\n                    .filter(x => x.kind === 'object');\n                // TODO: if x.kind !== 'object' items exist -> error?\n                const d2 = resolveSymbols(\n                    schema,\n                    operators.derived({\n                        ...ty,\n                        ...(ty.baseTypes ? {\n                            baseTypes: ty.baseTypes.filter(x => x.kind !== 'symlink'),\n                        } : {}),\n                    }, ...exts),\n                    ty.typeName ?\n                        {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2,\n                );\n                return updateSchema(ty, schema, {\n                    ...ty,\n                    ...d2,\n                }, ty.typeName);\n            } else {\n                return updateSchema(ty, schema, {\n                    ...{\n                        ...ty,\n                        members: ty.members\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    },\n                    ...(ty.additionalProps && 0 < ty.additionalProps.length ? {\n                        additionalProps: ty.additionalProps\n                            .map(x => [\n                                x[0],\n                                resolveSymbols(schema, x[1], ty.typeName ?\n                                    {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2),\n                                ...x.slice(2),\n                            ] as any),\n                    } : {}),\n                    ...(ty.baseTypes && 0 < ty.baseTypes.length ? {\n                        baseTypes: ctx.isDeserialization ?\n                            ty.baseTypes\n                                .map(x => x.kind === 'symlink' ? resolveSymbols(schema, x, ctx2) : x)\n                                .filter(x => x.kind === 'object') as ObjectAssertion[] :\n                            ty.baseTypes,\n                    } : {}),\n                }, ty.typeName);\n            }\n        }\n    case 'operator':\n        if (ctx2.operators) {\n            const ctx3 = ty.typeName ?\n                {...ctx2, symlinkStack: [...ctx2.symlinkStack, ty.typeName]} : ctx2;\n            const operands = ty.operands.map(x => {\n                if (typeof x === 'object' && x.kind) {\n                    return resolveSymbols(schema, x, ctx3);\n                }\n                return x;\n            });\n            if (0 < operands.filter(x => x && typeof x === 'object' &&\n                    (x.kind === 'symlink' || x.kind === 'operator')).length) {\n                throw new Error(`Unresolved type operator is found: ${ty.operator}`);\n            }\n            if (! ctx2.operators[ty.operator]) {\n                throw new Error(`Undefined type operator is found: ${ty.operator}`);\n            }\n            const ty2 = {...ty};\n            delete (ty2 as any).operator; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n            delete (ty2 as any).operands; // NOTE: (TS>=4.0) TS2790: The operand of a 'delete' operator must be optional.\n            return updateSchema(\n                ty, schema,\n                {\n                    ...ty2,\n                    ...resolveSymbols(schema, ctx2.operators[ty.operator](...operands), ctx3),\n                },\n                ty.typeName,\n            );\n        } else {\n            return ty;\n        }\n    default:\n        return ty;\n    }\n}\n\n\nconst resolverOps: SymbolResolverOperators = {\n    picked: operators.picked,\n    omit: operators.omit,\n    partial: operators.partial,\n    intersect: operators.intersect,\n    subtract: operators.subtract,\n};\n\n\nexport function resolveSchema(schema: TypeAssertionMap, opts?: ResolveSymbolOptions): TypeAssertionMap {\n    for (const ent of schema.entries()) {\n        const ty = resolveSymbols(schema, ent[1].ty, {...opts, nestLevel: 0, symlinkStack: [ent[0]], operators: resolverOps});\n        ent[1].ty = ty;\n    }\n\n    return schema;\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         ErrorMessages,\n         TypeAssertionErrorMessageConstraints,\n         TypeAssertion,\n         RepeatedAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         ValidationContext } from '../types';\nimport { escapeString }      from './escape';\nimport { nvl }               from './util';\n\n\nexport const errorTypeNames = [\n    '',\n    'InvalidDefinition',\n    'Required',\n    'TypeUnmatched',\n    'AdditionalPropUnmatched',\n    'RepeatQtyUnmatched',\n    'SequenceUnmatched',\n    'ValueRangeUnmatched',\n    'ValuePatternUnmatched',\n    'ValueLengthUnmatched',\n    'ValueUnmatched',\n];\n\n\nexport const defaultMessages: ErrorMessages = {\n    invalidDefinition:       '\"%{name}\" of \"%{parentType}\" type definition is invalid.',\n    required:                '\"%{name}\" of \"%{parentType}\" is required.',\n    typeUnmatched:           '\"%{name}\" of \"%{parentType}\" should be type \"%{expectedType}\".',\n    additionalPropUnmatched: '\"%{addtionalProps}\" of \"%{parentType}\" are not matched to additional property patterns.',\n    repeatQtyUnmatched:      '\"%{name}\" of \"%{parentType}\" should repeat %{repeatQty} times.',\n    sequenceUnmatched:       '\"%{name}\" of \"%{parentType}\" sequence is not matched',\n    valueRangeUnmatched:     '\"%{name}\" of \"%{parentType}\" value should be in the range %{minValue} to %{maxValue}.',\n    valuePatternUnmatched:   '\"%{name}\" of \"%{parentType}\" value should be matched to pattern \"%{pattern}\"',\n    valueLengthUnmatched:    '\"%{name}\" of \"%{parentType}\" length should be in the range %{minLength} to %{maxLength}.',\n    valueUnmatched:          '\"%{name}\" of \"%{parentType}\" value should be \"%{expectedValue}\".',\n};\n\n\ntype TopRepeatable = RepeatedAssertion | SpreadAssertion | OptionalAssertion | null;\n\n\ninterface ReportErrorArguments {\n    ctx: ValidationContext;\n    substitutions?: [[string, string]]; // addtional or overwritten substitution values\n}\n\n\nfunction getErrorMessage(errType: ErrorTypes, ...messages: ErrorMessages[]) {\n    for (const m of messages) {\n        switch (errType) {\n        case ErrorTypes.InvalidDefinition:\n            if (m.invalidDefinition) {\n                return m.invalidDefinition;\n            }\n            break;\n        case ErrorTypes.Required:\n            if (m.required) {\n                return m.required;\n            }\n            break;\n        case ErrorTypes.TypeUnmatched:\n            if (m.typeUnmatched) {\n                return m.typeUnmatched;\n            }\n            break;\n        case ErrorTypes.AdditionalPropUnmatched:\n            if (m.additionalPropUnmatched) {\n                return m.additionalPropUnmatched;\n            }\n            break;\n        case ErrorTypes.RepeatQtyUnmatched:\n            if (m.repeatQtyUnmatched) {\n                return m.repeatQtyUnmatched;\n            }\n            break;\n        case ErrorTypes.SequenceUnmatched:\n            if (m.sequenceUnmatched) {\n                return m.sequenceUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueRangeUnmatched:\n            if (m.valueRangeUnmatched) {\n                return m.valueRangeUnmatched;\n            }\n            break;\n        case ErrorTypes.ValuePatternUnmatched:\n            if (m.valuePatternUnmatched) {\n                return m.valuePatternUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueLengthUnmatched:\n            if (m.valueLengthUnmatched) {\n                return m.valueLengthUnmatched;\n            }\n            break;\n        case ErrorTypes.ValueUnmatched:\n            if (m.valueUnmatched) {\n                return m.valueUnmatched;\n            }\n            break;\n        }\n    }\n    return '';\n}\n\n\nfunction findTopRepeatableAssertion(ctx: ValidationContext): TopRepeatable {\n    const ret = ctx.typeStack\n        .slice()\n        .reverse()\n        .map(x => Array.isArray(x) ? x[0] : x)\n        .find(x => x.kind === 'repeated' || x.kind === 'spread' || x.kind === 'optional'\n                ) as RepeatedAssertion | SpreadAssertion | OptionalAssertion || null;\n    return ret;\n}\n\n\nfunction getExpectedType(ty: TypeAssertion): string {\n    switch (ty.kind) {\n    case 'repeated':\n        return `(repeated ${getExpectedType(ty.repeated)})`;\n    case 'spread':\n        return getExpectedType(ty.spread);\n    case 'sequence':\n        return '(sequence)';\n    case 'primitive':\n        return ty.primitiveName;\n    case 'primitive-value':\n        return `(value ${\n            typeof ty.value === 'string' ?\n                `'${String(ty.value)}'` :\n                String(ty.value)})`;\n    case 'optional':\n        return getExpectedType(ty.optional);\n    case 'one-of':\n        return `(one of ${ty.oneOf.map(x => getExpectedType(x)).join(', ')})`;\n    case 'never': case 'any': case 'unknown':\n        return ty.kind;\n    case 'symlink':\n        return ty.symlinkTargetName;\n    default:\n        return ty.typeName ? ty.typeName : '?';\n    }\n}\n\n\nexport function formatErrorMessage(\n        msg: string, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments,\n        values: {dataPath: string, topRepeatable: TopRepeatable, parentType: string, entryName: string}) {\n\n    let ret = msg;\n    // TODO: complex type object members' custom error messages are not displayed?\n    // TODO: escapeString() is needed?\n\n    const tr = values.topRepeatable;\n\n    const dict = new Map<string, string>([\n        ['expectedType',\n            ty.stereotype ?\n                ty.stereotype :\n            escapeString(getExpectedType(ty))],\n        ['type',\n            escapeString(typeof data)],\n        ['expectedValue',\n            escapeString(\n                ty.kind === 'primitive-value' ?\n                    String(ty.value) :\n                ty.kind === 'enum' ?\n                    ty.typeName ?\n                        `enum member of ${ty.typeName}` :\n                        '?' :\n                '?')],\n        ['value',\n            escapeString(String(data))],\n        ['repeatQty',\n            escapeString(\n                tr ?\n                    tr.kind !== 'optional' ? `${\n                        nvl(tr.min, '')}${\n                            (tr.min !== null && tr.min !== void 0) ||\n                            (tr.max !== null && tr.max !== void 0) ? '..' : ''}${\n                            nvl(tr.max, '')}` :\n                        '0..1' :\n                    '?')],\n        ['minValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minValue, nvl(ty.greaterThanValue, '(smallest)'))}` : '?')],\n        ['maxValue',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxValue, nvl(ty.lessThanValue, '(biggest)'))}` : '?')],\n        ['pattern',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${ty.pattern ? `/${ty.pattern.source}/${ty.pattern.flags}` : '(pattern)'}` : '?')],\n        ['minLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.minLength, '0')}` : '?')],\n        ['maxLength',\n            escapeString(\n                ty.kind === 'primitive' ?\n                    `${nvl(ty.maxLength, '(biggest)')}` : '?')],\n        ['name',\n            escapeString(\n                `${ty.kind !== 'repeated' && values.dataPath.endsWith('repeated)') ?\n                    'repeated item of ' :\n                   ty.kind !== 'sequence' && values.dataPath.endsWith('sequence)') ?\n                    'sequence item of ' : ''}${\n                values.entryName || '?'}`)],\n        ['parentType',\n            escapeString(\n                values.parentType || '?')],\n        ['dataPath',\n            values.dataPath],\n\n        ...(args.substitutions || []),\n    ]);\n\n    for (const ent of dict.entries()) {\n        ret = ret.replace(new RegExp(`%{${ent[0]}}`), ent[1]);\n    }\n\n    return ret;\n}\n\n\ninterface DataPathEntry {\n    name: string;\n    kind: 'type' | 'key' | 'index';\n}\n\n\nexport function reportError(\n        errType: ErrorTypes, data: any, ty: TypeAssertion,\n        args: ReportErrorArguments) {\n\n    const messages: ErrorMessages[] = [];\n    if (ty.messages) {\n        messages.push(ty.messages);\n    }\n    if (args.ctx.errorMessages) {\n        messages.push(args.ctx.errorMessages);\n    }\n    messages.push(defaultMessages);\n\n    const dataPathEntryArray: DataPathEntry[] = [];\n\n    for (let i = 0; i < args.ctx.typeStack.length; i++) {\n        const p = args.ctx.typeStack[i];\n        const next = args.ctx.typeStack[i + 1];\n        const pt = Array.isArray(p) ? p[0] : p;\n        const pi = Array.isArray(next) ? next[1] : void 0;\n\n        let isSet = false;\n        if (pt.kind === 'repeated') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}repeated)`});\n                isSet = true;\n            }\n        } else if (pt.kind === 'sequence') {\n            if (i !== args.ctx.typeStack.length - 1) {\n                if (pt.name) {\n                    dataPathEntryArray.push({kind: 'key', name: pt.name});\n                }\n                dataPathEntryArray.push({kind: 'index', name: `(${pi !== void 0 ? `${pi}:` : ''}sequence)`});\n                isSet = true;\n            }\n        }\n        if (! isSet) {\n            if (pt.name) {\n                if (i === 0) {\n                    if (pt.typeName) {\n                        dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                    } else {\n                        dataPathEntryArray.push({kind: 'key', name: pt.name});\n                    }\n                } else {\n                    const len = dataPathEntryArray.length;\n                    if (len && dataPathEntryArray[len - 1].kind === 'type') {\n                        if (pt.kind === 'object' && next && pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name as string}); // NOTE: type inference failed\n                        }\n                    } else {\n                        if (pt.typeName) {\n                            dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n                        } else {\n                            dataPathEntryArray.push({kind: 'key', name: pt.name});\n                        }\n                    }\n                }\n            } else if (pt.typeName) {\n                dataPathEntryArray.push({kind: 'type', name: pt.typeName});\n            }\n        }\n    }\n\n    let dataPath = '';\n    for (let i = 0; i < dataPathEntryArray.length; i++) {\n        const p = dataPathEntryArray[i];\n        dataPath += p.name;\n        if (i + 1 === dataPathEntryArray.length) {\n            break;\n        }\n        dataPath += p.kind === 'type' ? ':' : '.';\n    }\n\n    let parentType = '';\n    let entryName = '';\n    for (let i = dataPathEntryArray.length - 1; 0 <= i; i--) {\n        const p = dataPathEntryArray[i];\n        if (p.kind === 'type') {\n            if (i !== 0 && i === dataPathEntryArray.length - 1) {\n                const q = dataPathEntryArray[i - 1];\n                if (q.kind === 'index') {\n                    continue; // e.g.: \"File:acl.(0:repeated).ACL\"\n                }\n            }                 // else: \"File:acl.(0:repeated).ACL:target\"\n            parentType = p.name;\n            for (let j = i + 1; j < dataPathEntryArray.length; j++) {\n                const q = dataPathEntryArray[j];\n                if (q.kind === 'key') {\n                    entryName = q.name;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    if (! parentType) {\n        for (let i = args.ctx.typeStack.length - 1; 0 <= i; i--) {\n            const p = args.ctx.typeStack[i];\n            const pt = Array.isArray(p) ? p[0] : p;\n            if (pt.typeName) {\n                parentType = pt.typeName;\n            }\n        }\n    }\n\n    const topRepeatable: TopRepeatable = findTopRepeatableAssertion(args.ctx);\n    const values = {dataPath, topRepeatable, parentType, entryName};\n\n    const constraints: TypeAssertionErrorMessageConstraints = {};\n    const cSrces: TypeAssertionErrorMessageConstraints[] = [ty as any];\n\n    if (errType === ErrorTypes.RepeatQtyUnmatched && topRepeatable) {\n        cSrces.unshift(topRepeatable as any);\n    }\n\n    for (const cSrc of cSrces) {\n        if (nvl(cSrc.minValue, false)) {\n            constraints.minValue = cSrc.minValue;\n        }\n        if (nvl(cSrc.maxValue, false)) {\n            constraints.maxValue = cSrc.maxValue;\n        }\n        if (nvl(cSrc.greaterThanValue, false)) {\n            constraints.greaterThanValue = cSrc.greaterThanValue;\n        }\n        if (nvl(cSrc.lessThanValue, false)) {\n            constraints.lessThanValue = cSrc.lessThanValue;\n        }\n        if (nvl(cSrc.minLength, false)) {\n            constraints.minLength = cSrc.minLength;\n        }\n        if (nvl(cSrc.maxLength, false)) {\n            constraints.maxLength = cSrc.maxLength;\n        }\n        if (nvl(cSrc.pattern, false)) {\n            const pat = cSrc.pattern as any as RegExp;\n            constraints.pattern = `/${pat.source}/${pat.flags}`;\n        }\n        if (nvl(cSrc.min, false)) {\n            constraints.min = cSrc.min;\n        }\n        if (nvl(cSrc.max, false)) {\n            constraints.max = cSrc.max;\n        }\n    }\n\n    const val: {value?: any} = {};\n\n    switch (typeof data) {\n    case 'number': case 'bigint': case 'string': case 'boolean': case 'undefined':\n        val.value = data;\n        break;\n    case 'object':\n        if (data === null) {\n            val.value = data;\n        }\n    }\n\n    if (ty.messageId) {\n        args.ctx.errors.push({\n            code: `${ty.messageId}-${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message ?\n                ty.message :\n                getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else if (ty.message) {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(ty.message, data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    } else {\n        args.ctx.errors.push({\n            code: `${errorTypeNames[errType]}`,\n            message: formatErrorMessage(getErrorMessage(errType, ...messages), data, ty, args, values),\n            dataPath,\n            constraints,\n            ...val,\n        });\n    }\n}\n\n\nexport function reportErrorWithPush(\n        errType: ErrorTypes, data: any,\n        tyidx: [TypeAssertion, number | string | undefined],\n        args: ReportErrorArguments) {\n\n    try {\n        args.ctx.typeStack.push(tyidx);\n        reportError(errType, data, tyidx[0], args);\n    } finally {\n        args.ctx.typeStack.pop();\n    }\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype } from '../types';\n\n\n\nexport const noopStereotype: Stereotype = {\n    tryParse: (value: any) => {\n        return ({ value });\n    },\n    evaluateFormula: (valueOrFormula: any) => {\n        return valueOrFormula;\n    },\n    compare: (a: any, b: any) => {\n        // NOTE: You should pass assertion value (schema value) into 'a'.\n        const tyA = typeof a;\n        const tyB = typeof b;\n        if (tyA !== tyB) {\n            return NaN;\n        }\n        switch (tyA) {\n        case 'number':\n            if (Number.isNaN(a) && Number.isNaN(b)) {\n                return 0;\n            } else {\n                return a - b;\n            }\n        default:\n            if (a === b) {\n                return 0;\n            } else if (a > b) {\n                return 1;\n            } else if (a < b) {\n                return -1;\n            } else {\n                return NaN;\n            }\n        }\n    },\n    doCast: false,\n};\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { ErrorTypes,\n         NeverTypeAssertion,\n         AnyTypeAssertion,\n         UnknownTypeAssertion,\n         PrimitiveTypeAssertion,\n         PrimitiveValueTypeAssertion,\n         RepeatedAssertion,\n         SequenceAssertion,\n         SpreadAssertion,\n         OptionalAssertion,\n         OneOfAssertion,\n         EnumAssertion,\n         ObjectAssertion,\n         TypeAssertion,\n         ValidationContext,\n         TypeAssertionMap,\n         Stereotype,\n         CustomConstraintInfo } from './types';\nimport { ValidationError }      from './lib/errors';\nimport { NumberPattern }        from './lib/util';\nimport { isUnsafeVarNames }     from './lib/protection';\nimport { reportError,\n         reportErrorWithPush }  from './lib/reporter';\nimport { resolveSymbols }       from './lib/resolver';\nimport { noopStereotype }       from './stereotypes/noop';\n\n\n\nfunction checkStereotypes(\n    data: any, ty: TypeAssertion, ctx: ValidationContext):\n        {value: any, stereotype: Stereotype} | null | false {\n\n    if (ty.stereotype && ctx.stereotypes) {\n        if (ctx.stereotypes.has(ty.stereotype)) {\n            const stereotype = ctx.stereotypes.get(ty.stereotype) as Stereotype;\n            const parsed = stereotype.tryParse(data);\n            if (parsed) {\n                return ({\n                    value: parsed.value,\n                    stereotype,\n                });\n            } else {\n                return null;\n            }\n        } else {\n            throw new Error(`Undefined stereotype is specified: ${ty.stereotype}`);\n        }\n    }\n    return false;\n}\n\n\nfunction forceCast(\n    targetType:\n        'number' | 'integer' | 'bigint' | 'string' | 'boolean' | 'undefined' | 'null' |\n        'symbol' | 'object' | 'function',\n    value: any) {\n\n    switch (targetType) {\n    case 'number':\n        if (typeof value === 'number') {\n            return value;\n        } else {\n            const a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                return Number(value ?? 0);\n            } else {\n                return a;\n            }\n        }\n    case 'integer':\n        if (typeof value === 'number' && Math.trunc(value) === value) {\n            return value;\n        } else {\n            let a = Number.parseFloat(String(value));\n            if (Number.isNaN(a)) {\n                a = Number(value ?? 0);\n            }\n            return Math.trunc(a);\n        }\n    case 'bigint':\n        try {\n            return BigInt(value ?? 0);\n        } catch {\n            return NaN;\n        }\n    case 'string':\n        return String(value);\n    case 'boolean':\n        return Boolean(value);\n    case 'undefined':\n        return void 0;\n    case 'null':\n        return null;\n    default:\n        return value;\n    }\n}\n\n\nfunction checkCustomConstraints(\n    data: any, ty: TypeAssertion, ctx: ValidationContext): boolean | null {\n\n    if (ty.customConstraints && ctx.customConstraints) {\n        for (const ccName of ty.customConstraints) {\n            if (ctx.customConstraints.has(ccName)) {\n                const cc = ctx.customConstraints.get(ccName) as CustomConstraintInfo;\n                if (cc.kinds && !cc.kinds.includes(ty.kind)) {\n                    return null;\n                }\n                if (! cc.check(data, ty.customConstraintsArgs && ty.customConstraintsArgs[ccName])) {\n                    return null;\n                }\n            } else {\n                throw new Error(`Undefined constraint is specified: ${ccName}`);\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\n\nfunction validateNeverTypeAssertion<T>(\n    data: any, ty: NeverTypeAssertion, ctx: ValidationContext): null {\n\n    reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateAnyTypeAssertion<T>(\n    data: any, ty: AnyTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validateUnknownTypeAssertion<T>(\n    data: any, ty: UnknownTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let chkSt = checkStereotypes(data, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: data,\n            stereotype: noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    // always matched\n    return ({value: ctx.mapper\n        ? ctx.mapper(styp.doCast ? chkSt.value : data, ty)\n        :            styp.doCast ? chkSt.value : data});\n}\n\n\nfunction validatePrimitiveTypeAssertion<T>(\n    data: any, ty: PrimitiveTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(ty.primitiveName, data) : data;\n\n    if (ty.primitiveName === 'null') {\n        if (chkTarget !== null) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (ty.primitiveName === 'integer') {\n        if (typeof chkTarget !== 'number') {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n        if (Math.trunc(chkTarget) !== chkTarget) {\n            reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n            return null;\n        }\n    } else if (typeof chkTarget !== ty.primitiveName) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    // TODO: Function, DateStr, DateTimeStr\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n\n    const styVal = chkSt.value;\n    const styp = chkSt.stereotype;\n    let err = false;\n\n    let valueRangeErr = false;\n    switch (typeof ty.minValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.minValue)) < 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.maxValue)) > 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.greaterThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.greaterThanValue)) <= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.lessThanValue) {\n    case 'number': case 'string': // TODO: bigint\n        if (styp.compare(styVal, styp.evaluateFormula(ty.lessThanValue)) >= 0) {\n            if (! valueRangeErr) {\n                reportError(ErrorTypes.ValueRangeUnmatched, data, ty, {ctx});\n            }\n            valueRangeErr = true;\n            err = true;\n        }\n    }\n\n    let valueLengthErr = false;\n    switch (typeof ty.minLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length < ty.minLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n    switch (typeof ty.maxLength) {\n    case 'number':\n        if (typeof styVal !== 'string' || styVal.length > ty.maxLength) {\n            if (! valueLengthErr) {\n                reportError(ErrorTypes.ValueLengthUnmatched, data, ty, {ctx});\n            }\n            valueLengthErr = true;\n            err = true;\n        }\n    }\n\n    if (ty.pattern) {\n        if (typeof styVal !== 'string' || !ty.pattern.test(styVal)) {\n            reportError(ErrorTypes.ValuePatternUnmatched, data, ty, {ctx});\n            err = true;\n        }\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        err = true;\n    }\n\n    const ret = !err\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    return ret;\n}\n\n\nfunction validatePrimitiveValueTypeAssertion<T>(\n    data: any, ty: PrimitiveValueTypeAssertion, ctx: ValidationContext): {value: T} | null {\n\n    const chkTarget = ty.forceCast ? forceCast(typeof ty.value, data) : data;\n\n    let chkSt = checkStereotypes(chkTarget, ty, ctx);\n    if (chkSt === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    } else if (chkSt === false) {\n        chkSt = {\n            value: chkTarget,\n            stereotype: ty.forceCast ? noopStereotype : noopStereotype,\n        };\n    }\n    const styp = chkSt.stereotype;\n\n    let ret = styp.compare(chkSt.value, styp.evaluateFormula(ty.value)) === 0\n        ? {value: ctx.mapper\n            ? ctx.mapper(styp.doCast ? chkSt.value : chkTarget, ty)\n            :            styp.doCast ? chkSt.value : chkTarget}\n        : null;\n    if (! ret) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        ret = null;\n    }\n\n    return ret;\n}\n\n\nfunction validateRepeatedAssertion<T>(\n    data: any, ty: RepeatedAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.min === 'number' && data.length < ty.min) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n    if (typeof ty.max === 'number' && data.length > ty.max) {\n        reportError(ErrorTypes.RepeatQtyUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    const retVals: any[] = [];\n    for (let i = 0; i < data.length; i++) {\n        const x = data[i];\n        const r = validateRoot<T>(x, ty.repeated, ctx, i);\n        if (! r) {\n            return null;\n        }\n        retVals.push(r.value);\n    }\n\n    if (checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return {value: retVals as any};\n}\n\n\nfunction validateSequenceAssertion<T>(\n    data: any, ty: SequenceAssertion, ctx: ValidationContext): {value: T} | null {\n\n    if (! Array.isArray(data)) {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        return null;\n    }\n    let dIdx = 0, // index of data\n        sIdx = 0; // index of types\n    let spreadLen = 0;\n    let optionalOmitted = false;\n\n    const checkSpreadQuantity = (ts: SpreadAssertion, index: number) => {\n        if (typeof ts.min === 'number' && spreadLen < ts.min) {\n            reportErrorWithPush(\n                spreadLen === 0 ?\n                    ErrorTypes.TypeUnmatched :\n                    ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        if (typeof ts.max === 'number' && spreadLen > ts.max) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const checkOptionalQuantity = (ts: OptionalAssertion, index: number) => {\n        if (spreadLen === 0) {\n            // All subsequent 'optional' assertions should be 'spreadLen === 0'.\n            optionalOmitted = true;\n        } else if (optionalOmitted) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        } else if (spreadLen > 1) {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, index], {ctx});\n            return null;\n        }\n        return ts;\n    };\n\n    const retVals: any[] = [];\n    while (dIdx < data.length && sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.spread, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkSpreadQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else if (ts.kind === 'optional') {\n            const savedErrLen = ctx.errors.length;\n            const r = validateRoot<T>(data[dIdx], ts.optional, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                spreadLen++;\n            } else {\n                // End of spreading\n                // rollback reported errors\n                ctx.errors.length = savedErrLen;\n                if (! checkOptionalQuantity(ts, dIdx)) {\n                    return null;\n                }\n                spreadLen = 0;\n                sIdx++;\n            }\n        } else {\n            const r = validateRoot<T>(data[dIdx], ts, ctx, dIdx);\n            if (r) {\n                retVals.push(r.value);\n                dIdx++;\n                sIdx++;\n            } else {\n                return null;\n            }\n        }\n    }\n    while (sIdx < ty.sequence.length) {\n        const ts = ty.sequence[sIdx];\n        if (ts.kind === 'spread') {\n            if (! checkSpreadQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else if (ts.kind === 'optional') {\n            if (! checkOptionalQuantity(ts, dIdx)) {\n                return null;\n            }\n            spreadLen = 0;\n            sIdx++;\n        } else {\n            reportErrorWithPush(ErrorTypes.RepeatQtyUnmatched, data, [ts, dIdx], {ctx});\n            return null;\n        }\n    }\n\n    const ret = data.length === dIdx ? {value: retVals as any} : null;\n    if (! ret) {\n        reportError(ErrorTypes.SequenceUnmatched, data, ty, {ctx});\n    }\n\n    if (ret && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return ret;\n}\n\n\nfunction validateOneOfAssertion<T>(\n    data: any, ty: OneOfAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let choosed = false;\n    const savedCtxRecordTypeFieldValidated = ctx.recordTypeFieldValidated;\n    ctx.recordTypeFieldValidated = false;\n\n    const savedErrLen = ctx.errors.length;\n    let count = 0;\n    let firstErrLen = savedErrLen;\n\n    for (const tyOne of ty.oneOf) {\n        const r = validateRoot<T>(data, tyOne, ctx);\n        if (r) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n            ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n            return r;\n        }\n\n        if (ctx.recordTypeFieldValidated) {\n            if (count !== 0) {\n                const e2 = ctx.errors.slice(firstErrLen);\n                ctx.errors.length = savedErrLen;\n                ctx.errors.push(...e2);\n            }\n            choosed = true;\n            break;\n        }\n\n        if (count === 0) {\n            firstErrLen = ctx.errors.length;\n        } else {\n            ctx.errors.length = firstErrLen;\n        }\n        count++;\n    }\n\n    if (! choosed) {\n        if (! ctx.checkAll) {\n            // rollback reported errors\n            ctx.errors.length = savedErrLen;\n        }\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n    }\n\n    ctx.recordTypeFieldValidated = savedCtxRecordTypeFieldValidated;\n    return null;\n}\n\n\nfunction validateEnumAssertion<T>(\n    data: any, ty: EnumAssertion, ctx: ValidationContext): {value: T} | null {\n\n    for (const v of ty.values) {\n        if (data === v[1]) {\n            return ({value: ctx.mapper ? ctx.mapper(data, ty) : data});\n        }\n    }\n    reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n    return null;\n}\n\n\nfunction validateObjectAssertion<T>(\n    data: any, ty: ObjectAssertion, ctx: ValidationContext): {value: T} | null {\n\n    let retVal = Array.isArray(data) ? [...data] : {...data};\n    const revMembers = ty.members.slice().reverse();\n    for (const x of ty.members) {\n        if (ty.members.find(m => m[0] === x[0]) !== revMembers.find(m => m[0] === x[0])) {\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(\n                `Duplicated member is found: ${x[0]} in ${ty.name || '(unnamed)'}`, ty, ctx);\n        }\n    }\n\n    if (data === null || typeof data !== 'object') {\n        reportError(ErrorTypes.TypeUnmatched, data, ty, {ctx});\n        if (ctx && ctx.checkAll) {\n            retVal = null;\n        } else {\n            return null;\n        }\n    } else {\n        const dataMembers = new Set<string>();\n        if (ctx.noAdditionalProps || ty.additionalProps && 0 < ty.additionalProps.length) {\n            if (! Array.isArray(data)) {\n                for (const m in data) {\n                    if (Object.prototype.hasOwnProperty.call(data, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n        }\n        if (ctx.noAdditionalProps && Array.isArray(data) && 0 < data.length) {\n            const aps = ty.additionalProps || [];\n            if (aps.filter(x => x[0].includes('number')).length === 0) {\n                reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                    ctx,\n                    substitutions: [['addtionalProps', '[number]']],\n                });\n                if (ctx && ctx.checkAll) {\n                    retVal = null;\n                } else {\n                    return null;\n                }\n            }\n        }\n\n        for (const x of ty.members) {\n            dataMembers.delete(x[0]);\n            if (Object.prototype.hasOwnProperty.call(data, x[0])) {\n                const mt = x[1].kind === 'optional' ?  // TODO: set name at compile time\n                    {\n                        ...x[1].optional,\n                        name: x[0],\n                        message: x[1].message,\n                        messages: x[1].messages,\n                        messageId: x[1].messageId,\n                    } : x[1];\n                const ret = validateRoot<T>(data[x[0]], mt, ctx);\n\n                if (ret) {\n                    if (retVal) {\n                        if (isUnsafeVarNames(retVal, x[0])) {\n                            continue;\n                        }\n                        retVal[x[0]] = ret.value;\n                        if (mt.isRecordTypeField) {\n                            ctx.recordTypeFieldValidated = true;\n                        }\n                    }\n                } else {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            } else {\n                if (x[1].kind !== 'optional') {\n                    reportErrorWithPush(ErrorTypes.Required, data, [x[1], void 0], {ctx});\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ty.additionalProps && 0 < ty.additionalProps.length) {\n            function* getAdditionalMembers() {\n                for (const m of dataMembers.values()) {\n                    yield m;\n                }\n                if (Array.isArray(data)) {\n                    for (let i = 0; i < data.length; i++) {\n                        yield String(i);\n                    }\n                }\n            }\n            for (const m of getAdditionalMembers()) {\n                let allowImplicit = false;\n                const matchedAssertions: TypeAssertion[] = [];\n\n                for (const ap of ty.additionalProps) {\n                    for (const pt of ap[0]) {\n                        const at = ap[1];\n                        if (pt === 'number') {\n                            if (NumberPattern.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        } else if (pt === 'string') {\n                            matchedAssertions.push(at);\n                        } else {\n                            if (pt.test(m)) {\n                                matchedAssertions.push(at);\n                            }\n                        }\n                        if (at.kind === 'optional') {\n                            allowImplicit = true;\n                        }\n                    }\n                }\n                if (matchedAssertions.length === 0) {\n                    if (allowImplicit) {\n                        continue;\n                    }\n                    reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                        ctx,\n                        substitutions: [['addtionalProps', m]],\n                    });\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                        continue;\n                    } else {\n                        return null;\n                    }\n                }\n\n                dataMembers.delete(m);\n                let hasError = false;\n                const savedErrLen = ctx.errors.length;\n\n                for (const at of matchedAssertions) {\n                    const ret = validateRoot<T>(data[m], at.kind === 'optional' ?\n                        {\n                            ...at.optional,\n                            message: at.message,\n                            messages: at.messages,\n                            messageId: at.messageId,\n                            name: m,\n                        } : {\n                            ...at,\n                            name: m,\n                        }, ctx);\n                    if (ret) {\n                        if (retVal) {\n                            hasError = false;\n                            ctx.errors.length = savedErrLen;\n                            if (isUnsafeVarNames(retVal, m)) {\n                                continue;\n                            }\n                            retVal[m] = ret.value;\n                        }\n                        break;\n                    } else {\n                        hasError = true;\n                    }\n                }\n                if (hasError) {\n                    if (ctx && ctx.checkAll) {\n                        retVal = null;\n                    } else {\n                        return null;\n                    }\n                }\n            }\n        }\n\n        if (ctx.noAdditionalProps && 0 < dataMembers.size) {\n            reportError(ErrorTypes.AdditionalPropUnmatched, data, ty, {\n                ctx,\n                substitutions: [['addtionalProps', Array.from(dataMembers.values()).join(', ')]],\n            });\n            if (ctx && ctx.checkAll) {\n                retVal = null;\n            } else {\n                return null;\n            }\n        }\n    }\n    if (! retVal) {\n        // TODO: Child is unmatched. reportError?\n        // TODO: report object's custom error message\n    }\n\n    if (retVal && checkCustomConstraints(data, ty, ctx) === null) {\n        reportError(ErrorTypes.ValueUnmatched, data, ty, {ctx});\n        return null;\n    }\n\n    return retVal ? {value: (ctx && ctx.mapper) ? ctx.mapper(retVal, ty) : retVal} : null;\n}\n\n\nexport function validateRoot<T>(\n    data: any, ty: TypeAssertion, ctx: ValidationContext, dataIndex?: number | string): {value: T} | null {\n\n    try {\n        ctx.typeStack.push(\n            typeof dataIndex === 'number' || typeof dataIndex === 'string' ?\n            [ty, dataIndex] : ty);\n\n        switch (ty.kind) {\n        case 'never':\n            return validateNeverTypeAssertion(data, ty, ctx);\n        case 'any':\n            return validateAnyTypeAssertion(data, ty, ctx);\n        case 'unknown':\n            return validateUnknownTypeAssertion(data, ty, ctx);\n        case 'primitive':\n            return validatePrimitiveTypeAssertion(data, ty, ctx);\n        case 'primitive-value':\n            return validatePrimitiveValueTypeAssertion(data, ty, ctx);\n        case 'repeated':\n            return validateRepeatedAssertion(data, ty, ctx);\n        case 'sequence':\n            return validateSequenceAssertion(data, ty, ctx);\n        case 'one-of':\n            return validateOneOfAssertion(data, ty, ctx);\n        case 'enum':\n            return validateEnumAssertion(data, ty, ctx);\n        case 'object':\n            return validateObjectAssertion(data, ty, ctx);\n        case 'symlink':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved symbol '${ty.symlinkTargetName}' is appeared.`, ty, ctx);\n        case 'operator':\n            if (ctx.schema) {\n                return validateRoot<T>(data, resolveSymbols(ctx.schema, ty, {nestLevel: 0, symlinkStack: []}), ctx);\n            }\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unresolved type operator is found: ${ty.operator}`, ty, ctx);\n        case 'spread': case 'optional':\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n        default:\n            reportError(ErrorTypes.InvalidDefinition, data, ty, {ctx});\n            throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n        }\n    } finally {\n        ctx.typeStack.pop();\n    }\n}\n\n\nexport function validate<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): {value: T} | null {\n\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    try {\n        return validateRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nexport function isType<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): data is T {\n\n    return (!! validate<T>(data, ty, ctx));\n}\n\n\nexport function assertType<T>(\n    data: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): asserts data is T {\n\n    if (! validate<T>(data, ty, ctx)) {\n        throw new Error(`Assertion failed: Expected data should be of type \"${ty.typeName || ty.name || '?'}\".`);\n    }\n}\n\n\nexport function getType(schema: TypeAssertionMap, name: string): TypeAssertion {\n    if (schema.has(name)) {\n        return schema.get(name)?.ty as TypeAssertion;\n    }\n    throw new Error(`Undefined type name is referred: ${name}`);\n}\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { RecursivePartial,\n         TypeAssertion,\n         ValidationContext } from './types';\nimport { ValidationError }   from './lib/errors';\nimport { isUnsafeVarNames }  from './lib/protection';\nimport { validate }          from './validator';\n\n\n\nfunction pickMapper(value: any, ty: TypeAssertion) {\n    switch (ty.kind) {\n    case 'object':\n        {\n            const ret = Array.isArray(value) ? [] : {};\n\n            const dataMembers = new Set<string>();\n            if (! Array.isArray(value)) {\n                for (const m in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, m)) {\n                        dataMembers.add(m);\n                    }\n                }\n            }\n\n            for (const x of ty.members) {\n                if (Object.hasOwnProperty.call(value, x[0])) {\n                    dataMembers.delete(x[0]);\n                    ret[x[0]] = value[x[0]];\n                }\n            }\n            if (ty.additionalProps && 0 < ty.additionalProps.length) {\n                function* getAdditionalMembers() {\n                    for (const m of dataMembers.values()) {\n                        yield m;\n                    }\n                    if (Array.isArray(value)) {\n                        for (let i = 0; i < value.length; i++) {\n                            yield String(i);\n                        }\n                    }\n                }\n                for (const m of getAdditionalMembers()) {\n                    ret[m] = value[m];\n                }\n            }\n            return ret;\n        }\n    default:\n        return value;\n    }\n}\n\n\nexport function pickRoot<T>(data: T, ty: TypeAssertion, ctx: ValidationContext): T {\n    switch (ty.kind) {\n    case 'never':\n        throw new ValidationError(`Type unmatched: ${(ty as any).kind}`, ty, ctx);\n    case 'any':\n        // FALL_THRU\n    case 'unknown':\n        // FALL_THRU\n    case 'primitive':\n        // FALL_THRU\n    case 'primitive-value':\n        // FALL_THRU\n    case 'repeated':\n        // FALL_THRU\n    case 'sequence':\n        // FALL_THRU\n    case 'one-of':\n        // FALL_THRU\n    case 'enum':\n        // FALL_THRU\n    case 'object':\n        {\n            const r = validate<T>(data, ty, ctx);\n            if (r) {\n                return r.value;\n            } else {\n                throw new ValidationError('Validation failed.', ty, ctx);\n            }\n        }\n    case 'spread': case 'optional': case 'symlink': case 'operator':\n        throw new ValidationError(`Unexpected type assertion: ${(ty as any).kind}`, ty, ctx);\n    default:\n        throw new ValidationError(`Unknown type assertion: ${(ty as any).kind}`, ty, ctx);\n    }\n}\n\n\nexport function pick<T>(data: T, ty: TypeAssertion, ctx?: Partial<ValidationContext>): RecursivePartial<T> {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n        mapper: pickMapper,\n    };\n    try {\n        return pickRoot<T>(data, ty, ctx2);\n    } finally {\n        if (ctx) {\n            ctx.errors = ctx2.errors;\n        }\n    }\n}\n\n\nfunction merge(data: any, needle: any) {\n    if (data === null || data === void 0) {\n        return needle;\n    }\n    switch (typeof data) {\n    case 'object':\n        if (Array.isArray(data)) {\n            return [...needle];\n        } else {\n            const r: any = {...data};\n            for (const k in needle) {\n                if (Object.prototype.hasOwnProperty.call(needle, k)) {\n                    if (isUnsafeVarNames(r, k)) {\n                        continue;\n                    }\n                    r[k] = merge(r[k], needle[k]);\n                }\n            }\n            return r;\n        }\n    default:\n        return needle;\n    }\n}\n\n\nexport function patch<T>(data: T, needle: any, ty: TypeAssertion, ctx?: Partial<ValidationContext>): T {\n    const ctx2: ValidationContext = {\n        ...{errors: [], typeStack: []},\n        ...(ctx || {}),\n    };\n    const validated = pick<T>(needle, ty, ctx2);\n    return merge(data, validated);\n}\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype }         from '../types';\nimport { DatePattern,\n         DateTimePattern,\n         DateTimeNoTzPattern } from '../lib/util';\n\n\n\nconst FyPattern = /^first-date-of-fy\\(([0-9]+)\\)$/;\nconst FormulaPattern = /^([-+@])([0-9]+)(yr|mo|day|days|hr|min|sec|ms)$/;\n\n\nclass UtcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as UTC\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate(),\n                    d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()));\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setUTCDate(1);\n\n        this.setUTCFullYear(year);\n        this.setUTCMonth(typeof month === 'number' ? month : 0);\n        this.setUTCDate(typeof date === 'number' ? date : 1);\n        this.setUTCHours(typeof hours === 'number' ? hours : 0);\n        this.setUTCMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setUTCSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setUTCMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n\n    public getFullYear(): number {\n        return this.getUTCFullYear();\n    }\n\n    public getMonth(): number {\n        return this.getUTCMonth();\n    }\n\n    public getDate(): number {\n        return this.getUTCDate();\n    }\n\n    public getHours(): number {\n        return this.getUTCHours();\n    }\n\n    public getMinutes(): number {\n        return this.getUTCMinutes();\n    }\n\n    public getSeconds(): number {\n        return this.getUTCSeconds();\n    }\n\n    public getMilliseconds(): number {\n        return this.getUTCMilliseconds();\n    }\n\n    // NOTE: set???() are not overridden!\n}\n\n\nclass LcDate extends Date {\n    public constructor();\n    // tslint:disable-next-line: unified-signatures\n    public constructor(str: string);\n    public constructor(\n        year: number, month: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number)\n    public constructor(\n        year?: number | string, month?: number, date?: number,\n        hours?: number, minutes?: number, seconds?: number, ms?: number) {\n\n        super();\n        if (year === void 0) {\n            return;\n        }\n        if (typeof year === 'string') {\n            if (DateTimePattern.test(year)) {\n                // string parameter is expected to be treated as specified TZ\n                this.setTime(Date.parse(year)); // returns date in specified TZ\n            } else if (DatePattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in UTC TZ (getUTC??? returns string parameter's date & time digits)\n                const l = new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n                this.setTime(l.getTime());\n            } else if (DateTimeNoTzPattern.test(year)) {\n                // string parameter is expected to be treated as local TZ\n                const d = new Date(year);       // returns date in local TZ (get??? returns string parameter's date & time digits)\n                this.setTime(d.getTime());\n            } else {\n                this.setTime(NaN);\n            }\n            return;\n        }\n\n        this.setDate(1);\n\n        this.setFullYear(year);\n        this.setMonth(typeof month === 'number' ? month : 0);\n        this.setDate(typeof date === 'number' ? date : 1);\n        this.setHours(typeof hours === 'number' ? hours : 0);\n        this.setMinutes(typeof minutes === 'number' ? minutes : 0);\n        this.setSeconds(typeof seconds === 'number' ? seconds : 0);\n        this.setMilliseconds(typeof ms === 'number' ? ms : 0);\n    }\n}\n\n\ninterface DateConstructor {\n    new (): Date;\n    // tslint:disable-next-line: unified-signatures\n    new (str: string): Date;\n    new (year: number, month: number, date?: number,\n         hours?: number, minutes?: number, seconds?: number, ms?: number): Date;\n}\n\n\nfunction evaluateFormulaBase(dateCtor: DateConstructor, valueOrFormula: string): Date {\n    const errMsg = `evaluateFormula: invalid parameter ${valueOrFormula}`;\n    if (typeof valueOrFormula !== 'string') {\n        throw new Error(errMsg);\n    }\n    if (valueOrFormula.startsWith('=')) {\n        const formula = valueOrFormula.slice(1).split(' ');\n        let d = new dateCtor();\n        const now = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());\n        const today = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate());\n        d = now;\n        for (const f of formula) {\n            switch (f) {\n            case 'current': case 'now':\n                d = now;\n                break;\n            case 'today':\n                d = today;\n                break;\n            case 'first-date-of-yr': case 'first-date-of-fy(1)':\n                d = new dateCtor(d.getFullYear(), 0, 1);\n                break;\n            case 'last-date-of-yr':\n                d = new dateCtor(d.getFullYear(), 11, 31);\n                break;\n            case 'first-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth(), 1);\n                break;\n            case 'last-date-of-mo':\n                d = new dateCtor(d.getFullYear(), d.getMonth() + 1, 0);\n                break;\n            default:\n                if (f.startsWith('first-date-of-fy(')) {\n                    const m = FyPattern.exec(f);\n                    if (m) {\n                        const n = Number.parseInt(m[1], 10);\n                        if (0 < n && n <= 12) {\n                            const mo = d.getMonth() + 1;\n                            let yr = d.getFullYear();\n                            if (mo < n) {\n                                yr--;\n                            }\n                            d = new dateCtor(yr, n - 1, 1);\n                        } else {\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        throw new Error(errMsg);\n                    }\n                } else {\n                    const m = FormulaPattern.exec(f);\n                    if (m) {\n                        let n = Number.parseInt(m[2], 10);\n                        switch (m[3]) {\n                        case 'yr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getFullYear() + n;\n                                break;\n                            case '-':\n                                n = d.getFullYear() - n;\n                                break;\n                            }\n                            d = new dateCtor(n, d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'mo':\n                            switch (m[1]) {\n                            case '@':\n                                n -= 1;\n                                break;\n                            case '+':\n                                n = d.getMonth() + n;\n                                break;\n                            case '-':\n                                n = d.getMonth() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), n, d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'day': case 'days':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getDate() + n;\n                                break;\n                            case '-':\n                                n = d.getDate() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), n,\n                                d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'hr':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getHours() + n;\n                                break;\n                            case '-':\n                                n = d.getHours() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'min':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMinutes() + n;\n                                break;\n                            case '-':\n                                n = d.getMinutes() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), n, d.getSeconds(), d.getMilliseconds());\n                            break;\n                        case 'sec':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getSeconds() + n;\n                                break;\n                            case '-':\n                                n = d.getSeconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), n, d.getMilliseconds());\n                            break;\n                        case 'ms':\n                            switch (m[1]) {\n                            case '@':\n                                break;\n                            case '+':\n                                n = d.getMilliseconds() + n;\n                                break;\n                            case '-':\n                                n = d.getMilliseconds() - n;\n                                break;\n                            }\n                            d = new dateCtor(d.getFullYear(), d.getMonth(), d.getDate(),\n                                d.getHours(), d.getMinutes(), d.getSeconds(), n);\n                            break;\n                        default:\n                            throw new Error(errMsg);\n                        }\n                    } else {\n                        if (!(DatePattern.test(f) || DateTimePattern.test(f) || DateTimeNoTzPattern.test(f))) {\n                            throw new Error(errMsg);\n                        }\n                        d = new dateCtor(f);\n                    }\n                }\n            }\n        }\n        return d;\n    } else {\n        if (! DatePattern.test(valueOrFormula)) {\n            throw new Error(errMsg);\n        }\n        return new dateCtor(valueOrFormula);\n    }\n}\n\n\nexport const dateStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && DatePattern.test(value)\n                ? { value: (new UtcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(UtcDate, valueOrFormula);\n        return (new UtcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDateStereotype: Stereotype = {\n    ...dateStereotype,\n    tryParse: (value: unknown) => {\n        if (typeof value === 'string' && DatePattern.test(value)) {\n            return ({ value: (new LcDate(value)).getTime() });\n        } else {\n            return null;\n        }\n    },\n    evaluateFormula: valueOrFormula => {\n        const d = evaluateFormulaBase(LcDate, valueOrFormula);\n        return (new LcDate(d.getFullYear(), d.getMonth(), d.getDate())).getTime();\n    },\n}\n\n\nexport const datetimeStereotype: Stereotype = {\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new UtcDate(value)).getTime() } // If timezone is not specified, it is local time\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(UtcDate, valueOrFormula).getTime(),\n    compare: (a: number, b: number) => a - b,\n    doCast: false,\n};\n\n\nexport const lcDatetimeStereotype: Stereotype = {\n    ...datetimeStereotype,\n    tryParse: (value: unknown) => {\n        return (\n            typeof value === 'string' && (DateTimePattern.test(value) || DateTimeNoTzPattern.test(value))\n                ? { value: (new LcDate(value)).getTime() }\n                : null\n        );\n    },\n    evaluateFormula: valueOrFormula => evaluateFormulaBase(LcDate, valueOrFormula).getTime(),\n}\n\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ['date', dateStereotype],\n    ['lcdate', lcDateStereotype],\n    ['datetime', datetimeStereotype],\n    ['lcdatetime', lcDatetimeStereotype],\n];\n","// Copyright (c) 2020 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { CustomConstraintInfo } from '../types';\nimport { dummyTargetObject,\n         isUnsafeVarNames }     from '../lib/protection';\n\n\n\ntype MapperFn = (data: any, fields: string[]) => any[];\nconst mapperErrMsg = 'Unsafe symbol name is appeared in unique constraint assertion:';\n\n\nconst normalMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field]);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst nonNullMapper: MapperFn = (data: any, fields: string[]) => {\n    const ret: any[] = [];\n    if (0 < fields.length) {\n        for (const field of fields) {\n            if (isUnsafeVarNames(dummyTargetObject, field)) {\n                throw new Error(`${mapperErrMsg} ${field}`);\n            }\n            ret.push(data[field] ?? NaN);\n        }\n    } else {\n        ret.push(data);\n    }\n    return ret;\n};\n\n\nconst checkerGen = (mapper: MapperFn) => {\n    return ((data: any, args: any) => {\n        const errMsg = `evaluateFormula: invalid parameter ${args}`;\n        if (! Array.isArray(data)) {\n            throw new Error(errMsg);\n        }\n\n        const fields: string[] = [];\n        if (typeof args === 'string') {\n            fields.push(args);\n        } else if (Array.isArray(args)) {\n            for (const z of args) {\n                if (typeof z !== 'string') {\n                    throw new Error(errMsg);\n                }\n            }\n            fields.push(...args);\n        }\n\n        const mapped = data.map(x => mapper(x, fields));\n        for (let i = 0; i < mapped.length; i++) {\n            CMP: for (let j = 0; j < mapped.length; j++) {\n                if (i === j) {\n                    continue;\n                }\n                const a = mapped[i];\n                const b = mapped[j];\n                for (let k = 0; k < a.length; k++) { // TODO: this is slow! more better checking\n                    if (a[k] !== b[k]) {\n                        continue CMP;\n                    }\n                }\n                return false;\n            }\n        }\n\n        return true;\n    });\n};\n\n\nexport const constraints: Array<[string, CustomConstraintInfo]> = [\n    ['unique', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(normalMapper),\n    }],\n    ['unique-non-null', {\n        kinds: ['repeated', 'sequence'],\n        check: checkerGen(nonNullMapper),\n    }],\n];\n","// Copyright (c) 2019 Shellyl_N and Authors\n// license: ISC\n// https://github.com/shellyln\n\n\nimport { Stereotype,\n         CustomConstraintInfo }             from './types';\nimport { stereotypes as dateStereotypes }   from './stereotypes/date';\nimport { constraints as uniqueConstraints } from './constraints/unique';\n\nexport * from './types';\nexport * from './operators';\nexport * from './validator';\nexport * from './picker';\n\nexport const stereotypes: Array<[string, Stereotype]> = [\n    ...dateStereotypes,\n];\n\nexport const customConstraints: Array<[string, CustomConstraintInfo]> = [\n    ...uniqueConstraints,\n];\n"],"sourceRoot":""}